const e = window, t = e.ShadowRoot && (void 0 === e.ShadyCSS || e.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, i = Symbol(), n = /* @__PURE__ */ new WeakMap();
let o = class {
  constructor(e3, t2, n2) {
    if (this._$cssResult$ = true, n2 !== i)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = e3, this.t = t2;
  }
  get styleSheet() {
    let e3 = this.o;
    const i2 = this.t;
    if (t && void 0 === e3) {
      const t2 = void 0 !== i2 && 1 === i2.length;
      t2 && (e3 = n.get(i2)), void 0 === e3 && ((this.o = e3 = new CSSStyleSheet()).replaceSync(this.cssText), t2 && n.set(i2, e3));
    }
    return e3;
  }
  toString() {
    return this.cssText;
  }
};
const r = (e3, ...t2) => {
  const n2 = 1 === e3.length ? e3[0] : t2.reduce((t3, i2, n3) => t3 + ((e4) => {
    if (true === e4._$cssResult$)
      return e4.cssText;
    if ("number" == typeof e4)
      return e4;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + e4 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(i2) + e3[n3 + 1], e3[0]);
  return new o(n2, e3, i);
}, s = t ? (e3) => e3 : (e3) => e3 instanceof CSSStyleSheet ? ((e4) => {
  let t2 = "";
  for (const i2 of e4.cssRules)
    t2 += i2.cssText;
  return ((e5) => new o("string" == typeof e5 ? e5 : e5 + "", void 0, i))(t2);
})(e3) : e3;
var a;
const l = window, c = l.trustedTypes, h = c ? c.emptyScript : "", u = l.reactiveElementPolyfillSupport, d = { toAttribute(e3, t2) {
  switch (t2) {
    case Boolean:
      e3 = e3 ? h : null;
      break;
    case Object:
    case Array:
      e3 = null == e3 ? e3 : JSON.stringify(e3);
  }
  return e3;
}, fromAttribute(e3, t2) {
  let i2 = e3;
  switch (t2) {
    case Boolean:
      i2 = null !== e3;
      break;
    case Number:
      i2 = null === e3 ? null : Number(e3);
      break;
    case Object:
    case Array:
      try {
        i2 = JSON.parse(e3);
      } catch (e4) {
        i2 = null;
      }
  }
  return i2;
} }, p = (e3, t2) => t2 !== e3 && (t2 == t2 || e3 == e3), _ = { attribute: true, type: String, converter: d, reflect: false, hasChanged: p }, g = "finalized";
let m = class extends HTMLElement {
  constructor() {
    super(), this._$Ei = /* @__PURE__ */ new Map(), this.isUpdatePending = false, this.hasUpdated = false, this._$El = null, this.u();
  }
  static addInitializer(e3) {
    var t2;
    this.finalize(), (null !== (t2 = this.h) && void 0 !== t2 ? t2 : this.h = []).push(e3);
  }
  static get observedAttributes() {
    this.finalize();
    const e3 = [];
    return this.elementProperties.forEach((t2, i2) => {
      const n2 = this._$Ep(i2, t2);
      void 0 !== n2 && (this._$Ev.set(n2, i2), e3.push(n2));
    }), e3;
  }
  static createProperty(e3, t2 = _) {
    if (t2.state && (t2.attribute = false), this.finalize(), this.elementProperties.set(e3, t2), !t2.noAccessor && !this.prototype.hasOwnProperty(e3)) {
      const i2 = "symbol" == typeof e3 ? Symbol() : "__" + e3, n2 = this.getPropertyDescriptor(e3, i2, t2);
      void 0 !== n2 && Object.defineProperty(this.prototype, e3, n2);
    }
  }
  static getPropertyDescriptor(e3, t2, i2) {
    return { get() {
      return this[t2];
    }, set(n2) {
      const o2 = this[e3];
      this[t2] = n2, this.requestUpdate(e3, o2, i2);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(e3) {
    return this.elementProperties.get(e3) || _;
  }
  static finalize() {
    if (this.hasOwnProperty(g))
      return false;
    this[g] = true;
    const e3 = Object.getPrototypeOf(this);
    if (e3.finalize(), void 0 !== e3.h && (this.h = [...e3.h]), this.elementProperties = new Map(e3.elementProperties), this._$Ev = /* @__PURE__ */ new Map(), this.hasOwnProperty("properties")) {
      const e4 = this.properties, t2 = [...Object.getOwnPropertyNames(e4), ...Object.getOwnPropertySymbols(e4)];
      for (const i2 of t2)
        this.createProperty(i2, e4[i2]);
    }
    return this.elementStyles = this.finalizeStyles(this.styles), true;
  }
  static finalizeStyles(e3) {
    const t2 = [];
    if (Array.isArray(e3)) {
      const i2 = new Set(e3.flat(1 / 0).reverse());
      for (const e4 of i2)
        t2.unshift(s(e4));
    } else
      void 0 !== e3 && t2.push(s(e3));
    return t2;
  }
  static _$Ep(e3, t2) {
    const i2 = t2.attribute;
    return false === i2 ? void 0 : "string" == typeof i2 ? i2 : "string" == typeof e3 ? e3.toLowerCase() : void 0;
  }
  u() {
    var e3;
    this._$E_ = new Promise((e4) => this.enableUpdating = e4), this._$AL = /* @__PURE__ */ new Map(), this._$Eg(), this.requestUpdate(), null === (e3 = this.constructor.h) || void 0 === e3 || e3.forEach((e4) => e4(this));
  }
  addController(e3) {
    var t2, i2;
    (null !== (t2 = this._$ES) && void 0 !== t2 ? t2 : this._$ES = []).push(e3), void 0 !== this.renderRoot && this.isConnected && (null === (i2 = e3.hostConnected) || void 0 === i2 || i2.call(e3));
  }
  removeController(e3) {
    var t2;
    null === (t2 = this._$ES) || void 0 === t2 || t2.splice(this._$ES.indexOf(e3) >>> 0, 1);
  }
  _$Eg() {
    this.constructor.elementProperties.forEach((e3, t2) => {
      this.hasOwnProperty(t2) && (this._$Ei.set(t2, this[t2]), delete this[t2]);
    });
  }
  createRenderRoot() {
    var i2;
    const n2 = null !== (i2 = this.shadowRoot) && void 0 !== i2 ? i2 : this.attachShadow(this.constructor.shadowRootOptions);
    return ((i3, n3) => {
      t ? i3.adoptedStyleSheets = n3.map((e3) => e3 instanceof CSSStyleSheet ? e3 : e3.styleSheet) : n3.forEach((t2) => {
        const n4 = document.createElement("style"), o2 = e.litNonce;
        void 0 !== o2 && n4.setAttribute("nonce", o2), n4.textContent = t2.cssText, i3.appendChild(n4);
      });
    })(n2, this.constructor.elementStyles), n2;
  }
  connectedCallback() {
    var e3;
    void 0 === this.renderRoot && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), null === (e3 = this._$ES) || void 0 === e3 || e3.forEach((e4) => {
      var t2;
      return null === (t2 = e4.hostConnected) || void 0 === t2 ? void 0 : t2.call(e4);
    });
  }
  enableUpdating(e3) {
  }
  disconnectedCallback() {
    var e3;
    null === (e3 = this._$ES) || void 0 === e3 || e3.forEach((e4) => {
      var t2;
      return null === (t2 = e4.hostDisconnected) || void 0 === t2 ? void 0 : t2.call(e4);
    });
  }
  attributeChangedCallback(e3, t2, i2) {
    this._$AK(e3, i2);
  }
  _$EO(e3, t2, i2 = _) {
    var n2;
    const o2 = this.constructor._$Ep(e3, i2);
    if (void 0 !== o2 && true === i2.reflect) {
      const r2 = (void 0 !== (null === (n2 = i2.converter) || void 0 === n2 ? void 0 : n2.toAttribute) ? i2.converter : d).toAttribute(t2, i2.type);
      this._$El = e3, null == r2 ? this.removeAttribute(o2) : this.setAttribute(o2, r2), this._$El = null;
    }
  }
  _$AK(e3, t2) {
    var i2;
    const n2 = this.constructor, o2 = n2._$Ev.get(e3);
    if (void 0 !== o2 && this._$El !== o2) {
      const e4 = n2.getPropertyOptions(o2), r2 = "function" == typeof e4.converter ? { fromAttribute: e4.converter } : void 0 !== (null === (i2 = e4.converter) || void 0 === i2 ? void 0 : i2.fromAttribute) ? e4.converter : d;
      this._$El = o2, this[o2] = r2.fromAttribute(t2, e4.type), this._$El = null;
    }
  }
  requestUpdate(e3, t2, i2) {
    let n2 = true;
    void 0 !== e3 && (((i2 = i2 || this.constructor.getPropertyOptions(e3)).hasChanged || p)(this[e3], t2) ? (this._$AL.has(e3) || this._$AL.set(e3, t2), true === i2.reflect && this._$El !== e3 && (void 0 === this._$EC && (this._$EC = /* @__PURE__ */ new Map()), this._$EC.set(e3, i2))) : n2 = false), !this.isUpdatePending && n2 && (this._$E_ = this._$Ej());
  }
  async _$Ej() {
    this.isUpdatePending = true;
    try {
      await this._$E_;
    } catch (e4) {
      Promise.reject(e4);
    }
    const e3 = this.scheduleUpdate();
    return null != e3 && await e3, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var e3;
    if (!this.isUpdatePending)
      return;
    this.hasUpdated, this._$Ei && (this._$Ei.forEach((e4, t3) => this[t3] = e4), this._$Ei = void 0);
    let t2 = false;
    const i2 = this._$AL;
    try {
      t2 = this.shouldUpdate(i2), t2 ? (this.willUpdate(i2), null === (e3 = this._$ES) || void 0 === e3 || e3.forEach((e4) => {
        var t3;
        return null === (t3 = e4.hostUpdate) || void 0 === t3 ? void 0 : t3.call(e4);
      }), this.update(i2)) : this._$Ek();
    } catch (e4) {
      throw t2 = false, this._$Ek(), e4;
    }
    t2 && this._$AE(i2);
  }
  willUpdate(e3) {
  }
  _$AE(e3) {
    var t2;
    null === (t2 = this._$ES) || void 0 === t2 || t2.forEach((e4) => {
      var t3;
      return null === (t3 = e4.hostUpdated) || void 0 === t3 ? void 0 : t3.call(e4);
    }), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(e3)), this.updated(e3);
  }
  _$Ek() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$E_;
  }
  shouldUpdate(e3) {
    return true;
  }
  update(e3) {
    void 0 !== this._$EC && (this._$EC.forEach((e4, t2) => this._$EO(t2, this[t2], e4)), this._$EC = void 0), this._$Ek();
  }
  updated(e3) {
  }
  firstUpdated(e3) {
  }
};
var f;
m[g] = true, m.elementProperties = /* @__PURE__ */ new Map(), m.elementStyles = [], m.shadowRootOptions = { mode: "open" }, null == u || u({ ReactiveElement: m }), (null !== (a = l.reactiveElementVersions) && void 0 !== a ? a : l.reactiveElementVersions = []).push("1.6.2");
const v = window, A = v.trustedTypes, b = A ? A.createPolicy("lit-html", { createHTML: (e3) => e3 }) : void 0, y = "$lit$", w = `lit$${(Math.random() + "").slice(9)}$`, x = "?" + w, C = `<${x}>`, S = document, E = () => S.createComment(""), I = (e3) => null === e3 || "object" != typeof e3 && "function" != typeof e3, T = Array.isArray, B = (e3) => T(e3) || "function" == typeof (null == e3 ? void 0 : e3[Symbol.iterator]), M = "[ 	\n\f\r]", k = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, R = /-->/g, P = />/g, D = RegExp(`>|${M}(?:([^\\s"'>=/]+)(${M}*=${M}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), L = /'/g, F = /"/g, N = /^(?:script|style|textarea|title)$/i, O = (e3) => (t2, ...i2) => ({ _$litType$: e3, strings: t2, values: i2 }), z = O(1), U = O(2), H = Symbol.for("lit-noChange"), Q = Symbol.for("lit-nothing"), V = /* @__PURE__ */ new WeakMap(), G = S.createTreeWalker(S, 129, null, false), $ = (e3, t2) => {
  const i2 = e3.length - 1, n2 = [];
  let o2, r2 = 2 === t2 ? "<svg>" : "", s2 = k;
  for (let t3 = 0; t3 < i2; t3++) {
    const i3 = e3[t3];
    let a3, l2, c2 = -1, h2 = 0;
    for (; h2 < i3.length && (s2.lastIndex = h2, l2 = s2.exec(i3), null !== l2); )
      h2 = s2.lastIndex, s2 === k ? "!--" === l2[1] ? s2 = R : void 0 !== l2[1] ? s2 = P : void 0 !== l2[2] ? (N.test(l2[2]) && (o2 = RegExp("</" + l2[2], "g")), s2 = D) : void 0 !== l2[3] && (s2 = D) : s2 === D ? ">" === l2[0] ? (s2 = null != o2 ? o2 : k, c2 = -1) : void 0 === l2[1] ? c2 = -2 : (c2 = s2.lastIndex - l2[2].length, a3 = l2[1], s2 = void 0 === l2[3] ? D : '"' === l2[3] ? F : L) : s2 === F || s2 === L ? s2 = D : s2 === R || s2 === P ? s2 = k : (s2 = D, o2 = void 0);
    const u2 = s2 === D && e3[t3 + 1].startsWith("/>") ? " " : "";
    r2 += s2 === k ? i3 + C : c2 >= 0 ? (n2.push(a3), i3.slice(0, c2) + y + i3.slice(c2) + w + u2) : i3 + w + (-2 === c2 ? (n2.push(void 0), t3) : u2);
  }
  const a2 = r2 + (e3[i2] || "<?>") + (2 === t2 ? "</svg>" : "");
  if (!Array.isArray(e3) || !e3.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return [void 0 !== b ? b.createHTML(a2) : a2, n2];
};
class W {
  constructor({ strings: e3, _$litType$: t2 }, i2) {
    let n2;
    this.parts = [];
    let o2 = 0, r2 = 0;
    const s2 = e3.length - 1, a2 = this.parts, [l2, c2] = $(e3, t2);
    if (this.el = W.createElement(l2, i2), G.currentNode = this.el.content, 2 === t2) {
      const e4 = this.el.content, t3 = e4.firstChild;
      t3.remove(), e4.append(...t3.childNodes);
    }
    for (; null !== (n2 = G.nextNode()) && a2.length < s2; ) {
      if (1 === n2.nodeType) {
        if (n2.hasAttributes()) {
          const e4 = [];
          for (const t3 of n2.getAttributeNames())
            if (t3.endsWith(y) || t3.startsWith(w)) {
              const i3 = c2[r2++];
              if (e4.push(t3), void 0 !== i3) {
                const e5 = n2.getAttribute(i3.toLowerCase() + y).split(w), t4 = /([.?@])?(.*)/.exec(i3);
                a2.push({ type: 1, index: o2, name: t4[2], strings: e5, ctor: "." === t4[1] ? K : "?" === t4[1] ? J : "@" === t4[1] ? ee : Y });
              } else
                a2.push({ type: 6, index: o2 });
            }
          for (const t3 of e4)
            n2.removeAttribute(t3);
        }
        if (N.test(n2.tagName)) {
          const e4 = n2.textContent.split(w), t3 = e4.length - 1;
          if (t3 > 0) {
            n2.textContent = A ? A.emptyScript : "";
            for (let i3 = 0; i3 < t3; i3++)
              n2.append(e4[i3], E()), G.nextNode(), a2.push({ type: 2, index: ++o2 });
            n2.append(e4[t3], E());
          }
        }
      } else if (8 === n2.nodeType)
        if (n2.data === x)
          a2.push({ type: 2, index: o2 });
        else {
          let e4 = -1;
          for (; -1 !== (e4 = n2.data.indexOf(w, e4 + 1)); )
            a2.push({ type: 7, index: o2 }), e4 += w.length - 1;
        }
      o2++;
    }
  }
  static createElement(e3, t2) {
    const i2 = S.createElement("template");
    return i2.innerHTML = e3, i2;
  }
}
function q(e3, t2, i2 = e3, n2) {
  var o2, r2, s2, a2;
  if (t2 === H)
    return t2;
  let l2 = void 0 !== n2 ? null === (o2 = i2._$Co) || void 0 === o2 ? void 0 : o2[n2] : i2._$Cl;
  const c2 = I(t2) ? void 0 : t2._$litDirective$;
  return (null == l2 ? void 0 : l2.constructor) !== c2 && (null === (r2 = null == l2 ? void 0 : l2._$AO) || void 0 === r2 || r2.call(l2, false), void 0 === c2 ? l2 = void 0 : (l2 = new c2(e3), l2._$AT(e3, i2, n2)), void 0 !== n2 ? (null !== (s2 = (a2 = i2)._$Co) && void 0 !== s2 ? s2 : a2._$Co = [])[n2] = l2 : i2._$Cl = l2), void 0 !== l2 && (t2 = q(e3, l2._$AS(e3, t2.values), l2, n2)), t2;
}
class j {
  constructor(e3, t2) {
    this._$AV = [], this._$AN = void 0, this._$AD = e3, this._$AM = t2;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(e3) {
    var t2;
    const { el: { content: i2 }, parts: n2 } = this._$AD, o2 = (null !== (t2 = null == e3 ? void 0 : e3.creationScope) && void 0 !== t2 ? t2 : S).importNode(i2, true);
    G.currentNode = o2;
    let r2 = G.nextNode(), s2 = 0, a2 = 0, l2 = n2[0];
    for (; void 0 !== l2; ) {
      if (s2 === l2.index) {
        let t3;
        2 === l2.type ? t3 = new X(r2, r2.nextSibling, this, e3) : 1 === l2.type ? t3 = new l2.ctor(r2, l2.name, l2.strings, this, e3) : 6 === l2.type && (t3 = new te(r2, this, e3)), this._$AV.push(t3), l2 = n2[++a2];
      }
      s2 !== (null == l2 ? void 0 : l2.index) && (r2 = G.nextNode(), s2++);
    }
    return G.currentNode = S, o2;
  }
  v(e3) {
    let t2 = 0;
    for (const i2 of this._$AV)
      void 0 !== i2 && (void 0 !== i2.strings ? (i2._$AI(e3, i2, t2), t2 += i2.strings.length - 2) : i2._$AI(e3[t2])), t2++;
  }
}
class X {
  constructor(e3, t2, i2, n2) {
    var o2;
    this.type = 2, this._$AH = Q, this._$AN = void 0, this._$AA = e3, this._$AB = t2, this._$AM = i2, this.options = n2, this._$Cp = null === (o2 = null == n2 ? void 0 : n2.isConnected) || void 0 === o2 || o2;
  }
  get _$AU() {
    var e3, t2;
    return null !== (t2 = null === (e3 = this._$AM) || void 0 === e3 ? void 0 : e3._$AU) && void 0 !== t2 ? t2 : this._$Cp;
  }
  get parentNode() {
    let e3 = this._$AA.parentNode;
    const t2 = this._$AM;
    return void 0 !== t2 && 11 === (null == e3 ? void 0 : e3.nodeType) && (e3 = t2.parentNode), e3;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(e3, t2 = this) {
    e3 = q(this, e3, t2), I(e3) ? e3 === Q || null == e3 || "" === e3 ? (this._$AH !== Q && this._$AR(), this._$AH = Q) : e3 !== this._$AH && e3 !== H && this._(e3) : void 0 !== e3._$litType$ ? this.g(e3) : void 0 !== e3.nodeType ? this.$(e3) : B(e3) ? this.T(e3) : this._(e3);
  }
  k(e3) {
    return this._$AA.parentNode.insertBefore(e3, this._$AB);
  }
  $(e3) {
    this._$AH !== e3 && (this._$AR(), this._$AH = this.k(e3));
  }
  _(e3) {
    this._$AH !== Q && I(this._$AH) ? this._$AA.nextSibling.data = e3 : this.$(S.createTextNode(e3)), this._$AH = e3;
  }
  g(e3) {
    var t2;
    const { values: i2, _$litType$: n2 } = e3, o2 = "number" == typeof n2 ? this._$AC(e3) : (void 0 === n2.el && (n2.el = W.createElement(n2.h, this.options)), n2);
    if ((null === (t2 = this._$AH) || void 0 === t2 ? void 0 : t2._$AD) === o2)
      this._$AH.v(i2);
    else {
      const e4 = new j(o2, this), t3 = e4.u(this.options);
      e4.v(i2), this.$(t3), this._$AH = e4;
    }
  }
  _$AC(e3) {
    let t2 = V.get(e3.strings);
    return void 0 === t2 && V.set(e3.strings, t2 = new W(e3)), t2;
  }
  T(e3) {
    T(this._$AH) || (this._$AH = [], this._$AR());
    const t2 = this._$AH;
    let i2, n2 = 0;
    for (const o2 of e3)
      n2 === t2.length ? t2.push(i2 = new X(this.k(E()), this.k(E()), this, this.options)) : i2 = t2[n2], i2._$AI(o2), n2++;
    n2 < t2.length && (this._$AR(i2 && i2._$AB.nextSibling, n2), t2.length = n2);
  }
  _$AR(e3 = this._$AA.nextSibling, t2) {
    var i2;
    for (null === (i2 = this._$AP) || void 0 === i2 || i2.call(this, false, true, t2); e3 && e3 !== this._$AB; ) {
      const t3 = e3.nextSibling;
      e3.remove(), e3 = t3;
    }
  }
  setConnected(e3) {
    var t2;
    void 0 === this._$AM && (this._$Cp = e3, null === (t2 = this._$AP) || void 0 === t2 || t2.call(this, e3));
  }
}
let Y = class {
  constructor(e3, t2, i2, n2, o2) {
    this.type = 1, this._$AH = Q, this._$AN = void 0, this.element = e3, this.name = t2, this._$AM = n2, this.options = o2, i2.length > 2 || "" !== i2[0] || "" !== i2[1] ? (this._$AH = Array(i2.length - 1).fill(new String()), this.strings = i2) : this._$AH = Q;
  }
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(e3, t2 = this, i2, n2) {
    const o2 = this.strings;
    let r2 = false;
    if (void 0 === o2)
      e3 = q(this, e3, t2, 0), r2 = !I(e3) || e3 !== this._$AH && e3 !== H, r2 && (this._$AH = e3);
    else {
      const n3 = e3;
      let s2, a2;
      for (e3 = o2[0], s2 = 0; s2 < o2.length - 1; s2++)
        a2 = q(this, n3[i2 + s2], t2, s2), a2 === H && (a2 = this._$AH[s2]), r2 || (r2 = !I(a2) || a2 !== this._$AH[s2]), a2 === Q ? e3 = Q : e3 !== Q && (e3 += (null != a2 ? a2 : "") + o2[s2 + 1]), this._$AH[s2] = a2;
    }
    r2 && !n2 && this.j(e3);
  }
  j(e3) {
    e3 === Q ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, null != e3 ? e3 : "");
  }
};
class K extends Y {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(e3) {
    this.element[this.name] = e3 === Q ? void 0 : e3;
  }
}
const Z = A ? A.emptyScript : "";
let J = class extends Y {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(e3) {
    e3 && e3 !== Q ? this.element.setAttribute(this.name, Z) : this.element.removeAttribute(this.name);
  }
};
class ee extends Y {
  constructor(e3, t2, i2, n2, o2) {
    super(e3, t2, i2, n2, o2), this.type = 5;
  }
  _$AI(e3, t2 = this) {
    var i2;
    if ((e3 = null !== (i2 = q(this, e3, t2, 0)) && void 0 !== i2 ? i2 : Q) === H)
      return;
    const n2 = this._$AH, o2 = e3 === Q && n2 !== Q || e3.capture !== n2.capture || e3.once !== n2.once || e3.passive !== n2.passive, r2 = e3 !== Q && (n2 === Q || o2);
    o2 && this.element.removeEventListener(this.name, this, n2), r2 && this.element.addEventListener(this.name, this, e3), this._$AH = e3;
  }
  handleEvent(e3) {
    var t2, i2;
    "function" == typeof this._$AH ? this._$AH.call(null !== (i2 = null === (t2 = this.options) || void 0 === t2 ? void 0 : t2.host) && void 0 !== i2 ? i2 : this.element, e3) : this._$AH.handleEvent(e3);
  }
}
class te {
  constructor(e3, t2, i2) {
    this.element = e3, this.type = 6, this._$AN = void 0, this._$AM = t2, this.options = i2;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(e3) {
    q(this, e3);
  }
}
const ie = { O: y, P: w, A: x, C: 1, M: $, L: j, D: B, R: q, I: X, V: Y, H: J, N: ee, U: K, F: te }, ne = v.litHtmlPolyfillSupport;
null == ne || ne(W, X), (null !== (f = v.litHtmlVersions) && void 0 !== f ? f : v.litHtmlVersions = []).push("2.7.4");
const oe = (e3, t2, i2) => {
  var n2, o2;
  const r2 = null !== (n2 = null == i2 ? void 0 : i2.renderBefore) && void 0 !== n2 ? n2 : t2;
  let s2 = r2._$litPart$;
  if (void 0 === s2) {
    const e4 = null !== (o2 = null == i2 ? void 0 : i2.renderBefore) && void 0 !== o2 ? o2 : null;
    r2._$litPart$ = s2 = new X(t2.insertBefore(E(), e4), e4, void 0, null != i2 ? i2 : {});
  }
  return s2._$AI(e3), s2;
};
var re, se;
let ae = class extends m {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var e3, t2;
    const i2 = super.createRenderRoot();
    return null !== (e3 = (t2 = this.renderOptions).renderBefore) && void 0 !== e3 || (t2.renderBefore = i2.firstChild), i2;
  }
  update(e3) {
    const t2 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(e3), this._$Do = oe(t2, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var e3;
    super.connectedCallback(), null === (e3 = this._$Do) || void 0 === e3 || e3.setConnected(true);
  }
  disconnectedCallback() {
    var e3;
    super.disconnectedCallback(), null === (e3 = this._$Do) || void 0 === e3 || e3.setConnected(false);
  }
  render() {
    return H;
  }
};
ae.finalized = true, ae._$litElement$ = true, null === (re = globalThis.litElementHydrateSupport) || void 0 === re || re.call(globalThis, { LitElement: ae });
const le = globalThis.litElementPolyfillSupport;
null == le || le({ LitElement: ae }), (null !== (se = globalThis.litElementVersions) && void 0 !== se ? se : globalThis.litElementVersions = []).push("3.3.2");
const ce = (e3) => (t2) => "function" == typeof t2 ? ((e4, t3) => (customElements.define(e4, t3), t3))(e3, t2) : ((e4, t3) => {
  const { kind: i2, elements: n2 } = t3;
  return { kind: i2, elements: n2, finisher(t4) {
    customElements.define(e4, t4);
  } };
})(e3, t2), he = (e3, t2) => "method" === t2.kind && t2.descriptor && !("value" in t2.descriptor) ? { ...t2, finisher(i2) {
  i2.createProperty(t2.key, e3);
} } : { kind: "field", key: Symbol(), placement: "own", descriptor: {}, originalKey: t2.key, initializer() {
  "function" == typeof t2.initializer && (this[t2.key] = t2.initializer.call(this));
}, finisher(i2) {
  i2.createProperty(t2.key, e3);
} };
function ue(e3) {
  return (t2, i2) => void 0 !== i2 ? ((e4, t3, i3) => {
    t3.constructor.createProperty(i3, e4);
  })(e3, t2, i2) : he(e3, t2);
}
function de(e3, t2) {
  return (({ finisher: e4, descriptor: t3 }) => (i2, n2) => {
    var o2;
    if (void 0 === n2) {
      const n3 = null !== (o2 = i2.originalKey) && void 0 !== o2 ? o2 : i2.key, r2 = null != t3 ? { kind: "method", placement: "prototype", key: n3, descriptor: t3(i2.key) } : { ...i2, key: n3 };
      return null != e4 && (r2.finisher = function(t4) {
        e4(t4, n3);
      }), r2;
    }
    {
      const o3 = i2.constructor;
      void 0 !== t3 && Object.defineProperty(i2, n2, t3(n2)), null == e4 || e4(o3, n2);
    }
  })({ descriptor: (i2) => {
    const n2 = { get() {
      var t3, i3;
      return null !== (i3 = null === (t3 = this.renderRoot) || void 0 === t3 ? void 0 : t3.querySelector(e3)) && void 0 !== i3 ? i3 : null;
    }, enumerable: true, configurable: true };
    if (t2) {
      const t3 = "symbol" == typeof i2 ? Symbol() : "__" + i2;
      n2.get = function() {
        var i3, n3;
        return void 0 === this[t3] && (this[t3] = null !== (n3 = null === (i3 = this.renderRoot) || void 0 === i3 ? void 0 : i3.querySelector(e3)) && void 0 !== n3 ? n3 : null), this[t3];
      };
    }
    return n2;
  } });
}
var pe;
null === (pe = window.HTMLSlotElement) || void 0 === pe || pe.prototype.assignedElements;
const _e = "151", ge = 1, me = 2, fe = 3, ve = 0, Ae = 1, be = 2, ye = 100, we = 0, xe = 1, Ce = 2, Se = 0, Ee = 1, Ie = 2, Te = 3, Be = 4, Me = 5, ke = 301, Re = 302, Pe = 303, De = 306, Le = 1e3, Fe = 1001, Ne = 1002, Oe = 1003, ze = 1004, Ue = 1005, He = 1006, Qe = 1007, Ve = 1008, Ge = 1009, $e = 1014, We = 1015, qe = 1016, je = 1020, Xe = 1023, Ye = 1026, Ke = 1027, Ze = 1028, Je = 1030, et = 33776, tt = 33777, it = 33778, nt = 33779, ot = 35840, rt = 35842, st = 37492, at = 37496, lt = 37808, ct = 36492, ht = 2201, ut = 2202, dt = 2300, pt = 2301, _t = 2302, gt = 2400, mt = 2401, ft = 2402, vt = 2500, At = 3e3, bt = 3001, yt = "srgb", wt = "srgb-linear", xt = "display-p3", Ct = 7680, St = 35044, Et = "300 es", It = 1035;
class Tt {
  addEventListener(e3, t2) {
    void 0 === this._listeners && (this._listeners = {});
    const i2 = this._listeners;
    void 0 === i2[e3] && (i2[e3] = []), -1 === i2[e3].indexOf(t2) && i2[e3].push(t2);
  }
  hasEventListener(e3, t2) {
    if (void 0 === this._listeners)
      return false;
    const i2 = this._listeners;
    return void 0 !== i2[e3] && -1 !== i2[e3].indexOf(t2);
  }
  removeEventListener(e3, t2) {
    if (void 0 === this._listeners)
      return;
    const i2 = this._listeners[e3];
    if (void 0 !== i2) {
      const e4 = i2.indexOf(t2);
      -1 !== e4 && i2.splice(e4, 1);
    }
  }
  dispatchEvent(e3) {
    if (void 0 === this._listeners)
      return;
    const t2 = this._listeners[e3.type];
    if (void 0 !== t2) {
      e3.target = this;
      const i2 = t2.slice(0);
      for (let t3 = 0, n2 = i2.length; t3 < n2; t3++)
        i2[t3].call(this, e3);
      e3.target = null;
    }
  }
}
const Bt = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let Mt = 1234567;
const kt = Math.PI / 180, Rt = 180 / Math.PI;
function Pt() {
  const e3 = 4294967295 * Math.random() | 0, t2 = 4294967295 * Math.random() | 0, i2 = 4294967295 * Math.random() | 0, n2 = 4294967295 * Math.random() | 0;
  return (Bt[255 & e3] + Bt[e3 >> 8 & 255] + Bt[e3 >> 16 & 255] + Bt[e3 >> 24 & 255] + "-" + Bt[255 & t2] + Bt[t2 >> 8 & 255] + "-" + Bt[t2 >> 16 & 15 | 64] + Bt[t2 >> 24 & 255] + "-" + Bt[63 & i2 | 128] + Bt[i2 >> 8 & 255] + "-" + Bt[i2 >> 16 & 255] + Bt[i2 >> 24 & 255] + Bt[255 & n2] + Bt[n2 >> 8 & 255] + Bt[n2 >> 16 & 255] + Bt[n2 >> 24 & 255]).toLowerCase();
}
function Dt(e3, t2, i2) {
  return Math.max(t2, Math.min(i2, e3));
}
function Lt(e3, t2) {
  return (e3 % t2 + t2) % t2;
}
function Ft(e3, t2, i2) {
  return (1 - i2) * e3 + i2 * t2;
}
function Nt(e3) {
  return 0 == (e3 & e3 - 1) && 0 !== e3;
}
function Ot(e3) {
  return Math.pow(2, Math.ceil(Math.log(e3) / Math.LN2));
}
function zt(e3) {
  return Math.pow(2, Math.floor(Math.log(e3) / Math.LN2));
}
function Ut(e3, t2) {
  switch (t2.constructor) {
    case Float32Array:
      return e3;
    case Uint16Array:
      return e3 / 65535;
    case Uint8Array:
      return e3 / 255;
    case Int16Array:
      return Math.max(e3 / 32767, -1);
    case Int8Array:
      return Math.max(e3 / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function Ht(e3, t2) {
  switch (t2.constructor) {
    case Float32Array:
      return e3;
    case Uint16Array:
      return Math.round(65535 * e3);
    case Uint8Array:
      return Math.round(255 * e3);
    case Int16Array:
      return Math.round(32767 * e3);
    case Int8Array:
      return Math.round(127 * e3);
    default:
      throw new Error("Invalid component type.");
  }
}
const Qt = { DEG2RAD: kt, RAD2DEG: Rt, generateUUID: Pt, clamp: Dt, euclideanModulo: Lt, mapLinear: function(e3, t2, i2, n2, o2) {
  return n2 + (e3 - t2) * (o2 - n2) / (i2 - t2);
}, inverseLerp: function(e3, t2, i2) {
  return e3 !== t2 ? (i2 - e3) / (t2 - e3) : 0;
}, lerp: Ft, damp: function(e3, t2, i2, n2) {
  return Ft(e3, t2, 1 - Math.exp(-i2 * n2));
}, pingpong: function(e3, t2 = 1) {
  return t2 - Math.abs(Lt(e3, 2 * t2) - t2);
}, smoothstep: function(e3, t2, i2) {
  return e3 <= t2 ? 0 : e3 >= i2 ? 1 : (e3 = (e3 - t2) / (i2 - t2)) * e3 * (3 - 2 * e3);
}, smootherstep: function(e3, t2, i2) {
  return e3 <= t2 ? 0 : e3 >= i2 ? 1 : (e3 = (e3 - t2) / (i2 - t2)) * e3 * e3 * (e3 * (6 * e3 - 15) + 10);
}, randInt: function(e3, t2) {
  return e3 + Math.floor(Math.random() * (t2 - e3 + 1));
}, randFloat: function(e3, t2) {
  return e3 + Math.random() * (t2 - e3);
}, randFloatSpread: function(e3) {
  return e3 * (0.5 - Math.random());
}, seededRandom: function(e3) {
  void 0 !== e3 && (Mt = e3);
  let t2 = Mt += 1831565813;
  return t2 = Math.imul(t2 ^ t2 >>> 15, 1 | t2), t2 ^= t2 + Math.imul(t2 ^ t2 >>> 7, 61 | t2), ((t2 ^ t2 >>> 14) >>> 0) / 4294967296;
}, degToRad: function(e3) {
  return e3 * kt;
}, radToDeg: function(e3) {
  return e3 * Rt;
}, isPowerOfTwo: Nt, ceilPowerOfTwo: Ot, floorPowerOfTwo: zt, setQuaternionFromProperEuler: function(e3, t2, i2, n2, o2) {
  const r2 = Math.cos, s2 = Math.sin, a2 = r2(i2 / 2), l2 = s2(i2 / 2), c2 = r2((t2 + n2) / 2), h2 = s2((t2 + n2) / 2), u2 = r2((t2 - n2) / 2), d2 = s2((t2 - n2) / 2), p2 = r2((n2 - t2) / 2), _2 = s2((n2 - t2) / 2);
  switch (o2) {
    case "XYX":
      e3.set(a2 * h2, l2 * u2, l2 * d2, a2 * c2);
      break;
    case "YZY":
      e3.set(l2 * d2, a2 * h2, l2 * u2, a2 * c2);
      break;
    case "ZXZ":
      e3.set(l2 * u2, l2 * d2, a2 * h2, a2 * c2);
      break;
    case "XZX":
      e3.set(a2 * h2, l2 * _2, l2 * p2, a2 * c2);
      break;
    case "YXY":
      e3.set(l2 * p2, a2 * h2, l2 * _2, a2 * c2);
      break;
    case "ZYZ":
      e3.set(l2 * _2, l2 * p2, a2 * h2, a2 * c2);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + o2);
  }
}, normalize: Ht, denormalize: Ut };
class Vt {
  constructor(e3 = 0, t2 = 0) {
    Vt.prototype.isVector2 = true, this.x = e3, this.y = t2;
  }
  get width() {
    return this.x;
  }
  set width(e3) {
    this.x = e3;
  }
  get height() {
    return this.y;
  }
  set height(e3) {
    this.y = e3;
  }
  set(e3, t2) {
    return this.x = e3, this.y = t2, this;
  }
  setScalar(e3) {
    return this.x = e3, this.y = e3, this;
  }
  setX(e3) {
    return this.x = e3, this;
  }
  setY(e3) {
    return this.y = e3, this;
  }
  setComponent(e3, t2) {
    switch (e3) {
      case 0:
        this.x = t2;
        break;
      case 1:
        this.y = t2;
        break;
      default:
        throw new Error("index is out of range: " + e3);
    }
    return this;
  }
  getComponent(e3) {
    switch (e3) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e3);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e3) {
    return this.x = e3.x, this.y = e3.y, this;
  }
  add(e3) {
    return this.x += e3.x, this.y += e3.y, this;
  }
  addScalar(e3) {
    return this.x += e3, this.y += e3, this;
  }
  addVectors(e3, t2) {
    return this.x = e3.x + t2.x, this.y = e3.y + t2.y, this;
  }
  addScaledVector(e3, t2) {
    return this.x += e3.x * t2, this.y += e3.y * t2, this;
  }
  sub(e3) {
    return this.x -= e3.x, this.y -= e3.y, this;
  }
  subScalar(e3) {
    return this.x -= e3, this.y -= e3, this;
  }
  subVectors(e3, t2) {
    return this.x = e3.x - t2.x, this.y = e3.y - t2.y, this;
  }
  multiply(e3) {
    return this.x *= e3.x, this.y *= e3.y, this;
  }
  multiplyScalar(e3) {
    return this.x *= e3, this.y *= e3, this;
  }
  divide(e3) {
    return this.x /= e3.x, this.y /= e3.y, this;
  }
  divideScalar(e3) {
    return this.multiplyScalar(1 / e3);
  }
  applyMatrix3(e3) {
    const t2 = this.x, i2 = this.y, n2 = e3.elements;
    return this.x = n2[0] * t2 + n2[3] * i2 + n2[6], this.y = n2[1] * t2 + n2[4] * i2 + n2[7], this;
  }
  min(e3) {
    return this.x = Math.min(this.x, e3.x), this.y = Math.min(this.y, e3.y), this;
  }
  max(e3) {
    return this.x = Math.max(this.x, e3.x), this.y = Math.max(this.y, e3.y), this;
  }
  clamp(e3, t2) {
    return this.x = Math.max(e3.x, Math.min(t2.x, this.x)), this.y = Math.max(e3.y, Math.min(t2.y, this.y)), this;
  }
  clampScalar(e3, t2) {
    return this.x = Math.max(e3, Math.min(t2, this.x)), this.y = Math.max(e3, Math.min(t2, this.y)), this;
  }
  clampLength(e3, t2) {
    const i2 = this.length();
    return this.divideScalar(i2 || 1).multiplyScalar(Math.max(e3, Math.min(t2, i2)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e3) {
    return this.x * e3.x + this.y * e3.y;
  }
  cross(e3) {
    return this.x * e3.y - this.y * e3.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e3) {
    const t2 = Math.sqrt(this.lengthSq() * e3.lengthSq());
    if (0 === t2)
      return Math.PI / 2;
    const i2 = this.dot(e3) / t2;
    return Math.acos(Dt(i2, -1, 1));
  }
  distanceTo(e3) {
    return Math.sqrt(this.distanceToSquared(e3));
  }
  distanceToSquared(e3) {
    const t2 = this.x - e3.x, i2 = this.y - e3.y;
    return t2 * t2 + i2 * i2;
  }
  manhattanDistanceTo(e3) {
    return Math.abs(this.x - e3.x) + Math.abs(this.y - e3.y);
  }
  setLength(e3) {
    return this.normalize().multiplyScalar(e3);
  }
  lerp(e3, t2) {
    return this.x += (e3.x - this.x) * t2, this.y += (e3.y - this.y) * t2, this;
  }
  lerpVectors(e3, t2, i2) {
    return this.x = e3.x + (t2.x - e3.x) * i2, this.y = e3.y + (t2.y - e3.y) * i2, this;
  }
  equals(e3) {
    return e3.x === this.x && e3.y === this.y;
  }
  fromArray(e3, t2 = 0) {
    return this.x = e3[t2], this.y = e3[t2 + 1], this;
  }
  toArray(e3 = [], t2 = 0) {
    return e3[t2] = this.x, e3[t2 + 1] = this.y, e3;
  }
  fromBufferAttribute(e3, t2) {
    return this.x = e3.getX(t2), this.y = e3.getY(t2), this;
  }
  rotateAround(e3, t2) {
    const i2 = Math.cos(t2), n2 = Math.sin(t2), o2 = this.x - e3.x, r2 = this.y - e3.y;
    return this.x = o2 * i2 - r2 * n2 + e3.x, this.y = o2 * n2 + r2 * i2 + e3.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Gt {
  constructor() {
    Gt.prototype.isMatrix3 = true, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  }
  set(e3, t2, i2, n2, o2, r2, s2, a2, l2) {
    const c2 = this.elements;
    return c2[0] = e3, c2[1] = n2, c2[2] = s2, c2[3] = t2, c2[4] = o2, c2[5] = a2, c2[6] = i2, c2[7] = r2, c2[8] = l2, this;
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e3) {
    const t2 = this.elements, i2 = e3.elements;
    return t2[0] = i2[0], t2[1] = i2[1], t2[2] = i2[2], t2[3] = i2[3], t2[4] = i2[4], t2[5] = i2[5], t2[6] = i2[6], t2[7] = i2[7], t2[8] = i2[8], this;
  }
  extractBasis(e3, t2, i2) {
    return e3.setFromMatrix3Column(this, 0), t2.setFromMatrix3Column(this, 1), i2.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e3) {
    const t2 = e3.elements;
    return this.set(t2[0], t2[4], t2[8], t2[1], t2[5], t2[9], t2[2], t2[6], t2[10]), this;
  }
  multiply(e3) {
    return this.multiplyMatrices(this, e3);
  }
  premultiply(e3) {
    return this.multiplyMatrices(e3, this);
  }
  multiplyMatrices(e3, t2) {
    const i2 = e3.elements, n2 = t2.elements, o2 = this.elements, r2 = i2[0], s2 = i2[3], a2 = i2[6], l2 = i2[1], c2 = i2[4], h2 = i2[7], u2 = i2[2], d2 = i2[5], p2 = i2[8], _2 = n2[0], g2 = n2[3], m2 = n2[6], f2 = n2[1], v2 = n2[4], A2 = n2[7], b2 = n2[2], y2 = n2[5], w2 = n2[8];
    return o2[0] = r2 * _2 + s2 * f2 + a2 * b2, o2[3] = r2 * g2 + s2 * v2 + a2 * y2, o2[6] = r2 * m2 + s2 * A2 + a2 * w2, o2[1] = l2 * _2 + c2 * f2 + h2 * b2, o2[4] = l2 * g2 + c2 * v2 + h2 * y2, o2[7] = l2 * m2 + c2 * A2 + h2 * w2, o2[2] = u2 * _2 + d2 * f2 + p2 * b2, o2[5] = u2 * g2 + d2 * v2 + p2 * y2, o2[8] = u2 * m2 + d2 * A2 + p2 * w2, this;
  }
  multiplyScalar(e3) {
    const t2 = this.elements;
    return t2[0] *= e3, t2[3] *= e3, t2[6] *= e3, t2[1] *= e3, t2[4] *= e3, t2[7] *= e3, t2[2] *= e3, t2[5] *= e3, t2[8] *= e3, this;
  }
  determinant() {
    const e3 = this.elements, t2 = e3[0], i2 = e3[1], n2 = e3[2], o2 = e3[3], r2 = e3[4], s2 = e3[5], a2 = e3[6], l2 = e3[7], c2 = e3[8];
    return t2 * r2 * c2 - t2 * s2 * l2 - i2 * o2 * c2 + i2 * s2 * a2 + n2 * o2 * l2 - n2 * r2 * a2;
  }
  invert() {
    const e3 = this.elements, t2 = e3[0], i2 = e3[1], n2 = e3[2], o2 = e3[3], r2 = e3[4], s2 = e3[5], a2 = e3[6], l2 = e3[7], c2 = e3[8], h2 = c2 * r2 - s2 * l2, u2 = s2 * a2 - c2 * o2, d2 = l2 * o2 - r2 * a2, p2 = t2 * h2 + i2 * u2 + n2 * d2;
    if (0 === p2)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const _2 = 1 / p2;
    return e3[0] = h2 * _2, e3[1] = (n2 * l2 - c2 * i2) * _2, e3[2] = (s2 * i2 - n2 * r2) * _2, e3[3] = u2 * _2, e3[4] = (c2 * t2 - n2 * a2) * _2, e3[5] = (n2 * o2 - s2 * t2) * _2, e3[6] = d2 * _2, e3[7] = (i2 * a2 - l2 * t2) * _2, e3[8] = (r2 * t2 - i2 * o2) * _2, this;
  }
  transpose() {
    let e3;
    const t2 = this.elements;
    return e3 = t2[1], t2[1] = t2[3], t2[3] = e3, e3 = t2[2], t2[2] = t2[6], t2[6] = e3, e3 = t2[5], t2[5] = t2[7], t2[7] = e3, this;
  }
  getNormalMatrix(e3) {
    return this.setFromMatrix4(e3).invert().transpose();
  }
  transposeIntoArray(e3) {
    const t2 = this.elements;
    return e3[0] = t2[0], e3[1] = t2[3], e3[2] = t2[6], e3[3] = t2[1], e3[4] = t2[4], e3[5] = t2[7], e3[6] = t2[2], e3[7] = t2[5], e3[8] = t2[8], this;
  }
  setUvTransform(e3, t2, i2, n2, o2, r2, s2) {
    const a2 = Math.cos(o2), l2 = Math.sin(o2);
    return this.set(i2 * a2, i2 * l2, -i2 * (a2 * r2 + l2 * s2) + r2 + e3, -n2 * l2, n2 * a2, -n2 * (-l2 * r2 + a2 * s2) + s2 + t2, 0, 0, 1), this;
  }
  scale(e3, t2) {
    return this.premultiply($t.makeScale(e3, t2)), this;
  }
  rotate(e3) {
    return this.premultiply($t.makeRotation(-e3)), this;
  }
  translate(e3, t2) {
    return this.premultiply($t.makeTranslation(e3, t2)), this;
  }
  makeTranslation(e3, t2) {
    return this.set(1, 0, e3, 0, 1, t2, 0, 0, 1), this;
  }
  makeRotation(e3) {
    const t2 = Math.cos(e3), i2 = Math.sin(e3);
    return this.set(t2, -i2, 0, i2, t2, 0, 0, 0, 1), this;
  }
  makeScale(e3, t2) {
    return this.set(e3, 0, 0, 0, t2, 0, 0, 0, 1), this;
  }
  equals(e3) {
    const t2 = this.elements, i2 = e3.elements;
    for (let e4 = 0; e4 < 9; e4++)
      if (t2[e4] !== i2[e4])
        return false;
    return true;
  }
  fromArray(e3, t2 = 0) {
    for (let i2 = 0; i2 < 9; i2++)
      this.elements[i2] = e3[i2 + t2];
    return this;
  }
  toArray(e3 = [], t2 = 0) {
    const i2 = this.elements;
    return e3[t2] = i2[0], e3[t2 + 1] = i2[1], e3[t2 + 2] = i2[2], e3[t2 + 3] = i2[3], e3[t2 + 4] = i2[4], e3[t2 + 5] = i2[5], e3[t2 + 6] = i2[6], e3[t2 + 7] = i2[7], e3[t2 + 8] = i2[8], e3;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const $t = new Gt();
function Wt(e3) {
  for (let t2 = e3.length - 1; t2 >= 0; --t2)
    if (e3[t2] >= 65535)
      return true;
  return false;
}
function qt(e3) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", e3);
}
function jt(e3) {
  return e3 < 0.04045 ? 0.0773993808 * e3 : Math.pow(0.9478672986 * e3 + 0.0521327014, 2.4);
}
function Xt(e3) {
  return e3 < 31308e-7 ? 12.92 * e3 : 1.055 * Math.pow(e3, 0.41666) - 0.055;
}
const Yt = new Gt().fromArray([0.8224621, 0.0331941, 0.0170827, 0.177538, 0.9668058, 0.0723974, -1e-7, 1e-7, 0.9105199]), Kt = new Gt().fromArray([1.2249401, -0.0420569, -0.0196376, -0.2249404, 1.0420571, -0.0786361, 1e-7, 0, 1.0982735]);
const Zt = { [wt]: (e3) => e3, [yt]: (e3) => e3.convertSRGBToLinear(), [xt]: function(e3) {
  return e3.convertSRGBToLinear().applyMatrix3(Kt);
} }, Jt = { [wt]: (e3) => e3, [yt]: (e3) => e3.convertLinearToSRGB(), [xt]: function(e3) {
  return e3.applyMatrix3(Yt).convertLinearToSRGB();
} }, ei = { enabled: false, get legacyMode() {
  return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), !this.enabled;
}, set legacyMode(e3) {
  console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), this.enabled = !e3;
}, get workingColorSpace() {
  return wt;
}, set workingColorSpace(e3) {
  console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
}, convert: function(e3, t2, i2) {
  if (false === this.enabled || t2 === i2 || !t2 || !i2)
    return e3;
  const n2 = Zt[t2], o2 = Jt[i2];
  if (void 0 === n2 || void 0 === o2)
    throw new Error(`Unsupported color space conversion, "${t2}" to "${i2}".`);
  return o2(n2(e3));
}, fromWorkingColorSpace: function(e3, t2) {
  return this.convert(e3, this.workingColorSpace, t2);
}, toWorkingColorSpace: function(e3, t2) {
  return this.convert(e3, t2, this.workingColorSpace);
} };
let ti;
class ii {
  static getDataURL(e3) {
    if (/^data:/i.test(e3.src))
      return e3.src;
    if ("undefined" == typeof HTMLCanvasElement)
      return e3.src;
    let t2;
    if (e3 instanceof HTMLCanvasElement)
      t2 = e3;
    else {
      void 0 === ti && (ti = qt("canvas")), ti.width = e3.width, ti.height = e3.height;
      const i2 = ti.getContext("2d");
      e3 instanceof ImageData ? i2.putImageData(e3, 0, 0) : i2.drawImage(e3, 0, 0, e3.width, e3.height), t2 = ti;
    }
    return t2.width > 2048 || t2.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e3), t2.toDataURL("image/jpeg", 0.6)) : t2.toDataURL("image/png");
  }
  static sRGBToLinear(e3) {
    if ("undefined" != typeof HTMLImageElement && e3 instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e3 instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e3 instanceof ImageBitmap) {
      const t2 = qt("canvas");
      t2.width = e3.width, t2.height = e3.height;
      const i2 = t2.getContext("2d");
      i2.drawImage(e3, 0, 0, e3.width, e3.height);
      const n2 = i2.getImageData(0, 0, e3.width, e3.height), o2 = n2.data;
      for (let e4 = 0; e4 < o2.length; e4++)
        o2[e4] = 255 * jt(o2[e4] / 255);
      return i2.putImageData(n2, 0, 0), t2;
    }
    if (e3.data) {
      const t2 = e3.data.slice(0);
      for (let e4 = 0; e4 < t2.length; e4++)
        t2 instanceof Uint8Array || t2 instanceof Uint8ClampedArray ? t2[e4] = Math.floor(255 * jt(t2[e4] / 255)) : t2[e4] = jt(t2[e4]);
      return { data: t2, width: e3.width, height: e3.height };
    }
    return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e3;
  }
}
class ni {
  constructor(e3 = null) {
    this.isSource = true, this.uuid = Pt(), this.data = e3, this.version = 0;
  }
  set needsUpdate(e3) {
    true === e3 && this.version++;
  }
  toJSON(e3) {
    const t2 = void 0 === e3 || "string" == typeof e3;
    if (!t2 && void 0 !== e3.images[this.uuid])
      return e3.images[this.uuid];
    const i2 = { uuid: this.uuid, url: "" }, n2 = this.data;
    if (null !== n2) {
      let e4;
      if (Array.isArray(n2)) {
        e4 = [];
        for (let t3 = 0, i3 = n2.length; t3 < i3; t3++)
          n2[t3].isDataTexture ? e4.push(oi(n2[t3].image)) : e4.push(oi(n2[t3]));
      } else
        e4 = oi(n2);
      i2.url = e4;
    }
    return t2 || (e3.images[this.uuid] = i2), i2;
  }
}
function oi(e3) {
  return "undefined" != typeof HTMLImageElement && e3 instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e3 instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e3 instanceof ImageBitmap ? ii.getDataURL(e3) : e3.data ? { data: Array.from(e3.data), width: e3.width, height: e3.height, type: e3.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let ri = 0, si = class e2 extends Tt {
  constructor(t2 = e2.DEFAULT_IMAGE, i2 = e2.DEFAULT_MAPPING, n2 = 1001, o2 = 1001, r2 = 1006, s2 = 1008, a2 = 1023, l2 = 1009, c2 = e2.DEFAULT_ANISOTROPY, h2 = At) {
    super(), this.isTexture = true, Object.defineProperty(this, "id", { value: ri++ }), this.uuid = Pt(), this.name = "", this.source = new ni(t2), this.mipmaps = [], this.mapping = i2, this.channel = 0, this.wrapS = n2, this.wrapT = o2, this.magFilter = r2, this.minFilter = s2, this.anisotropy = c2, this.format = a2, this.internalFormat = null, this.type = l2, this.offset = new Vt(0, 0), this.repeat = new Vt(1, 1), this.center = new Vt(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new Gt(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.encoding = h2, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = false, this.needsPMREMUpdate = false;
  }
  get image() {
    return this.source.data;
  }
  set image(e3 = null) {
    this.source.data = e3;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e3) {
    return this.name = e3.name, this.source = e3.source, this.mipmaps = e3.mipmaps.slice(0), this.mapping = e3.mapping, this.channel = e3.channel, this.wrapS = e3.wrapS, this.wrapT = e3.wrapT, this.magFilter = e3.magFilter, this.minFilter = e3.minFilter, this.anisotropy = e3.anisotropy, this.format = e3.format, this.internalFormat = e3.internalFormat, this.type = e3.type, this.offset.copy(e3.offset), this.repeat.copy(e3.repeat), this.center.copy(e3.center), this.rotation = e3.rotation, this.matrixAutoUpdate = e3.matrixAutoUpdate, this.matrix.copy(e3.matrix), this.generateMipmaps = e3.generateMipmaps, this.premultiplyAlpha = e3.premultiplyAlpha, this.flipY = e3.flipY, this.unpackAlignment = e3.unpackAlignment, this.encoding = e3.encoding, this.userData = JSON.parse(JSON.stringify(e3.userData)), this.needsUpdate = true, this;
  }
  toJSON(e3) {
    const t2 = void 0 === e3 || "string" == typeof e3;
    if (!t2 && void 0 !== e3.textures[this.uuid])
      return e3.textures[this.uuid];
    const i2 = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, image: this.source.toJSON(e3).uuid, mapping: this.mapping, channel: this.channel, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, internalFormat: this.internalFormat, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, generateMipmaps: this.generateMipmaps, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
    return Object.keys(this.userData).length > 0 && (i2.userData = this.userData), t2 || (e3.textures[this.uuid] = i2), i2;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e3) {
    if (300 !== this.mapping)
      return e3;
    if (e3.applyMatrix3(this.matrix), e3.x < 0 || e3.x > 1)
      switch (this.wrapS) {
        case Le:
          e3.x = e3.x - Math.floor(e3.x);
          break;
        case Fe:
          e3.x = e3.x < 0 ? 0 : 1;
          break;
        case Ne:
          1 === Math.abs(Math.floor(e3.x) % 2) ? e3.x = Math.ceil(e3.x) - e3.x : e3.x = e3.x - Math.floor(e3.x);
      }
    if (e3.y < 0 || e3.y > 1)
      switch (this.wrapT) {
        case Le:
          e3.y = e3.y - Math.floor(e3.y);
          break;
        case Fe:
          e3.y = e3.y < 0 ? 0 : 1;
          break;
        case Ne:
          1 === Math.abs(Math.floor(e3.y) % 2) ? e3.y = Math.ceil(e3.y) - e3.y : e3.y = e3.y - Math.floor(e3.y);
      }
    return this.flipY && (e3.y = 1 - e3.y), e3;
  }
  set needsUpdate(e3) {
    true === e3 && (this.version++, this.source.needsUpdate = true);
  }
};
si.DEFAULT_IMAGE = null, si.DEFAULT_MAPPING = 300, si.DEFAULT_ANISOTROPY = 1;
class ai {
  constructor(e3 = 0, t2 = 0, i2 = 0, n2 = 1) {
    ai.prototype.isVector4 = true, this.x = e3, this.y = t2, this.z = i2, this.w = n2;
  }
  get width() {
    return this.z;
  }
  set width(e3) {
    this.z = e3;
  }
  get height() {
    return this.w;
  }
  set height(e3) {
    this.w = e3;
  }
  set(e3, t2, i2, n2) {
    return this.x = e3, this.y = t2, this.z = i2, this.w = n2, this;
  }
  setScalar(e3) {
    return this.x = e3, this.y = e3, this.z = e3, this.w = e3, this;
  }
  setX(e3) {
    return this.x = e3, this;
  }
  setY(e3) {
    return this.y = e3, this;
  }
  setZ(e3) {
    return this.z = e3, this;
  }
  setW(e3) {
    return this.w = e3, this;
  }
  setComponent(e3, t2) {
    switch (e3) {
      case 0:
        this.x = t2;
        break;
      case 1:
        this.y = t2;
        break;
      case 2:
        this.z = t2;
        break;
      case 3:
        this.w = t2;
        break;
      default:
        throw new Error("index is out of range: " + e3);
    }
    return this;
  }
  getComponent(e3) {
    switch (e3) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e3);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e3) {
    return this.x = e3.x, this.y = e3.y, this.z = e3.z, this.w = void 0 !== e3.w ? e3.w : 1, this;
  }
  add(e3) {
    return this.x += e3.x, this.y += e3.y, this.z += e3.z, this.w += e3.w, this;
  }
  addScalar(e3) {
    return this.x += e3, this.y += e3, this.z += e3, this.w += e3, this;
  }
  addVectors(e3, t2) {
    return this.x = e3.x + t2.x, this.y = e3.y + t2.y, this.z = e3.z + t2.z, this.w = e3.w + t2.w, this;
  }
  addScaledVector(e3, t2) {
    return this.x += e3.x * t2, this.y += e3.y * t2, this.z += e3.z * t2, this.w += e3.w * t2, this;
  }
  sub(e3) {
    return this.x -= e3.x, this.y -= e3.y, this.z -= e3.z, this.w -= e3.w, this;
  }
  subScalar(e3) {
    return this.x -= e3, this.y -= e3, this.z -= e3, this.w -= e3, this;
  }
  subVectors(e3, t2) {
    return this.x = e3.x - t2.x, this.y = e3.y - t2.y, this.z = e3.z - t2.z, this.w = e3.w - t2.w, this;
  }
  multiply(e3) {
    return this.x *= e3.x, this.y *= e3.y, this.z *= e3.z, this.w *= e3.w, this;
  }
  multiplyScalar(e3) {
    return this.x *= e3, this.y *= e3, this.z *= e3, this.w *= e3, this;
  }
  applyMatrix4(e3) {
    const t2 = this.x, i2 = this.y, n2 = this.z, o2 = this.w, r2 = e3.elements;
    return this.x = r2[0] * t2 + r2[4] * i2 + r2[8] * n2 + r2[12] * o2, this.y = r2[1] * t2 + r2[5] * i2 + r2[9] * n2 + r2[13] * o2, this.z = r2[2] * t2 + r2[6] * i2 + r2[10] * n2 + r2[14] * o2, this.w = r2[3] * t2 + r2[7] * i2 + r2[11] * n2 + r2[15] * o2, this;
  }
  divideScalar(e3) {
    return this.multiplyScalar(1 / e3);
  }
  setAxisAngleFromQuaternion(e3) {
    this.w = 2 * Math.acos(e3.w);
    const t2 = Math.sqrt(1 - e3.w * e3.w);
    return t2 < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e3.x / t2, this.y = e3.y / t2, this.z = e3.z / t2), this;
  }
  setAxisAngleFromRotationMatrix(e3) {
    let t2, i2, n2, o2;
    const r2 = 0.01, s2 = 0.1, a2 = e3.elements, l2 = a2[0], c2 = a2[4], h2 = a2[8], u2 = a2[1], d2 = a2[5], p2 = a2[9], _2 = a2[2], g2 = a2[6], m2 = a2[10];
    if (Math.abs(c2 - u2) < r2 && Math.abs(h2 - _2) < r2 && Math.abs(p2 - g2) < r2) {
      if (Math.abs(c2 + u2) < s2 && Math.abs(h2 + _2) < s2 && Math.abs(p2 + g2) < s2 && Math.abs(l2 + d2 + m2 - 3) < s2)
        return this.set(1, 0, 0, 0), this;
      t2 = Math.PI;
      const e4 = (l2 + 1) / 2, a3 = (d2 + 1) / 2, f3 = (m2 + 1) / 2, v2 = (c2 + u2) / 4, A2 = (h2 + _2) / 4, b2 = (p2 + g2) / 4;
      return e4 > a3 && e4 > f3 ? e4 < r2 ? (i2 = 0, n2 = 0.707106781, o2 = 0.707106781) : (i2 = Math.sqrt(e4), n2 = v2 / i2, o2 = A2 / i2) : a3 > f3 ? a3 < r2 ? (i2 = 0.707106781, n2 = 0, o2 = 0.707106781) : (n2 = Math.sqrt(a3), i2 = v2 / n2, o2 = b2 / n2) : f3 < r2 ? (i2 = 0.707106781, n2 = 0.707106781, o2 = 0) : (o2 = Math.sqrt(f3), i2 = A2 / o2, n2 = b2 / o2), this.set(i2, n2, o2, t2), this;
    }
    let f2 = Math.sqrt((g2 - p2) * (g2 - p2) + (h2 - _2) * (h2 - _2) + (u2 - c2) * (u2 - c2));
    return Math.abs(f2) < 1e-3 && (f2 = 1), this.x = (g2 - p2) / f2, this.y = (h2 - _2) / f2, this.z = (u2 - c2) / f2, this.w = Math.acos((l2 + d2 + m2 - 1) / 2), this;
  }
  min(e3) {
    return this.x = Math.min(this.x, e3.x), this.y = Math.min(this.y, e3.y), this.z = Math.min(this.z, e3.z), this.w = Math.min(this.w, e3.w), this;
  }
  max(e3) {
    return this.x = Math.max(this.x, e3.x), this.y = Math.max(this.y, e3.y), this.z = Math.max(this.z, e3.z), this.w = Math.max(this.w, e3.w), this;
  }
  clamp(e3, t2) {
    return this.x = Math.max(e3.x, Math.min(t2.x, this.x)), this.y = Math.max(e3.y, Math.min(t2.y, this.y)), this.z = Math.max(e3.z, Math.min(t2.z, this.z)), this.w = Math.max(e3.w, Math.min(t2.w, this.w)), this;
  }
  clampScalar(e3, t2) {
    return this.x = Math.max(e3, Math.min(t2, this.x)), this.y = Math.max(e3, Math.min(t2, this.y)), this.z = Math.max(e3, Math.min(t2, this.z)), this.w = Math.max(e3, Math.min(t2, this.w)), this;
  }
  clampLength(e3, t2) {
    const i2 = this.length();
    return this.divideScalar(i2 || 1).multiplyScalar(Math.max(e3, Math.min(t2, i2)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e3) {
    return this.x * e3.x + this.y * e3.y + this.z * e3.z + this.w * e3.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e3) {
    return this.normalize().multiplyScalar(e3);
  }
  lerp(e3, t2) {
    return this.x += (e3.x - this.x) * t2, this.y += (e3.y - this.y) * t2, this.z += (e3.z - this.z) * t2, this.w += (e3.w - this.w) * t2, this;
  }
  lerpVectors(e3, t2, i2) {
    return this.x = e3.x + (t2.x - e3.x) * i2, this.y = e3.y + (t2.y - e3.y) * i2, this.z = e3.z + (t2.z - e3.z) * i2, this.w = e3.w + (t2.w - e3.w) * i2, this;
  }
  equals(e3) {
    return e3.x === this.x && e3.y === this.y && e3.z === this.z && e3.w === this.w;
  }
  fromArray(e3, t2 = 0) {
    return this.x = e3[t2], this.y = e3[t2 + 1], this.z = e3[t2 + 2], this.w = e3[t2 + 3], this;
  }
  toArray(e3 = [], t2 = 0) {
    return e3[t2] = this.x, e3[t2 + 1] = this.y, e3[t2 + 2] = this.z, e3[t2 + 3] = this.w, e3;
  }
  fromBufferAttribute(e3, t2) {
    return this.x = e3.getX(t2), this.y = e3.getY(t2), this.z = e3.getZ(t2), this.w = e3.getW(t2), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class li extends Tt {
  constructor(e3 = 1, t2 = 1, i2 = {}) {
    super(), this.isWebGLRenderTarget = true, this.width = e3, this.height = t2, this.depth = 1, this.scissor = new ai(0, 0, e3, t2), this.scissorTest = false, this.viewport = new ai(0, 0, e3, t2);
    const n2 = { width: e3, height: t2, depth: 1 };
    this.texture = new si(n2, i2.mapping, i2.wrapS, i2.wrapT, i2.magFilter, i2.minFilter, i2.format, i2.type, i2.anisotropy, i2.encoding), this.texture.isRenderTargetTexture = true, this.texture.flipY = false, this.texture.generateMipmaps = void 0 !== i2.generateMipmaps && i2.generateMipmaps, this.texture.internalFormat = void 0 !== i2.internalFormat ? i2.internalFormat : null, this.texture.minFilter = void 0 !== i2.minFilter ? i2.minFilter : He, this.depthBuffer = void 0 === i2.depthBuffer || i2.depthBuffer, this.stencilBuffer = void 0 !== i2.stencilBuffer && i2.stencilBuffer, this.depthTexture = void 0 !== i2.depthTexture ? i2.depthTexture : null, this.samples = void 0 !== i2.samples ? i2.samples : 0;
  }
  setSize(e3, t2, i2 = 1) {
    this.width === e3 && this.height === t2 && this.depth === i2 || (this.width = e3, this.height = t2, this.depth = i2, this.texture.image.width = e3, this.texture.image.height = t2, this.texture.image.depth = i2, this.dispose()), this.viewport.set(0, 0, e3, t2), this.scissor.set(0, 0, e3, t2);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e3) {
    this.width = e3.width, this.height = e3.height, this.depth = e3.depth, this.viewport.copy(e3.viewport), this.texture = e3.texture.clone(), this.texture.isRenderTargetTexture = true;
    const t2 = Object.assign({}, e3.texture.image);
    return this.texture.source = new ni(t2), this.depthBuffer = e3.depthBuffer, this.stencilBuffer = e3.stencilBuffer, null !== e3.depthTexture && (this.depthTexture = e3.depthTexture.clone()), this.samples = e3.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class ci extends si {
  constructor(e3 = null, t2 = 1, i2 = 1, n2 = 1) {
    super(null), this.isDataArrayTexture = true, this.image = { data: e3, width: t2, height: i2, depth: n2 }, this.magFilter = Oe, this.minFilter = Oe, this.wrapR = Fe, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
  }
}
class hi extends si {
  constructor(e3 = null, t2 = 1, i2 = 1, n2 = 1) {
    super(null), this.isData3DTexture = true, this.image = { data: e3, width: t2, height: i2, depth: n2 }, this.magFilter = Oe, this.minFilter = Oe, this.wrapR = Fe, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
  }
}
class ui {
  constructor(e3 = 0, t2 = 0, i2 = 0, n2 = 1) {
    this.isQuaternion = true, this._x = e3, this._y = t2, this._z = i2, this._w = n2;
  }
  static slerpFlat(e3, t2, i2, n2, o2, r2, s2) {
    let a2 = i2[n2 + 0], l2 = i2[n2 + 1], c2 = i2[n2 + 2], h2 = i2[n2 + 3];
    const u2 = o2[r2 + 0], d2 = o2[r2 + 1], p2 = o2[r2 + 2], _2 = o2[r2 + 3];
    if (0 === s2)
      return e3[t2 + 0] = a2, e3[t2 + 1] = l2, e3[t2 + 2] = c2, void (e3[t2 + 3] = h2);
    if (1 === s2)
      return e3[t2 + 0] = u2, e3[t2 + 1] = d2, e3[t2 + 2] = p2, void (e3[t2 + 3] = _2);
    if (h2 !== _2 || a2 !== u2 || l2 !== d2 || c2 !== p2) {
      let e4 = 1 - s2;
      const t3 = a2 * u2 + l2 * d2 + c2 * p2 + h2 * _2, i3 = t3 >= 0 ? 1 : -1, n3 = 1 - t3 * t3;
      if (n3 > Number.EPSILON) {
        const o4 = Math.sqrt(n3), r3 = Math.atan2(o4, t3 * i3);
        e4 = Math.sin(e4 * r3) / o4, s2 = Math.sin(s2 * r3) / o4;
      }
      const o3 = s2 * i3;
      if (a2 = a2 * e4 + u2 * o3, l2 = l2 * e4 + d2 * o3, c2 = c2 * e4 + p2 * o3, h2 = h2 * e4 + _2 * o3, e4 === 1 - s2) {
        const e5 = 1 / Math.sqrt(a2 * a2 + l2 * l2 + c2 * c2 + h2 * h2);
        a2 *= e5, l2 *= e5, c2 *= e5, h2 *= e5;
      }
    }
    e3[t2] = a2, e3[t2 + 1] = l2, e3[t2 + 2] = c2, e3[t2 + 3] = h2;
  }
  static multiplyQuaternionsFlat(e3, t2, i2, n2, o2, r2) {
    const s2 = i2[n2], a2 = i2[n2 + 1], l2 = i2[n2 + 2], c2 = i2[n2 + 3], h2 = o2[r2], u2 = o2[r2 + 1], d2 = o2[r2 + 2], p2 = o2[r2 + 3];
    return e3[t2] = s2 * p2 + c2 * h2 + a2 * d2 - l2 * u2, e3[t2 + 1] = a2 * p2 + c2 * u2 + l2 * h2 - s2 * d2, e3[t2 + 2] = l2 * p2 + c2 * d2 + s2 * u2 - a2 * h2, e3[t2 + 3] = c2 * p2 - s2 * h2 - a2 * u2 - l2 * d2, e3;
  }
  get x() {
    return this._x;
  }
  set x(e3) {
    this._x = e3, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e3) {
    this._y = e3, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e3) {
    this._z = e3, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e3) {
    this._w = e3, this._onChangeCallback();
  }
  set(e3, t2, i2, n2) {
    return this._x = e3, this._y = t2, this._z = i2, this._w = n2, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e3) {
    return this._x = e3.x, this._y = e3.y, this._z = e3.z, this._w = e3.w, this._onChangeCallback(), this;
  }
  setFromEuler(e3, t2) {
    const i2 = e3._x, n2 = e3._y, o2 = e3._z, r2 = e3._order, s2 = Math.cos, a2 = Math.sin, l2 = s2(i2 / 2), c2 = s2(n2 / 2), h2 = s2(o2 / 2), u2 = a2(i2 / 2), d2 = a2(n2 / 2), p2 = a2(o2 / 2);
    switch (r2) {
      case "XYZ":
        this._x = u2 * c2 * h2 + l2 * d2 * p2, this._y = l2 * d2 * h2 - u2 * c2 * p2, this._z = l2 * c2 * p2 + u2 * d2 * h2, this._w = l2 * c2 * h2 - u2 * d2 * p2;
        break;
      case "YXZ":
        this._x = u2 * c2 * h2 + l2 * d2 * p2, this._y = l2 * d2 * h2 - u2 * c2 * p2, this._z = l2 * c2 * p2 - u2 * d2 * h2, this._w = l2 * c2 * h2 + u2 * d2 * p2;
        break;
      case "ZXY":
        this._x = u2 * c2 * h2 - l2 * d2 * p2, this._y = l2 * d2 * h2 + u2 * c2 * p2, this._z = l2 * c2 * p2 + u2 * d2 * h2, this._w = l2 * c2 * h2 - u2 * d2 * p2;
        break;
      case "ZYX":
        this._x = u2 * c2 * h2 - l2 * d2 * p2, this._y = l2 * d2 * h2 + u2 * c2 * p2, this._z = l2 * c2 * p2 - u2 * d2 * h2, this._w = l2 * c2 * h2 + u2 * d2 * p2;
        break;
      case "YZX":
        this._x = u2 * c2 * h2 + l2 * d2 * p2, this._y = l2 * d2 * h2 + u2 * c2 * p2, this._z = l2 * c2 * p2 - u2 * d2 * h2, this._w = l2 * c2 * h2 - u2 * d2 * p2;
        break;
      case "XZY":
        this._x = u2 * c2 * h2 - l2 * d2 * p2, this._y = l2 * d2 * h2 - u2 * c2 * p2, this._z = l2 * c2 * p2 + u2 * d2 * h2, this._w = l2 * c2 * h2 + u2 * d2 * p2;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + r2);
    }
    return false !== t2 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e3, t2) {
    const i2 = t2 / 2, n2 = Math.sin(i2);
    return this._x = e3.x * n2, this._y = e3.y * n2, this._z = e3.z * n2, this._w = Math.cos(i2), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e3) {
    const t2 = e3.elements, i2 = t2[0], n2 = t2[4], o2 = t2[8], r2 = t2[1], s2 = t2[5], a2 = t2[9], l2 = t2[2], c2 = t2[6], h2 = t2[10], u2 = i2 + s2 + h2;
    if (u2 > 0) {
      const e4 = 0.5 / Math.sqrt(u2 + 1);
      this._w = 0.25 / e4, this._x = (c2 - a2) * e4, this._y = (o2 - l2) * e4, this._z = (r2 - n2) * e4;
    } else if (i2 > s2 && i2 > h2) {
      const e4 = 2 * Math.sqrt(1 + i2 - s2 - h2);
      this._w = (c2 - a2) / e4, this._x = 0.25 * e4, this._y = (n2 + r2) / e4, this._z = (o2 + l2) / e4;
    } else if (s2 > h2) {
      const e4 = 2 * Math.sqrt(1 + s2 - i2 - h2);
      this._w = (o2 - l2) / e4, this._x = (n2 + r2) / e4, this._y = 0.25 * e4, this._z = (a2 + c2) / e4;
    } else {
      const e4 = 2 * Math.sqrt(1 + h2 - i2 - s2);
      this._w = (r2 - n2) / e4, this._x = (o2 + l2) / e4, this._y = (a2 + c2) / e4, this._z = 0.25 * e4;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e3, t2) {
    let i2 = e3.dot(t2) + 1;
    return i2 < Number.EPSILON ? (i2 = 0, Math.abs(e3.x) > Math.abs(e3.z) ? (this._x = -e3.y, this._y = e3.x, this._z = 0, this._w = i2) : (this._x = 0, this._y = -e3.z, this._z = e3.y, this._w = i2)) : (this._x = e3.y * t2.z - e3.z * t2.y, this._y = e3.z * t2.x - e3.x * t2.z, this._z = e3.x * t2.y - e3.y * t2.x, this._w = i2), this.normalize();
  }
  angleTo(e3) {
    return 2 * Math.acos(Math.abs(Dt(this.dot(e3), -1, 1)));
  }
  rotateTowards(e3, t2) {
    const i2 = this.angleTo(e3);
    if (0 === i2)
      return this;
    const n2 = Math.min(1, t2 / i2);
    return this.slerp(e3, n2), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e3) {
    return this._x * e3._x + this._y * e3._y + this._z * e3._z + this._w * e3._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e3 = this.length();
    return 0 === e3 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e3 = 1 / e3, this._x = this._x * e3, this._y = this._y * e3, this._z = this._z * e3, this._w = this._w * e3), this._onChangeCallback(), this;
  }
  multiply(e3) {
    return this.multiplyQuaternions(this, e3);
  }
  premultiply(e3) {
    return this.multiplyQuaternions(e3, this);
  }
  multiplyQuaternions(e3, t2) {
    const i2 = e3._x, n2 = e3._y, o2 = e3._z, r2 = e3._w, s2 = t2._x, a2 = t2._y, l2 = t2._z, c2 = t2._w;
    return this._x = i2 * c2 + r2 * s2 + n2 * l2 - o2 * a2, this._y = n2 * c2 + r2 * a2 + o2 * s2 - i2 * l2, this._z = o2 * c2 + r2 * l2 + i2 * a2 - n2 * s2, this._w = r2 * c2 - i2 * s2 - n2 * a2 - o2 * l2, this._onChangeCallback(), this;
  }
  slerp(e3, t2) {
    if (0 === t2)
      return this;
    if (1 === t2)
      return this.copy(e3);
    const i2 = this._x, n2 = this._y, o2 = this._z, r2 = this._w;
    let s2 = r2 * e3._w + i2 * e3._x + n2 * e3._y + o2 * e3._z;
    if (s2 < 0 ? (this._w = -e3._w, this._x = -e3._x, this._y = -e3._y, this._z = -e3._z, s2 = -s2) : this.copy(e3), s2 >= 1)
      return this._w = r2, this._x = i2, this._y = n2, this._z = o2, this;
    const a2 = 1 - s2 * s2;
    if (a2 <= Number.EPSILON) {
      const e4 = 1 - t2;
      return this._w = e4 * r2 + t2 * this._w, this._x = e4 * i2 + t2 * this._x, this._y = e4 * n2 + t2 * this._y, this._z = e4 * o2 + t2 * this._z, this.normalize(), this._onChangeCallback(), this;
    }
    const l2 = Math.sqrt(a2), c2 = Math.atan2(l2, s2), h2 = Math.sin((1 - t2) * c2) / l2, u2 = Math.sin(t2 * c2) / l2;
    return this._w = r2 * h2 + this._w * u2, this._x = i2 * h2 + this._x * u2, this._y = n2 * h2 + this._y * u2, this._z = o2 * h2 + this._z * u2, this._onChangeCallback(), this;
  }
  slerpQuaternions(e3, t2, i2) {
    return this.copy(e3).slerp(t2, i2);
  }
  random() {
    const e3 = Math.random(), t2 = Math.sqrt(1 - e3), i2 = Math.sqrt(e3), n2 = 2 * Math.PI * Math.random(), o2 = 2 * Math.PI * Math.random();
    return this.set(t2 * Math.cos(n2), i2 * Math.sin(o2), i2 * Math.cos(o2), t2 * Math.sin(n2));
  }
  equals(e3) {
    return e3._x === this._x && e3._y === this._y && e3._z === this._z && e3._w === this._w;
  }
  fromArray(e3, t2 = 0) {
    return this._x = e3[t2], this._y = e3[t2 + 1], this._z = e3[t2 + 2], this._w = e3[t2 + 3], this._onChangeCallback(), this;
  }
  toArray(e3 = [], t2 = 0) {
    return e3[t2] = this._x, e3[t2 + 1] = this._y, e3[t2 + 2] = this._z, e3[t2 + 3] = this._w, e3;
  }
  fromBufferAttribute(e3, t2) {
    return this._x = e3.getX(t2), this._y = e3.getY(t2), this._z = e3.getZ(t2), this._w = e3.getW(t2), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e3) {
    return this._onChangeCallback = e3, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class di {
  constructor(e3 = 0, t2 = 0, i2 = 0) {
    di.prototype.isVector3 = true, this.x = e3, this.y = t2, this.z = i2;
  }
  set(e3, t2, i2) {
    return void 0 === i2 && (i2 = this.z), this.x = e3, this.y = t2, this.z = i2, this;
  }
  setScalar(e3) {
    return this.x = e3, this.y = e3, this.z = e3, this;
  }
  setX(e3) {
    return this.x = e3, this;
  }
  setY(e3) {
    return this.y = e3, this;
  }
  setZ(e3) {
    return this.z = e3, this;
  }
  setComponent(e3, t2) {
    switch (e3) {
      case 0:
        this.x = t2;
        break;
      case 1:
        this.y = t2;
        break;
      case 2:
        this.z = t2;
        break;
      default:
        throw new Error("index is out of range: " + e3);
    }
    return this;
  }
  getComponent(e3) {
    switch (e3) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e3);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e3) {
    return this.x = e3.x, this.y = e3.y, this.z = e3.z, this;
  }
  add(e3) {
    return this.x += e3.x, this.y += e3.y, this.z += e3.z, this;
  }
  addScalar(e3) {
    return this.x += e3, this.y += e3, this.z += e3, this;
  }
  addVectors(e3, t2) {
    return this.x = e3.x + t2.x, this.y = e3.y + t2.y, this.z = e3.z + t2.z, this;
  }
  addScaledVector(e3, t2) {
    return this.x += e3.x * t2, this.y += e3.y * t2, this.z += e3.z * t2, this;
  }
  sub(e3) {
    return this.x -= e3.x, this.y -= e3.y, this.z -= e3.z, this;
  }
  subScalar(e3) {
    return this.x -= e3, this.y -= e3, this.z -= e3, this;
  }
  subVectors(e3, t2) {
    return this.x = e3.x - t2.x, this.y = e3.y - t2.y, this.z = e3.z - t2.z, this;
  }
  multiply(e3) {
    return this.x *= e3.x, this.y *= e3.y, this.z *= e3.z, this;
  }
  multiplyScalar(e3) {
    return this.x *= e3, this.y *= e3, this.z *= e3, this;
  }
  multiplyVectors(e3, t2) {
    return this.x = e3.x * t2.x, this.y = e3.y * t2.y, this.z = e3.z * t2.z, this;
  }
  applyEuler(e3) {
    return this.applyQuaternion(_i.setFromEuler(e3));
  }
  applyAxisAngle(e3, t2) {
    return this.applyQuaternion(_i.setFromAxisAngle(e3, t2));
  }
  applyMatrix3(e3) {
    const t2 = this.x, i2 = this.y, n2 = this.z, o2 = e3.elements;
    return this.x = o2[0] * t2 + o2[3] * i2 + o2[6] * n2, this.y = o2[1] * t2 + o2[4] * i2 + o2[7] * n2, this.z = o2[2] * t2 + o2[5] * i2 + o2[8] * n2, this;
  }
  applyNormalMatrix(e3) {
    return this.applyMatrix3(e3).normalize();
  }
  applyMatrix4(e3) {
    const t2 = this.x, i2 = this.y, n2 = this.z, o2 = e3.elements, r2 = 1 / (o2[3] * t2 + o2[7] * i2 + o2[11] * n2 + o2[15]);
    return this.x = (o2[0] * t2 + o2[4] * i2 + o2[8] * n2 + o2[12]) * r2, this.y = (o2[1] * t2 + o2[5] * i2 + o2[9] * n2 + o2[13]) * r2, this.z = (o2[2] * t2 + o2[6] * i2 + o2[10] * n2 + o2[14]) * r2, this;
  }
  applyQuaternion(e3) {
    const t2 = this.x, i2 = this.y, n2 = this.z, o2 = e3.x, r2 = e3.y, s2 = e3.z, a2 = e3.w, l2 = a2 * t2 + r2 * n2 - s2 * i2, c2 = a2 * i2 + s2 * t2 - o2 * n2, h2 = a2 * n2 + o2 * i2 - r2 * t2, u2 = -o2 * t2 - r2 * i2 - s2 * n2;
    return this.x = l2 * a2 + u2 * -o2 + c2 * -s2 - h2 * -r2, this.y = c2 * a2 + u2 * -r2 + h2 * -o2 - l2 * -s2, this.z = h2 * a2 + u2 * -s2 + l2 * -r2 - c2 * -o2, this;
  }
  project(e3) {
    return this.applyMatrix4(e3.matrixWorldInverse).applyMatrix4(e3.projectionMatrix);
  }
  unproject(e3) {
    return this.applyMatrix4(e3.projectionMatrixInverse).applyMatrix4(e3.matrixWorld);
  }
  transformDirection(e3) {
    const t2 = this.x, i2 = this.y, n2 = this.z, o2 = e3.elements;
    return this.x = o2[0] * t2 + o2[4] * i2 + o2[8] * n2, this.y = o2[1] * t2 + o2[5] * i2 + o2[9] * n2, this.z = o2[2] * t2 + o2[6] * i2 + o2[10] * n2, this.normalize();
  }
  divide(e3) {
    return this.x /= e3.x, this.y /= e3.y, this.z /= e3.z, this;
  }
  divideScalar(e3) {
    return this.multiplyScalar(1 / e3);
  }
  min(e3) {
    return this.x = Math.min(this.x, e3.x), this.y = Math.min(this.y, e3.y), this.z = Math.min(this.z, e3.z), this;
  }
  max(e3) {
    return this.x = Math.max(this.x, e3.x), this.y = Math.max(this.y, e3.y), this.z = Math.max(this.z, e3.z), this;
  }
  clamp(e3, t2) {
    return this.x = Math.max(e3.x, Math.min(t2.x, this.x)), this.y = Math.max(e3.y, Math.min(t2.y, this.y)), this.z = Math.max(e3.z, Math.min(t2.z, this.z)), this;
  }
  clampScalar(e3, t2) {
    return this.x = Math.max(e3, Math.min(t2, this.x)), this.y = Math.max(e3, Math.min(t2, this.y)), this.z = Math.max(e3, Math.min(t2, this.z)), this;
  }
  clampLength(e3, t2) {
    const i2 = this.length();
    return this.divideScalar(i2 || 1).multiplyScalar(Math.max(e3, Math.min(t2, i2)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e3) {
    return this.x * e3.x + this.y * e3.y + this.z * e3.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e3) {
    return this.normalize().multiplyScalar(e3);
  }
  lerp(e3, t2) {
    return this.x += (e3.x - this.x) * t2, this.y += (e3.y - this.y) * t2, this.z += (e3.z - this.z) * t2, this;
  }
  lerpVectors(e3, t2, i2) {
    return this.x = e3.x + (t2.x - e3.x) * i2, this.y = e3.y + (t2.y - e3.y) * i2, this.z = e3.z + (t2.z - e3.z) * i2, this;
  }
  cross(e3) {
    return this.crossVectors(this, e3);
  }
  crossVectors(e3, t2) {
    const i2 = e3.x, n2 = e3.y, o2 = e3.z, r2 = t2.x, s2 = t2.y, a2 = t2.z;
    return this.x = n2 * a2 - o2 * s2, this.y = o2 * r2 - i2 * a2, this.z = i2 * s2 - n2 * r2, this;
  }
  projectOnVector(e3) {
    const t2 = e3.lengthSq();
    if (0 === t2)
      return this.set(0, 0, 0);
    const i2 = e3.dot(this) / t2;
    return this.copy(e3).multiplyScalar(i2);
  }
  projectOnPlane(e3) {
    return pi.copy(this).projectOnVector(e3), this.sub(pi);
  }
  reflect(e3) {
    return this.sub(pi.copy(e3).multiplyScalar(2 * this.dot(e3)));
  }
  angleTo(e3) {
    const t2 = Math.sqrt(this.lengthSq() * e3.lengthSq());
    if (0 === t2)
      return Math.PI / 2;
    const i2 = this.dot(e3) / t2;
    return Math.acos(Dt(i2, -1, 1));
  }
  distanceTo(e3) {
    return Math.sqrt(this.distanceToSquared(e3));
  }
  distanceToSquared(e3) {
    const t2 = this.x - e3.x, i2 = this.y - e3.y, n2 = this.z - e3.z;
    return t2 * t2 + i2 * i2 + n2 * n2;
  }
  manhattanDistanceTo(e3) {
    return Math.abs(this.x - e3.x) + Math.abs(this.y - e3.y) + Math.abs(this.z - e3.z);
  }
  setFromSpherical(e3) {
    return this.setFromSphericalCoords(e3.radius, e3.phi, e3.theta);
  }
  setFromSphericalCoords(e3, t2, i2) {
    const n2 = Math.sin(t2) * e3;
    return this.x = n2 * Math.sin(i2), this.y = Math.cos(t2) * e3, this.z = n2 * Math.cos(i2), this;
  }
  setFromCylindrical(e3) {
    return this.setFromCylindricalCoords(e3.radius, e3.theta, e3.y);
  }
  setFromCylindricalCoords(e3, t2, i2) {
    return this.x = e3 * Math.sin(t2), this.y = i2, this.z = e3 * Math.cos(t2), this;
  }
  setFromMatrixPosition(e3) {
    const t2 = e3.elements;
    return this.x = t2[12], this.y = t2[13], this.z = t2[14], this;
  }
  setFromMatrixScale(e3) {
    const t2 = this.setFromMatrixColumn(e3, 0).length(), i2 = this.setFromMatrixColumn(e3, 1).length(), n2 = this.setFromMatrixColumn(e3, 2).length();
    return this.x = t2, this.y = i2, this.z = n2, this;
  }
  setFromMatrixColumn(e3, t2) {
    return this.fromArray(e3.elements, 4 * t2);
  }
  setFromMatrix3Column(e3, t2) {
    return this.fromArray(e3.elements, 3 * t2);
  }
  setFromEuler(e3) {
    return this.x = e3._x, this.y = e3._y, this.z = e3._z, this;
  }
  setFromColor(e3) {
    return this.x = e3.r, this.y = e3.g, this.z = e3.b, this;
  }
  equals(e3) {
    return e3.x === this.x && e3.y === this.y && e3.z === this.z;
  }
  fromArray(e3, t2 = 0) {
    return this.x = e3[t2], this.y = e3[t2 + 1], this.z = e3[t2 + 2], this;
  }
  toArray(e3 = [], t2 = 0) {
    return e3[t2] = this.x, e3[t2 + 1] = this.y, e3[t2 + 2] = this.z, e3;
  }
  fromBufferAttribute(e3, t2) {
    return this.x = e3.getX(t2), this.y = e3.getY(t2), this.z = e3.getZ(t2), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e3 = 2 * (Math.random() - 0.5), t2 = Math.random() * Math.PI * 2, i2 = Math.sqrt(1 - e3 ** 2);
    return this.x = i2 * Math.cos(t2), this.y = i2 * Math.sin(t2), this.z = e3, this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const pi = new di(), _i = new ui();
class gi {
  constructor(e3 = new di(1 / 0, 1 / 0, 1 / 0), t2 = new di(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = true, this.min = e3, this.max = t2;
  }
  set(e3, t2) {
    return this.min.copy(e3), this.max.copy(t2), this;
  }
  setFromArray(e3) {
    this.makeEmpty();
    for (let t2 = 0, i2 = e3.length; t2 < i2; t2 += 3)
      this.expandByPoint(fi.fromArray(e3, t2));
    return this;
  }
  setFromBufferAttribute(e3) {
    this.makeEmpty();
    for (let t2 = 0, i2 = e3.count; t2 < i2; t2++)
      this.expandByPoint(fi.fromBufferAttribute(e3, t2));
    return this;
  }
  setFromPoints(e3) {
    this.makeEmpty();
    for (let t2 = 0, i2 = e3.length; t2 < i2; t2++)
      this.expandByPoint(e3[t2]);
    return this;
  }
  setFromCenterAndSize(e3, t2) {
    const i2 = fi.copy(t2).multiplyScalar(0.5);
    return this.min.copy(e3).sub(i2), this.max.copy(e3).add(i2), this;
  }
  setFromObject(e3, t2 = false) {
    return this.makeEmpty(), this.expandByObject(e3, t2);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e3) {
    return this.min.copy(e3.min), this.max.copy(e3.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e3) {
    return this.isEmpty() ? e3.set(0, 0, 0) : e3.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e3) {
    return this.isEmpty() ? e3.set(0, 0, 0) : e3.subVectors(this.max, this.min);
  }
  expandByPoint(e3) {
    return this.min.min(e3), this.max.max(e3), this;
  }
  expandByVector(e3) {
    return this.min.sub(e3), this.max.add(e3), this;
  }
  expandByScalar(e3) {
    return this.min.addScalar(-e3), this.max.addScalar(e3), this;
  }
  expandByObject(e3, t2 = false) {
    if (e3.updateWorldMatrix(false, false), void 0 !== e3.boundingBox)
      null === e3.boundingBox && e3.computeBoundingBox(), vi.copy(e3.boundingBox), vi.applyMatrix4(e3.matrixWorld), this.union(vi);
    else {
      const i3 = e3.geometry;
      if (void 0 !== i3)
        if (t2 && void 0 !== i3.attributes && void 0 !== i3.attributes.position) {
          const t3 = i3.attributes.position;
          for (let i4 = 0, n2 = t3.count; i4 < n2; i4++)
            fi.fromBufferAttribute(t3, i4).applyMatrix4(e3.matrixWorld), this.expandByPoint(fi);
        } else
          null === i3.boundingBox && i3.computeBoundingBox(), vi.copy(i3.boundingBox), vi.applyMatrix4(e3.matrixWorld), this.union(vi);
    }
    const i2 = e3.children;
    for (let e4 = 0, n2 = i2.length; e4 < n2; e4++)
      this.expandByObject(i2[e4], t2);
    return this;
  }
  containsPoint(e3) {
    return !(e3.x < this.min.x || e3.x > this.max.x || e3.y < this.min.y || e3.y > this.max.y || e3.z < this.min.z || e3.z > this.max.z);
  }
  containsBox(e3) {
    return this.min.x <= e3.min.x && e3.max.x <= this.max.x && this.min.y <= e3.min.y && e3.max.y <= this.max.y && this.min.z <= e3.min.z && e3.max.z <= this.max.z;
  }
  getParameter(e3, t2) {
    return t2.set((e3.x - this.min.x) / (this.max.x - this.min.x), (e3.y - this.min.y) / (this.max.y - this.min.y), (e3.z - this.min.z) / (this.max.z - this.min.z));
  }
  intersectsBox(e3) {
    return !(e3.max.x < this.min.x || e3.min.x > this.max.x || e3.max.y < this.min.y || e3.min.y > this.max.y || e3.max.z < this.min.z || e3.min.z > this.max.z);
  }
  intersectsSphere(e3) {
    return this.clampPoint(e3.center, fi), fi.distanceToSquared(e3.center) <= e3.radius * e3.radius;
  }
  intersectsPlane(e3) {
    let t2, i2;
    return e3.normal.x > 0 ? (t2 = e3.normal.x * this.min.x, i2 = e3.normal.x * this.max.x) : (t2 = e3.normal.x * this.max.x, i2 = e3.normal.x * this.min.x), e3.normal.y > 0 ? (t2 += e3.normal.y * this.min.y, i2 += e3.normal.y * this.max.y) : (t2 += e3.normal.y * this.max.y, i2 += e3.normal.y * this.min.y), e3.normal.z > 0 ? (t2 += e3.normal.z * this.min.z, i2 += e3.normal.z * this.max.z) : (t2 += e3.normal.z * this.max.z, i2 += e3.normal.z * this.min.z), t2 <= -e3.constant && i2 >= -e3.constant;
  }
  intersectsTriangle(e3) {
    if (this.isEmpty())
      return false;
    this.getCenter(Si), Ei.subVectors(this.max, Si), Ai.subVectors(e3.a, Si), bi.subVectors(e3.b, Si), yi.subVectors(e3.c, Si), wi.subVectors(bi, Ai), xi.subVectors(yi, bi), Ci.subVectors(Ai, yi);
    let t2 = [0, -wi.z, wi.y, 0, -xi.z, xi.y, 0, -Ci.z, Ci.y, wi.z, 0, -wi.x, xi.z, 0, -xi.x, Ci.z, 0, -Ci.x, -wi.y, wi.x, 0, -xi.y, xi.x, 0, -Ci.y, Ci.x, 0];
    return !!Bi(t2, Ai, bi, yi, Ei) && (t2 = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Bi(t2, Ai, bi, yi, Ei) && (Ii.crossVectors(wi, xi), t2 = [Ii.x, Ii.y, Ii.z], Bi(t2, Ai, bi, yi, Ei)));
  }
  clampPoint(e3, t2) {
    return t2.copy(e3).clamp(this.min, this.max);
  }
  distanceToPoint(e3) {
    return this.clampPoint(e3, fi).distanceTo(e3);
  }
  getBoundingSphere(e3) {
    return this.isEmpty() ? e3.makeEmpty() : (this.getCenter(e3.center), e3.radius = 0.5 * this.getSize(fi).length()), e3;
  }
  intersect(e3) {
    return this.min.max(e3.min), this.max.min(e3.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e3) {
    return this.min.min(e3.min), this.max.max(e3.max), this;
  }
  applyMatrix4(e3) {
    return this.isEmpty() || (mi[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e3), mi[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e3), mi[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e3), mi[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e3), mi[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e3), mi[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e3), mi[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e3), mi[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e3), this.setFromPoints(mi)), this;
  }
  translate(e3) {
    return this.min.add(e3), this.max.add(e3), this;
  }
  equals(e3) {
    return e3.min.equals(this.min) && e3.max.equals(this.max);
  }
}
const mi = [new di(), new di(), new di(), new di(), new di(), new di(), new di(), new di()], fi = new di(), vi = new gi(), Ai = new di(), bi = new di(), yi = new di(), wi = new di(), xi = new di(), Ci = new di(), Si = new di(), Ei = new di(), Ii = new di(), Ti = new di();
function Bi(e3, t2, i2, n2, o2) {
  for (let r2 = 0, s2 = e3.length - 3; r2 <= s2; r2 += 3) {
    Ti.fromArray(e3, r2);
    const s3 = o2.x * Math.abs(Ti.x) + o2.y * Math.abs(Ti.y) + o2.z * Math.abs(Ti.z), a2 = t2.dot(Ti), l2 = i2.dot(Ti), c2 = n2.dot(Ti);
    if (Math.max(-Math.max(a2, l2, c2), Math.min(a2, l2, c2)) > s3)
      return false;
  }
  return true;
}
const Mi = new gi(), ki = new di(), Ri = new di();
class Pi {
  constructor(e3 = new di(), t2 = -1) {
    this.center = e3, this.radius = t2;
  }
  set(e3, t2) {
    return this.center.copy(e3), this.radius = t2, this;
  }
  setFromPoints(e3, t2) {
    const i2 = this.center;
    void 0 !== t2 ? i2.copy(t2) : Mi.setFromPoints(e3).getCenter(i2);
    let n2 = 0;
    for (let t3 = 0, o2 = e3.length; t3 < o2; t3++)
      n2 = Math.max(n2, i2.distanceToSquared(e3[t3]));
    return this.radius = Math.sqrt(n2), this;
  }
  copy(e3) {
    return this.center.copy(e3.center), this.radius = e3.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e3) {
    return e3.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e3) {
    return e3.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e3) {
    const t2 = this.radius + e3.radius;
    return e3.center.distanceToSquared(this.center) <= t2 * t2;
  }
  intersectsBox(e3) {
    return e3.intersectsSphere(this);
  }
  intersectsPlane(e3) {
    return Math.abs(e3.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e3, t2) {
    const i2 = this.center.distanceToSquared(e3);
    return t2.copy(e3), i2 > this.radius * this.radius && (t2.sub(this.center).normalize(), t2.multiplyScalar(this.radius).add(this.center)), t2;
  }
  getBoundingBox(e3) {
    return this.isEmpty() ? (e3.makeEmpty(), e3) : (e3.set(this.center, this.center), e3.expandByScalar(this.radius), e3);
  }
  applyMatrix4(e3) {
    return this.center.applyMatrix4(e3), this.radius = this.radius * e3.getMaxScaleOnAxis(), this;
  }
  translate(e3) {
    return this.center.add(e3), this;
  }
  expandByPoint(e3) {
    if (this.isEmpty())
      return this.center.copy(e3), this.radius = 0, this;
    ki.subVectors(e3, this.center);
    const t2 = ki.lengthSq();
    if (t2 > this.radius * this.radius) {
      const e4 = Math.sqrt(t2), i2 = 0.5 * (e4 - this.radius);
      this.center.addScaledVector(ki, i2 / e4), this.radius += i2;
    }
    return this;
  }
  union(e3) {
    return e3.isEmpty() ? this : this.isEmpty() ? (this.copy(e3), this) : (true === this.center.equals(e3.center) ? this.radius = Math.max(this.radius, e3.radius) : (Ri.subVectors(e3.center, this.center).setLength(e3.radius), this.expandByPoint(ki.copy(e3.center).add(Ri)), this.expandByPoint(ki.copy(e3.center).sub(Ri))), this);
  }
  equals(e3) {
    return e3.center.equals(this.center) && e3.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Di = new di(), Li = new di(), Fi = new di(), Ni = new di(), Oi = new di(), zi = new di(), Ui = new di();
class Hi {
  constructor(e3 = new di(), t2 = new di(0, 0, -1)) {
    this.origin = e3, this.direction = t2;
  }
  set(e3, t2) {
    return this.origin.copy(e3), this.direction.copy(t2), this;
  }
  copy(e3) {
    return this.origin.copy(e3.origin), this.direction.copy(e3.direction), this;
  }
  at(e3, t2) {
    return t2.copy(this.origin).addScaledVector(this.direction, e3);
  }
  lookAt(e3) {
    return this.direction.copy(e3).sub(this.origin).normalize(), this;
  }
  recast(e3) {
    return this.origin.copy(this.at(e3, Di)), this;
  }
  closestPointToPoint(e3, t2) {
    t2.subVectors(e3, this.origin);
    const i2 = t2.dot(this.direction);
    return i2 < 0 ? t2.copy(this.origin) : t2.copy(this.origin).addScaledVector(this.direction, i2);
  }
  distanceToPoint(e3) {
    return Math.sqrt(this.distanceSqToPoint(e3));
  }
  distanceSqToPoint(e3) {
    const t2 = Di.subVectors(e3, this.origin).dot(this.direction);
    return t2 < 0 ? this.origin.distanceToSquared(e3) : (Di.copy(this.origin).addScaledVector(this.direction, t2), Di.distanceToSquared(e3));
  }
  distanceSqToSegment(e3, t2, i2, n2) {
    Li.copy(e3).add(t2).multiplyScalar(0.5), Fi.copy(t2).sub(e3).normalize(), Ni.copy(this.origin).sub(Li);
    const o2 = 0.5 * e3.distanceTo(t2), r2 = -this.direction.dot(Fi), s2 = Ni.dot(this.direction), a2 = -Ni.dot(Fi), l2 = Ni.lengthSq(), c2 = Math.abs(1 - r2 * r2);
    let h2, u2, d2, p2;
    if (c2 > 0)
      if (h2 = r2 * a2 - s2, u2 = r2 * s2 - a2, p2 = o2 * c2, h2 >= 0)
        if (u2 >= -p2)
          if (u2 <= p2) {
            const e4 = 1 / c2;
            h2 *= e4, u2 *= e4, d2 = h2 * (h2 + r2 * u2 + 2 * s2) + u2 * (r2 * h2 + u2 + 2 * a2) + l2;
          } else
            u2 = o2, h2 = Math.max(0, -(r2 * u2 + s2)), d2 = -h2 * h2 + u2 * (u2 + 2 * a2) + l2;
        else
          u2 = -o2, h2 = Math.max(0, -(r2 * u2 + s2)), d2 = -h2 * h2 + u2 * (u2 + 2 * a2) + l2;
      else
        u2 <= -p2 ? (h2 = Math.max(0, -(-r2 * o2 + s2)), u2 = h2 > 0 ? -o2 : Math.min(Math.max(-o2, -a2), o2), d2 = -h2 * h2 + u2 * (u2 + 2 * a2) + l2) : u2 <= p2 ? (h2 = 0, u2 = Math.min(Math.max(-o2, -a2), o2), d2 = u2 * (u2 + 2 * a2) + l2) : (h2 = Math.max(0, -(r2 * o2 + s2)), u2 = h2 > 0 ? o2 : Math.min(Math.max(-o2, -a2), o2), d2 = -h2 * h2 + u2 * (u2 + 2 * a2) + l2);
    else
      u2 = r2 > 0 ? -o2 : o2, h2 = Math.max(0, -(r2 * u2 + s2)), d2 = -h2 * h2 + u2 * (u2 + 2 * a2) + l2;
    return i2 && i2.copy(this.origin).addScaledVector(this.direction, h2), n2 && n2.copy(Li).addScaledVector(Fi, u2), d2;
  }
  intersectSphere(e3, t2) {
    Di.subVectors(e3.center, this.origin);
    const i2 = Di.dot(this.direction), n2 = Di.dot(Di) - i2 * i2, o2 = e3.radius * e3.radius;
    if (n2 > o2)
      return null;
    const r2 = Math.sqrt(o2 - n2), s2 = i2 - r2, a2 = i2 + r2;
    return a2 < 0 ? null : s2 < 0 ? this.at(a2, t2) : this.at(s2, t2);
  }
  intersectsSphere(e3) {
    return this.distanceSqToPoint(e3.center) <= e3.radius * e3.radius;
  }
  distanceToPlane(e3) {
    const t2 = e3.normal.dot(this.direction);
    if (0 === t2)
      return 0 === e3.distanceToPoint(this.origin) ? 0 : null;
    const i2 = -(this.origin.dot(e3.normal) + e3.constant) / t2;
    return i2 >= 0 ? i2 : null;
  }
  intersectPlane(e3, t2) {
    const i2 = this.distanceToPlane(e3);
    return null === i2 ? null : this.at(i2, t2);
  }
  intersectsPlane(e3) {
    const t2 = e3.distanceToPoint(this.origin);
    if (0 === t2)
      return true;
    return e3.normal.dot(this.direction) * t2 < 0;
  }
  intersectBox(e3, t2) {
    let i2, n2, o2, r2, s2, a2;
    const l2 = 1 / this.direction.x, c2 = 1 / this.direction.y, h2 = 1 / this.direction.z, u2 = this.origin;
    return l2 >= 0 ? (i2 = (e3.min.x - u2.x) * l2, n2 = (e3.max.x - u2.x) * l2) : (i2 = (e3.max.x - u2.x) * l2, n2 = (e3.min.x - u2.x) * l2), c2 >= 0 ? (o2 = (e3.min.y - u2.y) * c2, r2 = (e3.max.y - u2.y) * c2) : (o2 = (e3.max.y - u2.y) * c2, r2 = (e3.min.y - u2.y) * c2), i2 > r2 || o2 > n2 ? null : ((o2 > i2 || isNaN(i2)) && (i2 = o2), (r2 < n2 || isNaN(n2)) && (n2 = r2), h2 >= 0 ? (s2 = (e3.min.z - u2.z) * h2, a2 = (e3.max.z - u2.z) * h2) : (s2 = (e3.max.z - u2.z) * h2, a2 = (e3.min.z - u2.z) * h2), i2 > a2 || s2 > n2 ? null : ((s2 > i2 || i2 != i2) && (i2 = s2), (a2 < n2 || n2 != n2) && (n2 = a2), n2 < 0 ? null : this.at(i2 >= 0 ? i2 : n2, t2)));
  }
  intersectsBox(e3) {
    return null !== this.intersectBox(e3, Di);
  }
  intersectTriangle(e3, t2, i2, n2, o2) {
    Oi.subVectors(t2, e3), zi.subVectors(i2, e3), Ui.crossVectors(Oi, zi);
    let r2, s2 = this.direction.dot(Ui);
    if (s2 > 0) {
      if (n2)
        return null;
      r2 = 1;
    } else {
      if (!(s2 < 0))
        return null;
      r2 = -1, s2 = -s2;
    }
    Ni.subVectors(this.origin, e3);
    const a2 = r2 * this.direction.dot(zi.crossVectors(Ni, zi));
    if (a2 < 0)
      return null;
    const l2 = r2 * this.direction.dot(Oi.cross(Ni));
    if (l2 < 0)
      return null;
    if (a2 + l2 > s2)
      return null;
    const c2 = -r2 * Ni.dot(Ui);
    return c2 < 0 ? null : this.at(c2 / s2, o2);
  }
  applyMatrix4(e3) {
    return this.origin.applyMatrix4(e3), this.direction.transformDirection(e3), this;
  }
  equals(e3) {
    return e3.origin.equals(this.origin) && e3.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Qi {
  constructor() {
    Qi.prototype.isMatrix4 = true, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  set(e3, t2, i2, n2, o2, r2, s2, a2, l2, c2, h2, u2, d2, p2, _2, g2) {
    const m2 = this.elements;
    return m2[0] = e3, m2[4] = t2, m2[8] = i2, m2[12] = n2, m2[1] = o2, m2[5] = r2, m2[9] = s2, m2[13] = a2, m2[2] = l2, m2[6] = c2, m2[10] = h2, m2[14] = u2, m2[3] = d2, m2[7] = p2, m2[11] = _2, m2[15] = g2, this;
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new Qi().fromArray(this.elements);
  }
  copy(e3) {
    const t2 = this.elements, i2 = e3.elements;
    return t2[0] = i2[0], t2[1] = i2[1], t2[2] = i2[2], t2[3] = i2[3], t2[4] = i2[4], t2[5] = i2[5], t2[6] = i2[6], t2[7] = i2[7], t2[8] = i2[8], t2[9] = i2[9], t2[10] = i2[10], t2[11] = i2[11], t2[12] = i2[12], t2[13] = i2[13], t2[14] = i2[14], t2[15] = i2[15], this;
  }
  copyPosition(e3) {
    const t2 = this.elements, i2 = e3.elements;
    return t2[12] = i2[12], t2[13] = i2[13], t2[14] = i2[14], this;
  }
  setFromMatrix3(e3) {
    const t2 = e3.elements;
    return this.set(t2[0], t2[3], t2[6], 0, t2[1], t2[4], t2[7], 0, t2[2], t2[5], t2[8], 0, 0, 0, 0, 1), this;
  }
  extractBasis(e3, t2, i2) {
    return e3.setFromMatrixColumn(this, 0), t2.setFromMatrixColumn(this, 1), i2.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e3, t2, i2) {
    return this.set(e3.x, t2.x, i2.x, 0, e3.y, t2.y, i2.y, 0, e3.z, t2.z, i2.z, 0, 0, 0, 0, 1), this;
  }
  extractRotation(e3) {
    const t2 = this.elements, i2 = e3.elements, n2 = 1 / Vi.setFromMatrixColumn(e3, 0).length(), o2 = 1 / Vi.setFromMatrixColumn(e3, 1).length(), r2 = 1 / Vi.setFromMatrixColumn(e3, 2).length();
    return t2[0] = i2[0] * n2, t2[1] = i2[1] * n2, t2[2] = i2[2] * n2, t2[3] = 0, t2[4] = i2[4] * o2, t2[5] = i2[5] * o2, t2[6] = i2[6] * o2, t2[7] = 0, t2[8] = i2[8] * r2, t2[9] = i2[9] * r2, t2[10] = i2[10] * r2, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, this;
  }
  makeRotationFromEuler(e3) {
    const t2 = this.elements, i2 = e3.x, n2 = e3.y, o2 = e3.z, r2 = Math.cos(i2), s2 = Math.sin(i2), a2 = Math.cos(n2), l2 = Math.sin(n2), c2 = Math.cos(o2), h2 = Math.sin(o2);
    if ("XYZ" === e3.order) {
      const e4 = r2 * c2, i3 = r2 * h2, n3 = s2 * c2, o3 = s2 * h2;
      t2[0] = a2 * c2, t2[4] = -a2 * h2, t2[8] = l2, t2[1] = i3 + n3 * l2, t2[5] = e4 - o3 * l2, t2[9] = -s2 * a2, t2[2] = o3 - e4 * l2, t2[6] = n3 + i3 * l2, t2[10] = r2 * a2;
    } else if ("YXZ" === e3.order) {
      const e4 = a2 * c2, i3 = a2 * h2, n3 = l2 * c2, o3 = l2 * h2;
      t2[0] = e4 + o3 * s2, t2[4] = n3 * s2 - i3, t2[8] = r2 * l2, t2[1] = r2 * h2, t2[5] = r2 * c2, t2[9] = -s2, t2[2] = i3 * s2 - n3, t2[6] = o3 + e4 * s2, t2[10] = r2 * a2;
    } else if ("ZXY" === e3.order) {
      const e4 = a2 * c2, i3 = a2 * h2, n3 = l2 * c2, o3 = l2 * h2;
      t2[0] = e4 - o3 * s2, t2[4] = -r2 * h2, t2[8] = n3 + i3 * s2, t2[1] = i3 + n3 * s2, t2[5] = r2 * c2, t2[9] = o3 - e4 * s2, t2[2] = -r2 * l2, t2[6] = s2, t2[10] = r2 * a2;
    } else if ("ZYX" === e3.order) {
      const e4 = r2 * c2, i3 = r2 * h2, n3 = s2 * c2, o3 = s2 * h2;
      t2[0] = a2 * c2, t2[4] = n3 * l2 - i3, t2[8] = e4 * l2 + o3, t2[1] = a2 * h2, t2[5] = o3 * l2 + e4, t2[9] = i3 * l2 - n3, t2[2] = -l2, t2[6] = s2 * a2, t2[10] = r2 * a2;
    } else if ("YZX" === e3.order) {
      const e4 = r2 * a2, i3 = r2 * l2, n3 = s2 * a2, o3 = s2 * l2;
      t2[0] = a2 * c2, t2[4] = o3 - e4 * h2, t2[8] = n3 * h2 + i3, t2[1] = h2, t2[5] = r2 * c2, t2[9] = -s2 * c2, t2[2] = -l2 * c2, t2[6] = i3 * h2 + n3, t2[10] = e4 - o3 * h2;
    } else if ("XZY" === e3.order) {
      const e4 = r2 * a2, i3 = r2 * l2, n3 = s2 * a2, o3 = s2 * l2;
      t2[0] = a2 * c2, t2[4] = -h2, t2[8] = l2 * c2, t2[1] = e4 * h2 + o3, t2[5] = r2 * c2, t2[9] = i3 * h2 - n3, t2[2] = n3 * h2 - i3, t2[6] = s2 * c2, t2[10] = o3 * h2 + e4;
    }
    return t2[3] = 0, t2[7] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, this;
  }
  makeRotationFromQuaternion(e3) {
    return this.compose($i, e3, Wi);
  }
  lookAt(e3, t2, i2) {
    const n2 = this.elements;
    return Xi.subVectors(e3, t2), 0 === Xi.lengthSq() && (Xi.z = 1), Xi.normalize(), qi.crossVectors(i2, Xi), 0 === qi.lengthSq() && (1 === Math.abs(i2.z) ? Xi.x += 1e-4 : Xi.z += 1e-4, Xi.normalize(), qi.crossVectors(i2, Xi)), qi.normalize(), ji.crossVectors(Xi, qi), n2[0] = qi.x, n2[4] = ji.x, n2[8] = Xi.x, n2[1] = qi.y, n2[5] = ji.y, n2[9] = Xi.y, n2[2] = qi.z, n2[6] = ji.z, n2[10] = Xi.z, this;
  }
  multiply(e3) {
    return this.multiplyMatrices(this, e3);
  }
  premultiply(e3) {
    return this.multiplyMatrices(e3, this);
  }
  multiplyMatrices(e3, t2) {
    const i2 = e3.elements, n2 = t2.elements, o2 = this.elements, r2 = i2[0], s2 = i2[4], a2 = i2[8], l2 = i2[12], c2 = i2[1], h2 = i2[5], u2 = i2[9], d2 = i2[13], p2 = i2[2], _2 = i2[6], g2 = i2[10], m2 = i2[14], f2 = i2[3], v2 = i2[7], A2 = i2[11], b2 = i2[15], y2 = n2[0], w2 = n2[4], x2 = n2[8], C2 = n2[12], S2 = n2[1], E2 = n2[5], I2 = n2[9], T2 = n2[13], B2 = n2[2], M2 = n2[6], k2 = n2[10], R2 = n2[14], P2 = n2[3], D2 = n2[7], L2 = n2[11], F2 = n2[15];
    return o2[0] = r2 * y2 + s2 * S2 + a2 * B2 + l2 * P2, o2[4] = r2 * w2 + s2 * E2 + a2 * M2 + l2 * D2, o2[8] = r2 * x2 + s2 * I2 + a2 * k2 + l2 * L2, o2[12] = r2 * C2 + s2 * T2 + a2 * R2 + l2 * F2, o2[1] = c2 * y2 + h2 * S2 + u2 * B2 + d2 * P2, o2[5] = c2 * w2 + h2 * E2 + u2 * M2 + d2 * D2, o2[9] = c2 * x2 + h2 * I2 + u2 * k2 + d2 * L2, o2[13] = c2 * C2 + h2 * T2 + u2 * R2 + d2 * F2, o2[2] = p2 * y2 + _2 * S2 + g2 * B2 + m2 * P2, o2[6] = p2 * w2 + _2 * E2 + g2 * M2 + m2 * D2, o2[10] = p2 * x2 + _2 * I2 + g2 * k2 + m2 * L2, o2[14] = p2 * C2 + _2 * T2 + g2 * R2 + m2 * F2, o2[3] = f2 * y2 + v2 * S2 + A2 * B2 + b2 * P2, o2[7] = f2 * w2 + v2 * E2 + A2 * M2 + b2 * D2, o2[11] = f2 * x2 + v2 * I2 + A2 * k2 + b2 * L2, o2[15] = f2 * C2 + v2 * T2 + A2 * R2 + b2 * F2, this;
  }
  multiplyScalar(e3) {
    const t2 = this.elements;
    return t2[0] *= e3, t2[4] *= e3, t2[8] *= e3, t2[12] *= e3, t2[1] *= e3, t2[5] *= e3, t2[9] *= e3, t2[13] *= e3, t2[2] *= e3, t2[6] *= e3, t2[10] *= e3, t2[14] *= e3, t2[3] *= e3, t2[7] *= e3, t2[11] *= e3, t2[15] *= e3, this;
  }
  determinant() {
    const e3 = this.elements, t2 = e3[0], i2 = e3[4], n2 = e3[8], o2 = e3[12], r2 = e3[1], s2 = e3[5], a2 = e3[9], l2 = e3[13], c2 = e3[2], h2 = e3[6], u2 = e3[10], d2 = e3[14];
    return e3[3] * (+o2 * a2 * h2 - n2 * l2 * h2 - o2 * s2 * u2 + i2 * l2 * u2 + n2 * s2 * d2 - i2 * a2 * d2) + e3[7] * (+t2 * a2 * d2 - t2 * l2 * u2 + o2 * r2 * u2 - n2 * r2 * d2 + n2 * l2 * c2 - o2 * a2 * c2) + e3[11] * (+t2 * l2 * h2 - t2 * s2 * d2 - o2 * r2 * h2 + i2 * r2 * d2 + o2 * s2 * c2 - i2 * l2 * c2) + e3[15] * (-n2 * s2 * c2 - t2 * a2 * h2 + t2 * s2 * u2 + n2 * r2 * h2 - i2 * r2 * u2 + i2 * a2 * c2);
  }
  transpose() {
    const e3 = this.elements;
    let t2;
    return t2 = e3[1], e3[1] = e3[4], e3[4] = t2, t2 = e3[2], e3[2] = e3[8], e3[8] = t2, t2 = e3[6], e3[6] = e3[9], e3[9] = t2, t2 = e3[3], e3[3] = e3[12], e3[12] = t2, t2 = e3[7], e3[7] = e3[13], e3[13] = t2, t2 = e3[11], e3[11] = e3[14], e3[14] = t2, this;
  }
  setPosition(e3, t2, i2) {
    const n2 = this.elements;
    return e3.isVector3 ? (n2[12] = e3.x, n2[13] = e3.y, n2[14] = e3.z) : (n2[12] = e3, n2[13] = t2, n2[14] = i2), this;
  }
  invert() {
    const e3 = this.elements, t2 = e3[0], i2 = e3[1], n2 = e3[2], o2 = e3[3], r2 = e3[4], s2 = e3[5], a2 = e3[6], l2 = e3[7], c2 = e3[8], h2 = e3[9], u2 = e3[10], d2 = e3[11], p2 = e3[12], _2 = e3[13], g2 = e3[14], m2 = e3[15], f2 = h2 * g2 * l2 - _2 * u2 * l2 + _2 * a2 * d2 - s2 * g2 * d2 - h2 * a2 * m2 + s2 * u2 * m2, v2 = p2 * u2 * l2 - c2 * g2 * l2 - p2 * a2 * d2 + r2 * g2 * d2 + c2 * a2 * m2 - r2 * u2 * m2, A2 = c2 * _2 * l2 - p2 * h2 * l2 + p2 * s2 * d2 - r2 * _2 * d2 - c2 * s2 * m2 + r2 * h2 * m2, b2 = p2 * h2 * a2 - c2 * _2 * a2 - p2 * s2 * u2 + r2 * _2 * u2 + c2 * s2 * g2 - r2 * h2 * g2, y2 = t2 * f2 + i2 * v2 + n2 * A2 + o2 * b2;
    if (0 === y2)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const w2 = 1 / y2;
    return e3[0] = f2 * w2, e3[1] = (_2 * u2 * o2 - h2 * g2 * o2 - _2 * n2 * d2 + i2 * g2 * d2 + h2 * n2 * m2 - i2 * u2 * m2) * w2, e3[2] = (s2 * g2 * o2 - _2 * a2 * o2 + _2 * n2 * l2 - i2 * g2 * l2 - s2 * n2 * m2 + i2 * a2 * m2) * w2, e3[3] = (h2 * a2 * o2 - s2 * u2 * o2 - h2 * n2 * l2 + i2 * u2 * l2 + s2 * n2 * d2 - i2 * a2 * d2) * w2, e3[4] = v2 * w2, e3[5] = (c2 * g2 * o2 - p2 * u2 * o2 + p2 * n2 * d2 - t2 * g2 * d2 - c2 * n2 * m2 + t2 * u2 * m2) * w2, e3[6] = (p2 * a2 * o2 - r2 * g2 * o2 - p2 * n2 * l2 + t2 * g2 * l2 + r2 * n2 * m2 - t2 * a2 * m2) * w2, e3[7] = (r2 * u2 * o2 - c2 * a2 * o2 + c2 * n2 * l2 - t2 * u2 * l2 - r2 * n2 * d2 + t2 * a2 * d2) * w2, e3[8] = A2 * w2, e3[9] = (p2 * h2 * o2 - c2 * _2 * o2 - p2 * i2 * d2 + t2 * _2 * d2 + c2 * i2 * m2 - t2 * h2 * m2) * w2, e3[10] = (r2 * _2 * o2 - p2 * s2 * o2 + p2 * i2 * l2 - t2 * _2 * l2 - r2 * i2 * m2 + t2 * s2 * m2) * w2, e3[11] = (c2 * s2 * o2 - r2 * h2 * o2 - c2 * i2 * l2 + t2 * h2 * l2 + r2 * i2 * d2 - t2 * s2 * d2) * w2, e3[12] = b2 * w2, e3[13] = (c2 * _2 * n2 - p2 * h2 * n2 + p2 * i2 * u2 - t2 * _2 * u2 - c2 * i2 * g2 + t2 * h2 * g2) * w2, e3[14] = (p2 * s2 * n2 - r2 * _2 * n2 - p2 * i2 * a2 + t2 * _2 * a2 + r2 * i2 * g2 - t2 * s2 * g2) * w2, e3[15] = (r2 * h2 * n2 - c2 * s2 * n2 + c2 * i2 * a2 - t2 * h2 * a2 - r2 * i2 * u2 + t2 * s2 * u2) * w2, this;
  }
  scale(e3) {
    const t2 = this.elements, i2 = e3.x, n2 = e3.y, o2 = e3.z;
    return t2[0] *= i2, t2[4] *= n2, t2[8] *= o2, t2[1] *= i2, t2[5] *= n2, t2[9] *= o2, t2[2] *= i2, t2[6] *= n2, t2[10] *= o2, t2[3] *= i2, t2[7] *= n2, t2[11] *= o2, this;
  }
  getMaxScaleOnAxis() {
    const e3 = this.elements, t2 = e3[0] * e3[0] + e3[1] * e3[1] + e3[2] * e3[2], i2 = e3[4] * e3[4] + e3[5] * e3[5] + e3[6] * e3[6], n2 = e3[8] * e3[8] + e3[9] * e3[9] + e3[10] * e3[10];
    return Math.sqrt(Math.max(t2, i2, n2));
  }
  makeTranslation(e3, t2, i2) {
    return this.set(1, 0, 0, e3, 0, 1, 0, t2, 0, 0, 1, i2, 0, 0, 0, 1), this;
  }
  makeRotationX(e3) {
    const t2 = Math.cos(e3), i2 = Math.sin(e3);
    return this.set(1, 0, 0, 0, 0, t2, -i2, 0, 0, i2, t2, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e3) {
    const t2 = Math.cos(e3), i2 = Math.sin(e3);
    return this.set(t2, 0, i2, 0, 0, 1, 0, 0, -i2, 0, t2, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e3) {
    const t2 = Math.cos(e3), i2 = Math.sin(e3);
    return this.set(t2, -i2, 0, 0, i2, t2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e3, t2) {
    const i2 = Math.cos(t2), n2 = Math.sin(t2), o2 = 1 - i2, r2 = e3.x, s2 = e3.y, a2 = e3.z, l2 = o2 * r2, c2 = o2 * s2;
    return this.set(l2 * r2 + i2, l2 * s2 - n2 * a2, l2 * a2 + n2 * s2, 0, l2 * s2 + n2 * a2, c2 * s2 + i2, c2 * a2 - n2 * r2, 0, l2 * a2 - n2 * s2, c2 * a2 + n2 * r2, o2 * a2 * a2 + i2, 0, 0, 0, 0, 1), this;
  }
  makeScale(e3, t2, i2) {
    return this.set(e3, 0, 0, 0, 0, t2, 0, 0, 0, 0, i2, 0, 0, 0, 0, 1), this;
  }
  makeShear(e3, t2, i2, n2, o2, r2) {
    return this.set(1, i2, o2, 0, e3, 1, r2, 0, t2, n2, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e3, t2, i2) {
    const n2 = this.elements, o2 = t2._x, r2 = t2._y, s2 = t2._z, a2 = t2._w, l2 = o2 + o2, c2 = r2 + r2, h2 = s2 + s2, u2 = o2 * l2, d2 = o2 * c2, p2 = o2 * h2, _2 = r2 * c2, g2 = r2 * h2, m2 = s2 * h2, f2 = a2 * l2, v2 = a2 * c2, A2 = a2 * h2, b2 = i2.x, y2 = i2.y, w2 = i2.z;
    return n2[0] = (1 - (_2 + m2)) * b2, n2[1] = (d2 + A2) * b2, n2[2] = (p2 - v2) * b2, n2[3] = 0, n2[4] = (d2 - A2) * y2, n2[5] = (1 - (u2 + m2)) * y2, n2[6] = (g2 + f2) * y2, n2[7] = 0, n2[8] = (p2 + v2) * w2, n2[9] = (g2 - f2) * w2, n2[10] = (1 - (u2 + _2)) * w2, n2[11] = 0, n2[12] = e3.x, n2[13] = e3.y, n2[14] = e3.z, n2[15] = 1, this;
  }
  decompose(e3, t2, i2) {
    const n2 = this.elements;
    let o2 = Vi.set(n2[0], n2[1], n2[2]).length();
    const r2 = Vi.set(n2[4], n2[5], n2[6]).length(), s2 = Vi.set(n2[8], n2[9], n2[10]).length();
    this.determinant() < 0 && (o2 = -o2), e3.x = n2[12], e3.y = n2[13], e3.z = n2[14], Gi.copy(this);
    const a2 = 1 / o2, l2 = 1 / r2, c2 = 1 / s2;
    return Gi.elements[0] *= a2, Gi.elements[1] *= a2, Gi.elements[2] *= a2, Gi.elements[4] *= l2, Gi.elements[5] *= l2, Gi.elements[6] *= l2, Gi.elements[8] *= c2, Gi.elements[9] *= c2, Gi.elements[10] *= c2, t2.setFromRotationMatrix(Gi), i2.x = o2, i2.y = r2, i2.z = s2, this;
  }
  makePerspective(e3, t2, i2, n2, o2, r2) {
    const s2 = this.elements, a2 = 2 * o2 / (t2 - e3), l2 = 2 * o2 / (i2 - n2), c2 = (t2 + e3) / (t2 - e3), h2 = (i2 + n2) / (i2 - n2), u2 = -(r2 + o2) / (r2 - o2), d2 = -2 * r2 * o2 / (r2 - o2);
    return s2[0] = a2, s2[4] = 0, s2[8] = c2, s2[12] = 0, s2[1] = 0, s2[5] = l2, s2[9] = h2, s2[13] = 0, s2[2] = 0, s2[6] = 0, s2[10] = u2, s2[14] = d2, s2[3] = 0, s2[7] = 0, s2[11] = -1, s2[15] = 0, this;
  }
  makeOrthographic(e3, t2, i2, n2, o2, r2) {
    const s2 = this.elements, a2 = 1 / (t2 - e3), l2 = 1 / (i2 - n2), c2 = 1 / (r2 - o2), h2 = (t2 + e3) * a2, u2 = (i2 + n2) * l2, d2 = (r2 + o2) * c2;
    return s2[0] = 2 * a2, s2[4] = 0, s2[8] = 0, s2[12] = -h2, s2[1] = 0, s2[5] = 2 * l2, s2[9] = 0, s2[13] = -u2, s2[2] = 0, s2[6] = 0, s2[10] = -2 * c2, s2[14] = -d2, s2[3] = 0, s2[7] = 0, s2[11] = 0, s2[15] = 1, this;
  }
  equals(e3) {
    const t2 = this.elements, i2 = e3.elements;
    for (let e4 = 0; e4 < 16; e4++)
      if (t2[e4] !== i2[e4])
        return false;
    return true;
  }
  fromArray(e3, t2 = 0) {
    for (let i2 = 0; i2 < 16; i2++)
      this.elements[i2] = e3[i2 + t2];
    return this;
  }
  toArray(e3 = [], t2 = 0) {
    const i2 = this.elements;
    return e3[t2] = i2[0], e3[t2 + 1] = i2[1], e3[t2 + 2] = i2[2], e3[t2 + 3] = i2[3], e3[t2 + 4] = i2[4], e3[t2 + 5] = i2[5], e3[t2 + 6] = i2[6], e3[t2 + 7] = i2[7], e3[t2 + 8] = i2[8], e3[t2 + 9] = i2[9], e3[t2 + 10] = i2[10], e3[t2 + 11] = i2[11], e3[t2 + 12] = i2[12], e3[t2 + 13] = i2[13], e3[t2 + 14] = i2[14], e3[t2 + 15] = i2[15], e3;
  }
}
const Vi = new di(), Gi = new Qi(), $i = new di(0, 0, 0), Wi = new di(1, 1, 1), qi = new di(), ji = new di(), Xi = new di(), Yi = new Qi(), Ki = new ui();
class Zi {
  constructor(e3 = 0, t2 = 0, i2 = 0, n2 = Zi.DEFAULT_ORDER) {
    this.isEuler = true, this._x = e3, this._y = t2, this._z = i2, this._order = n2;
  }
  get x() {
    return this._x;
  }
  set x(e3) {
    this._x = e3, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e3) {
    this._y = e3, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e3) {
    this._z = e3, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e3) {
    this._order = e3, this._onChangeCallback();
  }
  set(e3, t2, i2, n2 = this._order) {
    return this._x = e3, this._y = t2, this._z = i2, this._order = n2, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e3) {
    return this._x = e3._x, this._y = e3._y, this._z = e3._z, this._order = e3._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e3, t2 = this._order, i2 = true) {
    const n2 = e3.elements, o2 = n2[0], r2 = n2[4], s2 = n2[8], a2 = n2[1], l2 = n2[5], c2 = n2[9], h2 = n2[2], u2 = n2[6], d2 = n2[10];
    switch (t2) {
      case "XYZ":
        this._y = Math.asin(Dt(s2, -1, 1)), Math.abs(s2) < 0.9999999 ? (this._x = Math.atan2(-c2, d2), this._z = Math.atan2(-r2, o2)) : (this._x = Math.atan2(u2, l2), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-Dt(c2, -1, 1)), Math.abs(c2) < 0.9999999 ? (this._y = Math.atan2(s2, d2), this._z = Math.atan2(a2, l2)) : (this._y = Math.atan2(-h2, o2), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(Dt(u2, -1, 1)), Math.abs(u2) < 0.9999999 ? (this._y = Math.atan2(-h2, d2), this._z = Math.atan2(-r2, l2)) : (this._y = 0, this._z = Math.atan2(a2, o2));
        break;
      case "ZYX":
        this._y = Math.asin(-Dt(h2, -1, 1)), Math.abs(h2) < 0.9999999 ? (this._x = Math.atan2(u2, d2), this._z = Math.atan2(a2, o2)) : (this._x = 0, this._z = Math.atan2(-r2, l2));
        break;
      case "YZX":
        this._z = Math.asin(Dt(a2, -1, 1)), Math.abs(a2) < 0.9999999 ? (this._x = Math.atan2(-c2, l2), this._y = Math.atan2(-h2, o2)) : (this._x = 0, this._y = Math.atan2(s2, d2));
        break;
      case "XZY":
        this._z = Math.asin(-Dt(r2, -1, 1)), Math.abs(r2) < 0.9999999 ? (this._x = Math.atan2(u2, l2), this._y = Math.atan2(s2, o2)) : (this._x = Math.atan2(-c2, d2), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t2);
    }
    return this._order = t2, true === i2 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e3, t2, i2) {
    return Yi.makeRotationFromQuaternion(e3), this.setFromRotationMatrix(Yi, t2, i2);
  }
  setFromVector3(e3, t2 = this._order) {
    return this.set(e3.x, e3.y, e3.z, t2);
  }
  reorder(e3) {
    return Ki.setFromEuler(this), this.setFromQuaternion(Ki, e3);
  }
  equals(e3) {
    return e3._x === this._x && e3._y === this._y && e3._z === this._z && e3._order === this._order;
  }
  fromArray(e3) {
    return this._x = e3[0], this._y = e3[1], this._z = e3[2], void 0 !== e3[3] && (this._order = e3[3]), this._onChangeCallback(), this;
  }
  toArray(e3 = [], t2 = 0) {
    return e3[t2] = this._x, e3[t2 + 1] = this._y, e3[t2 + 2] = this._z, e3[t2 + 3] = this._order, e3;
  }
  _onChange(e3) {
    return this._onChangeCallback = e3, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Zi.DEFAULT_ORDER = "XYZ";
class Ji {
  constructor() {
    this.mask = 1;
  }
  set(e3) {
    this.mask = (1 << e3 | 0) >>> 0;
  }
  enable(e3) {
    this.mask |= 1 << e3 | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e3) {
    this.mask ^= 1 << e3 | 0;
  }
  disable(e3) {
    this.mask &= ~(1 << e3 | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e3) {
    return 0 != (this.mask & e3.mask);
  }
  isEnabled(e3) {
    return 0 != (this.mask & (1 << e3 | 0));
  }
}
let en = 0;
const tn = new di(), nn = new ui(), on = new Qi(), rn = new di(), sn = new di(), an = new di(), ln = new ui(), cn = new di(1, 0, 0), hn = new di(0, 1, 0), un = new di(0, 0, 1), dn = { type: "added" }, pn = { type: "removed" };
class _n extends Tt {
  constructor() {
    super(), this.isObject3D = true, Object.defineProperty(this, "id", { value: en++ }), this.uuid = Pt(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = _n.DEFAULT_UP.clone();
    const e3 = new di(), t2 = new Zi(), i2 = new ui(), n2 = new di(1, 1, 1);
    t2._onChange(function() {
      i2.setFromEuler(t2, false);
    }), i2._onChange(function() {
      t2.setFromQuaternion(i2, void 0, false);
    }), Object.defineProperties(this, { position: { configurable: true, enumerable: true, value: e3 }, rotation: { configurable: true, enumerable: true, value: t2 }, quaternion: { configurable: true, enumerable: true, value: i2 }, scale: { configurable: true, enumerable: true, value: n2 }, modelViewMatrix: { value: new Qi() }, normalMatrix: { value: new Gt() } }), this.matrix = new Qi(), this.matrixWorld = new Qi(), this.matrixAutoUpdate = _n.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldNeedsUpdate = false, this.matrixWorldAutoUpdate = _n.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.layers = new Ji(), this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e3) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e3), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e3) {
    return this.quaternion.premultiply(e3), this;
  }
  setRotationFromAxisAngle(e3, t2) {
    this.quaternion.setFromAxisAngle(e3, t2);
  }
  setRotationFromEuler(e3) {
    this.quaternion.setFromEuler(e3, true);
  }
  setRotationFromMatrix(e3) {
    this.quaternion.setFromRotationMatrix(e3);
  }
  setRotationFromQuaternion(e3) {
    this.quaternion.copy(e3);
  }
  rotateOnAxis(e3, t2) {
    return nn.setFromAxisAngle(e3, t2), this.quaternion.multiply(nn), this;
  }
  rotateOnWorldAxis(e3, t2) {
    return nn.setFromAxisAngle(e3, t2), this.quaternion.premultiply(nn), this;
  }
  rotateX(e3) {
    return this.rotateOnAxis(cn, e3);
  }
  rotateY(e3) {
    return this.rotateOnAxis(hn, e3);
  }
  rotateZ(e3) {
    return this.rotateOnAxis(un, e3);
  }
  translateOnAxis(e3, t2) {
    return tn.copy(e3).applyQuaternion(this.quaternion), this.position.add(tn.multiplyScalar(t2)), this;
  }
  translateX(e3) {
    return this.translateOnAxis(cn, e3);
  }
  translateY(e3) {
    return this.translateOnAxis(hn, e3);
  }
  translateZ(e3) {
    return this.translateOnAxis(un, e3);
  }
  localToWorld(e3) {
    return this.updateWorldMatrix(true, false), e3.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e3) {
    return this.updateWorldMatrix(true, false), e3.applyMatrix4(on.copy(this.matrixWorld).invert());
  }
  lookAt(e3, t2, i2) {
    e3.isVector3 ? rn.copy(e3) : rn.set(e3, t2, i2);
    const n2 = this.parent;
    this.updateWorldMatrix(true, false), sn.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? on.lookAt(sn, rn, this.up) : on.lookAt(rn, sn, this.up), this.quaternion.setFromRotationMatrix(on), n2 && (on.extractRotation(n2.matrixWorld), nn.setFromRotationMatrix(on), this.quaternion.premultiply(nn.invert()));
  }
  add(e3) {
    if (arguments.length > 1) {
      for (let e4 = 0; e4 < arguments.length; e4++)
        this.add(arguments[e4]);
      return this;
    }
    return e3 === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e3), this) : (e3 && e3.isObject3D ? (null !== e3.parent && e3.parent.remove(e3), e3.parent = this, this.children.push(e3), e3.dispatchEvent(dn)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e3), this);
  }
  remove(e3) {
    if (arguments.length > 1) {
      for (let e4 = 0; e4 < arguments.length; e4++)
        this.remove(arguments[e4]);
      return this;
    }
    const t2 = this.children.indexOf(e3);
    return -1 !== t2 && (e3.parent = null, this.children.splice(t2, 1), e3.dispatchEvent(pn)), this;
  }
  removeFromParent() {
    const e3 = this.parent;
    return null !== e3 && e3.remove(this), this;
  }
  clear() {
    for (let e3 = 0; e3 < this.children.length; e3++) {
      const t2 = this.children[e3];
      t2.parent = null, t2.dispatchEvent(pn);
    }
    return this.children.length = 0, this;
  }
  attach(e3) {
    return this.updateWorldMatrix(true, false), on.copy(this.matrixWorld).invert(), null !== e3.parent && (e3.parent.updateWorldMatrix(true, false), on.multiply(e3.parent.matrixWorld)), e3.applyMatrix4(on), this.add(e3), e3.updateWorldMatrix(false, true), this;
  }
  getObjectById(e3) {
    return this.getObjectByProperty("id", e3);
  }
  getObjectByName(e3) {
    return this.getObjectByProperty("name", e3);
  }
  getObjectByProperty(e3, t2) {
    if (this[e3] === t2)
      return this;
    for (let i2 = 0, n2 = this.children.length; i2 < n2; i2++) {
      const n3 = this.children[i2].getObjectByProperty(e3, t2);
      if (void 0 !== n3)
        return n3;
    }
  }
  getObjectsByProperty(e3, t2) {
    let i2 = [];
    this[e3] === t2 && i2.push(this);
    for (let n2 = 0, o2 = this.children.length; n2 < o2; n2++) {
      const o3 = this.children[n2].getObjectsByProperty(e3, t2);
      o3.length > 0 && (i2 = i2.concat(o3));
    }
    return i2;
  }
  getWorldPosition(e3) {
    return this.updateWorldMatrix(true, false), e3.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e3) {
    return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(sn, e3, an), e3;
  }
  getWorldScale(e3) {
    return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(sn, ln, e3), e3;
  }
  getWorldDirection(e3) {
    this.updateWorldMatrix(true, false);
    const t2 = this.matrixWorld.elements;
    return e3.set(t2[8], t2[9], t2[10]).normalize();
  }
  raycast() {
  }
  traverse(e3) {
    e3(this);
    const t2 = this.children;
    for (let i2 = 0, n2 = t2.length; i2 < n2; i2++)
      t2[i2].traverse(e3);
  }
  traverseVisible(e3) {
    if (false === this.visible)
      return;
    e3(this);
    const t2 = this.children;
    for (let i2 = 0, n2 = t2.length; i2 < n2; i2++)
      t2[i2].traverseVisible(e3);
  }
  traverseAncestors(e3) {
    const t2 = this.parent;
    null !== t2 && (e3(t2), t2.traverseAncestors(e3));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
  }
  updateMatrixWorld(e3) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e3) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = false, e3 = true);
    const t2 = this.children;
    for (let i2 = 0, n2 = t2.length; i2 < n2; i2++) {
      const n3 = t2[i2];
      true !== n3.matrixWorldAutoUpdate && true !== e3 || n3.updateMatrixWorld(e3);
    }
  }
  updateWorldMatrix(e3, t2) {
    const i2 = this.parent;
    if (true === e3 && null !== i2 && true === i2.matrixWorldAutoUpdate && i2.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), true === t2) {
      const e4 = this.children;
      for (let t3 = 0, i3 = e4.length; t3 < i3; t3++) {
        const i4 = e4[t3];
        true === i4.matrixWorldAutoUpdate && i4.updateWorldMatrix(false, true);
      }
    }
  }
  toJSON(e3) {
    const t2 = void 0 === e3 || "string" == typeof e3, i2 = {};
    t2 && (e3 = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }, i2.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" });
    const n2 = {};
    function o2(t3, i3) {
      return void 0 === t3[i3.uuid] && (t3[i3.uuid] = i3.toJSON(e3)), i3.uuid;
    }
    if (n2.uuid = this.uuid, n2.type = this.type, "" !== this.name && (n2.name = this.name), true === this.castShadow && (n2.castShadow = true), true === this.receiveShadow && (n2.receiveShadow = true), false === this.visible && (n2.visible = false), false === this.frustumCulled && (n2.frustumCulled = false), 0 !== this.renderOrder && (n2.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (n2.userData = this.userData), n2.layers = this.layers.mask, n2.matrix = this.matrix.toArray(), n2.up = this.up.toArray(), false === this.matrixAutoUpdate && (n2.matrixAutoUpdate = false), this.isInstancedMesh && (n2.type = "InstancedMesh", n2.count = this.count, n2.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (n2.instanceColor = this.instanceColor.toJSON())), this.isScene)
      this.background && (this.background.isColor ? n2.background = this.background.toJSON() : this.background.isTexture && (n2.background = this.background.toJSON(e3).uuid)), this.environment && this.environment.isTexture && true !== this.environment.isRenderTargetTexture && (n2.environment = this.environment.toJSON(e3).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      n2.geometry = o2(e3.geometries, this.geometry);
      const t3 = this.geometry.parameters;
      if (void 0 !== t3 && void 0 !== t3.shapes) {
        const i3 = t3.shapes;
        if (Array.isArray(i3))
          for (let t4 = 0, n3 = i3.length; t4 < n3; t4++) {
            const n4 = i3[t4];
            o2(e3.shapes, n4);
          }
        else
          o2(e3.shapes, i3);
      }
    }
    if (this.isSkinnedMesh && (n2.bindMode = this.bindMode, n2.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (o2(e3.skeletons, this.skeleton), n2.skeleton = this.skeleton.uuid)), void 0 !== this.material)
      if (Array.isArray(this.material)) {
        const t3 = [];
        for (let i3 = 0, n3 = this.material.length; i3 < n3; i3++)
          t3.push(o2(e3.materials, this.material[i3]));
        n2.material = t3;
      } else
        n2.material = o2(e3.materials, this.material);
    if (this.children.length > 0) {
      n2.children = [];
      for (let t3 = 0; t3 < this.children.length; t3++)
        n2.children.push(this.children[t3].toJSON(e3).object);
    }
    if (this.animations.length > 0) {
      n2.animations = [];
      for (let t3 = 0; t3 < this.animations.length; t3++) {
        const i3 = this.animations[t3];
        n2.animations.push(o2(e3.animations, i3));
      }
    }
    if (t2) {
      const t3 = r2(e3.geometries), n3 = r2(e3.materials), o3 = r2(e3.textures), s2 = r2(e3.images), a2 = r2(e3.shapes), l2 = r2(e3.skeletons), c2 = r2(e3.animations), h2 = r2(e3.nodes);
      t3.length > 0 && (i2.geometries = t3), n3.length > 0 && (i2.materials = n3), o3.length > 0 && (i2.textures = o3), s2.length > 0 && (i2.images = s2), a2.length > 0 && (i2.shapes = a2), l2.length > 0 && (i2.skeletons = l2), c2.length > 0 && (i2.animations = c2), h2.length > 0 && (i2.nodes = h2);
    }
    return i2.object = n2, i2;
    function r2(e4) {
      const t3 = [];
      for (const i3 in e4) {
        const n3 = e4[i3];
        delete n3.metadata, t3.push(n3);
      }
      return t3;
    }
  }
  clone(e3) {
    return new this.constructor().copy(this, e3);
  }
  copy(e3, t2 = true) {
    if (this.name = e3.name, this.up.copy(e3.up), this.position.copy(e3.position), this.rotation.order = e3.rotation.order, this.quaternion.copy(e3.quaternion), this.scale.copy(e3.scale), this.matrix.copy(e3.matrix), this.matrixWorld.copy(e3.matrixWorld), this.matrixAutoUpdate = e3.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e3.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = e3.matrixWorldAutoUpdate, this.layers.mask = e3.layers.mask, this.visible = e3.visible, this.castShadow = e3.castShadow, this.receiveShadow = e3.receiveShadow, this.frustumCulled = e3.frustumCulled, this.renderOrder = e3.renderOrder, this.userData = JSON.parse(JSON.stringify(e3.userData)), true === t2)
      for (let t3 = 0; t3 < e3.children.length; t3++) {
        const i2 = e3.children[t3];
        this.add(i2.clone());
      }
    return this;
  }
}
_n.DEFAULT_UP = new di(0, 1, 0), _n.DEFAULT_MATRIX_AUTO_UPDATE = true, _n.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
const gn = new di(), mn = new di(), fn = new di(), vn = new di(), An = new di(), bn = new di(), yn = new di(), wn = new di(), xn = new di(), Cn = new di();
let Sn = false;
class En {
  constructor(e3 = new di(), t2 = new di(), i2 = new di()) {
    this.a = e3, this.b = t2, this.c = i2;
  }
  static getNormal(e3, t2, i2, n2) {
    n2.subVectors(i2, t2), gn.subVectors(e3, t2), n2.cross(gn);
    const o2 = n2.lengthSq();
    return o2 > 0 ? n2.multiplyScalar(1 / Math.sqrt(o2)) : n2.set(0, 0, 0);
  }
  static getBarycoord(e3, t2, i2, n2, o2) {
    gn.subVectors(n2, t2), mn.subVectors(i2, t2), fn.subVectors(e3, t2);
    const r2 = gn.dot(gn), s2 = gn.dot(mn), a2 = gn.dot(fn), l2 = mn.dot(mn), c2 = mn.dot(fn), h2 = r2 * l2 - s2 * s2;
    if (0 === h2)
      return o2.set(-2, -1, -1);
    const u2 = 1 / h2, d2 = (l2 * a2 - s2 * c2) * u2, p2 = (r2 * c2 - s2 * a2) * u2;
    return o2.set(1 - d2 - p2, p2, d2);
  }
  static containsPoint(e3, t2, i2, n2) {
    return this.getBarycoord(e3, t2, i2, n2, vn), vn.x >= 0 && vn.y >= 0 && vn.x + vn.y <= 1;
  }
  static getUV(e3, t2, i2, n2, o2, r2, s2, a2) {
    return false === Sn && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), Sn = true), this.getInterpolation(e3, t2, i2, n2, o2, r2, s2, a2);
  }
  static getInterpolation(e3, t2, i2, n2, o2, r2, s2, a2) {
    return this.getBarycoord(e3, t2, i2, n2, vn), a2.setScalar(0), a2.addScaledVector(o2, vn.x), a2.addScaledVector(r2, vn.y), a2.addScaledVector(s2, vn.z), a2;
  }
  static isFrontFacing(e3, t2, i2, n2) {
    return gn.subVectors(i2, t2), mn.subVectors(e3, t2), gn.cross(mn).dot(n2) < 0;
  }
  set(e3, t2, i2) {
    return this.a.copy(e3), this.b.copy(t2), this.c.copy(i2), this;
  }
  setFromPointsAndIndices(e3, t2, i2, n2) {
    return this.a.copy(e3[t2]), this.b.copy(e3[i2]), this.c.copy(e3[n2]), this;
  }
  setFromAttributeAndIndices(e3, t2, i2, n2) {
    return this.a.fromBufferAttribute(e3, t2), this.b.fromBufferAttribute(e3, i2), this.c.fromBufferAttribute(e3, n2), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e3) {
    return this.a.copy(e3.a), this.b.copy(e3.b), this.c.copy(e3.c), this;
  }
  getArea() {
    return gn.subVectors(this.c, this.b), mn.subVectors(this.a, this.b), 0.5 * gn.cross(mn).length();
  }
  getMidpoint(e3) {
    return e3.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e3) {
    return En.getNormal(this.a, this.b, this.c, e3);
  }
  getPlane(e3) {
    return e3.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e3, t2) {
    return En.getBarycoord(e3, this.a, this.b, this.c, t2);
  }
  getUV(e3, t2, i2, n2, o2) {
    return false === Sn && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), Sn = true), En.getInterpolation(e3, this.a, this.b, this.c, t2, i2, n2, o2);
  }
  getInterpolation(e3, t2, i2, n2, o2) {
    return En.getInterpolation(e3, this.a, this.b, this.c, t2, i2, n2, o2);
  }
  containsPoint(e3) {
    return En.containsPoint(e3, this.a, this.b, this.c);
  }
  isFrontFacing(e3) {
    return En.isFrontFacing(this.a, this.b, this.c, e3);
  }
  intersectsBox(e3) {
    return e3.intersectsTriangle(this);
  }
  closestPointToPoint(e3, t2) {
    const i2 = this.a, n2 = this.b, o2 = this.c;
    let r2, s2;
    An.subVectors(n2, i2), bn.subVectors(o2, i2), wn.subVectors(e3, i2);
    const a2 = An.dot(wn), l2 = bn.dot(wn);
    if (a2 <= 0 && l2 <= 0)
      return t2.copy(i2);
    xn.subVectors(e3, n2);
    const c2 = An.dot(xn), h2 = bn.dot(xn);
    if (c2 >= 0 && h2 <= c2)
      return t2.copy(n2);
    const u2 = a2 * h2 - c2 * l2;
    if (u2 <= 0 && a2 >= 0 && c2 <= 0)
      return r2 = a2 / (a2 - c2), t2.copy(i2).addScaledVector(An, r2);
    Cn.subVectors(e3, o2);
    const d2 = An.dot(Cn), p2 = bn.dot(Cn);
    if (p2 >= 0 && d2 <= p2)
      return t2.copy(o2);
    const _2 = d2 * l2 - a2 * p2;
    if (_2 <= 0 && l2 >= 0 && p2 <= 0)
      return s2 = l2 / (l2 - p2), t2.copy(i2).addScaledVector(bn, s2);
    const g2 = c2 * p2 - d2 * h2;
    if (g2 <= 0 && h2 - c2 >= 0 && d2 - p2 >= 0)
      return yn.subVectors(o2, n2), s2 = (h2 - c2) / (h2 - c2 + (d2 - p2)), t2.copy(n2).addScaledVector(yn, s2);
    const m2 = 1 / (g2 + _2 + u2);
    return r2 = _2 * m2, s2 = u2 * m2, t2.copy(i2).addScaledVector(An, r2).addScaledVector(bn, s2);
  }
  equals(e3) {
    return e3.a.equals(this.a) && e3.b.equals(this.b) && e3.c.equals(this.c);
  }
}
let In = 0, Tn = class extends Tt {
  constructor() {
    super(), this.isMaterial = true, Object.defineProperty(this, "id", { value: In++ }), this.uuid = Pt(), this.name = "", this.type = "Material", this.blending = 1, this.side = ve, this.vertexColors = false, this.opacity = 1, this.transparent = false, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = ye, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Ct, this.stencilZFail = Ct, this.stencilZPass = Ct, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaToCoverage = false, this.premultipliedAlpha = false, this.forceSinglePass = false, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e3) {
    this._alphaTest > 0 != e3 > 0 && this.version++, this._alphaTest = e3;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e3) {
    if (void 0 !== e3)
      for (const t2 in e3) {
        const i2 = e3[t2];
        if (void 0 === i2) {
          console.warn(`THREE.Material: parameter '${t2}' has value of undefined.`);
          continue;
        }
        const n2 = this[t2];
        void 0 !== n2 ? n2 && n2.isColor ? n2.set(i2) : n2 && n2.isVector3 && i2 && i2.isVector3 ? n2.copy(i2) : this[t2] = i2 : console.warn(`THREE.Material: '${t2}' is not a property of THREE.${this.type}.`);
      }
  }
  toJSON(e3) {
    const t2 = void 0 === e3 || "string" == typeof e3;
    t2 && (e3 = { textures: {}, images: {} });
    const i2 = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } };
    function n2(e4) {
      const t3 = [];
      for (const i3 in e4) {
        const n3 = e4[i3];
        delete n3.metadata, t3.push(n3);
      }
      return t3;
    }
    if (i2.uuid = this.uuid, i2.type = this.type, "" !== this.name && (i2.name = this.name), this.color && this.color.isColor && (i2.color = this.color.getHex()), void 0 !== this.roughness && (i2.roughness = this.roughness), void 0 !== this.metalness && (i2.metalness = this.metalness), void 0 !== this.sheen && (i2.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i2.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (i2.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i2.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (i2.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i2.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (i2.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i2.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (i2.shininess = this.shininess), void 0 !== this.clearcoat && (i2.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (i2.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i2.clearcoatMap = this.clearcoatMap.toJSON(e3).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i2.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e3).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i2.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e3).uuid, i2.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.iridescence && (i2.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (i2.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (i2.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i2.iridescenceMap = this.iridescenceMap.toJSON(e3).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i2.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e3).uuid), this.map && this.map.isTexture && (i2.map = this.map.toJSON(e3).uuid), this.matcap && this.matcap.isTexture && (i2.matcap = this.matcap.toJSON(e3).uuid), this.alphaMap && this.alphaMap.isTexture && (i2.alphaMap = this.alphaMap.toJSON(e3).uuid), this.lightMap && this.lightMap.isTexture && (i2.lightMap = this.lightMap.toJSON(e3).uuid, i2.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i2.aoMap = this.aoMap.toJSON(e3).uuid, i2.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i2.bumpMap = this.bumpMap.toJSON(e3).uuid, i2.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i2.normalMap = this.normalMap.toJSON(e3).uuid, i2.normalMapType = this.normalMapType, i2.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i2.displacementMap = this.displacementMap.toJSON(e3).uuid, i2.displacementScale = this.displacementScale, i2.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i2.roughnessMap = this.roughnessMap.toJSON(e3).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i2.metalnessMap = this.metalnessMap.toJSON(e3).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i2.emissiveMap = this.emissiveMap.toJSON(e3).uuid), this.specularMap && this.specularMap.isTexture && (i2.specularMap = this.specularMap.toJSON(e3).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i2.specularIntensityMap = this.specularIntensityMap.toJSON(e3).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i2.specularColorMap = this.specularColorMap.toJSON(e3).uuid), this.envMap && this.envMap.isTexture && (i2.envMap = this.envMap.toJSON(e3).uuid, void 0 !== this.combine && (i2.combine = this.combine)), void 0 !== this.envMapIntensity && (i2.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (i2.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (i2.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i2.gradientMap = this.gradientMap.toJSON(e3).uuid), void 0 !== this.transmission && (i2.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i2.transmissionMap = this.transmissionMap.toJSON(e3).uuid), void 0 !== this.thickness && (i2.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i2.thicknessMap = this.thicknessMap.toJSON(e3).uuid), void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (i2.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (i2.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (i2.size = this.size), null !== this.shadowSide && (i2.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (i2.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (i2.blending = this.blending), this.side !== ve && (i2.side = this.side), this.vertexColors && (i2.vertexColors = true), this.opacity < 1 && (i2.opacity = this.opacity), true === this.transparent && (i2.transparent = this.transparent), i2.depthFunc = this.depthFunc, i2.depthTest = this.depthTest, i2.depthWrite = this.depthWrite, i2.colorWrite = this.colorWrite, i2.stencilWrite = this.stencilWrite, i2.stencilWriteMask = this.stencilWriteMask, i2.stencilFunc = this.stencilFunc, i2.stencilRef = this.stencilRef, i2.stencilFuncMask = this.stencilFuncMask, i2.stencilFail = this.stencilFail, i2.stencilZFail = this.stencilZFail, i2.stencilZPass = this.stencilZPass, void 0 !== this.rotation && 0 !== this.rotation && (i2.rotation = this.rotation), true === this.polygonOffset && (i2.polygonOffset = true), 0 !== this.polygonOffsetFactor && (i2.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (i2.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (i2.linewidth = this.linewidth), void 0 !== this.dashSize && (i2.dashSize = this.dashSize), void 0 !== this.gapSize && (i2.gapSize = this.gapSize), void 0 !== this.scale && (i2.scale = this.scale), true === this.dithering && (i2.dithering = true), this.alphaTest > 0 && (i2.alphaTest = this.alphaTest), true === this.alphaToCoverage && (i2.alphaToCoverage = this.alphaToCoverage), true === this.premultipliedAlpha && (i2.premultipliedAlpha = this.premultipliedAlpha), true === this.forceSinglePass && (i2.forceSinglePass = this.forceSinglePass), true === this.wireframe && (i2.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (i2.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (i2.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (i2.wireframeLinejoin = this.wireframeLinejoin), true === this.flatShading && (i2.flatShading = this.flatShading), false === this.visible && (i2.visible = false), false === this.toneMapped && (i2.toneMapped = false), false === this.fog && (i2.fog = false), Object.keys(this.userData).length > 0 && (i2.userData = this.userData), t2) {
      const t3 = n2(e3.textures), o2 = n2(e3.images);
      t3.length > 0 && (i2.textures = t3), o2.length > 0 && (i2.images = o2);
    }
    return i2;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e3) {
    this.name = e3.name, this.blending = e3.blending, this.side = e3.side, this.vertexColors = e3.vertexColors, this.opacity = e3.opacity, this.transparent = e3.transparent, this.blendSrc = e3.blendSrc, this.blendDst = e3.blendDst, this.blendEquation = e3.blendEquation, this.blendSrcAlpha = e3.blendSrcAlpha, this.blendDstAlpha = e3.blendDstAlpha, this.blendEquationAlpha = e3.blendEquationAlpha, this.depthFunc = e3.depthFunc, this.depthTest = e3.depthTest, this.depthWrite = e3.depthWrite, this.stencilWriteMask = e3.stencilWriteMask, this.stencilFunc = e3.stencilFunc, this.stencilRef = e3.stencilRef, this.stencilFuncMask = e3.stencilFuncMask, this.stencilFail = e3.stencilFail, this.stencilZFail = e3.stencilZFail, this.stencilZPass = e3.stencilZPass, this.stencilWrite = e3.stencilWrite;
    const t2 = e3.clippingPlanes;
    let i2 = null;
    if (null !== t2) {
      const e4 = t2.length;
      i2 = new Array(e4);
      for (let n2 = 0; n2 !== e4; ++n2)
        i2[n2] = t2[n2].clone();
    }
    return this.clippingPlanes = i2, this.clipIntersection = e3.clipIntersection, this.clipShadows = e3.clipShadows, this.shadowSide = e3.shadowSide, this.colorWrite = e3.colorWrite, this.precision = e3.precision, this.polygonOffset = e3.polygonOffset, this.polygonOffsetFactor = e3.polygonOffsetFactor, this.polygonOffsetUnits = e3.polygonOffsetUnits, this.dithering = e3.dithering, this.alphaTest = e3.alphaTest, this.alphaToCoverage = e3.alphaToCoverage, this.premultipliedAlpha = e3.premultipliedAlpha, this.forceSinglePass = e3.forceSinglePass, this.visible = e3.visible, this.toneMapped = e3.toneMapped, this.userData = JSON.parse(JSON.stringify(e3.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e3) {
    true === e3 && this.version++;
  }
};
const Bn = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, Mn = { h: 0, s: 0, l: 0 }, kn = { h: 0, s: 0, l: 0 };
function Rn(e3, t2, i2) {
  return i2 < 0 && (i2 += 1), i2 > 1 && (i2 -= 1), i2 < 1 / 6 ? e3 + 6 * (t2 - e3) * i2 : i2 < 0.5 ? t2 : i2 < 2 / 3 ? e3 + 6 * (t2 - e3) * (2 / 3 - i2) : e3;
}
class Pn {
  constructor(e3, t2, i2) {
    return this.isColor = true, this.r = 1, this.g = 1, this.b = 1, void 0 === t2 && void 0 === i2 ? this.set(e3) : this.setRGB(e3, t2, i2);
  }
  set(e3) {
    return e3 && e3.isColor ? this.copy(e3) : "number" == typeof e3 ? this.setHex(e3) : "string" == typeof e3 && this.setStyle(e3), this;
  }
  setScalar(e3) {
    return this.r = e3, this.g = e3, this.b = e3, this;
  }
  setHex(e3, t2 = yt) {
    return e3 = Math.floor(e3), this.r = (e3 >> 16 & 255) / 255, this.g = (e3 >> 8 & 255) / 255, this.b = (255 & e3) / 255, ei.toWorkingColorSpace(this, t2), this;
  }
  setRGB(e3, t2, i2, n2 = ei.workingColorSpace) {
    return this.r = e3, this.g = t2, this.b = i2, ei.toWorkingColorSpace(this, n2), this;
  }
  setHSL(e3, t2, i2, n2 = ei.workingColorSpace) {
    if (e3 = Lt(e3, 1), t2 = Dt(t2, 0, 1), i2 = Dt(i2, 0, 1), 0 === t2)
      this.r = this.g = this.b = i2;
    else {
      const n3 = i2 <= 0.5 ? i2 * (1 + t2) : i2 + t2 - i2 * t2, o2 = 2 * i2 - n3;
      this.r = Rn(o2, n3, e3 + 1 / 3), this.g = Rn(o2, n3, e3), this.b = Rn(o2, n3, e3 - 1 / 3);
    }
    return ei.toWorkingColorSpace(this, n2), this;
  }
  setStyle(e3, t2 = yt) {
    function i2(t3) {
      void 0 !== t3 && parseFloat(t3) < 1 && console.warn("THREE.Color: Alpha component of " + e3 + " will be ignored.");
    }
    let n2;
    if (n2 = /^(\w+)\(([^\)]*)\)/.exec(e3)) {
      let o2;
      const r2 = n2[1], s2 = n2[2];
      switch (r2) {
        case "rgb":
        case "rgba":
          if (o2 = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s2))
            return this.r = Math.min(255, parseInt(o2[1], 10)) / 255, this.g = Math.min(255, parseInt(o2[2], 10)) / 255, this.b = Math.min(255, parseInt(o2[3], 10)) / 255, ei.toWorkingColorSpace(this, t2), i2(o2[4]), this;
          if (o2 = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s2))
            return this.r = Math.min(100, parseInt(o2[1], 10)) / 100, this.g = Math.min(100, parseInt(o2[2], 10)) / 100, this.b = Math.min(100, parseInt(o2[3], 10)) / 100, ei.toWorkingColorSpace(this, t2), i2(o2[4]), this;
          break;
        case "hsl":
        case "hsla":
          if (o2 = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s2)) {
            const e4 = parseFloat(o2[1]) / 360, n3 = parseFloat(o2[2]) / 100, r3 = parseFloat(o2[3]) / 100;
            return i2(o2[4]), this.setHSL(e4, n3, r3, t2);
          }
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e3);
      }
    } else if (n2 = /^\#([A-Fa-f\d]+)$/.exec(e3)) {
      const i3 = n2[1], o2 = i3.length;
      if (3 === o2)
        return this.setRGB(parseInt(i3.charAt(0), 16) / 15, parseInt(i3.charAt(1), 16) / 15, parseInt(i3.charAt(2), 16) / 15, t2);
      if (6 === o2)
        return this.setHex(parseInt(i3, 16), t2);
      console.warn("THREE.Color: Invalid hex color " + e3);
    } else if (e3 && e3.length > 0)
      return this.setColorName(e3, t2);
    return this;
  }
  setColorName(e3, t2 = yt) {
    const i2 = Bn[e3.toLowerCase()];
    return void 0 !== i2 ? this.setHex(i2, t2) : console.warn("THREE.Color: Unknown color " + e3), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e3) {
    return this.r = e3.r, this.g = e3.g, this.b = e3.b, this;
  }
  copySRGBToLinear(e3) {
    return this.r = jt(e3.r), this.g = jt(e3.g), this.b = jt(e3.b), this;
  }
  copyLinearToSRGB(e3) {
    return this.r = Xt(e3.r), this.g = Xt(e3.g), this.b = Xt(e3.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e3 = yt) {
    return ei.fromWorkingColorSpace(Dn.copy(this), e3), Dt(255 * Dn.r, 0, 255) << 16 ^ Dt(255 * Dn.g, 0, 255) << 8 ^ Dt(255 * Dn.b, 0, 255) << 0;
  }
  getHexString(e3 = yt) {
    return ("000000" + this.getHex(e3).toString(16)).slice(-6);
  }
  getHSL(e3, t2 = ei.workingColorSpace) {
    ei.fromWorkingColorSpace(Dn.copy(this), t2);
    const i2 = Dn.r, n2 = Dn.g, o2 = Dn.b, r2 = Math.max(i2, n2, o2), s2 = Math.min(i2, n2, o2);
    let a2, l2;
    const c2 = (s2 + r2) / 2;
    if (s2 === r2)
      a2 = 0, l2 = 0;
    else {
      const e4 = r2 - s2;
      switch (l2 = c2 <= 0.5 ? e4 / (r2 + s2) : e4 / (2 - r2 - s2), r2) {
        case i2:
          a2 = (n2 - o2) / e4 + (n2 < o2 ? 6 : 0);
          break;
        case n2:
          a2 = (o2 - i2) / e4 + 2;
          break;
        case o2:
          a2 = (i2 - n2) / e4 + 4;
      }
      a2 /= 6;
    }
    return e3.h = a2, e3.s = l2, e3.l = c2, e3;
  }
  getRGB(e3, t2 = ei.workingColorSpace) {
    return ei.fromWorkingColorSpace(Dn.copy(this), t2), e3.r = Dn.r, e3.g = Dn.g, e3.b = Dn.b, e3;
  }
  getStyle(e3 = yt) {
    ei.fromWorkingColorSpace(Dn.copy(this), e3);
    const t2 = Dn.r, i2 = Dn.g, n2 = Dn.b;
    return e3 !== yt ? `color(${e3} ${t2.toFixed(3)} ${i2.toFixed(3)} ${n2.toFixed(3)})` : `rgb(${255 * t2 | 0},${255 * i2 | 0},${255 * n2 | 0})`;
  }
  offsetHSL(e3, t2, i2) {
    return this.getHSL(Mn), Mn.h += e3, Mn.s += t2, Mn.l += i2, this.setHSL(Mn.h, Mn.s, Mn.l), this;
  }
  add(e3) {
    return this.r += e3.r, this.g += e3.g, this.b += e3.b, this;
  }
  addColors(e3, t2) {
    return this.r = e3.r + t2.r, this.g = e3.g + t2.g, this.b = e3.b + t2.b, this;
  }
  addScalar(e3) {
    return this.r += e3, this.g += e3, this.b += e3, this;
  }
  sub(e3) {
    return this.r = Math.max(0, this.r - e3.r), this.g = Math.max(0, this.g - e3.g), this.b = Math.max(0, this.b - e3.b), this;
  }
  multiply(e3) {
    return this.r *= e3.r, this.g *= e3.g, this.b *= e3.b, this;
  }
  multiplyScalar(e3) {
    return this.r *= e3, this.g *= e3, this.b *= e3, this;
  }
  lerp(e3, t2) {
    return this.r += (e3.r - this.r) * t2, this.g += (e3.g - this.g) * t2, this.b += (e3.b - this.b) * t2, this;
  }
  lerpColors(e3, t2, i2) {
    return this.r = e3.r + (t2.r - e3.r) * i2, this.g = e3.g + (t2.g - e3.g) * i2, this.b = e3.b + (t2.b - e3.b) * i2, this;
  }
  lerpHSL(e3, t2) {
    this.getHSL(Mn), e3.getHSL(kn);
    const i2 = Ft(Mn.h, kn.h, t2), n2 = Ft(Mn.s, kn.s, t2), o2 = Ft(Mn.l, kn.l, t2);
    return this.setHSL(i2, n2, o2), this;
  }
  setFromVector3(e3) {
    return this.r = e3.x, this.g = e3.y, this.b = e3.z, this;
  }
  applyMatrix3(e3) {
    const t2 = this.r, i2 = this.g, n2 = this.b, o2 = e3.elements;
    return this.r = o2[0] * t2 + o2[3] * i2 + o2[6] * n2, this.g = o2[1] * t2 + o2[4] * i2 + o2[7] * n2, this.b = o2[2] * t2 + o2[5] * i2 + o2[8] * n2, this;
  }
  equals(e3) {
    return e3.r === this.r && e3.g === this.g && e3.b === this.b;
  }
  fromArray(e3, t2 = 0) {
    return this.r = e3[t2], this.g = e3[t2 + 1], this.b = e3[t2 + 2], this;
  }
  toArray(e3 = [], t2 = 0) {
    return e3[t2] = this.r, e3[t2 + 1] = this.g, e3[t2 + 2] = this.b, e3;
  }
  fromBufferAttribute(e3, t2) {
    return this.r = e3.getX(t2), this.g = e3.getY(t2), this.b = e3.getZ(t2), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const Dn = new Pn();
Pn.NAMES = Bn;
class Ln extends Tn {
  constructor(e3) {
    super(), this.isMeshBasicMaterial = true, this.type = "MeshBasicMaterial", this.color = new Pn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = we, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = true, this.setValues(e3);
  }
  copy(e3) {
    return super.copy(e3), this.color.copy(e3.color), this.map = e3.map, this.lightMap = e3.lightMap, this.lightMapIntensity = e3.lightMapIntensity, this.aoMap = e3.aoMap, this.aoMapIntensity = e3.aoMapIntensity, this.specularMap = e3.specularMap, this.alphaMap = e3.alphaMap, this.envMap = e3.envMap, this.combine = e3.combine, this.reflectivity = e3.reflectivity, this.refractionRatio = e3.refractionRatio, this.wireframe = e3.wireframe, this.wireframeLinewidth = e3.wireframeLinewidth, this.wireframeLinecap = e3.wireframeLinecap, this.wireframeLinejoin = e3.wireframeLinejoin, this.fog = e3.fog, this;
  }
}
const Fn = Nn();
function Nn() {
  const e3 = new ArrayBuffer(4), t2 = new Float32Array(e3), i2 = new Uint32Array(e3), n2 = new Uint32Array(512), o2 = new Uint32Array(512);
  for (let e4 = 0; e4 < 256; ++e4) {
    const t3 = e4 - 127;
    t3 < -27 ? (n2[e4] = 0, n2[256 | e4] = 32768, o2[e4] = 24, o2[256 | e4] = 24) : t3 < -14 ? (n2[e4] = 1024 >> -t3 - 14, n2[256 | e4] = 1024 >> -t3 - 14 | 32768, o2[e4] = -t3 - 1, o2[256 | e4] = -t3 - 1) : t3 <= 15 ? (n2[e4] = t3 + 15 << 10, n2[256 | e4] = t3 + 15 << 10 | 32768, o2[e4] = 13, o2[256 | e4] = 13) : t3 < 128 ? (n2[e4] = 31744, n2[256 | e4] = 64512, o2[e4] = 24, o2[256 | e4] = 24) : (n2[e4] = 31744, n2[256 | e4] = 64512, o2[e4] = 13, o2[256 | e4] = 13);
  }
  const r2 = new Uint32Array(2048), s2 = new Uint32Array(64), a2 = new Uint32Array(64);
  for (let e4 = 1; e4 < 1024; ++e4) {
    let t3 = e4 << 13, i3 = 0;
    for (; 0 == (8388608 & t3); )
      t3 <<= 1, i3 -= 8388608;
    t3 &= -8388609, i3 += 947912704, r2[e4] = t3 | i3;
  }
  for (let e4 = 1024; e4 < 2048; ++e4)
    r2[e4] = 939524096 + (e4 - 1024 << 13);
  for (let e4 = 1; e4 < 31; ++e4)
    s2[e4] = e4 << 23;
  s2[31] = 1199570944, s2[32] = 2147483648;
  for (let e4 = 33; e4 < 63; ++e4)
    s2[e4] = 2147483648 + (e4 - 32 << 23);
  s2[63] = 3347054592;
  for (let e4 = 1; e4 < 64; ++e4)
    32 !== e4 && (a2[e4] = 1024);
  return { floatView: t2, uint32View: i2, baseTable: n2, shiftTable: o2, mantissaTable: r2, exponentTable: s2, offsetTable: a2 };
}
const On = { toHalfFloat: function(e3) {
  Math.abs(e3) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), e3 = Dt(e3, -65504, 65504), Fn.floatView[0] = e3;
  const t2 = Fn.uint32View[0], i2 = t2 >> 23 & 511;
  return Fn.baseTable[i2] + ((8388607 & t2) >> Fn.shiftTable[i2]);
}, fromHalfFloat: function(e3) {
  const t2 = e3 >> 10;
  return Fn.uint32View[0] = Fn.mantissaTable[Fn.offsetTable[t2] + (1023 & e3)] + Fn.exponentTable[t2], Fn.floatView[0];
} }, zn = new di(), Un = new Vt();
class Hn {
  constructor(e3, t2, i2 = false) {
    if (Array.isArray(e3))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = true, this.name = "", this.array = e3, this.itemSize = t2, this.count = void 0 !== e3 ? e3.length / t2 : 0, this.normalized = i2, this.usage = St, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e3) {
    true === e3 && this.version++;
  }
  setUsage(e3) {
    return this.usage = e3, this;
  }
  copy(e3) {
    return this.name = e3.name, this.array = new e3.array.constructor(e3.array), this.itemSize = e3.itemSize, this.count = e3.count, this.normalized = e3.normalized, this.usage = e3.usage, this;
  }
  copyAt(e3, t2, i2) {
    e3 *= this.itemSize, i2 *= t2.itemSize;
    for (let n2 = 0, o2 = this.itemSize; n2 < o2; n2++)
      this.array[e3 + n2] = t2.array[i2 + n2];
    return this;
  }
  copyArray(e3) {
    return this.array.set(e3), this;
  }
  applyMatrix3(e3) {
    if (2 === this.itemSize)
      for (let t2 = 0, i2 = this.count; t2 < i2; t2++)
        Un.fromBufferAttribute(this, t2), Un.applyMatrix3(e3), this.setXY(t2, Un.x, Un.y);
    else if (3 === this.itemSize)
      for (let t2 = 0, i2 = this.count; t2 < i2; t2++)
        zn.fromBufferAttribute(this, t2), zn.applyMatrix3(e3), this.setXYZ(t2, zn.x, zn.y, zn.z);
    return this;
  }
  applyMatrix4(e3) {
    for (let t2 = 0, i2 = this.count; t2 < i2; t2++)
      zn.fromBufferAttribute(this, t2), zn.applyMatrix4(e3), this.setXYZ(t2, zn.x, zn.y, zn.z);
    return this;
  }
  applyNormalMatrix(e3) {
    for (let t2 = 0, i2 = this.count; t2 < i2; t2++)
      zn.fromBufferAttribute(this, t2), zn.applyNormalMatrix(e3), this.setXYZ(t2, zn.x, zn.y, zn.z);
    return this;
  }
  transformDirection(e3) {
    for (let t2 = 0, i2 = this.count; t2 < i2; t2++)
      zn.fromBufferAttribute(this, t2), zn.transformDirection(e3), this.setXYZ(t2, zn.x, zn.y, zn.z);
    return this;
  }
  set(e3, t2 = 0) {
    return this.array.set(e3, t2), this;
  }
  getX(e3) {
    let t2 = this.array[e3 * this.itemSize];
    return this.normalized && (t2 = Ut(t2, this.array)), t2;
  }
  setX(e3, t2) {
    return this.normalized && (t2 = Ht(t2, this.array)), this.array[e3 * this.itemSize] = t2, this;
  }
  getY(e3) {
    let t2 = this.array[e3 * this.itemSize + 1];
    return this.normalized && (t2 = Ut(t2, this.array)), t2;
  }
  setY(e3, t2) {
    return this.normalized && (t2 = Ht(t2, this.array)), this.array[e3 * this.itemSize + 1] = t2, this;
  }
  getZ(e3) {
    let t2 = this.array[e3 * this.itemSize + 2];
    return this.normalized && (t2 = Ut(t2, this.array)), t2;
  }
  setZ(e3, t2) {
    return this.normalized && (t2 = Ht(t2, this.array)), this.array[e3 * this.itemSize + 2] = t2, this;
  }
  getW(e3) {
    let t2 = this.array[e3 * this.itemSize + 3];
    return this.normalized && (t2 = Ut(t2, this.array)), t2;
  }
  setW(e3, t2) {
    return this.normalized && (t2 = Ht(t2, this.array)), this.array[e3 * this.itemSize + 3] = t2, this;
  }
  setXY(e3, t2, i2) {
    return e3 *= this.itemSize, this.normalized && (t2 = Ht(t2, this.array), i2 = Ht(i2, this.array)), this.array[e3 + 0] = t2, this.array[e3 + 1] = i2, this;
  }
  setXYZ(e3, t2, i2, n2) {
    return e3 *= this.itemSize, this.normalized && (t2 = Ht(t2, this.array), i2 = Ht(i2, this.array), n2 = Ht(n2, this.array)), this.array[e3 + 0] = t2, this.array[e3 + 1] = i2, this.array[e3 + 2] = n2, this;
  }
  setXYZW(e3, t2, i2, n2, o2) {
    return e3 *= this.itemSize, this.normalized && (t2 = Ht(t2, this.array), i2 = Ht(i2, this.array), n2 = Ht(n2, this.array), o2 = Ht(o2, this.array)), this.array[e3 + 0] = t2, this.array[e3 + 1] = i2, this.array[e3 + 2] = n2, this.array[e3 + 3] = o2, this;
  }
  onUpload(e3) {
    return this.onUploadCallback = e3, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e3 = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.from(this.array), normalized: this.normalized };
    return "" !== this.name && (e3.name = this.name), this.usage !== St && (e3.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (e3.updateRange = this.updateRange), e3;
  }
  copyColorsArray() {
    console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.");
  }
  copyVector2sArray() {
    console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.");
  }
  copyVector3sArray() {
    console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.");
  }
  copyVector4sArray() {
    console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.");
  }
}
class Qn extends Hn {
  constructor(e3, t2, i2) {
    super(new Uint16Array(e3), t2, i2);
  }
}
class Vn extends Hn {
  constructor(e3, t2, i2) {
    super(new Uint32Array(e3), t2, i2);
  }
}
class Gn extends Hn {
  constructor(e3, t2, i2) {
    super(new Float32Array(e3), t2, i2);
  }
}
let $n = 0;
const Wn = new Qi(), qn = new _n(), jn = new di(), Xn = new gi(), Yn = new gi(), Kn = new di();
class Zn extends Tt {
  constructor() {
    super(), this.isBufferGeometry = true, Object.defineProperty(this, "id", { value: $n++ }), this.uuid = Pt(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e3) {
    return Array.isArray(e3) ? this.index = new (Wt(e3) ? Vn : Qn)(e3, 1) : this.index = e3, this;
  }
  getAttribute(e3) {
    return this.attributes[e3];
  }
  setAttribute(e3, t2) {
    return this.attributes[e3] = t2, this;
  }
  deleteAttribute(e3) {
    return delete this.attributes[e3], this;
  }
  hasAttribute(e3) {
    return void 0 !== this.attributes[e3];
  }
  addGroup(e3, t2, i2 = 0) {
    this.groups.push({ start: e3, count: t2, materialIndex: i2 });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e3, t2) {
    this.drawRange.start = e3, this.drawRange.count = t2;
  }
  applyMatrix4(e3) {
    const t2 = this.attributes.position;
    void 0 !== t2 && (t2.applyMatrix4(e3), t2.needsUpdate = true);
    const i2 = this.attributes.normal;
    if (void 0 !== i2) {
      const t3 = new Gt().getNormalMatrix(e3);
      i2.applyNormalMatrix(t3), i2.needsUpdate = true;
    }
    const n2 = this.attributes.tangent;
    return void 0 !== n2 && (n2.transformDirection(e3), n2.needsUpdate = true), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e3) {
    return Wn.makeRotationFromQuaternion(e3), this.applyMatrix4(Wn), this;
  }
  rotateX(e3) {
    return Wn.makeRotationX(e3), this.applyMatrix4(Wn), this;
  }
  rotateY(e3) {
    return Wn.makeRotationY(e3), this.applyMatrix4(Wn), this;
  }
  rotateZ(e3) {
    return Wn.makeRotationZ(e3), this.applyMatrix4(Wn), this;
  }
  translate(e3, t2, i2) {
    return Wn.makeTranslation(e3, t2, i2), this.applyMatrix4(Wn), this;
  }
  scale(e3, t2, i2) {
    return Wn.makeScale(e3, t2, i2), this.applyMatrix4(Wn), this;
  }
  lookAt(e3) {
    return qn.lookAt(e3), qn.updateMatrix(), this.applyMatrix4(qn.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(jn).negate(), this.translate(jn.x, jn.y, jn.z), this;
  }
  setFromPoints(e3) {
    const t2 = [];
    for (let i2 = 0, n2 = e3.length; i2 < n2; i2++) {
      const n3 = e3[i2];
      t2.push(n3.x, n3.y, n3.z || 0);
    }
    return this.setAttribute("position", new Gn(t2, 3)), this;
  }
  computeBoundingBox() {
    null === this.boundingBox && (this.boundingBox = new gi());
    const e3 = this.attributes.position, t2 = this.morphAttributes.position;
    if (e3 && e3.isGLBufferAttribute)
      return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new di(-1 / 0, -1 / 0, -1 / 0), new di(1 / 0, 1 / 0, 1 / 0));
    if (void 0 !== e3) {
      if (this.boundingBox.setFromBufferAttribute(e3), t2)
        for (let e4 = 0, i2 = t2.length; e4 < i2; e4++) {
          const i3 = t2[e4];
          Xn.setFromBufferAttribute(i3), this.morphTargetsRelative ? (Kn.addVectors(this.boundingBox.min, Xn.min), this.boundingBox.expandByPoint(Kn), Kn.addVectors(this.boundingBox.max, Xn.max), this.boundingBox.expandByPoint(Kn)) : (this.boundingBox.expandByPoint(Xn.min), this.boundingBox.expandByPoint(Xn.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    null === this.boundingSphere && (this.boundingSphere = new Pi());
    const e3 = this.attributes.position, t2 = this.morphAttributes.position;
    if (e3 && e3.isGLBufferAttribute)
      return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new di(), 1 / 0);
    if (e3) {
      const i2 = this.boundingSphere.center;
      if (Xn.setFromBufferAttribute(e3), t2)
        for (let e4 = 0, i3 = t2.length; e4 < i3; e4++) {
          const i4 = t2[e4];
          Yn.setFromBufferAttribute(i4), this.morphTargetsRelative ? (Kn.addVectors(Xn.min, Yn.min), Xn.expandByPoint(Kn), Kn.addVectors(Xn.max, Yn.max), Xn.expandByPoint(Kn)) : (Xn.expandByPoint(Yn.min), Xn.expandByPoint(Yn.max));
        }
      Xn.getCenter(i2);
      let n2 = 0;
      for (let t3 = 0, o2 = e3.count; t3 < o2; t3++)
        Kn.fromBufferAttribute(e3, t3), n2 = Math.max(n2, i2.distanceToSquared(Kn));
      if (t2)
        for (let o2 = 0, r2 = t2.length; o2 < r2; o2++) {
          const r3 = t2[o2], s2 = this.morphTargetsRelative;
          for (let t3 = 0, o3 = r3.count; t3 < o3; t3++)
            Kn.fromBufferAttribute(r3, t3), s2 && (jn.fromBufferAttribute(e3, t3), Kn.add(jn)), n2 = Math.max(n2, i2.distanceToSquared(Kn));
        }
      this.boundingSphere.radius = Math.sqrt(n2), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e3 = this.index, t2 = this.attributes;
    if (null === e3 || void 0 === t2.position || void 0 === t2.normal || void 0 === t2.uv)
      return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
    const i2 = e3.array, n2 = t2.position.array, o2 = t2.normal.array, r2 = t2.uv.array, s2 = n2.length / 3;
    false === this.hasAttribute("tangent") && this.setAttribute("tangent", new Hn(new Float32Array(4 * s2), 4));
    const a2 = this.getAttribute("tangent").array, l2 = [], c2 = [];
    for (let e4 = 0; e4 < s2; e4++)
      l2[e4] = new di(), c2[e4] = new di();
    const h2 = new di(), u2 = new di(), d2 = new di(), p2 = new Vt(), _2 = new Vt(), g2 = new Vt(), m2 = new di(), f2 = new di();
    function v2(e4, t3, i3) {
      h2.fromArray(n2, 3 * e4), u2.fromArray(n2, 3 * t3), d2.fromArray(n2, 3 * i3), p2.fromArray(r2, 2 * e4), _2.fromArray(r2, 2 * t3), g2.fromArray(r2, 2 * i3), u2.sub(h2), d2.sub(h2), _2.sub(p2), g2.sub(p2);
      const o3 = 1 / (_2.x * g2.y - g2.x * _2.y);
      isFinite(o3) && (m2.copy(u2).multiplyScalar(g2.y).addScaledVector(d2, -_2.y).multiplyScalar(o3), f2.copy(d2).multiplyScalar(_2.x).addScaledVector(u2, -g2.x).multiplyScalar(o3), l2[e4].add(m2), l2[t3].add(m2), l2[i3].add(m2), c2[e4].add(f2), c2[t3].add(f2), c2[i3].add(f2));
    }
    let A2 = this.groups;
    0 === A2.length && (A2 = [{ start: 0, count: i2.length }]);
    for (let e4 = 0, t3 = A2.length; e4 < t3; ++e4) {
      const t4 = A2[e4], n3 = t4.start;
      for (let e5 = n3, o3 = n3 + t4.count; e5 < o3; e5 += 3)
        v2(i2[e5 + 0], i2[e5 + 1], i2[e5 + 2]);
    }
    const b2 = new di(), y2 = new di(), w2 = new di(), x2 = new di();
    function C2(e4) {
      w2.fromArray(o2, 3 * e4), x2.copy(w2);
      const t3 = l2[e4];
      b2.copy(t3), b2.sub(w2.multiplyScalar(w2.dot(t3))).normalize(), y2.crossVectors(x2, t3);
      const i3 = y2.dot(c2[e4]) < 0 ? -1 : 1;
      a2[4 * e4] = b2.x, a2[4 * e4 + 1] = b2.y, a2[4 * e4 + 2] = b2.z, a2[4 * e4 + 3] = i3;
    }
    for (let e4 = 0, t3 = A2.length; e4 < t3; ++e4) {
      const t4 = A2[e4], n3 = t4.start;
      for (let e5 = n3, o3 = n3 + t4.count; e5 < o3; e5 += 3)
        C2(i2[e5 + 0]), C2(i2[e5 + 1]), C2(i2[e5 + 2]);
    }
  }
  computeVertexNormals() {
    const e3 = this.index, t2 = this.getAttribute("position");
    if (void 0 !== t2) {
      let i2 = this.getAttribute("normal");
      if (void 0 === i2)
        i2 = new Hn(new Float32Array(3 * t2.count), 3), this.setAttribute("normal", i2);
      else
        for (let e4 = 0, t3 = i2.count; e4 < t3; e4++)
          i2.setXYZ(e4, 0, 0, 0);
      const n2 = new di(), o2 = new di(), r2 = new di(), s2 = new di(), a2 = new di(), l2 = new di(), c2 = new di(), h2 = new di();
      if (e3)
        for (let u2 = 0, d2 = e3.count; u2 < d2; u2 += 3) {
          const d3 = e3.getX(u2 + 0), p2 = e3.getX(u2 + 1), _2 = e3.getX(u2 + 2);
          n2.fromBufferAttribute(t2, d3), o2.fromBufferAttribute(t2, p2), r2.fromBufferAttribute(t2, _2), c2.subVectors(r2, o2), h2.subVectors(n2, o2), c2.cross(h2), s2.fromBufferAttribute(i2, d3), a2.fromBufferAttribute(i2, p2), l2.fromBufferAttribute(i2, _2), s2.add(c2), a2.add(c2), l2.add(c2), i2.setXYZ(d3, s2.x, s2.y, s2.z), i2.setXYZ(p2, a2.x, a2.y, a2.z), i2.setXYZ(_2, l2.x, l2.y, l2.z);
        }
      else
        for (let e4 = 0, s3 = t2.count; e4 < s3; e4 += 3)
          n2.fromBufferAttribute(t2, e4 + 0), o2.fromBufferAttribute(t2, e4 + 1), r2.fromBufferAttribute(t2, e4 + 2), c2.subVectors(r2, o2), h2.subVectors(n2, o2), c2.cross(h2), i2.setXYZ(e4 + 0, c2.x, c2.y, c2.z), i2.setXYZ(e4 + 1, c2.x, c2.y, c2.z), i2.setXYZ(e4 + 2, c2.x, c2.y, c2.z);
      this.normalizeNormals(), i2.needsUpdate = true;
    }
  }
  merge() {
    return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeGeometries() instead."), this;
  }
  normalizeNormals() {
    const e3 = this.attributes.normal;
    for (let t2 = 0, i2 = e3.count; t2 < i2; t2++)
      Kn.fromBufferAttribute(e3, t2), Kn.normalize(), e3.setXYZ(t2, Kn.x, Kn.y, Kn.z);
  }
  toNonIndexed() {
    function e3(e4, t3) {
      const i3 = e4.array, n3 = e4.itemSize, o3 = e4.normalized, r3 = new i3.constructor(t3.length * n3);
      let s2 = 0, a2 = 0;
      for (let o4 = 0, l2 = t3.length; o4 < l2; o4++) {
        s2 = e4.isInterleavedBufferAttribute ? t3[o4] * e4.data.stride + e4.offset : t3[o4] * n3;
        for (let e5 = 0; e5 < n3; e5++)
          r3[a2++] = i3[s2++];
      }
      return new Hn(r3, n3, o3);
    }
    if (null === this.index)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t2 = new Zn(), i2 = this.index.array, n2 = this.attributes;
    for (const o3 in n2) {
      const r3 = e3(n2[o3], i2);
      t2.setAttribute(o3, r3);
    }
    const o2 = this.morphAttributes;
    for (const n3 in o2) {
      const r3 = [], s2 = o2[n3];
      for (let t3 = 0, n4 = s2.length; t3 < n4; t3++) {
        const n5 = e3(s2[t3], i2);
        r3.push(n5);
      }
      t2.morphAttributes[n3] = r3;
    }
    t2.morphTargetsRelative = this.morphTargetsRelative;
    const r2 = this.groups;
    for (let e4 = 0, i3 = r2.length; e4 < i3; e4++) {
      const i4 = r2[e4];
      t2.addGroup(i4.start, i4.count, i4.materialIndex);
    }
    return t2;
  }
  toJSON() {
    const e3 = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
    if (e3.uuid = this.uuid, e3.type = this.type, "" !== this.name && (e3.name = this.name), Object.keys(this.userData).length > 0 && (e3.userData = this.userData), void 0 !== this.parameters) {
      const t3 = this.parameters;
      for (const i3 in t3)
        void 0 !== t3[i3] && (e3[i3] = t3[i3]);
      return e3;
    }
    e3.data = { attributes: {} };
    const t2 = this.index;
    null !== t2 && (e3.data.index = { type: t2.array.constructor.name, array: Array.prototype.slice.call(t2.array) });
    const i2 = this.attributes;
    for (const t3 in i2) {
      const n3 = i2[t3];
      e3.data.attributes[t3] = n3.toJSON(e3.data);
    }
    const n2 = {};
    let o2 = false;
    for (const t3 in this.morphAttributes) {
      const i3 = this.morphAttributes[t3], r3 = [];
      for (let t4 = 0, n3 = i3.length; t4 < n3; t4++) {
        const n4 = i3[t4];
        r3.push(n4.toJSON(e3.data));
      }
      r3.length > 0 && (n2[t3] = r3, o2 = true);
    }
    o2 && (e3.data.morphAttributes = n2, e3.data.morphTargetsRelative = this.morphTargetsRelative);
    const r2 = this.groups;
    r2.length > 0 && (e3.data.groups = JSON.parse(JSON.stringify(r2)));
    const s2 = this.boundingSphere;
    return null !== s2 && (e3.data.boundingSphere = { center: s2.center.toArray(), radius: s2.radius }), e3;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e3) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t2 = {};
    this.name = e3.name;
    const i2 = e3.index;
    null !== i2 && this.setIndex(i2.clone(t2));
    const n2 = e3.attributes;
    for (const e4 in n2) {
      const i3 = n2[e4];
      this.setAttribute(e4, i3.clone(t2));
    }
    const o2 = e3.morphAttributes;
    for (const e4 in o2) {
      const i3 = [], n3 = o2[e4];
      for (let e5 = 0, o3 = n3.length; e5 < o3; e5++)
        i3.push(n3[e5].clone(t2));
      this.morphAttributes[e4] = i3;
    }
    this.morphTargetsRelative = e3.morphTargetsRelative;
    const r2 = e3.groups;
    for (let e4 = 0, t3 = r2.length; e4 < t3; e4++) {
      const t4 = r2[e4];
      this.addGroup(t4.start, t4.count, t4.materialIndex);
    }
    const s2 = e3.boundingBox;
    null !== s2 && (this.boundingBox = s2.clone());
    const a2 = e3.boundingSphere;
    return null !== a2 && (this.boundingSphere = a2.clone()), this.drawRange.start = e3.drawRange.start, this.drawRange.count = e3.drawRange.count, this.userData = e3.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const Jn = new Qi(), eo = new Hi(), to = new Pi(), io = new di(), no = new di(), oo = new di(), ro = new di(), so = new di(), ao = new di(), lo = new Vt(), co = new Vt(), ho = new Vt(), uo = new di(), po = new di(), _o = new di(), go = new di(), mo = new di();
class fo extends _n {
  constructor(e3 = new Zn(), t2 = new Ln()) {
    super(), this.isMesh = true, this.type = "Mesh", this.geometry = e3, this.material = t2, this.updateMorphTargets();
  }
  copy(e3, t2) {
    return super.copy(e3, t2), void 0 !== e3.morphTargetInfluences && (this.morphTargetInfluences = e3.morphTargetInfluences.slice()), void 0 !== e3.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e3.morphTargetDictionary)), this.material = e3.material, this.geometry = e3.geometry, this;
  }
  updateMorphTargets() {
    const e3 = this.geometry.morphAttributes, t2 = Object.keys(e3);
    if (t2.length > 0) {
      const i2 = e3[t2[0]];
      if (void 0 !== i2) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let e4 = 0, t3 = i2.length; e4 < t3; e4++) {
          const t4 = i2[e4].name || String(e4);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[t4] = e4;
        }
      }
    }
  }
  getVertexPosition(e3, t2) {
    const i2 = this.geometry, n2 = i2.attributes.position, o2 = i2.morphAttributes.position, r2 = i2.morphTargetsRelative;
    t2.fromBufferAttribute(n2, e3);
    const s2 = this.morphTargetInfluences;
    if (o2 && s2) {
      ao.set(0, 0, 0);
      for (let i3 = 0, n3 = o2.length; i3 < n3; i3++) {
        const n4 = s2[i3], a2 = o2[i3];
        0 !== n4 && (so.fromBufferAttribute(a2, e3), r2 ? ao.addScaledVector(so, n4) : ao.addScaledVector(so.sub(t2), n4));
      }
      t2.add(ao);
    }
    return this.isSkinnedMesh && this.applyBoneTransform(e3, t2), t2;
  }
  raycast(e3, t2) {
    const i2 = this.geometry, n2 = this.material, o2 = this.matrixWorld;
    if (void 0 === n2)
      return;
    if (null === i2.boundingSphere && i2.computeBoundingSphere(), to.copy(i2.boundingSphere), to.applyMatrix4(o2), eo.copy(e3.ray).recast(e3.near), false === to.containsPoint(eo.origin)) {
      if (null === eo.intersectSphere(to, io))
        return;
      if (eo.origin.distanceToSquared(io) > (e3.far - e3.near) ** 2)
        return;
    }
    if (Jn.copy(o2).invert(), eo.copy(e3.ray).applyMatrix4(Jn), null !== i2.boundingBox && false === eo.intersectsBox(i2.boundingBox))
      return;
    let r2;
    const s2 = i2.index, a2 = i2.attributes.position, l2 = i2.attributes.uv, c2 = i2.attributes.uv2, h2 = i2.attributes.normal, u2 = i2.groups, d2 = i2.drawRange;
    if (null !== s2)
      if (Array.isArray(n2))
        for (let i3 = 0, o3 = u2.length; i3 < o3; i3++) {
          const o4 = u2[i3], a3 = n2[o4.materialIndex];
          for (let i4 = Math.max(o4.start, d2.start), n3 = Math.min(s2.count, Math.min(o4.start + o4.count, d2.start + d2.count)); i4 < n3; i4 += 3) {
            const n4 = s2.getX(i4), u3 = s2.getX(i4 + 1), d3 = s2.getX(i4 + 2);
            r2 = vo(this, a3, e3, eo, l2, c2, h2, n4, u3, d3), r2 && (r2.faceIndex = Math.floor(i4 / 3), r2.face.materialIndex = o4.materialIndex, t2.push(r2));
          }
        }
      else {
        for (let i3 = Math.max(0, d2.start), o3 = Math.min(s2.count, d2.start + d2.count); i3 < o3; i3 += 3) {
          const o4 = s2.getX(i3), a3 = s2.getX(i3 + 1), u3 = s2.getX(i3 + 2);
          r2 = vo(this, n2, e3, eo, l2, c2, h2, o4, a3, u3), r2 && (r2.faceIndex = Math.floor(i3 / 3), t2.push(r2));
        }
      }
    else if (void 0 !== a2)
      if (Array.isArray(n2))
        for (let i3 = 0, o3 = u2.length; i3 < o3; i3++) {
          const o4 = u2[i3], s3 = n2[o4.materialIndex];
          for (let i4 = Math.max(o4.start, d2.start), n3 = Math.min(a2.count, Math.min(o4.start + o4.count, d2.start + d2.count)); i4 < n3; i4 += 3) {
            r2 = vo(this, s3, e3, eo, l2, c2, h2, i4, i4 + 1, i4 + 2), r2 && (r2.faceIndex = Math.floor(i4 / 3), r2.face.materialIndex = o4.materialIndex, t2.push(r2));
          }
        }
      else {
        for (let i3 = Math.max(0, d2.start), o3 = Math.min(a2.count, d2.start + d2.count); i3 < o3; i3 += 3) {
          r2 = vo(this, n2, e3, eo, l2, c2, h2, i3, i3 + 1, i3 + 2), r2 && (r2.faceIndex = Math.floor(i3 / 3), t2.push(r2));
        }
      }
  }
}
function vo(e3, t2, i2, n2, o2, r2, s2, a2, l2, c2) {
  e3.getVertexPosition(a2, no), e3.getVertexPosition(l2, oo), e3.getVertexPosition(c2, ro);
  const h2 = function(e4, t3, i3, n3, o3, r3, s3, a3) {
    let l3;
    if (l3 = t3.side === Ae ? n3.intersectTriangle(s3, r3, o3, true, a3) : n3.intersectTriangle(o3, r3, s3, t3.side === ve, a3), null === l3)
      return null;
    mo.copy(a3), mo.applyMatrix4(e4.matrixWorld);
    const c3 = i3.ray.origin.distanceTo(mo);
    return c3 < i3.near || c3 > i3.far ? null : { distance: c3, point: mo.clone(), object: e4 };
  }(e3, t2, i2, n2, no, oo, ro, go);
  if (h2) {
    o2 && (lo.fromBufferAttribute(o2, a2), co.fromBufferAttribute(o2, l2), ho.fromBufferAttribute(o2, c2), h2.uv = En.getInterpolation(go, no, oo, ro, lo, co, ho, new Vt())), r2 && (lo.fromBufferAttribute(r2, a2), co.fromBufferAttribute(r2, l2), ho.fromBufferAttribute(r2, c2), h2.uv2 = En.getInterpolation(go, no, oo, ro, lo, co, ho, new Vt())), s2 && (uo.fromBufferAttribute(s2, a2), po.fromBufferAttribute(s2, l2), _o.fromBufferAttribute(s2, c2), h2.normal = En.getInterpolation(go, no, oo, ro, uo, po, _o, new di()), h2.normal.dot(n2.direction) > 0 && h2.normal.multiplyScalar(-1));
    const e4 = { a: a2, b: l2, c: c2, normal: new di(), materialIndex: 0 };
    En.getNormal(no, oo, ro, e4.normal), h2.face = e4;
  }
  return h2;
}
class Ao extends Zn {
  constructor(e3 = 1, t2 = 1, i2 = 1, n2 = 1, o2 = 1, r2 = 1) {
    super(), this.type = "BoxGeometry", this.parameters = { width: e3, height: t2, depth: i2, widthSegments: n2, heightSegments: o2, depthSegments: r2 };
    const s2 = this;
    n2 = Math.floor(n2), o2 = Math.floor(o2), r2 = Math.floor(r2);
    const a2 = [], l2 = [], c2 = [], h2 = [];
    let u2 = 0, d2 = 0;
    function p2(e4, t3, i3, n3, o3, r3, p3, _2, g2, m2, f2) {
      const v2 = r3 / g2, A2 = p3 / m2, b2 = r3 / 2, y2 = p3 / 2, w2 = _2 / 2, x2 = g2 + 1, C2 = m2 + 1;
      let S2 = 0, E2 = 0;
      const I2 = new di();
      for (let r4 = 0; r4 < C2; r4++) {
        const s3 = r4 * A2 - y2;
        for (let a3 = 0; a3 < x2; a3++) {
          const u3 = a3 * v2 - b2;
          I2[e4] = u3 * n3, I2[t3] = s3 * o3, I2[i3] = w2, l2.push(I2.x, I2.y, I2.z), I2[e4] = 0, I2[t3] = 0, I2[i3] = _2 > 0 ? 1 : -1, c2.push(I2.x, I2.y, I2.z), h2.push(a3 / g2), h2.push(1 - r4 / m2), S2 += 1;
        }
      }
      for (let e5 = 0; e5 < m2; e5++)
        for (let t4 = 0; t4 < g2; t4++) {
          const i4 = u2 + t4 + x2 * e5, n4 = u2 + t4 + x2 * (e5 + 1), o4 = u2 + (t4 + 1) + x2 * (e5 + 1), r4 = u2 + (t4 + 1) + x2 * e5;
          a2.push(i4, n4, r4), a2.push(n4, o4, r4), E2 += 6;
        }
      s2.addGroup(d2, E2, f2), d2 += E2, u2 += S2;
    }
    p2("z", "y", "x", -1, -1, i2, t2, e3, r2, o2, 0), p2("z", "y", "x", 1, -1, i2, t2, -e3, r2, o2, 1), p2("x", "z", "y", 1, 1, e3, i2, t2, n2, r2, 2), p2("x", "z", "y", 1, -1, e3, i2, -t2, n2, r2, 3), p2("x", "y", "z", 1, -1, e3, t2, i2, n2, o2, 4), p2("x", "y", "z", -1, -1, e3, t2, -i2, n2, o2, 5), this.setIndex(a2), this.setAttribute("position", new Gn(l2, 3)), this.setAttribute("normal", new Gn(c2, 3)), this.setAttribute("uv", new Gn(h2, 2));
  }
  copy(e3) {
    return super.copy(e3), this.parameters = Object.assign({}, e3.parameters), this;
  }
  static fromJSON(e3) {
    return new Ao(e3.width, e3.height, e3.depth, e3.widthSegments, e3.heightSegments, e3.depthSegments);
  }
}
function bo(e3) {
  const t2 = {};
  for (const i2 in e3) {
    t2[i2] = {};
    for (const n2 in e3[i2]) {
      const o2 = e3[i2][n2];
      o2 && (o2.isColor || o2.isMatrix3 || o2.isMatrix4 || o2.isVector2 || o2.isVector3 || o2.isVector4 || o2.isTexture || o2.isQuaternion) ? o2.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), t2[i2][n2] = null) : t2[i2][n2] = o2.clone() : Array.isArray(o2) ? t2[i2][n2] = o2.slice() : t2[i2][n2] = o2;
    }
  }
  return t2;
}
function yo(e3) {
  const t2 = {};
  for (let i2 = 0; i2 < e3.length; i2++) {
    const n2 = bo(e3[i2]);
    for (const e4 in n2)
      t2[e4] = n2[e4];
  }
  return t2;
}
function wo(e3) {
  return null === e3.getRenderTarget() && e3.outputEncoding === bt ? yt : wt;
}
const xo = { clone: bo, merge: yo };
class Co extends Tn {
  constructor(e3) {
    super(), this.isShaderMaterial = true, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.forceSinglePass = true, this.extensions = { derivatives: false, fragDepth: false, drawBuffers: false, shaderTextureLOD: false }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, void 0 !== e3 && this.setValues(e3);
  }
  copy(e3) {
    return super.copy(e3), this.fragmentShader = e3.fragmentShader, this.vertexShader = e3.vertexShader, this.uniforms = bo(e3.uniforms), this.uniformsGroups = function(e4) {
      const t2 = [];
      for (let i2 = 0; i2 < e4.length; i2++)
        t2.push(e4[i2].clone());
      return t2;
    }(e3.uniformsGroups), this.defines = Object.assign({}, e3.defines), this.wireframe = e3.wireframe, this.wireframeLinewidth = e3.wireframeLinewidth, this.fog = e3.fog, this.lights = e3.lights, this.clipping = e3.clipping, this.extensions = Object.assign({}, e3.extensions), this.glslVersion = e3.glslVersion, this;
  }
  toJSON(e3) {
    const t2 = super.toJSON(e3);
    t2.glslVersion = this.glslVersion, t2.uniforms = {};
    for (const i3 in this.uniforms) {
      const n2 = this.uniforms[i3].value;
      n2 && n2.isTexture ? t2.uniforms[i3] = { type: "t", value: n2.toJSON(e3).uuid } : n2 && n2.isColor ? t2.uniforms[i3] = { type: "c", value: n2.getHex() } : n2 && n2.isVector2 ? t2.uniforms[i3] = { type: "v2", value: n2.toArray() } : n2 && n2.isVector3 ? t2.uniforms[i3] = { type: "v3", value: n2.toArray() } : n2 && n2.isVector4 ? t2.uniforms[i3] = { type: "v4", value: n2.toArray() } : n2 && n2.isMatrix3 ? t2.uniforms[i3] = { type: "m3", value: n2.toArray() } : n2 && n2.isMatrix4 ? t2.uniforms[i3] = { type: "m4", value: n2.toArray() } : t2.uniforms[i3] = { value: n2 };
    }
    Object.keys(this.defines).length > 0 && (t2.defines = this.defines), t2.vertexShader = this.vertexShader, t2.fragmentShader = this.fragmentShader;
    const i2 = {};
    for (const e4 in this.extensions)
      true === this.extensions[e4] && (i2[e4] = true);
    return Object.keys(i2).length > 0 && (t2.extensions = i2), t2;
  }
}
class So extends _n {
  constructor() {
    super(), this.isCamera = true, this.type = "Camera", this.matrixWorldInverse = new Qi(), this.projectionMatrix = new Qi(), this.projectionMatrixInverse = new Qi();
  }
  copy(e3, t2) {
    return super.copy(e3, t2), this.matrixWorldInverse.copy(e3.matrixWorldInverse), this.projectionMatrix.copy(e3.projectionMatrix), this.projectionMatrixInverse.copy(e3.projectionMatrixInverse), this;
  }
  getWorldDirection(e3) {
    this.updateWorldMatrix(true, false);
    const t2 = this.matrixWorld.elements;
    return e3.set(-t2[8], -t2[9], -t2[10]).normalize();
  }
  updateMatrixWorld(e3) {
    super.updateMatrixWorld(e3), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e3, t2) {
    super.updateWorldMatrix(e3, t2), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Eo extends So {
  constructor(e3 = 50, t2 = 1, i2 = 0.1, n2 = 2e3) {
    super(), this.isPerspectiveCamera = true, this.type = "PerspectiveCamera", this.fov = e3, this.zoom = 1, this.near = i2, this.far = n2, this.focus = 10, this.aspect = t2, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e3, t2) {
    return super.copy(e3, t2), this.fov = e3.fov, this.zoom = e3.zoom, this.near = e3.near, this.far = e3.far, this.focus = e3.focus, this.aspect = e3.aspect, this.view = null === e3.view ? null : Object.assign({}, e3.view), this.filmGauge = e3.filmGauge, this.filmOffset = e3.filmOffset, this;
  }
  setFocalLength(e3) {
    const t2 = 0.5 * this.getFilmHeight() / e3;
    this.fov = 2 * Rt * Math.atan(t2), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e3 = Math.tan(0.5 * kt * this.fov);
    return 0.5 * this.getFilmHeight() / e3;
  }
  getEffectiveFOV() {
    return 2 * Rt * Math.atan(Math.tan(0.5 * kt * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(e3, t2, i2, n2, o2, r2) {
    this.aspect = e3 / t2, null === this.view && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = e3, this.view.fullHeight = t2, this.view.offsetX = i2, this.view.offsetY = n2, this.view.width = o2, this.view.height = r2, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    null !== this.view && (this.view.enabled = false), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e3 = this.near;
    let t2 = e3 * Math.tan(0.5 * kt * this.fov) / this.zoom, i2 = 2 * t2, n2 = this.aspect * i2, o2 = -0.5 * n2;
    const r2 = this.view;
    if (null !== this.view && this.view.enabled) {
      const e4 = r2.fullWidth, s3 = r2.fullHeight;
      o2 += r2.offsetX * n2 / e4, t2 -= r2.offsetY * i2 / s3, n2 *= r2.width / e4, i2 *= r2.height / s3;
    }
    const s2 = this.filmOffset;
    0 !== s2 && (o2 += e3 * s2 / this.getFilmWidth()), this.projectionMatrix.makePerspective(o2, o2 + n2, t2, t2 - i2, e3, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e3) {
    const t2 = super.toJSON(e3);
    return t2.object.fov = this.fov, t2.object.zoom = this.zoom, t2.object.near = this.near, t2.object.far = this.far, t2.object.focus = this.focus, t2.object.aspect = this.aspect, null !== this.view && (t2.object.view = Object.assign({}, this.view)), t2.object.filmGauge = this.filmGauge, t2.object.filmOffset = this.filmOffset, t2;
  }
}
const Io = -90;
class To extends _n {
  constructor(e3, t2, i2) {
    super(), this.type = "CubeCamera", this.renderTarget = i2;
    const n2 = new Eo(Io, 1, e3, t2);
    n2.layers = this.layers, n2.up.set(0, 1, 0), n2.lookAt(1, 0, 0), this.add(n2);
    const o2 = new Eo(Io, 1, e3, t2);
    o2.layers = this.layers, o2.up.set(0, 1, 0), o2.lookAt(-1, 0, 0), this.add(o2);
    const r2 = new Eo(Io, 1, e3, t2);
    r2.layers = this.layers, r2.up.set(0, 0, -1), r2.lookAt(0, 1, 0), this.add(r2);
    const s2 = new Eo(Io, 1, e3, t2);
    s2.layers = this.layers, s2.up.set(0, 0, 1), s2.lookAt(0, -1, 0), this.add(s2);
    const a2 = new Eo(Io, 1, e3, t2);
    a2.layers = this.layers, a2.up.set(0, 1, 0), a2.lookAt(0, 0, 1), this.add(a2);
    const l2 = new Eo(Io, 1, e3, t2);
    l2.layers = this.layers, l2.up.set(0, 1, 0), l2.lookAt(0, 0, -1), this.add(l2);
  }
  update(e3, t2) {
    null === this.parent && this.updateMatrixWorld();
    const i2 = this.renderTarget, [n2, o2, r2, s2, a2, l2] = this.children, c2 = e3.getRenderTarget(), h2 = e3.toneMapping, u2 = e3.xr.enabled;
    e3.toneMapping = Se, e3.xr.enabled = false;
    const d2 = i2.texture.generateMipmaps;
    i2.texture.generateMipmaps = false, e3.setRenderTarget(i2, 0), e3.render(t2, n2), e3.setRenderTarget(i2, 1), e3.render(t2, o2), e3.setRenderTarget(i2, 2), e3.render(t2, r2), e3.setRenderTarget(i2, 3), e3.render(t2, s2), e3.setRenderTarget(i2, 4), e3.render(t2, a2), i2.texture.generateMipmaps = d2, e3.setRenderTarget(i2, 5), e3.render(t2, l2), e3.setRenderTarget(c2), e3.toneMapping = h2, e3.xr.enabled = u2, i2.texture.needsPMREMUpdate = true;
  }
}
class Bo extends si {
  constructor(e3, t2, i2, n2, o2, r2, s2, a2, l2, c2) {
    super(e3 = void 0 !== e3 ? e3 : [], t2 = void 0 !== t2 ? t2 : ke, i2, n2, o2, r2, s2, a2, l2, c2), this.isCubeTexture = true, this.flipY = false;
  }
  get images() {
    return this.image;
  }
  set images(e3) {
    this.image = e3;
  }
}
class Mo extends li {
  constructor(e3 = 1, t2 = {}) {
    super(e3, e3, t2), this.isWebGLCubeRenderTarget = true;
    const i2 = { width: e3, height: e3, depth: 1 }, n2 = [i2, i2, i2, i2, i2, i2];
    this.texture = new Bo(n2, t2.mapping, t2.wrapS, t2.wrapT, t2.magFilter, t2.minFilter, t2.format, t2.type, t2.anisotropy, t2.encoding), this.texture.isRenderTargetTexture = true, this.texture.generateMipmaps = void 0 !== t2.generateMipmaps && t2.generateMipmaps, this.texture.minFilter = void 0 !== t2.minFilter ? t2.minFilter : He;
  }
  fromEquirectangularTexture(e3, t2) {
    this.texture.type = t2.type, this.texture.encoding = t2.encoding, this.texture.generateMipmaps = t2.generateMipmaps, this.texture.minFilter = t2.minFilter, this.texture.magFilter = t2.magFilter;
    const i2 = { uniforms: { tEquirect: { value: null } }, vertexShader: "\n\n				varying vec3 vWorldDirection;\n\n				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n				}\n\n				void main() {\n\n					vWorldDirection = transformDirection( position, modelMatrix );\n\n					#include <begin_vertex>\n					#include <project_vertex>\n\n				}\n			", fragmentShader: "\n\n				uniform sampler2D tEquirect;\n\n				varying vec3 vWorldDirection;\n\n				#include <common>\n\n				void main() {\n\n					vec3 direction = normalize( vWorldDirection );\n\n					vec2 sampleUV = equirectUv( direction );\n\n					gl_FragColor = texture2D( tEquirect, sampleUV );\n\n				}\n			" }, n2 = new Ao(5, 5, 5), o2 = new Co({ name: "CubemapFromEquirect", uniforms: bo(i2.uniforms), vertexShader: i2.vertexShader, fragmentShader: i2.fragmentShader, side: Ae, blending: 0 });
    o2.uniforms.tEquirect.value = t2;
    const r2 = new fo(n2, o2), s2 = t2.minFilter;
    t2.minFilter === Ve && (t2.minFilter = He);
    return new To(1, 10, this).update(e3, r2), t2.minFilter = s2, r2.geometry.dispose(), r2.material.dispose(), this;
  }
  clear(e3, t2, i2, n2) {
    const o2 = e3.getRenderTarget();
    for (let o3 = 0; o3 < 6; o3++)
      e3.setRenderTarget(this, o3), e3.clear(t2, i2, n2);
    e3.setRenderTarget(o2);
  }
}
const ko = new di(), Ro = new di(), Po = new Gt();
class Do {
  constructor(e3 = new di(1, 0, 0), t2 = 0) {
    this.isPlane = true, this.normal = e3, this.constant = t2;
  }
  set(e3, t2) {
    return this.normal.copy(e3), this.constant = t2, this;
  }
  setComponents(e3, t2, i2, n2) {
    return this.normal.set(e3, t2, i2), this.constant = n2, this;
  }
  setFromNormalAndCoplanarPoint(e3, t2) {
    return this.normal.copy(e3), this.constant = -t2.dot(this.normal), this;
  }
  setFromCoplanarPoints(e3, t2, i2) {
    const n2 = ko.subVectors(i2, t2).cross(Ro.subVectors(e3, t2)).normalize();
    return this.setFromNormalAndCoplanarPoint(n2, e3), this;
  }
  copy(e3) {
    return this.normal.copy(e3.normal), this.constant = e3.constant, this;
  }
  normalize() {
    const e3 = 1 / this.normal.length();
    return this.normal.multiplyScalar(e3), this.constant *= e3, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e3) {
    return this.normal.dot(e3) + this.constant;
  }
  distanceToSphere(e3) {
    return this.distanceToPoint(e3.center) - e3.radius;
  }
  projectPoint(e3, t2) {
    return t2.copy(e3).addScaledVector(this.normal, -this.distanceToPoint(e3));
  }
  intersectLine(e3, t2) {
    const i2 = e3.delta(ko), n2 = this.normal.dot(i2);
    if (0 === n2)
      return 0 === this.distanceToPoint(e3.start) ? t2.copy(e3.start) : null;
    const o2 = -(e3.start.dot(this.normal) + this.constant) / n2;
    return o2 < 0 || o2 > 1 ? null : t2.copy(e3.start).addScaledVector(i2, o2);
  }
  intersectsLine(e3) {
    const t2 = this.distanceToPoint(e3.start), i2 = this.distanceToPoint(e3.end);
    return t2 < 0 && i2 > 0 || i2 < 0 && t2 > 0;
  }
  intersectsBox(e3) {
    return e3.intersectsPlane(this);
  }
  intersectsSphere(e3) {
    return e3.intersectsPlane(this);
  }
  coplanarPoint(e3) {
    return e3.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e3, t2) {
    const i2 = t2 || Po.getNormalMatrix(e3), n2 = this.coplanarPoint(ko).applyMatrix4(e3), o2 = this.normal.applyMatrix3(i2).normalize();
    return this.constant = -n2.dot(o2), this;
  }
  translate(e3) {
    return this.constant -= e3.dot(this.normal), this;
  }
  equals(e3) {
    return e3.normal.equals(this.normal) && e3.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Lo = new Pi(), Fo = new di();
class No {
  constructor(e3 = new Do(), t2 = new Do(), i2 = new Do(), n2 = new Do(), o2 = new Do(), r2 = new Do()) {
    this.planes = [e3, t2, i2, n2, o2, r2];
  }
  set(e3, t2, i2, n2, o2, r2) {
    const s2 = this.planes;
    return s2[0].copy(e3), s2[1].copy(t2), s2[2].copy(i2), s2[3].copy(n2), s2[4].copy(o2), s2[5].copy(r2), this;
  }
  copy(e3) {
    const t2 = this.planes;
    for (let i2 = 0; i2 < 6; i2++)
      t2[i2].copy(e3.planes[i2]);
    return this;
  }
  setFromProjectionMatrix(e3) {
    const t2 = this.planes, i2 = e3.elements, n2 = i2[0], o2 = i2[1], r2 = i2[2], s2 = i2[3], a2 = i2[4], l2 = i2[5], c2 = i2[6], h2 = i2[7], u2 = i2[8], d2 = i2[9], p2 = i2[10], _2 = i2[11], g2 = i2[12], m2 = i2[13], f2 = i2[14], v2 = i2[15];
    return t2[0].setComponents(s2 - n2, h2 - a2, _2 - u2, v2 - g2).normalize(), t2[1].setComponents(s2 + n2, h2 + a2, _2 + u2, v2 + g2).normalize(), t2[2].setComponents(s2 + o2, h2 + l2, _2 + d2, v2 + m2).normalize(), t2[3].setComponents(s2 - o2, h2 - l2, _2 - d2, v2 - m2).normalize(), t2[4].setComponents(s2 - r2, h2 - c2, _2 - p2, v2 - f2).normalize(), t2[5].setComponents(s2 + r2, h2 + c2, _2 + p2, v2 + f2).normalize(), this;
  }
  intersectsObject(e3) {
    if (void 0 !== e3.boundingSphere)
      null === e3.boundingSphere && e3.computeBoundingSphere(), Lo.copy(e3.boundingSphere).applyMatrix4(e3.matrixWorld);
    else {
      const t2 = e3.geometry;
      null === t2.boundingSphere && t2.computeBoundingSphere(), Lo.copy(t2.boundingSphere).applyMatrix4(e3.matrixWorld);
    }
    return this.intersectsSphere(Lo);
  }
  intersectsSprite(e3) {
    return Lo.center.set(0, 0, 0), Lo.radius = 0.7071067811865476, Lo.applyMatrix4(e3.matrixWorld), this.intersectsSphere(Lo);
  }
  intersectsSphere(e3) {
    const t2 = this.planes, i2 = e3.center, n2 = -e3.radius;
    for (let e4 = 0; e4 < 6; e4++) {
      if (t2[e4].distanceToPoint(i2) < n2)
        return false;
    }
    return true;
  }
  intersectsBox(e3) {
    const t2 = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      const n2 = t2[i2];
      if (Fo.x = n2.normal.x > 0 ? e3.max.x : e3.min.x, Fo.y = n2.normal.y > 0 ? e3.max.y : e3.min.y, Fo.z = n2.normal.z > 0 ? e3.max.z : e3.min.z, n2.distanceToPoint(Fo) < 0)
        return false;
    }
    return true;
  }
  containsPoint(e3) {
    const t2 = this.planes;
    for (let i2 = 0; i2 < 6; i2++)
      if (t2[i2].distanceToPoint(e3) < 0)
        return false;
    return true;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function Oo() {
  let e3 = null, t2 = false, i2 = null, n2 = null;
  function o2(t3, r2) {
    i2(t3, r2), n2 = e3.requestAnimationFrame(o2);
  }
  return { start: function() {
    true !== t2 && null !== i2 && (n2 = e3.requestAnimationFrame(o2), t2 = true);
  }, stop: function() {
    e3.cancelAnimationFrame(n2), t2 = false;
  }, setAnimationLoop: function(e4) {
    i2 = e4;
  }, setContext: function(t3) {
    e3 = t3;
  } };
}
function zo(e3, t2) {
  const i2 = t2.isWebGL2, n2 = /* @__PURE__ */ new WeakMap();
  return { get: function(e4) {
    return e4.isInterleavedBufferAttribute && (e4 = e4.data), n2.get(e4);
  }, remove: function(t3) {
    t3.isInterleavedBufferAttribute && (t3 = t3.data);
    const i3 = n2.get(t3);
    i3 && (e3.deleteBuffer(i3.buffer), n2.delete(t3));
  }, update: function(t3, o2) {
    if (t3.isGLBufferAttribute) {
      const e4 = n2.get(t3);
      return void ((!e4 || e4.version < t3.version) && n2.set(t3, { buffer: t3.buffer, type: t3.type, bytesPerElement: t3.elementSize, version: t3.version }));
    }
    t3.isInterleavedBufferAttribute && (t3 = t3.data);
    const r2 = n2.get(t3);
    void 0 === r2 ? n2.set(t3, function(t4, n3) {
      const o3 = t4.array, r3 = t4.usage, s2 = e3.createBuffer();
      let a2;
      if (e3.bindBuffer(n3, s2), e3.bufferData(n3, o3, r3), t4.onUploadCallback(), o3 instanceof Float32Array)
        a2 = 5126;
      else if (o3 instanceof Uint16Array)
        if (t4.isFloat16BufferAttribute) {
          if (!i2)
            throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
          a2 = 5131;
        } else
          a2 = 5123;
      else if (o3 instanceof Int16Array)
        a2 = 5122;
      else if (o3 instanceof Uint32Array)
        a2 = 5125;
      else if (o3 instanceof Int32Array)
        a2 = 5124;
      else if (o3 instanceof Int8Array)
        a2 = 5120;
      else if (o3 instanceof Uint8Array)
        a2 = 5121;
      else {
        if (!(o3 instanceof Uint8ClampedArray))
          throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + o3);
        a2 = 5121;
      }
      return { buffer: s2, type: a2, bytesPerElement: o3.BYTES_PER_ELEMENT, version: t4.version };
    }(t3, o2)) : r2.version < t3.version && (!function(t4, n3, o3) {
      const r3 = n3.array, s2 = n3.updateRange;
      e3.bindBuffer(o3, t4), -1 === s2.count ? e3.bufferSubData(o3, 0, r3) : (i2 ? e3.bufferSubData(o3, s2.offset * r3.BYTES_PER_ELEMENT, r3, s2.offset, s2.count) : e3.bufferSubData(o3, s2.offset * r3.BYTES_PER_ELEMENT, r3.subarray(s2.offset, s2.offset + s2.count)), s2.count = -1), n3.onUploadCallback();
    }(r2.buffer, t3, o2), r2.version = t3.version);
  } };
}
class Uo extends Zn {
  constructor(e3 = 1, t2 = 1, i2 = 1, n2 = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = { width: e3, height: t2, widthSegments: i2, heightSegments: n2 };
    const o2 = e3 / 2, r2 = t2 / 2, s2 = Math.floor(i2), a2 = Math.floor(n2), l2 = s2 + 1, c2 = a2 + 1, h2 = e3 / s2, u2 = t2 / a2, d2 = [], p2 = [], _2 = [], g2 = [];
    for (let e4 = 0; e4 < c2; e4++) {
      const t3 = e4 * u2 - r2;
      for (let i3 = 0; i3 < l2; i3++) {
        const n3 = i3 * h2 - o2;
        p2.push(n3, -t3, 0), _2.push(0, 0, 1), g2.push(i3 / s2), g2.push(1 - e4 / a2);
      }
    }
    for (let e4 = 0; e4 < a2; e4++)
      for (let t3 = 0; t3 < s2; t3++) {
        const i3 = t3 + l2 * e4, n3 = t3 + l2 * (e4 + 1), o3 = t3 + 1 + l2 * (e4 + 1), r3 = t3 + 1 + l2 * e4;
        d2.push(i3, n3, r3), d2.push(n3, o3, r3);
      }
    this.setIndex(d2), this.setAttribute("position", new Gn(p2, 3)), this.setAttribute("normal", new Gn(_2, 3)), this.setAttribute("uv", new Gn(g2, 2));
  }
  copy(e3) {
    return super.copy(e3), this.parameters = Object.assign({}, e3.parameters), this;
  }
  static fromJSON(e3) {
    return new Uo(e3.width, e3.height, e3.widthSegments, e3.heightSegments);
  }
}
const Ho = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif", alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "float G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n} // validated", iridescence_fragment: "#ifdef USE_IRIDESCENCE\n	const mat3 XYZ_TO_REC709 = mat3(\n		 3.2404542, -0.9692660,  0.0556434,\n		-1.5371385,  1.8760108, -0.2040259,\n		-0.4985314,  0.0415560,  1.0572252\n	);\n	vec3 Fresnel0ToIor( vec3 fresnel0 ) {\n		vec3 sqrtF0 = sqrt( fresnel0 );\n		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n	}\n	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n	}\n	float IorToFresnel0( float transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n	}\n	vec3 evalSensitivity( float OPD, vec3 shift ) {\n		float phase = 2.0 * PI * OPD * 1.0e-9;\n		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n		xyz /= 1.0685e-7;\n		vec3 rgb = XYZ_TO_REC709 * xyz;\n		return rgb;\n	}\n	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n		vec3 I;\n		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n		float cosTheta2Sq = 1.0 - sinTheta2Sq;\n		if ( cosTheta2Sq < 0.0 ) {\n			 return vec3( 1.0 );\n		}\n		float cosTheta2 = sqrt( cosTheta2Sq );\n		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n		float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n		float R21 = R12;\n		float T121 = 1.0 - R12;\n		float phi12 = 0.0;\n		if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n		float phi21 = PI - phi12;\n		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n		vec3 phi23 = vec3( 0.0 );\n		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n		vec3 phi = vec3( phi21 ) + phi23;\n		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n		vec3 r123 = sqrt( R123 );\n		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n		vec3 C0 = R12 + Rs;\n		I = C0;\n		vec3 Cm = Rs - T121;\n		for ( int m = 1; m <= 2; ++ m ) {\n			Cm *= r123;\n			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n			I += Cm * Sm;\n		}\n		return max( I, vec3( 0.0 ) );\n	}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vBumpMapUv );\n		vec2 dSTdy = dFdy( vBumpMapUv );\n		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = dFdx( surf_pos.xyz );\n		vec3 vSigmaY = dFdy( surf_pos.xyz );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif", color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif", color_vertex: "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n	return dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define cubeUV_r0 1.0\n	#define cubeUV_v0 0.339\n	#define cubeUV_m0 - 2.0\n	#define cubeUV_r1 0.8\n	#define cubeUV_v1 0.276\n	#define cubeUV_m1 - 1.0\n	#define cubeUV_r4 0.4\n	#define cubeUV_v4 0.046\n	#define cubeUV_m4 2.0\n	#define cubeUV_r5 0.305\n	#define cubeUV_v5 0.016\n	#define cubeUV_m5 3.0\n	#define cubeUV_r6 0.21\n	#define cubeUV_v6 0.0038\n	#define cubeUV_m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= cubeUV_r1 ) {\n			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n		} else if ( roughness >= cubeUV_r4 ) {\n			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n		} else if ( roughness >= cubeUV_r5 ) {\n			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n		} else if ( roughness >= cubeUV_r6 ) {\n			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "vec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		vec2 fw = fwidth( coord ) * 0.5;\n		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n	#endif\n}", lightmap_fragment: "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif", lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;", lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n	vec3 diffuseColor;\n	float specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Lambert\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( LEGACY_LIGHTS )\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#else\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	material.ior = ior;\n	#ifdef USE_SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULAR_COLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n		#endif\n		#ifdef USE_SPECULAR_INTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEEN_COLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n	#endif\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n	#ifdef IOR\n		float ior;\n	#endif\n	#ifdef USE_TRANSMISSION\n		float transmission;\n		float transmissionAlpha;\n		float thickness;\n		float attenuationDistance;\n		vec3 attenuationColor;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_CLEARCOAT\n	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n		vec3 f0 = material.clearcoatF0;\n		float f90 = material.clearcoatF90;\n		float roughness = material.clearcoatRoughness;\n		float alpha = pow2( roughness );\n		vec3 halfDir = normalize( lightDir + viewDir );\n		float dotNL = saturate( dot( normal, lightDir ) );\n		float dotNV = saturate( dot( normal, viewDir ) );\n		float dotNH = saturate( dot( normal, halfDir ) );\n		float dotVH = saturate( dot( viewDir, halfDir ) );\n		vec3 F = F_Schlick( f0, f90, dotVH );\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n		return F * ( V * D );\n	}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n	vec3 f0 = material.specularColor;\n	float f90 = material.specularF90;\n	float roughness = material.roughness;\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	#ifdef USE_IRIDESCENCE\n		F = mix( F, material.iridescenceFresnel, material.iridescence );\n	#endif\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n	float dotNVi = saturate( dot( normal, geometry.viewDir ) );\n	if ( material.iridescenceThickness == 0.0 ) {\n		material.iridescence = 0.0;\n	} else {\n		material.iridescence = saturate( material.iridescence );\n	}\n	if ( material.iridescence > 0.0 ) {\n		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n	}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	vec4 spotColor;\n	vec3 spotLightCoord;\n	bool inSpotLightMap;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n		#else\n		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#endif\n		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n		#endif\n		#undef SPOT_LIGHT_MAP_INDEX\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif", map_fragment: "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vMapUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	#if defined( USE_POINTS_UV )\n		vec2 uv = vUv;\n	#else\n		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n	#endif\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_POINTS_UV )\n	varying vec2 vUv;\n#else\n	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n		uniform mat3 uvTransform;\n	#endif\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n	metalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif", morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform ivec2 morphTargetsTextureSize;\n		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n			int y = texelIndex / morphTargetsTextureSize.x;\n			int x = texelIndex - y * morphTargetsTextureSize.x;\n			ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n			return texelFetch( morphTargetsTexture, morphUV, 0 );\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif", normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal *= faceDirection;\n	#endif\n#endif\n#ifdef USE_NORMALMAP_TANGENTSPACE\n	#ifdef USE_TANGENT\n		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn = getTangentFrame( - vViewPosition, normal, vNormalMapUv );\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn[0] *= faceDirection;\n		tbn[1] *= faceDirection;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	#ifdef USE_TANGENT\n		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn2[0] *= faceDirection;\n		tbn2[1] *= faceDirection;\n	#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps: "#ifdef USE_NORMALMAP_OBJECTSPACE\n	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	normal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif", normal_pars_fragment: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif", normal_pars_vertex: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif", normal_vertex: "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( uv.st );\n		vec2 st1 = dFdy( uv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n		return mat3( T * scale, B * scale, N );\n	}\n#endif", clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	clearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif", iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif", output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n	return packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * depth - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n	roughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif", shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif", shadowmap_vertex: "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n	vec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n		shadowWorldPosition = worldPosition;\n		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n		#endif\n		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	uniform int boneTextureSize;\n	mat4 getBoneMatrix( const in float i ) {\n		float j = i * 4.0;\n		float x = mod( j, float( boneTextureSize ) );\n		float y = floor( j / float( boneTextureSize ) );\n		float dx = 1.0 / float( boneTextureSize );\n		float dy = 1.0 / float( boneTextureSize );\n		y = dy * ( y + 0.5 );\n		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n		mat4 bone = mat4( v1, v2, v3, v4 );\n		return bone;\n	}\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmission_fragment: "#ifdef USE_TRANSMISSION\n	material.transmission = transmission;\n	material.transmissionAlpha = 1.0;\n	material.thickness = thickness;\n	material.attenuationDistance = attenuationDistance;\n	material.attenuationColor = attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n		material.attenuationColor, material.attenuationDistance );\n	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\n#endif", transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	float w0( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n	}\n	float w1( float a ) {\n		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n	}\n	float w2( float a ){\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n	}\n	float w3( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * a * a );\n	}\n	float g0( float a ) {\n		return w0( a ) + w1( a );\n	}\n	float g1( float a ) {\n		return w2( a ) + w3( a );\n	}\n	float h0( float a ) {\n		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n	}\n	float h1( float a ) {\n		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n	}\n	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, vec2 fullSize, float lod ) {\n		uv = uv * texelSize.zw + 0.5;\n		vec2 iuv = floor( uv );\n		vec2 fuv = fract( uv );\n		float g0x = g0( fuv.x );\n		float g1x = g1( fuv.x );\n		float h0x = h0( fuv.x );\n		float h1x = h1( fuv.x );\n		float h0y = h0( fuv.y );\n		float h1y = h1( fuv.y );\n		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		\n		vec2 lodFudge = pow( 1.95, lod ) / fullSize;\n		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n	}\n	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n		vec2 fLodSizeInv = 1.0 / fLodSize;\n		vec2 cLodSizeInv = 1.0 / cLodSize;\n		vec2 fullSize = vec2( textureSize( sampler, 0 ) );\n		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), fullSize, floor( lod ) );\n		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), fullSize, ceil( lod ) );\n		return mix( fSample, cSample, fract( lod ) );\n	}\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n	}\n	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( isinf( attenuationDistance ) ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif", uv_pars_fragment: "#ifdef USE_UV\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n	varying vec2 vUv;\n#endif\n#ifdef USE_UV2\n	attribute vec2 uv2;\n#endif\n#ifdef USE_MAP\n	uniform mat3 mapTransform;\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform mat3 alphaMapTransform;\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	uniform mat3 lightMapTransform;\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	uniform mat3 aoMapTransform;\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	uniform mat3 bumpMapTransform;\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	uniform mat3 normalMapTransform;\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	uniform mat3 displacementMapTransform;\n	varying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	uniform mat3 emissiveMapTransform;\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	uniform mat3 metalnessMapTransform;\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	uniform mat3 roughnessMapTransform;\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	uniform mat3 clearcoatMapTransform;\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform mat3 clearcoatNormalMapTransform;\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform mat3 clearcoatRoughnessMapTransform;\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	uniform mat3 sheenColorMapTransform;\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	uniform mat3 sheenRoughnessMapTransform;\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	uniform mat3 iridescenceMapTransform;\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform mat3 iridescenceThicknessMapTransform;\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	uniform mat3 specularMapTransform;\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	uniform mat3 specularColorMapTransform;\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	uniform mat3 specularIntensityMapTransform;\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif", uv_vertex: "#ifdef USE_UV\n	vUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}", background_frag: "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}", backgroundCube_frag: "#ifdef ENVMAP_TYPE_CUBE\n	uniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n	uniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n	#else\n		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}", cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n	gl_FragColor = texColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_lambert_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}", meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef USE_SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULAR_COLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n	#ifdef USE_SPECULAR_INTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEEN_COLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n	varying vec2 vUv;\n	uniform mat3 uvTransform;\n#endif\nvoid main() {\n	#ifdef USE_POINTS_UV\n		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	#endif\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}" }, Qo = { common: { diffuse: { value: new Pn(16777215) }, opacity: { value: 1 }, map: { value: null }, mapTransform: { value: new Gt() }, alphaMap: { value: null }, alphaMapTransform: { value: new Gt() }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null }, specularMapTransform: { value: new Gt() } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: 0.98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 }, aoMapTransform: { value: new Gt() } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 }, lightMapTransform: { value: new Gt() } }, bumpmap: { bumpMap: { value: null }, bumpMapTransform: { value: new Gt() }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalMapTransform: { value: new Gt() }, normalScale: { value: new Vt(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementMapTransform: { value: new Gt() }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, emissivemap: { emissiveMap: { value: null }, emissiveMapTransform: { value: new Gt() } }, metalnessmap: { metalnessMap: { value: null }, metalnessMapTransform: { value: new Gt() } }, roughnessmap: { roughnessMap: { value: null }, roughnessMapTransform: { value: new Gt() } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Pn(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotLightMap: { value: [] }, spotShadowMap: { value: [] }, spotLightMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new Pn(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new Gt() } }, sprite: { diffuse: { value: new Pn(16777215) }, opacity: { value: 1 }, center: { value: new Vt(0.5, 0.5) }, rotation: { value: 0 }, map: { value: null }, mapTransform: { value: new Gt() }, alphaMap: { value: null }, alphaTest: { value: 0 } } }, Vo = { basic: { uniforms: yo([Qo.common, Qo.specularmap, Qo.envmap, Qo.aomap, Qo.lightmap, Qo.fog]), vertexShader: Ho.meshbasic_vert, fragmentShader: Ho.meshbasic_frag }, lambert: { uniforms: yo([Qo.common, Qo.specularmap, Qo.envmap, Qo.aomap, Qo.lightmap, Qo.emissivemap, Qo.bumpmap, Qo.normalmap, Qo.displacementmap, Qo.fog, Qo.lights, { emissive: { value: new Pn(0) } }]), vertexShader: Ho.meshlambert_vert, fragmentShader: Ho.meshlambert_frag }, phong: { uniforms: yo([Qo.common, Qo.specularmap, Qo.envmap, Qo.aomap, Qo.lightmap, Qo.emissivemap, Qo.bumpmap, Qo.normalmap, Qo.displacementmap, Qo.fog, Qo.lights, { emissive: { value: new Pn(0) }, specular: { value: new Pn(1118481) }, shininess: { value: 30 } }]), vertexShader: Ho.meshphong_vert, fragmentShader: Ho.meshphong_frag }, standard: { uniforms: yo([Qo.common, Qo.envmap, Qo.aomap, Qo.lightmap, Qo.emissivemap, Qo.bumpmap, Qo.normalmap, Qo.displacementmap, Qo.roughnessmap, Qo.metalnessmap, Qo.fog, Qo.lights, { emissive: { value: new Pn(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: Ho.meshphysical_vert, fragmentShader: Ho.meshphysical_frag }, toon: { uniforms: yo([Qo.common, Qo.aomap, Qo.lightmap, Qo.emissivemap, Qo.bumpmap, Qo.normalmap, Qo.displacementmap, Qo.gradientmap, Qo.fog, Qo.lights, { emissive: { value: new Pn(0) } }]), vertexShader: Ho.meshtoon_vert, fragmentShader: Ho.meshtoon_frag }, matcap: { uniforms: yo([Qo.common, Qo.bumpmap, Qo.normalmap, Qo.displacementmap, Qo.fog, { matcap: { value: null } }]), vertexShader: Ho.meshmatcap_vert, fragmentShader: Ho.meshmatcap_frag }, points: { uniforms: yo([Qo.points, Qo.fog]), vertexShader: Ho.points_vert, fragmentShader: Ho.points_frag }, dashed: { uniforms: yo([Qo.common, Qo.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: Ho.linedashed_vert, fragmentShader: Ho.linedashed_frag }, depth: { uniforms: yo([Qo.common, Qo.displacementmap]), vertexShader: Ho.depth_vert, fragmentShader: Ho.depth_frag }, normal: { uniforms: yo([Qo.common, Qo.bumpmap, Qo.normalmap, Qo.displacementmap, { opacity: { value: 1 } }]), vertexShader: Ho.meshnormal_vert, fragmentShader: Ho.meshnormal_frag }, sprite: { uniforms: yo([Qo.sprite, Qo.fog]), vertexShader: Ho.sprite_vert, fragmentShader: Ho.sprite_frag }, background: { uniforms: { uvTransform: { value: new Gt() }, t2D: { value: null }, backgroundIntensity: { value: 1 } }, vertexShader: Ho.background_vert, fragmentShader: Ho.background_frag }, backgroundCube: { uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 }, backgroundBlurriness: { value: 0 }, backgroundIntensity: { value: 1 } }, vertexShader: Ho.backgroundCube_vert, fragmentShader: Ho.backgroundCube_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: Ho.cube_vert, fragmentShader: Ho.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: Ho.equirect_vert, fragmentShader: Ho.equirect_frag }, distanceRGBA: { uniforms: yo([Qo.common, Qo.displacementmap, { referencePosition: { value: new di() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: Ho.distanceRGBA_vert, fragmentShader: Ho.distanceRGBA_frag }, shadow: { uniforms: yo([Qo.lights, Qo.fog, { color: { value: new Pn(0) }, opacity: { value: 1 } }]), vertexShader: Ho.shadow_vert, fragmentShader: Ho.shadow_frag } };
Vo.physical = { uniforms: yo([Vo.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatMapTransform: { value: new Gt() }, clearcoatNormalMap: { value: null }, clearcoatNormalMapTransform: { value: new Gt() }, clearcoatNormalScale: { value: new Vt(1, 1) }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatRoughnessMapTransform: { value: new Gt() }, iridescence: { value: 0 }, iridescenceMap: { value: null }, iridescenceMapTransform: { value: new Gt() }, iridescenceIOR: { value: 1.3 }, iridescenceThicknessMinimum: { value: 100 }, iridescenceThicknessMaximum: { value: 400 }, iridescenceThicknessMap: { value: null }, iridescenceThicknessMapTransform: { value: new Gt() }, sheen: { value: 0 }, sheenColor: { value: new Pn(0) }, sheenColorMap: { value: null }, sheenColorMapTransform: { value: new Gt() }, sheenRoughness: { value: 1 }, sheenRoughnessMap: { value: null }, sheenRoughnessMapTransform: { value: new Gt() }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionMapTransform: { value: new Gt() }, transmissionSamplerSize: { value: new Vt() }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, thicknessMapTransform: { value: new Gt() }, attenuationDistance: { value: 0 }, attenuationColor: { value: new Pn(0) }, specularColor: { value: new Pn(1, 1, 1) }, specularColorMap: { value: null }, specularColorMapTransform: { value: new Gt() }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularIntensityMapTransform: { value: new Gt() } }]), vertexShader: Ho.meshphysical_vert, fragmentShader: Ho.meshphysical_frag };
const Go = { r: 0, b: 0, g: 0 };
function $o(e3, t2, i2, n2, o2, r2, s2) {
  const a2 = new Pn(0);
  let l2, c2, h2 = true === r2 ? 0 : 1, u2 = null, d2 = 0, p2 = null;
  function _2(t3, i3) {
    t3.getRGB(Go, wo(e3)), n2.buffers.color.setClear(Go.r, Go.g, Go.b, i3, s2);
  }
  return { getClearColor: function() {
    return a2;
  }, setClearColor: function(e4, t3 = 1) {
    a2.set(e4), h2 = t3, _2(a2, h2);
  }, getClearAlpha: function() {
    return h2;
  }, setClearAlpha: function(e4) {
    h2 = e4, _2(a2, h2);
  }, render: function(n3, r3) {
    let s3 = false, g2 = true === r3.isScene ? r3.background : null;
    if (g2 && g2.isTexture) {
      g2 = (r3.backgroundBlurriness > 0 ? i2 : t2).get(g2);
    }
    const m2 = e3.xr, f2 = m2.getSession && m2.getSession();
    f2 && "additive" === f2.environmentBlendMode && (g2 = null), null === g2 ? _2(a2, h2) : g2 && g2.isColor && (_2(g2, 1), s3 = true), (e3.autoClear || s3) && e3.clear(e3.autoClearColor, e3.autoClearDepth, e3.autoClearStencil), g2 && (g2.isCubeTexture || g2.mapping === De) ? (void 0 === c2 && (c2 = new fo(new Ao(1, 1, 1), new Co({ name: "BackgroundCubeMaterial", uniforms: bo(Vo.backgroundCube.uniforms), vertexShader: Vo.backgroundCube.vertexShader, fragmentShader: Vo.backgroundCube.fragmentShader, side: Ae, depthTest: false, depthWrite: false, fog: false })), c2.geometry.deleteAttribute("normal"), c2.geometry.deleteAttribute("uv"), c2.onBeforeRender = function(e4, t3, i3) {
      this.matrixWorld.copyPosition(i3.matrixWorld);
    }, Object.defineProperty(c2.material, "envMap", { get: function() {
      return this.uniforms.envMap.value;
    } }), o2.update(c2)), c2.material.uniforms.envMap.value = g2, c2.material.uniforms.flipEnvMap.value = g2.isCubeTexture && false === g2.isRenderTargetTexture ? -1 : 1, c2.material.uniforms.backgroundBlurriness.value = r3.backgroundBlurriness, c2.material.uniforms.backgroundIntensity.value = r3.backgroundIntensity, c2.material.toneMapped = g2.encoding !== bt, u2 === g2 && d2 === g2.version && p2 === e3.toneMapping || (c2.material.needsUpdate = true, u2 = g2, d2 = g2.version, p2 = e3.toneMapping), c2.layers.enableAll(), n3.unshift(c2, c2.geometry, c2.material, 0, 0, null)) : g2 && g2.isTexture && (void 0 === l2 && (l2 = new fo(new Uo(2, 2), new Co({ name: "BackgroundMaterial", uniforms: bo(Vo.background.uniforms), vertexShader: Vo.background.vertexShader, fragmentShader: Vo.background.fragmentShader, side: ve, depthTest: false, depthWrite: false, fog: false })), l2.geometry.deleteAttribute("normal"), Object.defineProperty(l2.material, "map", { get: function() {
      return this.uniforms.t2D.value;
    } }), o2.update(l2)), l2.material.uniforms.t2D.value = g2, l2.material.uniforms.backgroundIntensity.value = r3.backgroundIntensity, l2.material.toneMapped = g2.encoding !== bt, true === g2.matrixAutoUpdate && g2.updateMatrix(), l2.material.uniforms.uvTransform.value.copy(g2.matrix), u2 === g2 && d2 === g2.version && p2 === e3.toneMapping || (l2.material.needsUpdate = true, u2 = g2, d2 = g2.version, p2 = e3.toneMapping), l2.layers.enableAll(), n3.unshift(l2, l2.geometry, l2.material, 0, 0, null));
  } };
}
function Wo(e3, t2, i2, n2) {
  const o2 = e3.getParameter(34921), r2 = n2.isWebGL2 ? null : t2.get("OES_vertex_array_object"), s2 = n2.isWebGL2 || null !== r2, a2 = {}, l2 = p2(null);
  let c2 = l2, h2 = false;
  function u2(t3) {
    return n2.isWebGL2 ? e3.bindVertexArray(t3) : r2.bindVertexArrayOES(t3);
  }
  function d2(t3) {
    return n2.isWebGL2 ? e3.deleteVertexArray(t3) : r2.deleteVertexArrayOES(t3);
  }
  function p2(e4) {
    const t3 = [], i3 = [], n3 = [];
    for (let e5 = 0; e5 < o2; e5++)
      t3[e5] = 0, i3[e5] = 0, n3[e5] = 0;
    return { geometry: null, program: null, wireframe: false, newAttributes: t3, enabledAttributes: i3, attributeDivisors: n3, object: e4, attributes: {}, index: null };
  }
  function _2() {
    const e4 = c2.newAttributes;
    for (let t3 = 0, i3 = e4.length; t3 < i3; t3++)
      e4[t3] = 0;
  }
  function g2(e4) {
    m2(e4, 0);
  }
  function m2(i3, o3) {
    const r3 = c2.newAttributes, s3 = c2.enabledAttributes, a3 = c2.attributeDivisors;
    if (r3[i3] = 1, 0 === s3[i3] && (e3.enableVertexAttribArray(i3), s3[i3] = 1), a3[i3] !== o3) {
      (n2.isWebGL2 ? e3 : t2.get("ANGLE_instanced_arrays"))[n2.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](i3, o3), a3[i3] = o3;
    }
  }
  function f2() {
    const t3 = c2.newAttributes, i3 = c2.enabledAttributes;
    for (let n3 = 0, o3 = i3.length; n3 < o3; n3++)
      i3[n3] !== t3[n3] && (e3.disableVertexAttribArray(n3), i3[n3] = 0);
  }
  function v2(t3, i3, o3, r3, s3, a3) {
    true !== n2.isWebGL2 || 5124 !== o3 && 5125 !== o3 ? e3.vertexAttribPointer(t3, i3, o3, r3, s3, a3) : e3.vertexAttribIPointer(t3, i3, o3, s3, a3);
  }
  function A2() {
    b2(), h2 = true, c2 !== l2 && (c2 = l2, u2(c2.object));
  }
  function b2() {
    l2.geometry = null, l2.program = null, l2.wireframe = false;
  }
  return { setup: function(o3, l3, d3, A3, b3) {
    let y2 = false;
    if (s2) {
      const t3 = function(t4, i3, o4) {
        const s3 = true === o4.wireframe;
        let l4 = a2[t4.id];
        void 0 === l4 && (l4 = {}, a2[t4.id] = l4);
        let c3 = l4[i3.id];
        void 0 === c3 && (c3 = {}, l4[i3.id] = c3);
        let h3 = c3[s3];
        void 0 === h3 && (h3 = p2(n2.isWebGL2 ? e3.createVertexArray() : r2.createVertexArrayOES()), c3[s3] = h3);
        return h3;
      }(A3, d3, l3);
      c2 !== t3 && (c2 = t3, u2(c2.object)), y2 = function(e4, t4, i3, n3) {
        const o4 = c2.attributes, r3 = t4.attributes;
        let s3 = 0;
        const a3 = i3.getAttributes();
        for (const t5 in a3) {
          if (a3[t5].location >= 0) {
            const i4 = o4[t5];
            let n4 = r3[t5];
            if (void 0 === n4 && ("instanceMatrix" === t5 && e4.instanceMatrix && (n4 = e4.instanceMatrix), "instanceColor" === t5 && e4.instanceColor && (n4 = e4.instanceColor)), void 0 === i4)
              return true;
            if (i4.attribute !== n4)
              return true;
            if (n4 && i4.data !== n4.data)
              return true;
            s3++;
          }
        }
        return c2.attributesNum !== s3 || c2.index !== n3;
      }(o3, A3, d3, b3), y2 && function(e4, t4, i3, n3) {
        const o4 = {}, r3 = t4.attributes;
        let s3 = 0;
        const a3 = i3.getAttributes();
        for (const t5 in a3) {
          if (a3[t5].location >= 0) {
            let i4 = r3[t5];
            void 0 === i4 && ("instanceMatrix" === t5 && e4.instanceMatrix && (i4 = e4.instanceMatrix), "instanceColor" === t5 && e4.instanceColor && (i4 = e4.instanceColor));
            const n4 = {};
            n4.attribute = i4, i4 && i4.data && (n4.data = i4.data), o4[t5] = n4, s3++;
          }
        }
        c2.attributes = o4, c2.attributesNum = s3, c2.index = n3;
      }(o3, A3, d3, b3);
    } else {
      const e4 = true === l3.wireframe;
      c2.geometry === A3.id && c2.program === d3.id && c2.wireframe === e4 || (c2.geometry = A3.id, c2.program = d3.id, c2.wireframe = e4, y2 = true);
    }
    null !== b3 && i2.update(b3, 34963), (y2 || h2) && (h2 = false, function(o4, r3, s3, a3) {
      if (false === n2.isWebGL2 && (o4.isInstancedMesh || a3.isInstancedBufferGeometry) && null === t2.get("ANGLE_instanced_arrays"))
        return;
      _2();
      const l4 = a3.attributes, c3 = s3.getAttributes(), h3 = r3.defaultAttributeValues;
      for (const t3 in c3) {
        const n3 = c3[t3];
        if (n3.location >= 0) {
          let r4 = l4[t3];
          if (void 0 === r4 && ("instanceMatrix" === t3 && o4.instanceMatrix && (r4 = o4.instanceMatrix), "instanceColor" === t3 && o4.instanceColor && (r4 = o4.instanceColor)), void 0 !== r4) {
            const t4 = r4.normalized, s4 = r4.itemSize, l5 = i2.get(r4);
            if (void 0 === l5)
              continue;
            const c4 = l5.buffer, h4 = l5.type, u3 = l5.bytesPerElement;
            if (r4.isInterleavedBufferAttribute) {
              const i3 = r4.data, l6 = i3.stride, d4 = r4.offset;
              if (i3.isInstancedInterleavedBuffer) {
                for (let e4 = 0; e4 < n3.locationSize; e4++)
                  m2(n3.location + e4, i3.meshPerAttribute);
                true !== o4.isInstancedMesh && void 0 === a3._maxInstanceCount && (a3._maxInstanceCount = i3.meshPerAttribute * i3.count);
              } else
                for (let e4 = 0; e4 < n3.locationSize; e4++)
                  g2(n3.location + e4);
              e3.bindBuffer(34962, c4);
              for (let e4 = 0; e4 < n3.locationSize; e4++)
                v2(n3.location + e4, s4 / n3.locationSize, h4, t4, l6 * u3, (d4 + s4 / n3.locationSize * e4) * u3);
            } else {
              if (r4.isInstancedBufferAttribute) {
                for (let e4 = 0; e4 < n3.locationSize; e4++)
                  m2(n3.location + e4, r4.meshPerAttribute);
                true !== o4.isInstancedMesh && void 0 === a3._maxInstanceCount && (a3._maxInstanceCount = r4.meshPerAttribute * r4.count);
              } else
                for (let e4 = 0; e4 < n3.locationSize; e4++)
                  g2(n3.location + e4);
              e3.bindBuffer(34962, c4);
              for (let e4 = 0; e4 < n3.locationSize; e4++)
                v2(n3.location + e4, s4 / n3.locationSize, h4, t4, s4 * u3, s4 / n3.locationSize * e4 * u3);
            }
          } else if (void 0 !== h3) {
            const i3 = h3[t3];
            if (void 0 !== i3)
              switch (i3.length) {
                case 2:
                  e3.vertexAttrib2fv(n3.location, i3);
                  break;
                case 3:
                  e3.vertexAttrib3fv(n3.location, i3);
                  break;
                case 4:
                  e3.vertexAttrib4fv(n3.location, i3);
                  break;
                default:
                  e3.vertexAttrib1fv(n3.location, i3);
              }
          }
        }
      }
      f2();
    }(o3, l3, d3, A3), null !== b3 && e3.bindBuffer(34963, i2.get(b3).buffer));
  }, reset: A2, resetDefaultState: b2, dispose: function() {
    A2();
    for (const e4 in a2) {
      const t3 = a2[e4];
      for (const e5 in t3) {
        const i3 = t3[e5];
        for (const e6 in i3)
          d2(i3[e6].object), delete i3[e6];
        delete t3[e5];
      }
      delete a2[e4];
    }
  }, releaseStatesOfGeometry: function(e4) {
    if (void 0 === a2[e4.id])
      return;
    const t3 = a2[e4.id];
    for (const e5 in t3) {
      const i3 = t3[e5];
      for (const e6 in i3)
        d2(i3[e6].object), delete i3[e6];
      delete t3[e5];
    }
    delete a2[e4.id];
  }, releaseStatesOfProgram: function(e4) {
    for (const t3 in a2) {
      const i3 = a2[t3];
      if (void 0 === i3[e4.id])
        continue;
      const n3 = i3[e4.id];
      for (const e5 in n3)
        d2(n3[e5].object), delete n3[e5];
      delete i3[e4.id];
    }
  }, initAttributes: _2, enableAttribute: g2, disableUnusedAttributes: f2 };
}
function qo(e3, t2, i2, n2) {
  const o2 = n2.isWebGL2;
  let r2;
  this.setMode = function(e4) {
    r2 = e4;
  }, this.render = function(t3, n3) {
    e3.drawArrays(r2, t3, n3), i2.update(n3, r2, 1);
  }, this.renderInstances = function(n3, s2, a2) {
    if (0 === a2)
      return;
    let l2, c2;
    if (o2)
      l2 = e3, c2 = "drawArraysInstanced";
    else if (l2 = t2.get("ANGLE_instanced_arrays"), c2 = "drawArraysInstancedANGLE", null === l2)
      return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
    l2[c2](r2, n3, s2, a2), i2.update(s2, r2, a2);
  };
}
function jo(e3, t2, i2) {
  let n2;
  function o2(t3) {
    if ("highp" === t3) {
      if (e3.getShaderPrecisionFormat(35633, 36338).precision > 0 && e3.getShaderPrecisionFormat(35632, 36338).precision > 0)
        return "highp";
      t3 = "mediump";
    }
    return "mediump" === t3 && e3.getShaderPrecisionFormat(35633, 36337).precision > 0 && e3.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
  }
  const r2 = "undefined" != typeof WebGL2RenderingContext && "WebGL2RenderingContext" === e3.constructor.name;
  let s2 = void 0 !== i2.precision ? i2.precision : "highp";
  const a2 = o2(s2);
  a2 !== s2 && (console.warn("THREE.WebGLRenderer:", s2, "not supported, using", a2, "instead."), s2 = a2);
  const l2 = r2 || t2.has("WEBGL_draw_buffers"), c2 = true === i2.logarithmicDepthBuffer, h2 = e3.getParameter(34930), u2 = e3.getParameter(35660), d2 = e3.getParameter(3379), p2 = e3.getParameter(34076), _2 = e3.getParameter(34921), g2 = e3.getParameter(36347), m2 = e3.getParameter(36348), f2 = e3.getParameter(36349), v2 = u2 > 0, A2 = r2 || t2.has("OES_texture_float");
  return { isWebGL2: r2, drawBuffers: l2, getMaxAnisotropy: function() {
    if (void 0 !== n2)
      return n2;
    if (true === t2.has("EXT_texture_filter_anisotropic")) {
      const i3 = t2.get("EXT_texture_filter_anisotropic");
      n2 = e3.getParameter(i3.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      n2 = 0;
    return n2;
  }, getMaxPrecision: o2, precision: s2, logarithmicDepthBuffer: c2, maxTextures: h2, maxVertexTextures: u2, maxTextureSize: d2, maxCubemapSize: p2, maxAttributes: _2, maxVertexUniforms: g2, maxVaryings: m2, maxFragmentUniforms: f2, vertexTextures: v2, floatFragmentTextures: A2, floatVertexTextures: v2 && A2, maxSamples: r2 ? e3.getParameter(36183) : 0 };
}
function Xo(e3) {
  const t2 = this;
  let i2 = null, n2 = 0, o2 = false, r2 = false;
  const s2 = new Do(), a2 = new Gt(), l2 = { value: null, needsUpdate: false };
  function c2(e4, i3, n3, o3) {
    const r3 = null !== e4 ? e4.length : 0;
    let c3 = null;
    if (0 !== r3) {
      if (c3 = l2.value, true !== o3 || null === c3) {
        const t3 = n3 + 4 * r3, o4 = i3.matrixWorldInverse;
        a2.getNormalMatrix(o4), (null === c3 || c3.length < t3) && (c3 = new Float32Array(t3));
        for (let t4 = 0, i4 = n3; t4 !== r3; ++t4, i4 += 4)
          s2.copy(e4[t4]).applyMatrix4(o4, a2), s2.normal.toArray(c3, i4), c3[i4 + 3] = s2.constant;
      }
      l2.value = c3, l2.needsUpdate = true;
    }
    return t2.numPlanes = r3, t2.numIntersection = 0, c3;
  }
  this.uniform = l2, this.numPlanes = 0, this.numIntersection = 0, this.init = function(e4, t3) {
    const i3 = 0 !== e4.length || t3 || 0 !== n2 || o2;
    return o2 = t3, n2 = e4.length, i3;
  }, this.beginShadows = function() {
    r2 = true, c2(null);
  }, this.endShadows = function() {
    r2 = false;
  }, this.setGlobalState = function(e4, t3) {
    i2 = c2(e4, t3, 0);
  }, this.setState = function(s3, a3, h2) {
    const u2 = s3.clippingPlanes, d2 = s3.clipIntersection, p2 = s3.clipShadows, _2 = e3.get(s3);
    if (!o2 || null === u2 || 0 === u2.length || r2 && !p2)
      r2 ? c2(null) : function() {
        l2.value !== i2 && (l2.value = i2, l2.needsUpdate = n2 > 0);
        t2.numPlanes = n2, t2.numIntersection = 0;
      }();
    else {
      const e4 = r2 ? 0 : n2, t3 = 4 * e4;
      let o3 = _2.clippingState || null;
      l2.value = o3, o3 = c2(u2, a3, t3, h2);
      for (let e5 = 0; e5 !== t3; ++e5)
        o3[e5] = i2[e5];
      _2.clippingState = o3, this.numIntersection = d2 ? this.numPlanes : 0, this.numPlanes += e4;
    }
  };
}
function Yo(e3) {
  let t2 = /* @__PURE__ */ new WeakMap();
  function i2(e4, t3) {
    return t3 === Pe ? e4.mapping = ke : 304 === t3 && (e4.mapping = Re), e4;
  }
  function n2(e4) {
    const i3 = e4.target;
    i3.removeEventListener("dispose", n2);
    const o2 = t2.get(i3);
    void 0 !== o2 && (t2.delete(i3), o2.dispose());
  }
  return { get: function(o2) {
    if (o2 && o2.isTexture && false === o2.isRenderTargetTexture) {
      const r2 = o2.mapping;
      if (r2 === Pe || 304 === r2) {
        if (t2.has(o2)) {
          return i2(t2.get(o2).texture, o2.mapping);
        }
        {
          const r3 = o2.image;
          if (r3 && r3.height > 0) {
            const s2 = new Mo(r3.height / 2);
            return s2.fromEquirectangularTexture(e3, o2), t2.set(o2, s2), o2.addEventListener("dispose", n2), i2(s2.texture, o2.mapping);
          }
          return null;
        }
      }
    }
    return o2;
  }, dispose: function() {
    t2 = /* @__PURE__ */ new WeakMap();
  } };
}
class Ko extends So {
  constructor(e3 = -1, t2 = 1, i2 = 1, n2 = -1, o2 = 0.1, r2 = 2e3) {
    super(), this.isOrthographicCamera = true, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e3, this.right = t2, this.top = i2, this.bottom = n2, this.near = o2, this.far = r2, this.updateProjectionMatrix();
  }
  copy(e3, t2) {
    return super.copy(e3, t2), this.left = e3.left, this.right = e3.right, this.top = e3.top, this.bottom = e3.bottom, this.near = e3.near, this.far = e3.far, this.zoom = e3.zoom, this.view = null === e3.view ? null : Object.assign({}, e3.view), this;
  }
  setViewOffset(e3, t2, i2, n2, o2, r2) {
    null === this.view && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = e3, this.view.fullHeight = t2, this.view.offsetX = i2, this.view.offsetY = n2, this.view.width = o2, this.view.height = r2, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    null !== this.view && (this.view.enabled = false), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e3 = (this.right - this.left) / (2 * this.zoom), t2 = (this.top - this.bottom) / (2 * this.zoom), i2 = (this.right + this.left) / 2, n2 = (this.top + this.bottom) / 2;
    let o2 = i2 - e3, r2 = i2 + e3, s2 = n2 + t2, a2 = n2 - t2;
    if (null !== this.view && this.view.enabled) {
      const e4 = (this.right - this.left) / this.view.fullWidth / this.zoom, t3 = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      o2 += e4 * this.view.offsetX, r2 = o2 + e4 * this.view.width, s2 -= t3 * this.view.offsetY, a2 = s2 - t3 * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(o2, r2, s2, a2, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e3) {
    const t2 = super.toJSON(e3);
    return t2.object.zoom = this.zoom, t2.object.left = this.left, t2.object.right = this.right, t2.object.top = this.top, t2.object.bottom = this.bottom, t2.object.near = this.near, t2.object.far = this.far, null !== this.view && (t2.object.view = Object.assign({}, this.view)), t2;
  }
}
const Zo = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], Jo = 20, er = new Ko(), tr = new Pn();
let ir = null;
const nr = (1 + Math.sqrt(5)) / 2, or = 1 / nr, rr = [new di(1, 1, 1), new di(-1, 1, 1), new di(1, 1, -1), new di(-1, 1, -1), new di(0, nr, or), new di(0, nr, -or), new di(or, 0, nr), new di(-or, 0, nr), new di(nr, or, 0), new di(-nr, or, 0)];
class sr {
  constructor(e3) {
    this._renderer = e3, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  fromScene(e3, t2 = 0, i2 = 0.1, n2 = 100) {
    ir = this._renderer.getRenderTarget(), this._setSize(256);
    const o2 = this._allocateTargets();
    return o2.depthBuffer = true, this._sceneToCubeUV(e3, i2, n2, o2), t2 > 0 && this._blur(o2, 0, 0, t2), this._applyPMREM(o2), this._cleanup(o2), o2;
  }
  fromEquirectangular(e3, t2 = null) {
    return this._fromTexture(e3, t2);
  }
  fromCubemap(e3, t2 = null) {
    return this._fromTexture(e3, t2);
  }
  compileCubemapShader() {
    null === this._cubemapMaterial && (this._cubemapMaterial = hr(), this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    null === this._equirectMaterial && (this._equirectMaterial = cr(), this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose();
  }
  _setSize(e3) {
    this._lodMax = Math.floor(Math.log2(e3)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
    for (let e3 = 0; e3 < this._lodPlanes.length; e3++)
      this._lodPlanes[e3].dispose();
  }
  _cleanup(e3) {
    this._renderer.setRenderTarget(ir), e3.scissorTest = false, lr(e3, 0, 0, e3.width, e3.height);
  }
  _fromTexture(e3, t2) {
    e3.mapping === ke || e3.mapping === Re ? this._setSize(0 === e3.image.length ? 16 : e3.image[0].width || e3.image[0].image.width) : this._setSize(e3.image.width / 4), ir = this._renderer.getRenderTarget();
    const i2 = t2 || this._allocateTargets();
    return this._textureToCubeUV(e3, i2), this._applyPMREM(i2), this._cleanup(i2), i2;
  }
  _allocateTargets() {
    const e3 = 3 * Math.max(this._cubeSize, 112), t2 = 4 * this._cubeSize, i2 = { magFilter: He, minFilter: He, generateMipmaps: false, type: qe, format: Xe, encoding: At, depthBuffer: false }, n2 = ar(e3, t2, i2);
    if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== e3 || this._pingPongRenderTarget.height !== t2) {
      null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = ar(e3, t2, i2);
      const { _lodMax: n3 } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = function(e4) {
        const t3 = [], i3 = [], n4 = [];
        let o2 = e4;
        const r2 = e4 - 4 + 1 + Zo.length;
        for (let s2 = 0; s2 < r2; s2++) {
          const r3 = Math.pow(2, o2);
          i3.push(r3);
          let a2 = 1 / r3;
          s2 > e4 - 4 ? a2 = Zo[s2 - e4 + 4 - 1] : 0 === s2 && (a2 = 0), n4.push(a2);
          const l2 = 1 / (r3 - 2), c2 = -l2, h2 = 1 + l2, u2 = [c2, c2, h2, c2, h2, h2, c2, c2, h2, h2, c2, h2], d2 = 6, p2 = 6, _2 = 3, g2 = 2, m2 = 1, f2 = new Float32Array(_2 * p2 * d2), v2 = new Float32Array(g2 * p2 * d2), A2 = new Float32Array(m2 * p2 * d2);
          for (let e5 = 0; e5 < d2; e5++) {
            const t4 = e5 % 3 * 2 / 3 - 1, i4 = e5 > 2 ? 0 : -1, n5 = [t4, i4, 0, t4 + 2 / 3, i4, 0, t4 + 2 / 3, i4 + 1, 0, t4, i4, 0, t4 + 2 / 3, i4 + 1, 0, t4, i4 + 1, 0];
            f2.set(n5, _2 * p2 * e5), v2.set(u2, g2 * p2 * e5);
            const o3 = [e5, e5, e5, e5, e5, e5];
            A2.set(o3, m2 * p2 * e5);
          }
          const b2 = new Zn();
          b2.setAttribute("position", new Hn(f2, _2)), b2.setAttribute("uv", new Hn(v2, g2)), b2.setAttribute("faceIndex", new Hn(A2, m2)), t3.push(b2), o2 > 4 && o2--;
        }
        return { lodPlanes: t3, sizeLods: i3, sigmas: n4 };
      }(n3)), this._blurMaterial = function(e4, t3, i3) {
        const n4 = new Float32Array(Jo), o2 = new di(0, 1, 0), r2 = new Co({ name: "SphericalGaussianBlur", defines: { n: Jo, CUBEUV_TEXEL_WIDTH: 1 / t3, CUBEUV_TEXEL_HEIGHT: 1 / i3, CUBEUV_MAX_MIP: `${e4}.0` }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: n4 }, latitudinal: { value: false }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: o2 } }, vertexShader: ur(), fragmentShader: "\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform sampler2D envMap;\n			uniform int samples;\n			uniform float weights[ n ];\n			uniform bool latitudinal;\n			uniform float dTheta;\n			uniform float mipInt;\n			uniform vec3 poleAxis;\n\n			#define ENVMAP_TYPE_CUBE_UV\n			#include <cube_uv_reflection_fragment>\n\n			vec3 getSample( float theta, vec3 axis ) {\n\n				float cosTheta = cos( theta );\n				// Rodrigues' axis-angle rotation\n				vec3 sampleDirection = vOutputDirection * cosTheta\n					+ cross( axis, vOutputDirection ) * sin( theta )\n					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n				return bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n			}\n\n			void main() {\n\n				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n				}\n\n				axis = normalize( axis );\n\n				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n				for ( int i = 1; i < n; i++ ) {\n\n					if ( i >= samples ) {\n\n						break;\n\n					}\n\n					float theta = dTheta * float( i );\n					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n				}\n\n			}\n		", blending: 0, depthTest: false, depthWrite: false });
        return r2;
      }(n3, e3, t2);
    }
    return n2;
  }
  _compileMaterial(e3) {
    const t2 = new fo(this._lodPlanes[0], e3);
    this._renderer.compile(t2, er);
  }
  _sceneToCubeUV(e3, t2, i2, n2) {
    const o2 = new Eo(90, 1, t2, i2), r2 = [1, -1, 1, 1, 1, 1], s2 = [1, 1, 1, -1, -1, -1], a2 = this._renderer, l2 = a2.autoClear, c2 = a2.toneMapping;
    a2.getClearColor(tr), a2.toneMapping = Se, a2.autoClear = false;
    const h2 = new Ln({ name: "PMREM.Background", side: Ae, depthWrite: false, depthTest: false }), u2 = new fo(new Ao(), h2);
    let d2 = false;
    const p2 = e3.background;
    p2 ? p2.isColor && (h2.color.copy(p2), e3.background = null, d2 = true) : (h2.color.copy(tr), d2 = true);
    for (let t3 = 0; t3 < 6; t3++) {
      const i3 = t3 % 3;
      0 === i3 ? (o2.up.set(0, r2[t3], 0), o2.lookAt(s2[t3], 0, 0)) : 1 === i3 ? (o2.up.set(0, 0, r2[t3]), o2.lookAt(0, s2[t3], 0)) : (o2.up.set(0, r2[t3], 0), o2.lookAt(0, 0, s2[t3]));
      const l3 = this._cubeSize;
      lr(n2, i3 * l3, t3 > 2 ? l3 : 0, l3, l3), a2.setRenderTarget(n2), d2 && a2.render(u2, o2), a2.render(e3, o2);
    }
    u2.geometry.dispose(), u2.material.dispose(), a2.toneMapping = c2, a2.autoClear = l2, e3.background = p2;
  }
  _textureToCubeUV(e3, t2) {
    const i2 = this._renderer, n2 = e3.mapping === ke || e3.mapping === Re;
    n2 ? (null === this._cubemapMaterial && (this._cubemapMaterial = hr()), this._cubemapMaterial.uniforms.flipEnvMap.value = false === e3.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = cr());
    const o2 = n2 ? this._cubemapMaterial : this._equirectMaterial, r2 = new fo(this._lodPlanes[0], o2);
    o2.uniforms.envMap.value = e3;
    const s2 = this._cubeSize;
    lr(t2, 0, 0, 3 * s2, 2 * s2), i2.setRenderTarget(t2), i2.render(r2, er);
  }
  _applyPMREM(e3) {
    const t2 = this._renderer, i2 = t2.autoClear;
    t2.autoClear = false;
    for (let t3 = 1; t3 < this._lodPlanes.length; t3++) {
      const i3 = Math.sqrt(this._sigmas[t3] * this._sigmas[t3] - this._sigmas[t3 - 1] * this._sigmas[t3 - 1]), n2 = rr[(t3 - 1) % rr.length];
      this._blur(e3, t3 - 1, t3, i3, n2);
    }
    t2.autoClear = i2;
  }
  _blur(e3, t2, i2, n2, o2) {
    const r2 = this._pingPongRenderTarget;
    this._halfBlur(e3, r2, t2, i2, n2, "latitudinal", o2), this._halfBlur(r2, e3, i2, i2, n2, "longitudinal", o2);
  }
  _halfBlur(e3, t2, i2, n2, o2, r2, s2) {
    const a2 = this._renderer, l2 = this._blurMaterial;
    "latitudinal" !== r2 && "longitudinal" !== r2 && console.error("blur direction must be either latitudinal or longitudinal!");
    const c2 = new fo(this._lodPlanes[n2], l2), h2 = l2.uniforms, u2 = this._sizeLods[i2] - 1, d2 = isFinite(o2) ? Math.PI / (2 * u2) : 2 * Math.PI / 39, p2 = o2 / d2, _2 = isFinite(o2) ? 1 + Math.floor(3 * p2) : Jo;
    _2 > Jo && console.warn(`sigmaRadians, ${o2}, is too large and will clip, as it requested ${_2} samples when the maximum is set to 20`);
    const g2 = [];
    let m2 = 0;
    for (let e4 = 0; e4 < Jo; ++e4) {
      const t3 = e4 / p2, i3 = Math.exp(-t3 * t3 / 2);
      g2.push(i3), 0 === e4 ? m2 += i3 : e4 < _2 && (m2 += 2 * i3);
    }
    for (let e4 = 0; e4 < g2.length; e4++)
      g2[e4] = g2[e4] / m2;
    h2.envMap.value = e3.texture, h2.samples.value = _2, h2.weights.value = g2, h2.latitudinal.value = "latitudinal" === r2, s2 && (h2.poleAxis.value = s2);
    const { _lodMax: f2 } = this;
    h2.dTheta.value = d2, h2.mipInt.value = f2 - i2;
    const v2 = this._sizeLods[n2];
    lr(t2, 3 * v2 * (n2 > f2 - 4 ? n2 - f2 + 4 : 0), 4 * (this._cubeSize - v2), 3 * v2, 2 * v2), a2.setRenderTarget(t2), a2.render(c2, er);
  }
}
function ar(e3, t2, i2) {
  const n2 = new li(e3, t2, i2);
  return n2.texture.mapping = De, n2.texture.name = "PMREM.cubeUv", n2.scissorTest = true, n2;
}
function lr(e3, t2, i2, n2, o2) {
  e3.viewport.set(t2, i2, n2, o2), e3.scissor.set(t2, i2, n2, o2);
}
function cr() {
  return new Co({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null } }, vertexShader: ur(), fragmentShader: "\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform sampler2D envMap;\n\n			#include <common>\n\n			void main() {\n\n				vec3 outputDirection = normalize( vOutputDirection );\n				vec2 uv = equirectUv( outputDirection );\n\n				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n			}\n		", blending: 0, depthTest: false, depthWrite: false });
}
function hr() {
  return new Co({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } }, vertexShader: ur(), fragmentShader: "\n\n			precision mediump float;\n			precision mediump int;\n\n			uniform float flipEnvMap;\n\n			varying vec3 vOutputDirection;\n\n			uniform samplerCube envMap;\n\n			void main() {\n\n				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n			}\n		", blending: 0, depthTest: false, depthWrite: false });
}
function ur() {
  return "\n\n		precision mediump float;\n		precision mediump int;\n\n		attribute float faceIndex;\n\n		varying vec3 vOutputDirection;\n\n		// RH coordinate system; PMREM face-indexing convention\n		vec3 getDirection( vec2 uv, float face ) {\n\n			uv = 2.0 * uv - 1.0;\n\n			vec3 direction = vec3( uv, 1.0 );\n\n			if ( face == 0.0 ) {\n\n				direction = direction.zyx; // ( 1, v, u ) pos x\n\n			} else if ( face == 1.0 ) {\n\n				direction = direction.xzy;\n				direction.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n			} else if ( face == 2.0 ) {\n\n				direction.x *= -1.0; // ( -u, v, 1 ) pos z\n\n			} else if ( face == 3.0 ) {\n\n				direction = direction.zyx;\n				direction.xz *= -1.0; // ( -1, v, -u ) neg x\n\n			} else if ( face == 4.0 ) {\n\n				direction = direction.xzy;\n				direction.xy *= -1.0; // ( -u, -1, v ) neg y\n\n			} else if ( face == 5.0 ) {\n\n				direction.z *= -1.0; // ( u, v, -1 ) neg z\n\n			}\n\n			return direction;\n\n		}\n\n		void main() {\n\n			vOutputDirection = getDirection( uv, faceIndex );\n			gl_Position = vec4( position, 1.0 );\n\n		}\n	";
}
function dr(e3) {
  let t2 = /* @__PURE__ */ new WeakMap(), i2 = null;
  function n2(e4) {
    const i3 = e4.target;
    i3.removeEventListener("dispose", n2);
    const o2 = t2.get(i3);
    void 0 !== o2 && (t2.delete(i3), o2.dispose());
  }
  return { get: function(o2) {
    if (o2 && o2.isTexture) {
      const r2 = o2.mapping, s2 = r2 === Pe || 304 === r2, a2 = r2 === ke || r2 === Re;
      if (s2 || a2) {
        if (o2.isRenderTargetTexture && true === o2.needsPMREMUpdate) {
          o2.needsPMREMUpdate = false;
          let n3 = t2.get(o2);
          return null === i2 && (i2 = new sr(e3)), n3 = s2 ? i2.fromEquirectangular(o2, n3) : i2.fromCubemap(o2, n3), t2.set(o2, n3), n3.texture;
        }
        if (t2.has(o2))
          return t2.get(o2).texture;
        {
          const r3 = o2.image;
          if (s2 && r3 && r3.height > 0 || a2 && r3 && function(e4) {
            let t3 = 0;
            const i3 = 6;
            for (let n3 = 0; n3 < i3; n3++)
              void 0 !== e4[n3] && t3++;
            return t3 === i3;
          }(r3)) {
            null === i2 && (i2 = new sr(e3));
            const r4 = s2 ? i2.fromEquirectangular(o2) : i2.fromCubemap(o2);
            return t2.set(o2, r4), o2.addEventListener("dispose", n2), r4.texture;
          }
          return null;
        }
      }
    }
    return o2;
  }, dispose: function() {
    t2 = /* @__PURE__ */ new WeakMap(), null !== i2 && (i2.dispose(), i2 = null);
  } };
}
function pr(e3) {
  const t2 = {};
  function i2(i3) {
    if (void 0 !== t2[i3])
      return t2[i3];
    let n2;
    switch (i3) {
      case "WEBGL_depth_texture":
        n2 = e3.getExtension("WEBGL_depth_texture") || e3.getExtension("MOZ_WEBGL_depth_texture") || e3.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        n2 = e3.getExtension("EXT_texture_filter_anisotropic") || e3.getExtension("MOZ_EXT_texture_filter_anisotropic") || e3.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        n2 = e3.getExtension("WEBGL_compressed_texture_s3tc") || e3.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e3.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        n2 = e3.getExtension("WEBGL_compressed_texture_pvrtc") || e3.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        n2 = e3.getExtension(i3);
    }
    return t2[i3] = n2, n2;
  }
  return { has: function(e4) {
    return null !== i2(e4);
  }, init: function(e4) {
    e4.isWebGL2 ? i2("EXT_color_buffer_float") : (i2("WEBGL_depth_texture"), i2("OES_texture_float"), i2("OES_texture_half_float"), i2("OES_texture_half_float_linear"), i2("OES_standard_derivatives"), i2("OES_element_index_uint"), i2("OES_vertex_array_object"), i2("ANGLE_instanced_arrays")), i2("OES_texture_float_linear"), i2("EXT_color_buffer_half_float"), i2("WEBGL_multisampled_render_to_texture");
  }, get: function(e4) {
    const t3 = i2(e4);
    return null === t3 && console.warn("THREE.WebGLRenderer: " + e4 + " extension not supported."), t3;
  } };
}
function _r(e3, t2, i2, n2) {
  const o2 = {}, r2 = /* @__PURE__ */ new WeakMap();
  function s2(e4) {
    const a3 = e4.target;
    null !== a3.index && t2.remove(a3.index);
    for (const e5 in a3.attributes)
      t2.remove(a3.attributes[e5]);
    a3.removeEventListener("dispose", s2), delete o2[a3.id];
    const l2 = r2.get(a3);
    l2 && (t2.remove(l2), r2.delete(a3)), n2.releaseStatesOfGeometry(a3), true === a3.isInstancedBufferGeometry && delete a3._maxInstanceCount, i2.memory.geometries--;
  }
  function a2(e4) {
    const i3 = [], n3 = e4.index, o3 = e4.attributes.position;
    let s3 = 0;
    if (null !== n3) {
      const e5 = n3.array;
      s3 = n3.version;
      for (let t3 = 0, n4 = e5.length; t3 < n4; t3 += 3) {
        const n5 = e5[t3 + 0], o4 = e5[t3 + 1], r3 = e5[t3 + 2];
        i3.push(n5, o4, o4, r3, r3, n5);
      }
    } else {
      const e5 = o3.array;
      s3 = o3.version;
      for (let t3 = 0, n4 = e5.length / 3 - 1; t3 < n4; t3 += 3) {
        const e6 = t3 + 0, n5 = t3 + 1, o4 = t3 + 2;
        i3.push(e6, n5, n5, o4, o4, e6);
      }
    }
    const a3 = new (Wt(i3) ? Vn : Qn)(i3, 1);
    a3.version = s3;
    const l2 = r2.get(e4);
    l2 && t2.remove(l2), r2.set(e4, a3);
  }
  return { get: function(e4, t3) {
    return true === o2[t3.id] || (t3.addEventListener("dispose", s2), o2[t3.id] = true, i2.memory.geometries++), t3;
  }, update: function(e4) {
    const i3 = e4.attributes;
    for (const e5 in i3)
      t2.update(i3[e5], 34962);
    const n3 = e4.morphAttributes;
    for (const e5 in n3) {
      const i4 = n3[e5];
      for (let e6 = 0, n4 = i4.length; e6 < n4; e6++)
        t2.update(i4[e6], 34962);
    }
  }, getWireframeAttribute: function(e4) {
    const t3 = r2.get(e4);
    if (t3) {
      const i3 = e4.index;
      null !== i3 && t3.version < i3.version && a2(e4);
    } else
      a2(e4);
    return r2.get(e4);
  } };
}
function gr(e3, t2, i2, n2) {
  const o2 = n2.isWebGL2;
  let r2, s2, a2;
  this.setMode = function(e4) {
    r2 = e4;
  }, this.setIndex = function(e4) {
    s2 = e4.type, a2 = e4.bytesPerElement;
  }, this.render = function(t3, n3) {
    e3.drawElements(r2, n3, s2, t3 * a2), i2.update(n3, r2, 1);
  }, this.renderInstances = function(n3, l2, c2) {
    if (0 === c2)
      return;
    let h2, u2;
    if (o2)
      h2 = e3, u2 = "drawElementsInstanced";
    else if (h2 = t2.get("ANGLE_instanced_arrays"), u2 = "drawElementsInstancedANGLE", null === h2)
      return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
    h2[u2](r2, l2, s2, n3 * a2, c2), i2.update(l2, r2, c2);
  };
}
function mr(e3) {
  const t2 = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  return { memory: { geometries: 0, textures: 0 }, render: t2, programs: null, autoReset: true, reset: function() {
    t2.frame++, t2.calls = 0, t2.triangles = 0, t2.points = 0, t2.lines = 0;
  }, update: function(e4, i2, n2) {
    switch (t2.calls++, i2) {
      case 4:
        t2.triangles += n2 * (e4 / 3);
        break;
      case 1:
        t2.lines += n2 * (e4 / 2);
        break;
      case 3:
        t2.lines += n2 * (e4 - 1);
        break;
      case 2:
        t2.lines += n2 * e4;
        break;
      case 0:
        t2.points += n2 * e4;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", i2);
    }
  } };
}
function fr(e3, t2) {
  return e3[0] - t2[0];
}
function vr(e3, t2) {
  return Math.abs(t2[1]) - Math.abs(e3[1]);
}
function Ar(e3, t2, i2) {
  const n2 = {}, o2 = new Float32Array(8), r2 = /* @__PURE__ */ new WeakMap(), s2 = new ai(), a2 = [];
  for (let e4 = 0; e4 < 8; e4++)
    a2[e4] = [e4, 0];
  return { update: function(l2, c2, h2) {
    const u2 = l2.morphTargetInfluences;
    if (true === t2.isWebGL2) {
      const n3 = c2.morphAttributes.position || c2.morphAttributes.normal || c2.morphAttributes.color, o3 = void 0 !== n3 ? n3.length : 0;
      let a3 = r2.get(c2);
      if (void 0 === a3 || a3.count !== o3) {
        void 0 !== a3 && a3.texture.dispose();
        const e4 = void 0 !== c2.morphAttributes.position, i3 = void 0 !== c2.morphAttributes.normal, n4 = void 0 !== c2.morphAttributes.color, l4 = c2.morphAttributes.position || [], h3 = c2.morphAttributes.normal || [], u3 = c2.morphAttributes.color || [];
        let d3 = 0;
        true === e4 && (d3 = 1), true === i3 && (d3 = 2), true === n4 && (d3 = 3);
        let p2 = c2.attributes.position.count * d3, _2 = 1;
        p2 > t2.maxTextureSize && (_2 = Math.ceil(p2 / t2.maxTextureSize), p2 = t2.maxTextureSize);
        const g2 = new Float32Array(p2 * _2 * 4 * o3), m2 = new ci(g2, p2, _2, o3);
        m2.type = We, m2.needsUpdate = true;
        const f2 = 4 * d3;
        for (let t3 = 0; t3 < o3; t3++) {
          const o4 = l4[t3], r3 = h3[t3], a4 = u3[t3], c3 = p2 * _2 * 4 * t3;
          for (let t4 = 0; t4 < o4.count; t4++) {
            const l5 = t4 * f2;
            true === e4 && (s2.fromBufferAttribute(o4, t4), g2[c3 + l5 + 0] = s2.x, g2[c3 + l5 + 1] = s2.y, g2[c3 + l5 + 2] = s2.z, g2[c3 + l5 + 3] = 0), true === i3 && (s2.fromBufferAttribute(r3, t4), g2[c3 + l5 + 4] = s2.x, g2[c3 + l5 + 5] = s2.y, g2[c3 + l5 + 6] = s2.z, g2[c3 + l5 + 7] = 0), true === n4 && (s2.fromBufferAttribute(a4, t4), g2[c3 + l5 + 8] = s2.x, g2[c3 + l5 + 9] = s2.y, g2[c3 + l5 + 10] = s2.z, g2[c3 + l5 + 11] = 4 === a4.itemSize ? s2.w : 1);
          }
        }
        a3 = { count: o3, texture: m2, size: new Vt(p2, _2) }, r2.set(c2, a3), c2.addEventListener("dispose", function e5() {
          m2.dispose(), r2.delete(c2), c2.removeEventListener("dispose", e5);
        });
      }
      let l3 = 0;
      for (let e4 = 0; e4 < u2.length; e4++)
        l3 += u2[e4];
      const d2 = c2.morphTargetsRelative ? 1 : 1 - l3;
      h2.getUniforms().setValue(e3, "morphTargetBaseInfluence", d2), h2.getUniforms().setValue(e3, "morphTargetInfluences", u2), h2.getUniforms().setValue(e3, "morphTargetsTexture", a3.texture, i2), h2.getUniforms().setValue(e3, "morphTargetsTextureSize", a3.size);
    } else {
      const t3 = void 0 === u2 ? 0 : u2.length;
      let i3 = n2[c2.id];
      if (void 0 === i3 || i3.length !== t3) {
        i3 = [];
        for (let e4 = 0; e4 < t3; e4++)
          i3[e4] = [e4, 0];
        n2[c2.id] = i3;
      }
      for (let e4 = 0; e4 < t3; e4++) {
        const t4 = i3[e4];
        t4[0] = e4, t4[1] = u2[e4];
      }
      i3.sort(vr);
      for (let e4 = 0; e4 < 8; e4++)
        e4 < t3 && i3[e4][1] ? (a2[e4][0] = i3[e4][0], a2[e4][1] = i3[e4][1]) : (a2[e4][0] = Number.MAX_SAFE_INTEGER, a2[e4][1] = 0);
      a2.sort(fr);
      const r3 = c2.morphAttributes.position, s3 = c2.morphAttributes.normal;
      let l3 = 0;
      for (let e4 = 0; e4 < 8; e4++) {
        const t4 = a2[e4], i4 = t4[0], n3 = t4[1];
        i4 !== Number.MAX_SAFE_INTEGER && n3 ? (r3 && c2.getAttribute("morphTarget" + e4) !== r3[i4] && c2.setAttribute("morphTarget" + e4, r3[i4]), s3 && c2.getAttribute("morphNormal" + e4) !== s3[i4] && c2.setAttribute("morphNormal" + e4, s3[i4]), o2[e4] = n3, l3 += n3) : (r3 && true === c2.hasAttribute("morphTarget" + e4) && c2.deleteAttribute("morphTarget" + e4), s3 && true === c2.hasAttribute("morphNormal" + e4) && c2.deleteAttribute("morphNormal" + e4), o2[e4] = 0);
      }
      const d2 = c2.morphTargetsRelative ? 1 : 1 - l3;
      h2.getUniforms().setValue(e3, "morphTargetBaseInfluence", d2), h2.getUniforms().setValue(e3, "morphTargetInfluences", o2);
    }
  } };
}
function br(e3, t2, i2, n2) {
  let o2 = /* @__PURE__ */ new WeakMap();
  function r2(e4) {
    const t3 = e4.target;
    t3.removeEventListener("dispose", r2), i2.remove(t3.instanceMatrix), null !== t3.instanceColor && i2.remove(t3.instanceColor);
  }
  return { update: function(e4) {
    const s2 = n2.render.frame, a2 = e4.geometry, l2 = t2.get(e4, a2);
    return o2.get(l2) !== s2 && (t2.update(l2), o2.set(l2, s2)), e4.isInstancedMesh && (false === e4.hasEventListener("dispose", r2) && e4.addEventListener("dispose", r2), i2.update(e4.instanceMatrix, 34962), null !== e4.instanceColor && i2.update(e4.instanceColor, 34962)), l2;
  }, dispose: function() {
    o2 = /* @__PURE__ */ new WeakMap();
  } };
}
const yr = new si(), wr = new ci(), xr = new hi(), Cr = new Bo(), Sr = [], Er = [], Ir = new Float32Array(16), Tr = new Float32Array(9), Br = new Float32Array(4);
function Mr(e3, t2, i2) {
  const n2 = e3[0];
  if (n2 <= 0 || n2 > 0)
    return e3;
  const o2 = t2 * i2;
  let r2 = Sr[o2];
  if (void 0 === r2 && (r2 = new Float32Array(o2), Sr[o2] = r2), 0 !== t2) {
    n2.toArray(r2, 0);
    for (let n3 = 1, o3 = 0; n3 !== t2; ++n3)
      o3 += i2, e3[n3].toArray(r2, o3);
  }
  return r2;
}
function kr(e3, t2) {
  if (e3.length !== t2.length)
    return false;
  for (let i2 = 0, n2 = e3.length; i2 < n2; i2++)
    if (e3[i2] !== t2[i2])
      return false;
  return true;
}
function Rr(e3, t2) {
  for (let i2 = 0, n2 = t2.length; i2 < n2; i2++)
    e3[i2] = t2[i2];
}
function Pr(e3, t2) {
  let i2 = Er[t2];
  void 0 === i2 && (i2 = new Int32Array(t2), Er[t2] = i2);
  for (let n2 = 0; n2 !== t2; ++n2)
    i2[n2] = e3.allocateTextureUnit();
  return i2;
}
function Dr(e3, t2) {
  const i2 = this.cache;
  i2[0] !== t2 && (e3.uniform1f(this.addr, t2), i2[0] = t2);
}
function Lr(e3, t2) {
  const i2 = this.cache;
  if (void 0 !== t2.x)
    i2[0] === t2.x && i2[1] === t2.y || (e3.uniform2f(this.addr, t2.x, t2.y), i2[0] = t2.x, i2[1] = t2.y);
  else {
    if (kr(i2, t2))
      return;
    e3.uniform2fv(this.addr, t2), Rr(i2, t2);
  }
}
function Fr(e3, t2) {
  const i2 = this.cache;
  if (void 0 !== t2.x)
    i2[0] === t2.x && i2[1] === t2.y && i2[2] === t2.z || (e3.uniform3f(this.addr, t2.x, t2.y, t2.z), i2[0] = t2.x, i2[1] = t2.y, i2[2] = t2.z);
  else if (void 0 !== t2.r)
    i2[0] === t2.r && i2[1] === t2.g && i2[2] === t2.b || (e3.uniform3f(this.addr, t2.r, t2.g, t2.b), i2[0] = t2.r, i2[1] = t2.g, i2[2] = t2.b);
  else {
    if (kr(i2, t2))
      return;
    e3.uniform3fv(this.addr, t2), Rr(i2, t2);
  }
}
function Nr(e3, t2) {
  const i2 = this.cache;
  if (void 0 !== t2.x)
    i2[0] === t2.x && i2[1] === t2.y && i2[2] === t2.z && i2[3] === t2.w || (e3.uniform4f(this.addr, t2.x, t2.y, t2.z, t2.w), i2[0] = t2.x, i2[1] = t2.y, i2[2] = t2.z, i2[3] = t2.w);
  else {
    if (kr(i2, t2))
      return;
    e3.uniform4fv(this.addr, t2), Rr(i2, t2);
  }
}
function Or(e3, t2) {
  const i2 = this.cache, n2 = t2.elements;
  if (void 0 === n2) {
    if (kr(i2, t2))
      return;
    e3.uniformMatrix2fv(this.addr, false, t2), Rr(i2, t2);
  } else {
    if (kr(i2, n2))
      return;
    Br.set(n2), e3.uniformMatrix2fv(this.addr, false, Br), Rr(i2, n2);
  }
}
function zr(e3, t2) {
  const i2 = this.cache, n2 = t2.elements;
  if (void 0 === n2) {
    if (kr(i2, t2))
      return;
    e3.uniformMatrix3fv(this.addr, false, t2), Rr(i2, t2);
  } else {
    if (kr(i2, n2))
      return;
    Tr.set(n2), e3.uniformMatrix3fv(this.addr, false, Tr), Rr(i2, n2);
  }
}
function Ur(e3, t2) {
  const i2 = this.cache, n2 = t2.elements;
  if (void 0 === n2) {
    if (kr(i2, t2))
      return;
    e3.uniformMatrix4fv(this.addr, false, t2), Rr(i2, t2);
  } else {
    if (kr(i2, n2))
      return;
    Ir.set(n2), e3.uniformMatrix4fv(this.addr, false, Ir), Rr(i2, n2);
  }
}
function Hr(e3, t2) {
  const i2 = this.cache;
  i2[0] !== t2 && (e3.uniform1i(this.addr, t2), i2[0] = t2);
}
function Qr(e3, t2) {
  const i2 = this.cache;
  if (void 0 !== t2.x)
    i2[0] === t2.x && i2[1] === t2.y || (e3.uniform2i(this.addr, t2.x, t2.y), i2[0] = t2.x, i2[1] = t2.y);
  else {
    if (kr(i2, t2))
      return;
    e3.uniform2iv(this.addr, t2), Rr(i2, t2);
  }
}
function Vr(e3, t2) {
  const i2 = this.cache;
  if (void 0 !== t2.x)
    i2[0] === t2.x && i2[1] === t2.y && i2[2] === t2.z || (e3.uniform3i(this.addr, t2.x, t2.y, t2.z), i2[0] = t2.x, i2[1] = t2.y, i2[2] = t2.z);
  else {
    if (kr(i2, t2))
      return;
    e3.uniform3iv(this.addr, t2), Rr(i2, t2);
  }
}
function Gr(e3, t2) {
  const i2 = this.cache;
  if (void 0 !== t2.x)
    i2[0] === t2.x && i2[1] === t2.y && i2[2] === t2.z && i2[3] === t2.w || (e3.uniform4i(this.addr, t2.x, t2.y, t2.z, t2.w), i2[0] = t2.x, i2[1] = t2.y, i2[2] = t2.z, i2[3] = t2.w);
  else {
    if (kr(i2, t2))
      return;
    e3.uniform4iv(this.addr, t2), Rr(i2, t2);
  }
}
function $r(e3, t2) {
  const i2 = this.cache;
  i2[0] !== t2 && (e3.uniform1ui(this.addr, t2), i2[0] = t2);
}
function Wr(e3, t2) {
  const i2 = this.cache;
  if (void 0 !== t2.x)
    i2[0] === t2.x && i2[1] === t2.y || (e3.uniform2ui(this.addr, t2.x, t2.y), i2[0] = t2.x, i2[1] = t2.y);
  else {
    if (kr(i2, t2))
      return;
    e3.uniform2uiv(this.addr, t2), Rr(i2, t2);
  }
}
function qr(e3, t2) {
  const i2 = this.cache;
  if (void 0 !== t2.x)
    i2[0] === t2.x && i2[1] === t2.y && i2[2] === t2.z || (e3.uniform3ui(this.addr, t2.x, t2.y, t2.z), i2[0] = t2.x, i2[1] = t2.y, i2[2] = t2.z);
  else {
    if (kr(i2, t2))
      return;
    e3.uniform3uiv(this.addr, t2), Rr(i2, t2);
  }
}
function jr(e3, t2) {
  const i2 = this.cache;
  if (void 0 !== t2.x)
    i2[0] === t2.x && i2[1] === t2.y && i2[2] === t2.z && i2[3] === t2.w || (e3.uniform4ui(this.addr, t2.x, t2.y, t2.z, t2.w), i2[0] = t2.x, i2[1] = t2.y, i2[2] = t2.z, i2[3] = t2.w);
  else {
    if (kr(i2, t2))
      return;
    e3.uniform4uiv(this.addr, t2), Rr(i2, t2);
  }
}
function Xr(e3, t2, i2) {
  const n2 = this.cache, o2 = i2.allocateTextureUnit();
  n2[0] !== o2 && (e3.uniform1i(this.addr, o2), n2[0] = o2), i2.setTexture2D(t2 || yr, o2);
}
function Yr(e3, t2, i2) {
  const n2 = this.cache, o2 = i2.allocateTextureUnit();
  n2[0] !== o2 && (e3.uniform1i(this.addr, o2), n2[0] = o2), i2.setTexture3D(t2 || xr, o2);
}
function Kr(e3, t2, i2) {
  const n2 = this.cache, o2 = i2.allocateTextureUnit();
  n2[0] !== o2 && (e3.uniform1i(this.addr, o2), n2[0] = o2), i2.setTextureCube(t2 || Cr, o2);
}
function Zr(e3, t2, i2) {
  const n2 = this.cache, o2 = i2.allocateTextureUnit();
  n2[0] !== o2 && (e3.uniform1i(this.addr, o2), n2[0] = o2), i2.setTexture2DArray(t2 || wr, o2);
}
function Jr(e3, t2) {
  e3.uniform1fv(this.addr, t2);
}
function es(e3, t2) {
  const i2 = Mr(t2, this.size, 2);
  e3.uniform2fv(this.addr, i2);
}
function ts(e3, t2) {
  const i2 = Mr(t2, this.size, 3);
  e3.uniform3fv(this.addr, i2);
}
function is(e3, t2) {
  const i2 = Mr(t2, this.size, 4);
  e3.uniform4fv(this.addr, i2);
}
function ns(e3, t2) {
  const i2 = Mr(t2, this.size, 4);
  e3.uniformMatrix2fv(this.addr, false, i2);
}
function os(e3, t2) {
  const i2 = Mr(t2, this.size, 9);
  e3.uniformMatrix3fv(this.addr, false, i2);
}
function rs(e3, t2) {
  const i2 = Mr(t2, this.size, 16);
  e3.uniformMatrix4fv(this.addr, false, i2);
}
function ss(e3, t2) {
  e3.uniform1iv(this.addr, t2);
}
function as(e3, t2) {
  e3.uniform2iv(this.addr, t2);
}
function ls(e3, t2) {
  e3.uniform3iv(this.addr, t2);
}
function cs(e3, t2) {
  e3.uniform4iv(this.addr, t2);
}
function hs(e3, t2) {
  e3.uniform1uiv(this.addr, t2);
}
function us(e3, t2) {
  e3.uniform2uiv(this.addr, t2);
}
function ds(e3, t2) {
  e3.uniform3uiv(this.addr, t2);
}
function ps(e3, t2) {
  e3.uniform4uiv(this.addr, t2);
}
function _s(e3, t2, i2) {
  const n2 = this.cache, o2 = t2.length, r2 = Pr(i2, o2);
  kr(n2, r2) || (e3.uniform1iv(this.addr, r2), Rr(n2, r2));
  for (let e4 = 0; e4 !== o2; ++e4)
    i2.setTexture2D(t2[e4] || yr, r2[e4]);
}
function gs(e3, t2, i2) {
  const n2 = this.cache, o2 = t2.length, r2 = Pr(i2, o2);
  kr(n2, r2) || (e3.uniform1iv(this.addr, r2), Rr(n2, r2));
  for (let e4 = 0; e4 !== o2; ++e4)
    i2.setTexture3D(t2[e4] || xr, r2[e4]);
}
function ms(e3, t2, i2) {
  const n2 = this.cache, o2 = t2.length, r2 = Pr(i2, o2);
  kr(n2, r2) || (e3.uniform1iv(this.addr, r2), Rr(n2, r2));
  for (let e4 = 0; e4 !== o2; ++e4)
    i2.setTextureCube(t2[e4] || Cr, r2[e4]);
}
function fs(e3, t2, i2) {
  const n2 = this.cache, o2 = t2.length, r2 = Pr(i2, o2);
  kr(n2, r2) || (e3.uniform1iv(this.addr, r2), Rr(n2, r2));
  for (let e4 = 0; e4 !== o2; ++e4)
    i2.setTexture2DArray(t2[e4] || wr, r2[e4]);
}
class vs {
  constructor(e3, t2, i2) {
    this.id = e3, this.addr = i2, this.cache = [], this.setValue = function(e4) {
      switch (e4) {
        case 5126:
          return Dr;
        case 35664:
          return Lr;
        case 35665:
          return Fr;
        case 35666:
          return Nr;
        case 35674:
          return Or;
        case 35675:
          return zr;
        case 35676:
          return Ur;
        case 5124:
        case 35670:
          return Hr;
        case 35667:
        case 35671:
          return Qr;
        case 35668:
        case 35672:
          return Vr;
        case 35669:
        case 35673:
          return Gr;
        case 5125:
          return $r;
        case 36294:
          return Wr;
        case 36295:
          return qr;
        case 36296:
          return jr;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
          return Xr;
        case 35679:
        case 36299:
        case 36307:
          return Yr;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
          return Kr;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
          return Zr;
      }
    }(t2.type);
  }
}
class As {
  constructor(e3, t2, i2) {
    this.id = e3, this.addr = i2, this.cache = [], this.size = t2.size, this.setValue = function(e4) {
      switch (e4) {
        case 5126:
          return Jr;
        case 35664:
          return es;
        case 35665:
          return ts;
        case 35666:
          return is;
        case 35674:
          return ns;
        case 35675:
          return os;
        case 35676:
          return rs;
        case 5124:
        case 35670:
          return ss;
        case 35667:
        case 35671:
          return as;
        case 35668:
        case 35672:
          return ls;
        case 35669:
        case 35673:
          return cs;
        case 5125:
          return hs;
        case 36294:
          return us;
        case 36295:
          return ds;
        case 36296:
          return ps;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
          return _s;
        case 35679:
        case 36299:
        case 36307:
          return gs;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
          return ms;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
          return fs;
      }
    }(t2.type);
  }
}
class bs {
  constructor(e3) {
    this.id = e3, this.seq = [], this.map = {};
  }
  setValue(e3, t2, i2) {
    const n2 = this.seq;
    for (let o2 = 0, r2 = n2.length; o2 !== r2; ++o2) {
      const r3 = n2[o2];
      r3.setValue(e3, t2[r3.id], i2);
    }
  }
}
const ys = /(\w+)(\])?(\[|\.)?/g;
function ws(e3, t2) {
  e3.seq.push(t2), e3.map[t2.id] = t2;
}
function xs(e3, t2, i2) {
  const n2 = e3.name, o2 = n2.length;
  for (ys.lastIndex = 0; ; ) {
    const r2 = ys.exec(n2), s2 = ys.lastIndex;
    let a2 = r2[1];
    const l2 = "]" === r2[2], c2 = r2[3];
    if (l2 && (a2 |= 0), void 0 === c2 || "[" === c2 && s2 + 2 === o2) {
      ws(i2, void 0 === c2 ? new vs(a2, e3, t2) : new As(a2, e3, t2));
      break;
    }
    {
      let e4 = i2.map[a2];
      void 0 === e4 && (e4 = new bs(a2), ws(i2, e4)), i2 = e4;
    }
  }
}
class Cs {
  constructor(e3, t2) {
    this.seq = [], this.map = {};
    const i2 = e3.getProgramParameter(t2, 35718);
    for (let n2 = 0; n2 < i2; ++n2) {
      const i3 = e3.getActiveUniform(t2, n2);
      xs(i3, e3.getUniformLocation(t2, i3.name), this);
    }
  }
  setValue(e3, t2, i2, n2) {
    const o2 = this.map[t2];
    void 0 !== o2 && o2.setValue(e3, i2, n2);
  }
  setOptional(e3, t2, i2) {
    const n2 = t2[i2];
    void 0 !== n2 && this.setValue(e3, i2, n2);
  }
  static upload(e3, t2, i2, n2) {
    for (let o2 = 0, r2 = t2.length; o2 !== r2; ++o2) {
      const r3 = t2[o2], s2 = i2[r3.id];
      false !== s2.needsUpdate && r3.setValue(e3, s2.value, n2);
    }
  }
  static seqWithValue(e3, t2) {
    const i2 = [];
    for (let n2 = 0, o2 = e3.length; n2 !== o2; ++n2) {
      const o3 = e3[n2];
      o3.id in t2 && i2.push(o3);
    }
    return i2;
  }
}
function Ss(e3, t2, i2) {
  const n2 = e3.createShader(t2);
  return e3.shaderSource(n2, i2), e3.compileShader(n2), n2;
}
let Es = 0;
function Is(e3, t2, i2) {
  const n2 = e3.getShaderParameter(t2, 35713), o2 = e3.getShaderInfoLog(t2).trim();
  if (n2 && "" === o2)
    return "";
  const r2 = /ERROR: 0:(\d+)/.exec(o2);
  if (r2) {
    const n3 = parseInt(r2[1]);
    return i2.toUpperCase() + "\n\n" + o2 + "\n\n" + function(e4, t3) {
      const i3 = e4.split("\n"), n4 = [], o3 = Math.max(t3 - 6, 0), r3 = Math.min(t3 + 6, i3.length);
      for (let e5 = o3; e5 < r3; e5++) {
        const o4 = e5 + 1;
        n4.push(`${o4 === t3 ? ">" : " "} ${o4}: ${i3[e5]}`);
      }
      return n4.join("\n");
    }(e3.getShaderSource(t2), n3);
  }
  return o2;
}
function Ts(e3, t2) {
  const i2 = function(e4) {
    switch (e4) {
      case At:
        return ["Linear", "( value )"];
      case bt:
        return ["sRGB", "( value )"];
      default:
        return console.warn("THREE.WebGLProgram: Unsupported encoding:", e4), ["Linear", "( value )"];
    }
  }(t2);
  return "vec4 " + e3 + "( vec4 value ) { return LinearTo" + i2[0] + i2[1] + "; }";
}
function Bs(e3, t2) {
  let i2;
  switch (t2) {
    case Ee:
      i2 = "Linear";
      break;
    case Ie:
      i2 = "Reinhard";
      break;
    case Te:
      i2 = "OptimizedCineon";
      break;
    case Be:
      i2 = "ACESFilmic";
      break;
    case Me:
      i2 = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t2), i2 = "Linear";
  }
  return "vec3 " + e3 + "( vec3 color ) { return " + i2 + "ToneMapping( color ); }";
}
function Ms(e3) {
  return "" !== e3;
}
function ks(e3, t2) {
  const i2 = t2.numSpotLightShadows + t2.numSpotLightMaps - t2.numSpotLightShadowsWithMaps;
  return e3.replace(/NUM_DIR_LIGHTS/g, t2.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t2.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t2.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, i2).replace(/NUM_RECT_AREA_LIGHTS/g, t2.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t2.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t2.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t2.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t2.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t2.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t2.numPointLightShadows);
}
function Rs(e3, t2) {
  return e3.replace(/NUM_CLIPPING_PLANES/g, t2.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t2.numClippingPlanes - t2.numClipIntersection);
}
const Ps = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Ds(e3) {
  return e3.replace(Ps, Ls);
}
function Ls(e3, t2) {
  const i2 = Ho[t2];
  if (void 0 === i2)
    throw new Error("Can not resolve #include <" + t2 + ">");
  return Ds(i2);
}
const Fs = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Ns(e3) {
  return e3.replace(Fs, Os);
}
function Os(e3, t2, i2, n2) {
  let o2 = "";
  for (let e4 = parseInt(t2); e4 < parseInt(i2); e4++)
    o2 += n2.replace(/\[\s*i\s*\]/g, "[ " + e4 + " ]").replace(/UNROLLED_LOOP_INDEX/g, e4);
  return o2;
}
function zs(e3) {
  let t2 = "precision " + e3.precision + " float;\nprecision " + e3.precision + " int;";
  return "highp" === e3.precision ? t2 += "\n#define HIGH_PRECISION" : "mediump" === e3.precision ? t2 += "\n#define MEDIUM_PRECISION" : "lowp" === e3.precision && (t2 += "\n#define LOW_PRECISION"), t2;
}
function Us(e3, t2, i2, n2) {
  const o2 = e3.getContext(), r2 = i2.defines;
  let s2 = i2.vertexShader, a2 = i2.fragmentShader;
  const l2 = function(e4) {
    let t3 = "SHADOWMAP_TYPE_BASIC";
    return e4.shadowMapType === ge ? t3 = "SHADOWMAP_TYPE_PCF" : e4.shadowMapType === me ? t3 = "SHADOWMAP_TYPE_PCF_SOFT" : e4.shadowMapType === fe && (t3 = "SHADOWMAP_TYPE_VSM"), t3;
  }(i2), c2 = function(e4) {
    let t3 = "ENVMAP_TYPE_CUBE";
    if (e4.envMap)
      switch (e4.envMapMode) {
        case ke:
        case Re:
          t3 = "ENVMAP_TYPE_CUBE";
          break;
        case De:
          t3 = "ENVMAP_TYPE_CUBE_UV";
      }
    return t3;
  }(i2), h2 = function(e4) {
    let t3 = "ENVMAP_MODE_REFLECTION";
    e4.envMap && e4.envMapMode === Re && (t3 = "ENVMAP_MODE_REFRACTION");
    return t3;
  }(i2), u2 = function(e4) {
    let t3 = "ENVMAP_BLENDING_NONE";
    if (e4.envMap)
      switch (e4.combine) {
        case we:
          t3 = "ENVMAP_BLENDING_MULTIPLY";
          break;
        case xe:
          t3 = "ENVMAP_BLENDING_MIX";
          break;
        case Ce:
          t3 = "ENVMAP_BLENDING_ADD";
      }
    return t3;
  }(i2), d2 = function(e4) {
    const t3 = e4.envMapCubeUVHeight;
    if (null === t3)
      return null;
    const i3 = Math.log2(t3) - 2, n3 = 1 / t3;
    return { texelWidth: 1 / (3 * Math.max(Math.pow(2, i3), 112)), texelHeight: n3, maxMip: i3 };
  }(i2), p2 = i2.isWebGL2 ? "" : function(e4) {
    return [e4.extensionDerivatives || e4.envMapCubeUVHeight || e4.bumpMap || e4.normalMapTangentSpace || e4.clearcoatNormalMap || e4.flatShading || "physical" === e4.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e4.extensionFragDepth || e4.logarithmicDepthBuffer) && e4.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e4.extensionDrawBuffers && e4.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e4.extensionShaderTextureLOD || e4.envMap || e4.transmission) && e4.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Ms).join("\n");
  }(i2), _2 = function(e4) {
    const t3 = [];
    for (const i3 in e4) {
      const n3 = e4[i3];
      false !== n3 && t3.push("#define " + i3 + " " + n3);
    }
    return t3.join("\n");
  }(r2), g2 = o2.createProgram();
  let m2, f2, v2 = i2.glslVersion ? "#version " + i2.glslVersion + "\n" : "";
  i2.isRawShaderMaterial ? (m2 = [_2].filter(Ms).join("\n"), m2.length > 0 && (m2 += "\n"), f2 = [p2, _2].filter(Ms).join("\n"), f2.length > 0 && (f2 += "\n")) : (m2 = [zs(i2), "#define SHADER_NAME " + i2.shaderName, _2, i2.instancing ? "#define USE_INSTANCING" : "", i2.instancingColor ? "#define USE_INSTANCING_COLOR" : "", i2.useFog && i2.fog ? "#define USE_FOG" : "", i2.useFog && i2.fogExp2 ? "#define FOG_EXP2" : "", i2.map ? "#define USE_MAP" : "", i2.envMap ? "#define USE_ENVMAP" : "", i2.envMap ? "#define " + h2 : "", i2.lightMap ? "#define USE_LIGHTMAP" : "", i2.aoMap ? "#define USE_AOMAP" : "", i2.bumpMap ? "#define USE_BUMPMAP" : "", i2.normalMap ? "#define USE_NORMALMAP" : "", i2.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", i2.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", i2.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", i2.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i2.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i2.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i2.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i2.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", i2.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", i2.specularMap ? "#define USE_SPECULARMAP" : "", i2.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", i2.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", i2.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i2.metalnessMap ? "#define USE_METALNESSMAP" : "", i2.alphaMap ? "#define USE_ALPHAMAP" : "", i2.transmission ? "#define USE_TRANSMISSION" : "", i2.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i2.thicknessMap ? "#define USE_THICKNESSMAP" : "", i2.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", i2.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", i2.mapUv ? "#define MAP_UV " + i2.mapUv : "", i2.alphaMapUv ? "#define ALPHAMAP_UV " + i2.alphaMapUv : "", i2.lightMapUv ? "#define LIGHTMAP_UV " + i2.lightMapUv : "", i2.aoMapUv ? "#define AOMAP_UV " + i2.aoMapUv : "", i2.emissiveMapUv ? "#define EMISSIVEMAP_UV " + i2.emissiveMapUv : "", i2.bumpMapUv ? "#define BUMPMAP_UV " + i2.bumpMapUv : "", i2.normalMapUv ? "#define NORMALMAP_UV " + i2.normalMapUv : "", i2.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + i2.displacementMapUv : "", i2.metalnessMapUv ? "#define METALNESSMAP_UV " + i2.metalnessMapUv : "", i2.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + i2.roughnessMapUv : "", i2.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + i2.clearcoatMapUv : "", i2.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + i2.clearcoatNormalMapUv : "", i2.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + i2.clearcoatRoughnessMapUv : "", i2.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + i2.iridescenceMapUv : "", i2.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + i2.iridescenceThicknessMapUv : "", i2.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + i2.sheenColorMapUv : "", i2.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + i2.sheenRoughnessMapUv : "", i2.specularMapUv ? "#define SPECULARMAP_UV " + i2.specularMapUv : "", i2.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + i2.specularColorMapUv : "", i2.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + i2.specularIntensityMapUv : "", i2.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + i2.transmissionMapUv : "", i2.thicknessMapUv ? "#define THICKNESSMAP_UV " + i2.thicknessMapUv : "", i2.vertexTangents ? "#define USE_TANGENT" : "", i2.vertexColors ? "#define USE_COLOR" : "", i2.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i2.vertexUvs2 ? "#define USE_UV2" : "", i2.pointsUvs ? "#define USE_POINTS_UV" : "", i2.flatShading ? "#define FLAT_SHADED" : "", i2.skinning ? "#define USE_SKINNING" : "", i2.morphTargets ? "#define USE_MORPHTARGETS" : "", i2.morphNormals && false === i2.flatShading ? "#define USE_MORPHNORMALS" : "", i2.morphColors && i2.isWebGL2 ? "#define USE_MORPHCOLORS" : "", i2.morphTargetsCount > 0 && i2.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", i2.morphTargetsCount > 0 && i2.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + i2.morphTextureStride : "", i2.morphTargetsCount > 0 && i2.isWebGL2 ? "#define MORPHTARGETS_COUNT " + i2.morphTargetsCount : "", i2.doubleSided ? "#define DOUBLE_SIDED" : "", i2.flipSided ? "#define FLIP_SIDED" : "", i2.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i2.shadowMapEnabled ? "#define " + l2 : "", i2.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", i2.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i2.logarithmicDepthBuffer && i2.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(Ms).join("\n"), f2 = [p2, zs(i2), "#define SHADER_NAME " + i2.shaderName, _2, i2.useFog && i2.fog ? "#define USE_FOG" : "", i2.useFog && i2.fogExp2 ? "#define FOG_EXP2" : "", i2.map ? "#define USE_MAP" : "", i2.matcap ? "#define USE_MATCAP" : "", i2.envMap ? "#define USE_ENVMAP" : "", i2.envMap ? "#define " + c2 : "", i2.envMap ? "#define " + h2 : "", i2.envMap ? "#define " + u2 : "", d2 ? "#define CUBEUV_TEXEL_WIDTH " + d2.texelWidth : "", d2 ? "#define CUBEUV_TEXEL_HEIGHT " + d2.texelHeight : "", d2 ? "#define CUBEUV_MAX_MIP " + d2.maxMip + ".0" : "", i2.lightMap ? "#define USE_LIGHTMAP" : "", i2.aoMap ? "#define USE_AOMAP" : "", i2.bumpMap ? "#define USE_BUMPMAP" : "", i2.normalMap ? "#define USE_NORMALMAP" : "", i2.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", i2.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", i2.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i2.clearcoat ? "#define USE_CLEARCOAT" : "", i2.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i2.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i2.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i2.iridescence ? "#define USE_IRIDESCENCE" : "", i2.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", i2.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", i2.specularMap ? "#define USE_SPECULARMAP" : "", i2.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", i2.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", i2.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i2.metalnessMap ? "#define USE_METALNESSMAP" : "", i2.alphaMap ? "#define USE_ALPHAMAP" : "", i2.alphaTest ? "#define USE_ALPHATEST" : "", i2.sheen ? "#define USE_SHEEN" : "", i2.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", i2.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", i2.transmission ? "#define USE_TRANSMISSION" : "", i2.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i2.thicknessMap ? "#define USE_THICKNESSMAP" : "", i2.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", i2.vertexTangents ? "#define USE_TANGENT" : "", i2.vertexColors || i2.instancingColor ? "#define USE_COLOR" : "", i2.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i2.vertexUvs2 ? "#define USE_UV2" : "", i2.pointsUvs ? "#define USE_POINTS_UV" : "", i2.gradientMap ? "#define USE_GRADIENTMAP" : "", i2.flatShading ? "#define FLAT_SHADED" : "", i2.doubleSided ? "#define DOUBLE_SIDED" : "", i2.flipSided ? "#define FLIP_SIDED" : "", i2.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i2.shadowMapEnabled ? "#define " + l2 : "", i2.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", i2.useLegacyLights ? "#define LEGACY_LIGHTS" : "", i2.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i2.logarithmicDepthBuffer && i2.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", i2.toneMapping !== Se ? "#define TONE_MAPPING" : "", i2.toneMapping !== Se ? Ho.tonemapping_pars_fragment : "", i2.toneMapping !== Se ? Bs("toneMapping", i2.toneMapping) : "", i2.dithering ? "#define DITHERING" : "", i2.opaque ? "#define OPAQUE" : "", Ho.encodings_pars_fragment, Ts("linearToOutputTexel", i2.outputEncoding), i2.useDepthPacking ? "#define DEPTH_PACKING " + i2.depthPacking : "", "\n"].filter(Ms).join("\n")), s2 = Ds(s2), s2 = ks(s2, i2), s2 = Rs(s2, i2), a2 = Ds(a2), a2 = ks(a2, i2), a2 = Rs(a2, i2), s2 = Ns(s2), a2 = Ns(a2), i2.isWebGL2 && true !== i2.isRawShaderMaterial && (v2 = "#version 300 es\n", m2 = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + m2, f2 = ["#define varying in", i2.glslVersion === Et ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", i2.glslVersion === Et ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + f2);
  const A2 = v2 + f2 + a2, b2 = Ss(o2, 35633, v2 + m2 + s2), y2 = Ss(o2, 35632, A2);
  if (o2.attachShader(g2, b2), o2.attachShader(g2, y2), void 0 !== i2.index0AttributeName ? o2.bindAttribLocation(g2, 0, i2.index0AttributeName) : true === i2.morphTargets && o2.bindAttribLocation(g2, 0, "position"), o2.linkProgram(g2), e3.debug.checkShaderErrors) {
    const t3 = o2.getProgramInfoLog(g2).trim(), i3 = o2.getShaderInfoLog(b2).trim(), n3 = o2.getShaderInfoLog(y2).trim();
    let r3 = true, s3 = true;
    if (false === o2.getProgramParameter(g2, 35714))
      if (r3 = false, "function" == typeof e3.debug.onShaderError)
        e3.debug.onShaderError(o2, g2, b2, y2);
      else {
        const e4 = Is(o2, b2, "vertex"), i4 = Is(o2, y2, "fragment");
        console.error("THREE.WebGLProgram: Shader Error " + o2.getError() + " - VALIDATE_STATUS " + o2.getProgramParameter(g2, 35715) + "\n\nProgram Info Log: " + t3 + "\n" + e4 + "\n" + i4);
      }
    else
      "" !== t3 ? console.warn("THREE.WebGLProgram: Program Info Log:", t3) : "" !== i3 && "" !== n3 || (s3 = false);
    s3 && (this.diagnostics = { runnable: r3, programLog: t3, vertexShader: { log: i3, prefix: m2 }, fragmentShader: { log: n3, prefix: f2 } });
  }
  let w2, x2;
  return o2.deleteShader(b2), o2.deleteShader(y2), this.getUniforms = function() {
    return void 0 === w2 && (w2 = new Cs(o2, g2)), w2;
  }, this.getAttributes = function() {
    return void 0 === x2 && (x2 = function(e4, t3) {
      const i3 = {}, n3 = e4.getProgramParameter(t3, 35721);
      for (let o3 = 0; o3 < n3; o3++) {
        const n4 = e4.getActiveAttrib(t3, o3), r3 = n4.name;
        let s3 = 1;
        35674 === n4.type && (s3 = 2), 35675 === n4.type && (s3 = 3), 35676 === n4.type && (s3 = 4), i3[r3] = { type: n4.type, location: e4.getAttribLocation(t3, r3), locationSize: s3 };
      }
      return i3;
    }(o2, g2)), x2;
  }, this.destroy = function() {
    n2.releaseStatesOfProgram(this), o2.deleteProgram(g2), this.program = void 0;
  }, this.name = i2.shaderName, this.id = Es++, this.cacheKey = t2, this.usedTimes = 1, this.program = g2, this.vertexShader = b2, this.fragmentShader = y2, this;
}
let Hs = 0;
class Qs {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e3) {
    const t2 = e3.vertexShader, i2 = e3.fragmentShader, n2 = this._getShaderStage(t2), o2 = this._getShaderStage(i2), r2 = this._getShaderCacheForMaterial(e3);
    return false === r2.has(n2) && (r2.add(n2), n2.usedTimes++), false === r2.has(o2) && (r2.add(o2), o2.usedTimes++), this;
  }
  remove(e3) {
    const t2 = this.materialCache.get(e3);
    for (const e4 of t2)
      e4.usedTimes--, 0 === e4.usedTimes && this.shaderCache.delete(e4.code);
    return this.materialCache.delete(e3), this;
  }
  getVertexShaderID(e3) {
    return this._getShaderStage(e3.vertexShader).id;
  }
  getFragmentShaderID(e3) {
    return this._getShaderStage(e3.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e3) {
    const t2 = this.materialCache;
    let i2 = t2.get(e3);
    return void 0 === i2 && (i2 = /* @__PURE__ */ new Set(), t2.set(e3, i2)), i2;
  }
  _getShaderStage(e3) {
    const t2 = this.shaderCache;
    let i2 = t2.get(e3);
    return void 0 === i2 && (i2 = new Vs(e3), t2.set(e3, i2)), i2;
  }
}
class Vs {
  constructor(e3) {
    this.id = Hs++, this.code = e3, this.usedTimes = 0;
  }
}
function Gs(e3, t2, i2, n2, o2, r2, s2) {
  const a2 = new Ji(), l2 = new Qs(), c2 = [], h2 = o2.isWebGL2, u2 = o2.logarithmicDepthBuffer, d2 = o2.vertexTextures;
  let p2 = o2.precision;
  const _2 = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" };
  function g2(e4) {
    return 1 === e4 ? "uv2" : "uv";
  }
  return { getParameters: function(r3, a3, c3, m2, f2) {
    const v2 = m2.fog, A2 = f2.geometry, b2 = r3.isMeshStandardMaterial ? m2.environment : null, y2 = (r3.isMeshStandardMaterial ? i2 : t2).get(r3.envMap || b2), w2 = y2 && y2.mapping === De ? y2.image.height : null, x2 = _2[r3.type];
    null !== r3.precision && (p2 = o2.getMaxPrecision(r3.precision), p2 !== r3.precision && console.warn("THREE.WebGLProgram.getParameters:", r3.precision, "not supported, using", p2, "instead."));
    const C2 = A2.morphAttributes.position || A2.morphAttributes.normal || A2.morphAttributes.color, S2 = void 0 !== C2 ? C2.length : 0;
    let E2, I2, T2, B2, M2 = 0;
    if (void 0 !== A2.morphAttributes.position && (M2 = 1), void 0 !== A2.morphAttributes.normal && (M2 = 2), void 0 !== A2.morphAttributes.color && (M2 = 3), x2) {
      const e4 = Vo[x2];
      E2 = e4.vertexShader, I2 = e4.fragmentShader;
    } else
      E2 = r3.vertexShader, I2 = r3.fragmentShader, l2.update(r3), T2 = l2.getVertexShaderID(r3), B2 = l2.getFragmentShaderID(r3);
    const k2 = e3.getRenderTarget(), R2 = true === f2.isInstancedMesh, P2 = !!r3.map, D2 = !!r3.matcap, L2 = !!y2, F2 = !!r3.aoMap, N2 = !!r3.lightMap, O2 = !!r3.bumpMap, z2 = !!r3.normalMap, U2 = !!r3.displacementMap, H2 = !!r3.emissiveMap, Q2 = !!r3.metalnessMap, V2 = !!r3.roughnessMap, G2 = r3.clearcoat > 0, $2 = r3.iridescence > 0, W2 = r3.sheen > 0, q2 = r3.transmission > 0, j2 = G2 && !!r3.clearcoatMap, X2 = G2 && !!r3.clearcoatNormalMap, Y2 = G2 && !!r3.clearcoatRoughnessMap, K2 = $2 && !!r3.iridescenceMap, Z2 = $2 && !!r3.iridescenceThicknessMap, J2 = W2 && !!r3.sheenColorMap, ee2 = W2 && !!r3.sheenRoughnessMap, te2 = !!r3.specularMap, ie2 = !!r3.specularColorMap, ne2 = !!r3.specularIntensityMap, oe2 = q2 && !!r3.transmissionMap, re2 = q2 && !!r3.thicknessMap, se2 = !!r3.gradientMap, ae2 = !!r3.alphaMap, le2 = r3.alphaTest > 0, ce2 = !!r3.extensions, he2 = !!A2.attributes.uv2;
    return { isWebGL2: h2, shaderID: x2, shaderName: r3.type, vertexShader: E2, fragmentShader: I2, defines: r3.defines, customVertexShaderID: T2, customFragmentShaderID: B2, isRawShaderMaterial: true === r3.isRawShaderMaterial, glslVersion: r3.glslVersion, precision: p2, instancing: R2, instancingColor: R2 && null !== f2.instanceColor, supportsVertexTextures: d2, outputEncoding: null === k2 ? e3.outputEncoding : true === k2.isXRRenderTarget ? k2.texture.encoding : At, map: P2, matcap: D2, envMap: L2, envMapMode: L2 && y2.mapping, envMapCubeUVHeight: w2, aoMap: F2, lightMap: N2, bumpMap: O2, normalMap: z2, displacementMap: d2 && U2, emissiveMap: H2, normalMapObjectSpace: z2 && 1 === r3.normalMapType, normalMapTangentSpace: z2 && 0 === r3.normalMapType, decodeVideoTexture: P2 && true === r3.map.isVideoTexture && r3.map.encoding === bt, metalnessMap: Q2, roughnessMap: V2, clearcoat: G2, clearcoatMap: j2, clearcoatNormalMap: X2, clearcoatRoughnessMap: Y2, iridescence: $2, iridescenceMap: K2, iridescenceThicknessMap: Z2, sheen: W2, sheenColorMap: J2, sheenRoughnessMap: ee2, specularMap: te2, specularColorMap: ie2, specularIntensityMap: ne2, transmission: q2, transmissionMap: oe2, thicknessMap: re2, gradientMap: se2, opaque: false === r3.transparent && 1 === r3.blending, alphaMap: ae2, alphaTest: le2, combine: r3.combine, mapUv: P2 && g2(r3.map.channel), aoMapUv: F2 && g2(r3.aoMap.channel), lightMapUv: N2 && g2(r3.lightMap.channel), bumpMapUv: O2 && g2(r3.bumpMap.channel), normalMapUv: z2 && g2(r3.normalMap.channel), displacementMapUv: U2 && g2(r3.displacementMap.channel), emissiveMapUv: H2 && g2(r3.emissiveMap.channel), metalnessMapUv: Q2 && g2(r3.metalnessMap.channel), roughnessMapUv: V2 && g2(r3.roughnessMap.channel), clearcoatMapUv: j2 && g2(r3.clearcoatMap.channel), clearcoatNormalMapUv: X2 && g2(r3.clearcoatNormalMap.channel), clearcoatRoughnessMapUv: Y2 && g2(r3.clearcoatRoughnessMap.channel), iridescenceMapUv: K2 && g2(r3.iridescenceMap.channel), iridescenceThicknessMapUv: Z2 && g2(r3.iridescenceThicknessMap.channel), sheenColorMapUv: J2 && g2(r3.sheenColorMap.channel), sheenRoughnessMapUv: ee2 && g2(r3.sheenRoughnessMap.channel), specularMapUv: te2 && g2(r3.specularMap.channel), specularColorMapUv: ie2 && g2(r3.specularColorMap.channel), specularIntensityMapUv: ne2 && g2(r3.specularIntensityMap.channel), transmissionMapUv: oe2 && g2(r3.transmissionMap.channel), thicknessMapUv: re2 && g2(r3.thicknessMap.channel), alphaMapUv: ae2 && g2(r3.alphaMap.channel), vertexTangents: z2 && !!A2.attributes.tangent, vertexColors: r3.vertexColors, vertexAlphas: true === r3.vertexColors && !!A2.attributes.color && 4 === A2.attributes.color.itemSize, vertexUvs2: he2, pointsUvs: true === f2.isPoints && !!A2.attributes.uv && (P2 || ae2), fog: !!v2, useFog: true === r3.fog, fogExp2: v2 && v2.isFogExp2, flatShading: true === r3.flatShading, sizeAttenuation: true === r3.sizeAttenuation, logarithmicDepthBuffer: u2, skinning: true === f2.isSkinnedMesh, morphTargets: void 0 !== A2.morphAttributes.position, morphNormals: void 0 !== A2.morphAttributes.normal, morphColors: void 0 !== A2.morphAttributes.color, morphTargetsCount: S2, morphTextureStride: M2, numDirLights: a3.directional.length, numPointLights: a3.point.length, numSpotLights: a3.spot.length, numSpotLightMaps: a3.spotLightMap.length, numRectAreaLights: a3.rectArea.length, numHemiLights: a3.hemi.length, numDirLightShadows: a3.directionalShadowMap.length, numPointLightShadows: a3.pointShadowMap.length, numSpotLightShadows: a3.spotShadowMap.length, numSpotLightShadowsWithMaps: a3.numSpotLightShadowsWithMaps, numClippingPlanes: s2.numPlanes, numClipIntersection: s2.numIntersection, dithering: r3.dithering, shadowMapEnabled: e3.shadowMap.enabled && c3.length > 0, shadowMapType: e3.shadowMap.type, toneMapping: r3.toneMapped ? e3.toneMapping : Se, useLegacyLights: e3.useLegacyLights, premultipliedAlpha: r3.premultipliedAlpha, doubleSided: r3.side === be, flipSided: r3.side === Ae, useDepthPacking: r3.depthPacking >= 0, depthPacking: r3.depthPacking || 0, index0AttributeName: r3.index0AttributeName, extensionDerivatives: ce2 && true === r3.extensions.derivatives, extensionFragDepth: ce2 && true === r3.extensions.fragDepth, extensionDrawBuffers: ce2 && true === r3.extensions.drawBuffers, extensionShaderTextureLOD: ce2 && true === r3.extensions.shaderTextureLOD, rendererExtensionFragDepth: h2 || n2.has("EXT_frag_depth"), rendererExtensionDrawBuffers: h2 || n2.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: h2 || n2.has("EXT_shader_texture_lod"), customProgramCacheKey: r3.customProgramCacheKey() };
  }, getProgramCacheKey: function(t3) {
    const i3 = [];
    if (t3.shaderID ? i3.push(t3.shaderID) : (i3.push(t3.customVertexShaderID), i3.push(t3.customFragmentShaderID)), void 0 !== t3.defines)
      for (const e4 in t3.defines)
        i3.push(e4), i3.push(t3.defines[e4]);
    return false === t3.isRawShaderMaterial && (!function(e4, t4) {
      e4.push(t4.precision), e4.push(t4.outputEncoding), e4.push(t4.envMapMode), e4.push(t4.envMapCubeUVHeight), e4.push(t4.mapUv), e4.push(t4.alphaMapUv), e4.push(t4.lightMapUv), e4.push(t4.aoMapUv), e4.push(t4.bumpMapUv), e4.push(t4.normalMapUv), e4.push(t4.displacementMapUv), e4.push(t4.emissiveMapUv), e4.push(t4.metalnessMapUv), e4.push(t4.roughnessMapUv), e4.push(t4.clearcoatMapUv), e4.push(t4.clearcoatNormalMapUv), e4.push(t4.clearcoatRoughnessMapUv), e4.push(t4.iridescenceMapUv), e4.push(t4.iridescenceThicknessMapUv), e4.push(t4.sheenColorMapUv), e4.push(t4.sheenRoughnessMapUv), e4.push(t4.specularMapUv), e4.push(t4.specularColorMapUv), e4.push(t4.specularIntensityMapUv), e4.push(t4.transmissionMapUv), e4.push(t4.thicknessMapUv), e4.push(t4.combine), e4.push(t4.fogExp2), e4.push(t4.sizeAttenuation), e4.push(t4.morphTargetsCount), e4.push(t4.morphAttributeCount), e4.push(t4.numDirLights), e4.push(t4.numPointLights), e4.push(t4.numSpotLights), e4.push(t4.numSpotLightMaps), e4.push(t4.numHemiLights), e4.push(t4.numRectAreaLights), e4.push(t4.numDirLightShadows), e4.push(t4.numPointLightShadows), e4.push(t4.numSpotLightShadows), e4.push(t4.numSpotLightShadowsWithMaps), e4.push(t4.shadowMapType), e4.push(t4.toneMapping), e4.push(t4.numClippingPlanes), e4.push(t4.numClipIntersection), e4.push(t4.depthPacking);
    }(i3, t3), function(e4, t4) {
      a2.disableAll(), t4.isWebGL2 && a2.enable(0);
      t4.supportsVertexTextures && a2.enable(1);
      t4.instancing && a2.enable(2);
      t4.instancingColor && a2.enable(3);
      t4.matcap && a2.enable(4);
      t4.envMap && a2.enable(5);
      t4.normalMapObjectSpace && a2.enable(6);
      t4.normalMapTangentSpace && a2.enable(7);
      t4.clearcoat && a2.enable(8);
      t4.iridescence && a2.enable(9);
      t4.alphaTest && a2.enable(10);
      t4.vertexColors && a2.enable(11);
      t4.vertexAlphas && a2.enable(12);
      t4.vertexUvs2 && a2.enable(13);
      t4.vertexTangents && a2.enable(14);
      e4.push(a2.mask), a2.disableAll(), t4.fog && a2.enable(0);
      t4.useFog && a2.enable(1);
      t4.flatShading && a2.enable(2);
      t4.logarithmicDepthBuffer && a2.enable(3);
      t4.skinning && a2.enable(4);
      t4.morphTargets && a2.enable(5);
      t4.morphNormals && a2.enable(6);
      t4.morphColors && a2.enable(7);
      t4.premultipliedAlpha && a2.enable(8);
      t4.shadowMapEnabled && a2.enable(9);
      t4.useLegacyLights && a2.enable(10);
      t4.doubleSided && a2.enable(11);
      t4.flipSided && a2.enable(12);
      t4.useDepthPacking && a2.enable(13);
      t4.dithering && a2.enable(14);
      t4.transmission && a2.enable(15);
      t4.sheen && a2.enable(16);
      t4.decodeVideoTexture && a2.enable(17);
      t4.opaque && a2.enable(18);
      t4.pointsUvs && a2.enable(19);
      e4.push(a2.mask);
    }(i3, t3), i3.push(e3.outputEncoding)), i3.push(t3.customProgramCacheKey), i3.join();
  }, getUniforms: function(e4) {
    const t3 = _2[e4.type];
    let i3;
    if (t3) {
      const e5 = Vo[t3];
      i3 = xo.clone(e5.uniforms);
    } else
      i3 = e4.uniforms;
    return i3;
  }, acquireProgram: function(t3, i3) {
    let n3;
    for (let e4 = 0, t4 = c2.length; e4 < t4; e4++) {
      const t5 = c2[e4];
      if (t5.cacheKey === i3) {
        n3 = t5, ++n3.usedTimes;
        break;
      }
    }
    return void 0 === n3 && (n3 = new Us(e3, i3, t3, r2), c2.push(n3)), n3;
  }, releaseProgram: function(e4) {
    if (0 == --e4.usedTimes) {
      const t3 = c2.indexOf(e4);
      c2[t3] = c2[c2.length - 1], c2.pop(), e4.destroy();
    }
  }, releaseShaderCache: function(e4) {
    l2.remove(e4);
  }, programs: c2, dispose: function() {
    l2.dispose();
  } };
}
function $s() {
  let e3 = /* @__PURE__ */ new WeakMap();
  return { get: function(t2) {
    let i2 = e3.get(t2);
    return void 0 === i2 && (i2 = {}, e3.set(t2, i2)), i2;
  }, remove: function(t2) {
    e3.delete(t2);
  }, update: function(t2, i2, n2) {
    e3.get(t2)[i2] = n2;
  }, dispose: function() {
    e3 = /* @__PURE__ */ new WeakMap();
  } };
}
function Ws(e3, t2) {
  return e3.groupOrder !== t2.groupOrder ? e3.groupOrder - t2.groupOrder : e3.renderOrder !== t2.renderOrder ? e3.renderOrder - t2.renderOrder : e3.material.id !== t2.material.id ? e3.material.id - t2.material.id : e3.z !== t2.z ? e3.z - t2.z : e3.id - t2.id;
}
function qs(e3, t2) {
  return e3.groupOrder !== t2.groupOrder ? e3.groupOrder - t2.groupOrder : e3.renderOrder !== t2.renderOrder ? e3.renderOrder - t2.renderOrder : e3.z !== t2.z ? t2.z - e3.z : e3.id - t2.id;
}
function js() {
  const e3 = [];
  let t2 = 0;
  const i2 = [], n2 = [], o2 = [];
  function r2(i3, n3, o3, r3, s2, a2) {
    let l2 = e3[t2];
    return void 0 === l2 ? (l2 = { id: i3.id, object: i3, geometry: n3, material: o3, groupOrder: r3, renderOrder: i3.renderOrder, z: s2, group: a2 }, e3[t2] = l2) : (l2.id = i3.id, l2.object = i3, l2.geometry = n3, l2.material = o3, l2.groupOrder = r3, l2.renderOrder = i3.renderOrder, l2.z = s2, l2.group = a2), t2++, l2;
  }
  return { opaque: i2, transmissive: n2, transparent: o2, init: function() {
    t2 = 0, i2.length = 0, n2.length = 0, o2.length = 0;
  }, push: function(e4, t3, s2, a2, l2, c2) {
    const h2 = r2(e4, t3, s2, a2, l2, c2);
    s2.transmission > 0 ? n2.push(h2) : true === s2.transparent ? o2.push(h2) : i2.push(h2);
  }, unshift: function(e4, t3, s2, a2, l2, c2) {
    const h2 = r2(e4, t3, s2, a2, l2, c2);
    s2.transmission > 0 ? n2.unshift(h2) : true === s2.transparent ? o2.unshift(h2) : i2.unshift(h2);
  }, finish: function() {
    for (let i3 = t2, n3 = e3.length; i3 < n3; i3++) {
      const t3 = e3[i3];
      if (null === t3.id)
        break;
      t3.id = null, t3.object = null, t3.geometry = null, t3.material = null, t3.group = null;
    }
  }, sort: function(e4, t3) {
    i2.length > 1 && i2.sort(e4 || Ws), n2.length > 1 && n2.sort(t3 || qs), o2.length > 1 && o2.sort(t3 || qs);
  } };
}
function Xs() {
  let e3 = /* @__PURE__ */ new WeakMap();
  return { get: function(t2, i2) {
    const n2 = e3.get(t2);
    let o2;
    return void 0 === n2 ? (o2 = new js(), e3.set(t2, [o2])) : i2 >= n2.length ? (o2 = new js(), n2.push(o2)) : o2 = n2[i2], o2;
  }, dispose: function() {
    e3 = /* @__PURE__ */ new WeakMap();
  } };
}
function Ys() {
  const e3 = {};
  return { get: function(t2) {
    if (void 0 !== e3[t2.id])
      return e3[t2.id];
    let i2;
    switch (t2.type) {
      case "DirectionalLight":
        i2 = { direction: new di(), color: new Pn() };
        break;
      case "SpotLight":
        i2 = { position: new di(), direction: new di(), color: new Pn(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
        break;
      case "PointLight":
        i2 = { position: new di(), color: new Pn(), distance: 0, decay: 0 };
        break;
      case "HemisphereLight":
        i2 = { direction: new di(), skyColor: new Pn(), groundColor: new Pn() };
        break;
      case "RectAreaLight":
        i2 = { color: new Pn(), position: new di(), halfWidth: new di(), halfHeight: new di() };
    }
    return e3[t2.id] = i2, i2;
  } };
}
let Ks = 0;
function Zs(e3, t2) {
  return (t2.castShadow ? 2 : 0) - (e3.castShadow ? 2 : 0) + (t2.map ? 1 : 0) - (e3.map ? 1 : 0);
}
function Js(e3, t2) {
  const i2 = new Ys(), n2 = function() {
    const e4 = {};
    return { get: function(t3) {
      if (void 0 !== e4[t3.id])
        return e4[t3.id];
      let i3;
      switch (t3.type) {
        case "DirectionalLight":
        case "SpotLight":
          i3 = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Vt() };
          break;
        case "PointLight":
          i3 = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Vt(), shadowCameraNear: 1, shadowCameraFar: 1e3 };
      }
      return e4[t3.id] = i3, i3;
    } };
  }(), o2 = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1, numSpotMaps: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotLightMap: [], spotShadow: [], spotShadowMap: [], spotLightMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], numSpotLightShadowsWithMaps: 0 };
  for (let e4 = 0; e4 < 9; e4++)
    o2.probe.push(new di());
  const r2 = new di(), s2 = new Qi(), a2 = new Qi();
  return { setup: function(r3, s3) {
    let a3 = 0, l2 = 0, c2 = 0;
    for (let e4 = 0; e4 < 9; e4++)
      o2.probe[e4].set(0, 0, 0);
    let h2 = 0, u2 = 0, d2 = 0, p2 = 0, _2 = 0, g2 = 0, m2 = 0, f2 = 0, v2 = 0, A2 = 0;
    r3.sort(Zs);
    const b2 = true === s3 ? Math.PI : 1;
    for (let e4 = 0, t3 = r3.length; e4 < t3; e4++) {
      const t4 = r3[e4], s4 = t4.color, y3 = t4.intensity, w2 = t4.distance, x2 = t4.shadow && t4.shadow.map ? t4.shadow.map.texture : null;
      if (t4.isAmbientLight)
        a3 += s4.r * y3 * b2, l2 += s4.g * y3 * b2, c2 += s4.b * y3 * b2;
      else if (t4.isLightProbe)
        for (let e5 = 0; e5 < 9; e5++)
          o2.probe[e5].addScaledVector(t4.sh.coefficients[e5], y3);
      else if (t4.isDirectionalLight) {
        const e5 = i2.get(t4);
        if (e5.color.copy(t4.color).multiplyScalar(t4.intensity * b2), t4.castShadow) {
          const e6 = t4.shadow, i3 = n2.get(t4);
          i3.shadowBias = e6.bias, i3.shadowNormalBias = e6.normalBias, i3.shadowRadius = e6.radius, i3.shadowMapSize = e6.mapSize, o2.directionalShadow[h2] = i3, o2.directionalShadowMap[h2] = x2, o2.directionalShadowMatrix[h2] = t4.shadow.matrix, g2++;
        }
        o2.directional[h2] = e5, h2++;
      } else if (t4.isSpotLight) {
        const e5 = i2.get(t4);
        e5.position.setFromMatrixPosition(t4.matrixWorld), e5.color.copy(s4).multiplyScalar(y3 * b2), e5.distance = w2, e5.coneCos = Math.cos(t4.angle), e5.penumbraCos = Math.cos(t4.angle * (1 - t4.penumbra)), e5.decay = t4.decay, o2.spot[d2] = e5;
        const r4 = t4.shadow;
        if (t4.map && (o2.spotLightMap[v2] = t4.map, v2++, r4.updateMatrices(t4), t4.castShadow && A2++), o2.spotLightMatrix[d2] = r4.matrix, t4.castShadow) {
          const e6 = n2.get(t4);
          e6.shadowBias = r4.bias, e6.shadowNormalBias = r4.normalBias, e6.shadowRadius = r4.radius, e6.shadowMapSize = r4.mapSize, o2.spotShadow[d2] = e6, o2.spotShadowMap[d2] = x2, f2++;
        }
        d2++;
      } else if (t4.isRectAreaLight) {
        const e5 = i2.get(t4);
        e5.color.copy(s4).multiplyScalar(y3), e5.halfWidth.set(0.5 * t4.width, 0, 0), e5.halfHeight.set(0, 0.5 * t4.height, 0), o2.rectArea[p2] = e5, p2++;
      } else if (t4.isPointLight) {
        const e5 = i2.get(t4);
        if (e5.color.copy(t4.color).multiplyScalar(t4.intensity * b2), e5.distance = t4.distance, e5.decay = t4.decay, t4.castShadow) {
          const e6 = t4.shadow, i3 = n2.get(t4);
          i3.shadowBias = e6.bias, i3.shadowNormalBias = e6.normalBias, i3.shadowRadius = e6.radius, i3.shadowMapSize = e6.mapSize, i3.shadowCameraNear = e6.camera.near, i3.shadowCameraFar = e6.camera.far, o2.pointShadow[u2] = i3, o2.pointShadowMap[u2] = x2, o2.pointShadowMatrix[u2] = t4.shadow.matrix, m2++;
        }
        o2.point[u2] = e5, u2++;
      } else if (t4.isHemisphereLight) {
        const e5 = i2.get(t4);
        e5.skyColor.copy(t4.color).multiplyScalar(y3 * b2), e5.groundColor.copy(t4.groundColor).multiplyScalar(y3 * b2), o2.hemi[_2] = e5, _2++;
      }
    }
    p2 > 0 && (t2.isWebGL2 || true === e3.has("OES_texture_float_linear") ? (o2.rectAreaLTC1 = Qo.LTC_FLOAT_1, o2.rectAreaLTC2 = Qo.LTC_FLOAT_2) : true === e3.has("OES_texture_half_float_linear") ? (o2.rectAreaLTC1 = Qo.LTC_HALF_1, o2.rectAreaLTC2 = Qo.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), o2.ambient[0] = a3, o2.ambient[1] = l2, o2.ambient[2] = c2;
    const y2 = o2.hash;
    y2.directionalLength === h2 && y2.pointLength === u2 && y2.spotLength === d2 && y2.rectAreaLength === p2 && y2.hemiLength === _2 && y2.numDirectionalShadows === g2 && y2.numPointShadows === m2 && y2.numSpotShadows === f2 && y2.numSpotMaps === v2 || (o2.directional.length = h2, o2.spot.length = d2, o2.rectArea.length = p2, o2.point.length = u2, o2.hemi.length = _2, o2.directionalShadow.length = g2, o2.directionalShadowMap.length = g2, o2.pointShadow.length = m2, o2.pointShadowMap.length = m2, o2.spotShadow.length = f2, o2.spotShadowMap.length = f2, o2.directionalShadowMatrix.length = g2, o2.pointShadowMatrix.length = m2, o2.spotLightMatrix.length = f2 + v2 - A2, o2.spotLightMap.length = v2, o2.numSpotLightShadowsWithMaps = A2, y2.directionalLength = h2, y2.pointLength = u2, y2.spotLength = d2, y2.rectAreaLength = p2, y2.hemiLength = _2, y2.numDirectionalShadows = g2, y2.numPointShadows = m2, y2.numSpotShadows = f2, y2.numSpotMaps = v2, o2.version = Ks++);
  }, setupView: function(e4, t3) {
    let i3 = 0, n3 = 0, l2 = 0, c2 = 0, h2 = 0;
    const u2 = t3.matrixWorldInverse;
    for (let t4 = 0, d2 = e4.length; t4 < d2; t4++) {
      const d3 = e4[t4];
      if (d3.isDirectionalLight) {
        const e5 = o2.directional[i3];
        e5.direction.setFromMatrixPosition(d3.matrixWorld), r2.setFromMatrixPosition(d3.target.matrixWorld), e5.direction.sub(r2), e5.direction.transformDirection(u2), i3++;
      } else if (d3.isSpotLight) {
        const e5 = o2.spot[l2];
        e5.position.setFromMatrixPosition(d3.matrixWorld), e5.position.applyMatrix4(u2), e5.direction.setFromMatrixPosition(d3.matrixWorld), r2.setFromMatrixPosition(d3.target.matrixWorld), e5.direction.sub(r2), e5.direction.transformDirection(u2), l2++;
      } else if (d3.isRectAreaLight) {
        const e5 = o2.rectArea[c2];
        e5.position.setFromMatrixPosition(d3.matrixWorld), e5.position.applyMatrix4(u2), a2.identity(), s2.copy(d3.matrixWorld), s2.premultiply(u2), a2.extractRotation(s2), e5.halfWidth.set(0.5 * d3.width, 0, 0), e5.halfHeight.set(0, 0.5 * d3.height, 0), e5.halfWidth.applyMatrix4(a2), e5.halfHeight.applyMatrix4(a2), c2++;
      } else if (d3.isPointLight) {
        const e5 = o2.point[n3];
        e5.position.setFromMatrixPosition(d3.matrixWorld), e5.position.applyMatrix4(u2), n3++;
      } else if (d3.isHemisphereLight) {
        const e5 = o2.hemi[h2];
        e5.direction.setFromMatrixPosition(d3.matrixWorld), e5.direction.transformDirection(u2), h2++;
      }
    }
  }, state: o2 };
}
function ea(e3, t2) {
  const i2 = new Js(e3, t2), n2 = [], o2 = [];
  return { init: function() {
    n2.length = 0, o2.length = 0;
  }, state: { lightsArray: n2, shadowsArray: o2, lights: i2 }, setupLights: function(e4) {
    i2.setup(n2, e4);
  }, setupLightsView: function(e4) {
    i2.setupView(n2, e4);
  }, pushLight: function(e4) {
    n2.push(e4);
  }, pushShadow: function(e4) {
    o2.push(e4);
  } };
}
function ta(e3, t2) {
  let i2 = /* @__PURE__ */ new WeakMap();
  return { get: function(n2, o2 = 0) {
    const r2 = i2.get(n2);
    let s2;
    return void 0 === r2 ? (s2 = new ea(e3, t2), i2.set(n2, [s2])) : o2 >= r2.length ? (s2 = new ea(e3, t2), r2.push(s2)) : s2 = r2[o2], s2;
  }, dispose: function() {
    i2 = /* @__PURE__ */ new WeakMap();
  } };
}
class ia extends Tn {
  constructor(e3) {
    super(), this.isMeshDepthMaterial = true, this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.setValues(e3);
  }
  copy(e3) {
    return super.copy(e3), this.depthPacking = e3.depthPacking, this.map = e3.map, this.alphaMap = e3.alphaMap, this.displacementMap = e3.displacementMap, this.displacementScale = e3.displacementScale, this.displacementBias = e3.displacementBias, this.wireframe = e3.wireframe, this.wireframeLinewidth = e3.wireframeLinewidth, this;
  }
}
class na extends Tn {
  constructor(e3) {
    super(), this.isMeshDistanceMaterial = true, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e3);
  }
  copy(e3) {
    return super.copy(e3), this.map = e3.map, this.alphaMap = e3.alphaMap, this.displacementMap = e3.displacementMap, this.displacementScale = e3.displacementScale, this.displacementBias = e3.displacementBias, this;
  }
}
function oa(e3, t2, i2) {
  let n2 = new No();
  const o2 = new Vt(), r2 = new Vt(), s2 = new ai(), a2 = new ia({ depthPacking: 3201 }), l2 = new na(), c2 = {}, h2 = i2.maxTextureSize, u2 = { [ve]: Ae, [Ae]: ve, [be]: be }, d2 = new Co({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new Vt() }, radius: { value: 4 } }, vertexShader: "void main() {\n	gl_Position = vec4( position, 1.0 );\n}", fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}" }), p2 = d2.clone();
  p2.defines.HORIZONTAL_PASS = 1;
  const _2 = new Zn();
  _2.setAttribute("position", new Hn(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  const g2 = new fo(_2, d2), m2 = this;
  function f2(i3, n3) {
    const r3 = t2.update(g2);
    d2.defines.VSM_SAMPLES !== i3.blurSamples && (d2.defines.VSM_SAMPLES = i3.blurSamples, p2.defines.VSM_SAMPLES = i3.blurSamples, d2.needsUpdate = true, p2.needsUpdate = true), null === i3.mapPass && (i3.mapPass = new li(o2.x, o2.y)), d2.uniforms.shadow_pass.value = i3.map.texture, d2.uniforms.resolution.value = i3.mapSize, d2.uniforms.radius.value = i3.radius, e3.setRenderTarget(i3.mapPass), e3.clear(), e3.renderBufferDirect(n3, null, r3, d2, g2, null), p2.uniforms.shadow_pass.value = i3.mapPass.texture, p2.uniforms.resolution.value = i3.mapSize, p2.uniforms.radius.value = i3.radius, e3.setRenderTarget(i3.map), e3.clear(), e3.renderBufferDirect(n3, null, r3, p2, g2, null);
  }
  function v2(t3, i3, n3, o3) {
    let r3 = null;
    const s3 = true === n3.isPointLight ? t3.customDistanceMaterial : t3.customDepthMaterial;
    if (void 0 !== s3)
      r3 = s3;
    else if (r3 = true === n3.isPointLight ? l2 : a2, e3.localClippingEnabled && true === i3.clipShadows && Array.isArray(i3.clippingPlanes) && 0 !== i3.clippingPlanes.length || i3.displacementMap && 0 !== i3.displacementScale || i3.alphaMap && i3.alphaTest > 0 || i3.map && i3.alphaTest > 0) {
      const e4 = r3.uuid, t4 = i3.uuid;
      let n4 = c2[e4];
      void 0 === n4 && (n4 = {}, c2[e4] = n4);
      let o4 = n4[t4];
      void 0 === o4 && (o4 = r3.clone(), n4[t4] = o4), r3 = o4;
    }
    if (r3.visible = i3.visible, r3.wireframe = i3.wireframe, r3.side = o3 === fe ? null !== i3.shadowSide ? i3.shadowSide : i3.side : null !== i3.shadowSide ? i3.shadowSide : u2[i3.side], r3.alphaMap = i3.alphaMap, r3.alphaTest = i3.alphaTest, r3.map = i3.map, r3.clipShadows = i3.clipShadows, r3.clippingPlanes = i3.clippingPlanes, r3.clipIntersection = i3.clipIntersection, r3.displacementMap = i3.displacementMap, r3.displacementScale = i3.displacementScale, r3.displacementBias = i3.displacementBias, r3.wireframeLinewidth = i3.wireframeLinewidth, r3.linewidth = i3.linewidth, true === n3.isPointLight && true === r3.isMeshDistanceMaterial) {
      e3.properties.get(r3).light = n3;
    }
    return r3;
  }
  function A2(i3, o3, r3, s3, a3) {
    if (false === i3.visible)
      return;
    if (i3.layers.test(o3.layers) && (i3.isMesh || i3.isLine || i3.isPoints) && (i3.castShadow || i3.receiveShadow && a3 === fe) && (!i3.frustumCulled || n2.intersectsObject(i3))) {
      i3.modelViewMatrix.multiplyMatrices(r3.matrixWorldInverse, i3.matrixWorld);
      const n3 = t2.update(i3), o4 = i3.material;
      if (Array.isArray(o4)) {
        const t3 = n3.groups;
        for (let l4 = 0, c3 = t3.length; l4 < c3; l4++) {
          const c4 = t3[l4], h3 = o4[c4.materialIndex];
          if (h3 && h3.visible) {
            const t4 = v2(i3, h3, s3, a3);
            e3.renderBufferDirect(r3, null, n3, t4, i3, c4);
          }
        }
      } else if (o4.visible) {
        const t3 = v2(i3, o4, s3, a3);
        e3.renderBufferDirect(r3, null, n3, t3, i3, null);
      }
    }
    const l3 = i3.children;
    for (let e4 = 0, t3 = l3.length; e4 < t3; e4++)
      A2(l3[e4], o3, r3, s3, a3);
  }
  this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = ge, this.render = function(t3, i3, a3) {
    if (false === m2.enabled)
      return;
    if (false === m2.autoUpdate && false === m2.needsUpdate)
      return;
    if (0 === t3.length)
      return;
    const l3 = e3.getRenderTarget(), c3 = e3.getActiveCubeFace(), u3 = e3.getActiveMipmapLevel(), d3 = e3.state;
    d3.setBlending(0), d3.buffers.color.setClear(1, 1, 1, 1), d3.buffers.depth.setTest(true), d3.setScissorTest(false);
    for (let l4 = 0, c4 = t3.length; l4 < c4; l4++) {
      const c5 = t3[l4], u4 = c5.shadow;
      if (void 0 === u4) {
        console.warn("THREE.WebGLShadowMap:", c5, "has no shadow.");
        continue;
      }
      if (false === u4.autoUpdate && false === u4.needsUpdate)
        continue;
      o2.copy(u4.mapSize);
      const p3 = u4.getFrameExtents();
      if (o2.multiply(p3), r2.copy(u4.mapSize), (o2.x > h2 || o2.y > h2) && (o2.x > h2 && (r2.x = Math.floor(h2 / p3.x), o2.x = r2.x * p3.x, u4.mapSize.x = r2.x), o2.y > h2 && (r2.y = Math.floor(h2 / p3.y), o2.y = r2.y * p3.y, u4.mapSize.y = r2.y)), null === u4.map) {
        const e4 = this.type !== fe ? { minFilter: Oe, magFilter: Oe } : {};
        u4.map = new li(o2.x, o2.y, e4), u4.map.texture.name = c5.name + ".shadowMap", u4.camera.updateProjectionMatrix();
      }
      e3.setRenderTarget(u4.map), e3.clear();
      const _3 = u4.getViewportCount();
      for (let e4 = 0; e4 < _3; e4++) {
        const t4 = u4.getViewport(e4);
        s2.set(r2.x * t4.x, r2.y * t4.y, r2.x * t4.z, r2.y * t4.w), d3.viewport(s2), u4.updateMatrices(c5, e4), n2 = u4.getFrustum(), A2(i3, a3, u4.camera, c5, this.type);
      }
      true !== u4.isPointLightShadow && this.type === fe && f2(u4, a3), u4.needsUpdate = false;
    }
    m2.needsUpdate = false, e3.setRenderTarget(l3, c3, u3);
  };
}
function ra(e3, t2, i2) {
  const n2 = i2.isWebGL2;
  const o2 = new function() {
    let t3 = false;
    const i3 = new ai();
    let n3 = null;
    const o3 = new ai(0, 0, 0, 0);
    return { setMask: function(i4) {
      n3 === i4 || t3 || (e3.colorMask(i4, i4, i4, i4), n3 = i4);
    }, setLocked: function(e4) {
      t3 = e4;
    }, setClear: function(t4, n4, r3, s3, a3) {
      true === a3 && (t4 *= s3, n4 *= s3, r3 *= s3), i3.set(t4, n4, r3, s3), false === o3.equals(i3) && (e3.clearColor(t4, n4, r3, s3), o3.copy(i3));
    }, reset: function() {
      t3 = false, n3 = null, o3.set(-1, 0, 0, 0);
    } };
  }(), r2 = new function() {
    let t3 = false, i3 = null, n3 = null, o3 = null;
    return { setTest: function(e4) {
      e4 ? U2(2929) : H2(2929);
    }, setMask: function(n4) {
      i3 === n4 || t3 || (e3.depthMask(n4), i3 = n4);
    }, setFunc: function(t4) {
      if (n3 !== t4) {
        switch (t4) {
          case 0:
            e3.depthFunc(512);
            break;
          case 1:
            e3.depthFunc(519);
            break;
          case 2:
            e3.depthFunc(513);
            break;
          case 3:
          default:
            e3.depthFunc(515);
            break;
          case 4:
            e3.depthFunc(514);
            break;
          case 5:
            e3.depthFunc(518);
            break;
          case 6:
            e3.depthFunc(516);
            break;
          case 7:
            e3.depthFunc(517);
        }
        n3 = t4;
      }
    }, setLocked: function(e4) {
      t3 = e4;
    }, setClear: function(t4) {
      o3 !== t4 && (e3.clearDepth(t4), o3 = t4);
    }, reset: function() {
      t3 = false, i3 = null, n3 = null, o3 = null;
    } };
  }(), s2 = new function() {
    let t3 = false, i3 = null, n3 = null, o3 = null, r3 = null, s3 = null, a3 = null, l3 = null, c3 = null;
    return { setTest: function(e4) {
      t3 || (e4 ? U2(2960) : H2(2960));
    }, setMask: function(n4) {
      i3 === n4 || t3 || (e3.stencilMask(n4), i3 = n4);
    }, setFunc: function(t4, i4, s4) {
      n3 === t4 && o3 === i4 && r3 === s4 || (e3.stencilFunc(t4, i4, s4), n3 = t4, o3 = i4, r3 = s4);
    }, setOp: function(t4, i4, n4) {
      s3 === t4 && a3 === i4 && l3 === n4 || (e3.stencilOp(t4, i4, n4), s3 = t4, a3 = i4, l3 = n4);
    }, setLocked: function(e4) {
      t3 = e4;
    }, setClear: function(t4) {
      c3 !== t4 && (e3.clearStencil(t4), c3 = t4);
    }, reset: function() {
      t3 = false, i3 = null, n3 = null, o3 = null, r3 = null, s3 = null, a3 = null, l3 = null, c3 = null;
    } };
  }(), a2 = /* @__PURE__ */ new WeakMap(), l2 = /* @__PURE__ */ new WeakMap();
  let c2 = {}, h2 = {}, u2 = /* @__PURE__ */ new WeakMap(), d2 = [], p2 = null, _2 = false, g2 = null, m2 = null, f2 = null, v2 = null, A2 = null, b2 = null, y2 = null, w2 = false, x2 = null, C2 = null, S2 = null, E2 = null, I2 = null;
  const T2 = e3.getParameter(35661);
  let B2 = false, M2 = 0;
  const k2 = e3.getParameter(7938);
  -1 !== k2.indexOf("WebGL") ? (M2 = parseFloat(/^WebGL (\d)/.exec(k2)[1]), B2 = M2 >= 1) : -1 !== k2.indexOf("OpenGL ES") && (M2 = parseFloat(/^OpenGL ES (\d)/.exec(k2)[1]), B2 = M2 >= 2);
  let R2 = null, P2 = {};
  const D2 = e3.getParameter(3088), L2 = e3.getParameter(2978), F2 = new ai().fromArray(D2), N2 = new ai().fromArray(L2);
  function O2(t3, i3, n3) {
    const o3 = new Uint8Array(4), r3 = e3.createTexture();
    e3.bindTexture(t3, r3), e3.texParameteri(t3, 10241, 9728), e3.texParameteri(t3, 10240, 9728);
    for (let t4 = 0; t4 < n3; t4++)
      e3.texImage2D(i3 + t4, 0, 6408, 1, 1, 0, 6408, 5121, o3);
    return r3;
  }
  const z2 = {};
  function U2(t3) {
    true !== c2[t3] && (e3.enable(t3), c2[t3] = true);
  }
  function H2(t3) {
    false !== c2[t3] && (e3.disable(t3), c2[t3] = false);
  }
  z2[3553] = O2(3553, 3553, 1), z2[34067] = O2(34067, 34069, 6), o2.setClear(0, 0, 0, 1), r2.setClear(1), s2.setClear(0), U2(2929), r2.setFunc(3), $2(false), W2(1), U2(2884), G2(0);
  const Q2 = { [ye]: 32774, 101: 32778, 102: 32779 };
  if (n2)
    Q2[103] = 32775, Q2[104] = 32776;
  else {
    const e4 = t2.get("EXT_blend_minmax");
    null !== e4 && (Q2[103] = e4.MIN_EXT, Q2[104] = e4.MAX_EXT);
  }
  const V2 = { 200: 0, 201: 1, 202: 768, 204: 770, 210: 776, 208: 774, 206: 772, 203: 769, 205: 771, 209: 775, 207: 773 };
  function G2(t3, i3, n3, o3, r3, s3, a3, l3) {
    if (0 !== t3) {
      if (false === _2 && (U2(3042), _2 = true), 5 === t3)
        r3 = r3 || i3, s3 = s3 || n3, a3 = a3 || o3, i3 === m2 && r3 === A2 || (e3.blendEquationSeparate(Q2[i3], Q2[r3]), m2 = i3, A2 = r3), n3 === f2 && o3 === v2 && s3 === b2 && a3 === y2 || (e3.blendFuncSeparate(V2[n3], V2[o3], V2[s3], V2[a3]), f2 = n3, v2 = o3, b2 = s3, y2 = a3), g2 = t3, w2 = false;
      else if (t3 !== g2 || l3 !== w2) {
        if (m2 === ye && A2 === ye || (e3.blendEquation(32774), m2 = ye, A2 = ye), l3)
          switch (t3) {
            case 1:
              e3.blendFuncSeparate(1, 771, 1, 771);
              break;
            case 2:
              e3.blendFunc(1, 1);
              break;
            case 3:
              e3.blendFuncSeparate(0, 769, 0, 1);
              break;
            case 4:
              e3.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", t3);
          }
        else
          switch (t3) {
            case 1:
              e3.blendFuncSeparate(770, 771, 1, 771);
              break;
            case 2:
              e3.blendFunc(770, 1);
              break;
            case 3:
              e3.blendFuncSeparate(0, 769, 0, 1);
              break;
            case 4:
              e3.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", t3);
          }
        f2 = null, v2 = null, b2 = null, y2 = null, g2 = t3, w2 = l3;
      }
    } else
      true === _2 && (H2(3042), _2 = false);
  }
  function $2(t3) {
    x2 !== t3 && (t3 ? e3.frontFace(2304) : e3.frontFace(2305), x2 = t3);
  }
  function W2(t3) {
    0 !== t3 ? (U2(2884), t3 !== C2 && (1 === t3 ? e3.cullFace(1029) : 2 === t3 ? e3.cullFace(1028) : e3.cullFace(1032))) : H2(2884), C2 = t3;
  }
  function q2(t3, i3, n3) {
    t3 ? (U2(32823), E2 === i3 && I2 === n3 || (e3.polygonOffset(i3, n3), E2 = i3, I2 = n3)) : H2(32823);
  }
  return { buffers: { color: o2, depth: r2, stencil: s2 }, enable: U2, disable: H2, bindFramebuffer: function(t3, i3) {
    return h2[t3] !== i3 && (e3.bindFramebuffer(t3, i3), h2[t3] = i3, n2 && (36009 === t3 && (h2[36160] = i3), 36160 === t3 && (h2[36009] = i3)), true);
  }, drawBuffers: function(n3, o3) {
    let r3 = d2, s3 = false;
    if (n3)
      if (r3 = u2.get(o3), void 0 === r3 && (r3 = [], u2.set(o3, r3)), n3.isWebGLMultipleRenderTargets) {
        const e4 = n3.texture;
        if (r3.length !== e4.length || 36064 !== r3[0]) {
          for (let t3 = 0, i3 = e4.length; t3 < i3; t3++)
            r3[t3] = 36064 + t3;
          r3.length = e4.length, s3 = true;
        }
      } else
        36064 !== r3[0] && (r3[0] = 36064, s3 = true);
    else
      1029 !== r3[0] && (r3[0] = 1029, s3 = true);
    s3 && (i2.isWebGL2 ? e3.drawBuffers(r3) : t2.get("WEBGL_draw_buffers").drawBuffersWEBGL(r3));
  }, useProgram: function(t3) {
    return p2 !== t3 && (e3.useProgram(t3), p2 = t3, true);
  }, setBlending: G2, setMaterial: function(e4, t3) {
    e4.side === be ? H2(2884) : U2(2884);
    let i3 = e4.side === Ae;
    t3 && (i3 = !i3), $2(i3), 1 === e4.blending && false === e4.transparent ? G2(0) : G2(e4.blending, e4.blendEquation, e4.blendSrc, e4.blendDst, e4.blendEquationAlpha, e4.blendSrcAlpha, e4.blendDstAlpha, e4.premultipliedAlpha), r2.setFunc(e4.depthFunc), r2.setTest(e4.depthTest), r2.setMask(e4.depthWrite), o2.setMask(e4.colorWrite);
    const n3 = e4.stencilWrite;
    s2.setTest(n3), n3 && (s2.setMask(e4.stencilWriteMask), s2.setFunc(e4.stencilFunc, e4.stencilRef, e4.stencilFuncMask), s2.setOp(e4.stencilFail, e4.stencilZFail, e4.stencilZPass)), q2(e4.polygonOffset, e4.polygonOffsetFactor, e4.polygonOffsetUnits), true === e4.alphaToCoverage ? U2(32926) : H2(32926);
  }, setFlipSided: $2, setCullFace: W2, setLineWidth: function(t3) {
    t3 !== S2 && (B2 && e3.lineWidth(t3), S2 = t3);
  }, setPolygonOffset: q2, setScissorTest: function(e4) {
    e4 ? U2(3089) : H2(3089);
  }, activeTexture: function(t3) {
    void 0 === t3 && (t3 = 33984 + T2 - 1), R2 !== t3 && (e3.activeTexture(t3), R2 = t3);
  }, bindTexture: function(t3, i3, n3) {
    void 0 === n3 && (n3 = null === R2 ? 33984 + T2 - 1 : R2);
    let o3 = P2[n3];
    void 0 === o3 && (o3 = { type: void 0, texture: void 0 }, P2[n3] = o3), o3.type === t3 && o3.texture === i3 || (R2 !== n3 && (e3.activeTexture(n3), R2 = n3), e3.bindTexture(t3, i3 || z2[t3]), o3.type = t3, o3.texture = i3);
  }, unbindTexture: function() {
    const t3 = P2[R2];
    void 0 !== t3 && void 0 !== t3.type && (e3.bindTexture(t3.type, null), t3.type = void 0, t3.texture = void 0);
  }, compressedTexImage2D: function() {
    try {
      e3.compressedTexImage2D.apply(e3, arguments);
    } catch (e4) {
      console.error("THREE.WebGLState:", e4);
    }
  }, compressedTexImage3D: function() {
    try {
      e3.compressedTexImage3D.apply(e3, arguments);
    } catch (e4) {
      console.error("THREE.WebGLState:", e4);
    }
  }, texImage2D: function() {
    try {
      e3.texImage2D.apply(e3, arguments);
    } catch (e4) {
      console.error("THREE.WebGLState:", e4);
    }
  }, texImage3D: function() {
    try {
      e3.texImage3D.apply(e3, arguments);
    } catch (e4) {
      console.error("THREE.WebGLState:", e4);
    }
  }, updateUBOMapping: function(t3, i3) {
    let n3 = l2.get(i3);
    void 0 === n3 && (n3 = /* @__PURE__ */ new WeakMap(), l2.set(i3, n3));
    let o3 = n3.get(t3);
    void 0 === o3 && (o3 = e3.getUniformBlockIndex(i3, t3.name), n3.set(t3, o3));
  }, uniformBlockBinding: function(t3, i3) {
    const n3 = l2.get(i3).get(t3);
    a2.get(i3) !== n3 && (e3.uniformBlockBinding(i3, n3, t3.__bindingPointIndex), a2.set(i3, n3));
  }, texStorage2D: function() {
    try {
      e3.texStorage2D.apply(e3, arguments);
    } catch (e4) {
      console.error("THREE.WebGLState:", e4);
    }
  }, texStorage3D: function() {
    try {
      e3.texStorage3D.apply(e3, arguments);
    } catch (e4) {
      console.error("THREE.WebGLState:", e4);
    }
  }, texSubImage2D: function() {
    try {
      e3.texSubImage2D.apply(e3, arguments);
    } catch (e4) {
      console.error("THREE.WebGLState:", e4);
    }
  }, texSubImage3D: function() {
    try {
      e3.texSubImage3D.apply(e3, arguments);
    } catch (e4) {
      console.error("THREE.WebGLState:", e4);
    }
  }, compressedTexSubImage2D: function() {
    try {
      e3.compressedTexSubImage2D.apply(e3, arguments);
    } catch (e4) {
      console.error("THREE.WebGLState:", e4);
    }
  }, compressedTexSubImage3D: function() {
    try {
      e3.compressedTexSubImage3D.apply(e3, arguments);
    } catch (e4) {
      console.error("THREE.WebGLState:", e4);
    }
  }, scissor: function(t3) {
    false === F2.equals(t3) && (e3.scissor(t3.x, t3.y, t3.z, t3.w), F2.copy(t3));
  }, viewport: function(t3) {
    false === N2.equals(t3) && (e3.viewport(t3.x, t3.y, t3.z, t3.w), N2.copy(t3));
  }, reset: function() {
    e3.disable(3042), e3.disable(2884), e3.disable(2929), e3.disable(32823), e3.disable(3089), e3.disable(2960), e3.disable(32926), e3.blendEquation(32774), e3.blendFunc(1, 0), e3.blendFuncSeparate(1, 0, 1, 0), e3.colorMask(true, true, true, true), e3.clearColor(0, 0, 0, 0), e3.depthMask(true), e3.depthFunc(513), e3.clearDepth(1), e3.stencilMask(4294967295), e3.stencilFunc(519, 0, 4294967295), e3.stencilOp(7680, 7680, 7680), e3.clearStencil(0), e3.cullFace(1029), e3.frontFace(2305), e3.polygonOffset(0, 0), e3.activeTexture(33984), e3.bindFramebuffer(36160, null), true === n2 && (e3.bindFramebuffer(36009, null), e3.bindFramebuffer(36008, null)), e3.useProgram(null), e3.lineWidth(1), e3.scissor(0, 0, e3.canvas.width, e3.canvas.height), e3.viewport(0, 0, e3.canvas.width, e3.canvas.height), c2 = {}, R2 = null, P2 = {}, h2 = {}, u2 = /* @__PURE__ */ new WeakMap(), d2 = [], p2 = null, _2 = false, g2 = null, m2 = null, f2 = null, v2 = null, A2 = null, b2 = null, y2 = null, w2 = false, x2 = null, C2 = null, S2 = null, E2 = null, I2 = null, F2.set(0, 0, e3.canvas.width, e3.canvas.height), N2.set(0, 0, e3.canvas.width, e3.canvas.height), o2.reset(), r2.reset(), s2.reset();
  } };
}
function sa(e3, t2, i2, n2, o2, r2, s2) {
  const a2 = o2.isWebGL2, l2 = o2.maxTextures, c2 = o2.maxCubemapSize, h2 = o2.maxTextureSize, u2 = o2.maxSamples, d2 = t2.has("WEBGL_multisampled_render_to_texture") ? t2.get("WEBGL_multisampled_render_to_texture") : null, p2 = "undefined" != typeof navigator && /OculusBrowser/g.test(navigator.userAgent), _2 = /* @__PURE__ */ new WeakMap();
  let g2;
  const m2 = /* @__PURE__ */ new WeakMap();
  let f2 = false;
  try {
    f2 = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d");
  } catch (e4) {
  }
  function v2(e4, t3) {
    return f2 ? new OffscreenCanvas(e4, t3) : qt("canvas");
  }
  function A2(e4, t3, i3, n3) {
    let o3 = 1;
    if ((e4.width > n3 || e4.height > n3) && (o3 = n3 / Math.max(e4.width, e4.height)), o3 < 1 || true === t3) {
      if ("undefined" != typeof HTMLImageElement && e4 instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e4 instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e4 instanceof ImageBitmap) {
        const n4 = t3 ? zt : Math.floor, r3 = n4(o3 * e4.width), s3 = n4(o3 * e4.height);
        void 0 === g2 && (g2 = v2(r3, s3));
        const a3 = i3 ? v2(r3, s3) : g2;
        a3.width = r3, a3.height = s3;
        return a3.getContext("2d").drawImage(e4, 0, 0, r3, s3), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e4.width + "x" + e4.height + ") to (" + r3 + "x" + s3 + ")."), a3;
      }
      return "data" in e4 && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e4.width + "x" + e4.height + ")."), e4;
    }
    return e4;
  }
  function b2(e4) {
    return Nt(e4.width) && Nt(e4.height);
  }
  function y2(e4, t3) {
    return e4.generateMipmaps && t3 && e4.minFilter !== Oe && e4.minFilter !== He;
  }
  function w2(t3) {
    e3.generateMipmap(t3);
  }
  function x2(i3, n3, o3, r3, s3 = false) {
    if (false === a2)
      return n3;
    if (null !== i3) {
      if (void 0 !== e3[i3])
        return e3[i3];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + i3 + "'");
    }
    let l3 = n3;
    return 6403 === n3 && (5126 === o3 && (l3 = 33326), 5131 === o3 && (l3 = 33325), 5121 === o3 && (l3 = 33321)), 33319 === n3 && (5126 === o3 && (l3 = 33328), 5131 === o3 && (l3 = 33327), 5121 === o3 && (l3 = 33323)), 6408 === n3 && (5126 === o3 && (l3 = 34836), 5131 === o3 && (l3 = 34842), 5121 === o3 && (l3 = r3 === bt && false === s3 ? 35907 : 32856), 32819 === o3 && (l3 = 32854), 32820 === o3 && (l3 = 32855)), 33325 !== l3 && 33326 !== l3 && 33327 !== l3 && 33328 !== l3 && 34842 !== l3 && 34836 !== l3 || t2.get("EXT_color_buffer_float"), l3;
  }
  function C2(e4, t3, i3) {
    return true === y2(e4, i3) || e4.isFramebufferTexture && e4.minFilter !== Oe && e4.minFilter !== He ? Math.log2(Math.max(t3.width, t3.height)) + 1 : void 0 !== e4.mipmaps && e4.mipmaps.length > 0 ? e4.mipmaps.length : e4.isCompressedTexture && Array.isArray(e4.image) ? t3.mipmaps.length : 1;
  }
  function S2(e4) {
    return e4 === Oe || e4 === ze || e4 === Ue ? 9728 : 9729;
  }
  function E2(e4) {
    const t3 = e4.target;
    t3.removeEventListener("dispose", E2), function(e5) {
      const t4 = n2.get(e5);
      if (void 0 === t4.__webglInit)
        return;
      const i3 = e5.source, o3 = m2.get(i3);
      if (o3) {
        const n3 = o3[t4.__cacheKey];
        n3.usedTimes--, 0 === n3.usedTimes && T2(e5), 0 === Object.keys(o3).length && m2.delete(i3);
      }
      n2.remove(e5);
    }(t3), t3.isVideoTexture && _2.delete(t3);
  }
  function I2(t3) {
    const i3 = t3.target;
    i3.removeEventListener("dispose", I2), function(t4) {
      const i4 = t4.texture, o3 = n2.get(t4), r3 = n2.get(i4);
      void 0 !== r3.__webglTexture && (e3.deleteTexture(r3.__webglTexture), s2.memory.textures--);
      t4.depthTexture && t4.depthTexture.dispose();
      if (t4.isWebGLCubeRenderTarget)
        for (let t5 = 0; t5 < 6; t5++)
          e3.deleteFramebuffer(o3.__webglFramebuffer[t5]), o3.__webglDepthbuffer && e3.deleteRenderbuffer(o3.__webglDepthbuffer[t5]);
      else {
        if (e3.deleteFramebuffer(o3.__webglFramebuffer), o3.__webglDepthbuffer && e3.deleteRenderbuffer(o3.__webglDepthbuffer), o3.__webglMultisampledFramebuffer && e3.deleteFramebuffer(o3.__webglMultisampledFramebuffer), o3.__webglColorRenderbuffer)
          for (let t5 = 0; t5 < o3.__webglColorRenderbuffer.length; t5++)
            o3.__webglColorRenderbuffer[t5] && e3.deleteRenderbuffer(o3.__webglColorRenderbuffer[t5]);
        o3.__webglDepthRenderbuffer && e3.deleteRenderbuffer(o3.__webglDepthRenderbuffer);
      }
      if (t4.isWebGLMultipleRenderTargets)
        for (let t5 = 0, o4 = i4.length; t5 < o4; t5++) {
          const o5 = n2.get(i4[t5]);
          o5.__webglTexture && (e3.deleteTexture(o5.__webglTexture), s2.memory.textures--), n2.remove(i4[t5]);
        }
      n2.remove(i4), n2.remove(t4);
    }(i3);
  }
  function T2(t3) {
    const i3 = n2.get(t3);
    e3.deleteTexture(i3.__webglTexture);
    const o3 = t3.source;
    delete m2.get(o3)[i3.__cacheKey], s2.memory.textures--;
  }
  let B2 = 0;
  function M2(e4, t3) {
    const o3 = n2.get(e4);
    if (e4.isVideoTexture && function(e5) {
      const t4 = s2.render.frame;
      _2.get(e5) !== t4 && (_2.set(e5, t4), e5.update());
    }(e4), false === e4.isRenderTargetTexture && e4.version > 0 && o3.__version !== e4.version) {
      const i3 = e4.image;
      if (null === i3)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else {
        if (false !== i3.complete)
          return void L2(o3, e4, t3);
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      }
    }
    i2.bindTexture(3553, o3.__webglTexture, 33984 + t3);
  }
  const k2 = { [Le]: 10497, [Fe]: 33071, [Ne]: 33648 }, R2 = { [Oe]: 9728, [ze]: 9984, [Ue]: 9986, [He]: 9729, [Qe]: 9985, [Ve]: 9987 };
  function P2(i3, r3, s3) {
    if (s3 ? (e3.texParameteri(i3, 10242, k2[r3.wrapS]), e3.texParameteri(i3, 10243, k2[r3.wrapT]), 32879 !== i3 && 35866 !== i3 || e3.texParameteri(i3, 32882, k2[r3.wrapR]), e3.texParameteri(i3, 10240, R2[r3.magFilter]), e3.texParameteri(i3, 10241, R2[r3.minFilter])) : (e3.texParameteri(i3, 10242, 33071), e3.texParameteri(i3, 10243, 33071), 32879 !== i3 && 35866 !== i3 || e3.texParameteri(i3, 32882, 33071), r3.wrapS === Fe && r3.wrapT === Fe || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e3.texParameteri(i3, 10240, S2(r3.magFilter)), e3.texParameteri(i3, 10241, S2(r3.minFilter)), r3.minFilter !== Oe && r3.minFilter !== He && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), true === t2.has("EXT_texture_filter_anisotropic")) {
      const s4 = t2.get("EXT_texture_filter_anisotropic");
      if (r3.magFilter === Oe)
        return;
      if (r3.minFilter !== Ue && r3.minFilter !== Ve)
        return;
      if (r3.type === We && false === t2.has("OES_texture_float_linear"))
        return;
      if (false === a2 && r3.type === qe && false === t2.has("OES_texture_half_float_linear"))
        return;
      (r3.anisotropy > 1 || n2.get(r3).__currentAnisotropy) && (e3.texParameterf(i3, s4.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(r3.anisotropy, o2.getMaxAnisotropy())), n2.get(r3).__currentAnisotropy = r3.anisotropy);
    }
  }
  function D2(t3, i3) {
    let n3 = false;
    void 0 === t3.__webglInit && (t3.__webglInit = true, i3.addEventListener("dispose", E2));
    const o3 = i3.source;
    let r3 = m2.get(o3);
    void 0 === r3 && (r3 = {}, m2.set(o3, r3));
    const a3 = function(e4) {
      const t4 = [];
      return t4.push(e4.wrapS), t4.push(e4.wrapT), t4.push(e4.wrapR || 0), t4.push(e4.magFilter), t4.push(e4.minFilter), t4.push(e4.anisotropy), t4.push(e4.internalFormat), t4.push(e4.format), t4.push(e4.type), t4.push(e4.generateMipmaps), t4.push(e4.premultiplyAlpha), t4.push(e4.flipY), t4.push(e4.unpackAlignment), t4.push(e4.encoding), t4.join();
    }(i3);
    if (a3 !== t3.__cacheKey) {
      void 0 === r3[a3] && (r3[a3] = { texture: e3.createTexture(), usedTimes: 0 }, s2.memory.textures++, n3 = true), r3[a3].usedTimes++;
      const o4 = r3[t3.__cacheKey];
      void 0 !== o4 && (r3[t3.__cacheKey].usedTimes--, 0 === o4.usedTimes && T2(i3)), t3.__cacheKey = a3, t3.__webglTexture = r3[a3].texture;
    }
    return n3;
  }
  function L2(t3, o3, s3) {
    let l3 = 3553;
    (o3.isDataArrayTexture || o3.isCompressedArrayTexture) && (l3 = 35866), o3.isData3DTexture && (l3 = 32879);
    const c3 = D2(t3, o3), u3 = o3.source;
    i2.bindTexture(l3, t3.__webglTexture, 33984 + s3);
    const d3 = n2.get(u3);
    if (u3.version !== d3.__version || true === c3) {
      i2.activeTexture(33984 + s3), e3.pixelStorei(37440, o3.flipY), e3.pixelStorei(37441, o3.premultiplyAlpha), e3.pixelStorei(3317, o3.unpackAlignment), e3.pixelStorei(37443, 0);
      const t4 = function(e4) {
        return !a2 && (e4.wrapS !== Fe || e4.wrapT !== Fe || e4.minFilter !== Oe && e4.minFilter !== He);
      }(o3) && false === b2(o3.image);
      let n3 = A2(o3.image, t4, false, h2);
      n3 = H2(o3, n3);
      const p3 = b2(n3) || a2, _3 = r2.convert(o3.format, o3.encoding);
      let g3, m3 = r2.convert(o3.type), f3 = x2(o3.internalFormat, _3, m3, o3.encoding, o3.isVideoTexture);
      P2(l3, o3, p3);
      const v3 = o3.mipmaps, S3 = a2 && true !== o3.isVideoTexture, E3 = void 0 === d3.__version || true === c3, I3 = C2(o3, n3, p3);
      if (o3.isDepthTexture)
        f3 = 6402, a2 ? f3 = o3.type === We ? 36012 : o3.type === $e ? 33190 : o3.type === je ? 35056 : 33189 : o3.type === We && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), o3.format === Ye && 6402 === f3 && 1012 !== o3.type && o3.type !== $e && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), o3.type = $e, m3 = r2.convert(o3.type)), o3.format === Ke && 6402 === f3 && (f3 = 34041, o3.type !== je && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), o3.type = je, m3 = r2.convert(o3.type))), E3 && (S3 ? i2.texStorage2D(3553, 1, f3, n3.width, n3.height) : i2.texImage2D(3553, 0, f3, n3.width, n3.height, 0, _3, m3, null));
      else if (o3.isDataTexture)
        if (v3.length > 0 && p3) {
          S3 && E3 && i2.texStorage2D(3553, I3, f3, v3[0].width, v3[0].height);
          for (let e4 = 0, t5 = v3.length; e4 < t5; e4++)
            g3 = v3[e4], S3 ? i2.texSubImage2D(3553, e4, 0, 0, g3.width, g3.height, _3, m3, g3.data) : i2.texImage2D(3553, e4, f3, g3.width, g3.height, 0, _3, m3, g3.data);
          o3.generateMipmaps = false;
        } else
          S3 ? (E3 && i2.texStorage2D(3553, I3, f3, n3.width, n3.height), i2.texSubImage2D(3553, 0, 0, 0, n3.width, n3.height, _3, m3, n3.data)) : i2.texImage2D(3553, 0, f3, n3.width, n3.height, 0, _3, m3, n3.data);
      else if (o3.isCompressedTexture)
        if (o3.isCompressedArrayTexture) {
          S3 && E3 && i2.texStorage3D(35866, I3, f3, v3[0].width, v3[0].height, n3.depth);
          for (let e4 = 0, t5 = v3.length; e4 < t5; e4++)
            g3 = v3[e4], o3.format !== Xe ? null !== _3 ? S3 ? i2.compressedTexSubImage3D(35866, e4, 0, 0, 0, g3.width, g3.height, n3.depth, _3, g3.data, 0, 0) : i2.compressedTexImage3D(35866, e4, f3, g3.width, g3.height, n3.depth, 0, g3.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : S3 ? i2.texSubImage3D(35866, e4, 0, 0, 0, g3.width, g3.height, n3.depth, _3, m3, g3.data) : i2.texImage3D(35866, e4, f3, g3.width, g3.height, n3.depth, 0, _3, m3, g3.data);
        } else {
          S3 && E3 && i2.texStorage2D(3553, I3, f3, v3[0].width, v3[0].height);
          for (let e4 = 0, t5 = v3.length; e4 < t5; e4++)
            g3 = v3[e4], o3.format !== Xe ? null !== _3 ? S3 ? i2.compressedTexSubImage2D(3553, e4, 0, 0, g3.width, g3.height, _3, g3.data) : i2.compressedTexImage2D(3553, e4, f3, g3.width, g3.height, 0, g3.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : S3 ? i2.texSubImage2D(3553, e4, 0, 0, g3.width, g3.height, _3, m3, g3.data) : i2.texImage2D(3553, e4, f3, g3.width, g3.height, 0, _3, m3, g3.data);
        }
      else if (o3.isDataArrayTexture)
        S3 ? (E3 && i2.texStorage3D(35866, I3, f3, n3.width, n3.height, n3.depth), i2.texSubImage3D(35866, 0, 0, 0, 0, n3.width, n3.height, n3.depth, _3, m3, n3.data)) : i2.texImage3D(35866, 0, f3, n3.width, n3.height, n3.depth, 0, _3, m3, n3.data);
      else if (o3.isData3DTexture)
        S3 ? (E3 && i2.texStorage3D(32879, I3, f3, n3.width, n3.height, n3.depth), i2.texSubImage3D(32879, 0, 0, 0, 0, n3.width, n3.height, n3.depth, _3, m3, n3.data)) : i2.texImage3D(32879, 0, f3, n3.width, n3.height, n3.depth, 0, _3, m3, n3.data);
      else if (o3.isFramebufferTexture) {
        if (E3)
          if (S3)
            i2.texStorage2D(3553, I3, f3, n3.width, n3.height);
          else {
            let e4 = n3.width, t5 = n3.height;
            for (let n4 = 0; n4 < I3; n4++)
              i2.texImage2D(3553, n4, f3, e4, t5, 0, _3, m3, null), e4 >>= 1, t5 >>= 1;
          }
      } else if (v3.length > 0 && p3) {
        S3 && E3 && i2.texStorage2D(3553, I3, f3, v3[0].width, v3[0].height);
        for (let e4 = 0, t5 = v3.length; e4 < t5; e4++)
          g3 = v3[e4], S3 ? i2.texSubImage2D(3553, e4, 0, 0, _3, m3, g3) : i2.texImage2D(3553, e4, f3, _3, m3, g3);
        o3.generateMipmaps = false;
      } else
        S3 ? (E3 && i2.texStorage2D(3553, I3, f3, n3.width, n3.height), i2.texSubImage2D(3553, 0, 0, 0, _3, m3, n3)) : i2.texImage2D(3553, 0, f3, _3, m3, n3);
      y2(o3, p3) && w2(l3), d3.__version = u3.version, o3.onUpdate && o3.onUpdate(o3);
    }
    t3.__version = o3.version;
  }
  function F2(t3, o3, s3, a3, l3) {
    const c3 = r2.convert(s3.format, s3.encoding), h3 = r2.convert(s3.type), u3 = x2(s3.internalFormat, c3, h3, s3.encoding);
    n2.get(o3).__hasExternalTextures || (32879 === l3 || 35866 === l3 ? i2.texImage3D(l3, 0, u3, o3.width, o3.height, o3.depth, 0, c3, h3, null) : i2.texImage2D(l3, 0, u3, o3.width, o3.height, 0, c3, h3, null)), i2.bindFramebuffer(36160, t3), U2(o3) ? d2.framebufferTexture2DMultisampleEXT(36160, a3, l3, n2.get(s3).__webglTexture, 0, z2(o3)) : (3553 === l3 || l3 >= 34069 && l3 <= 34074) && e3.framebufferTexture2D(36160, a3, l3, n2.get(s3).__webglTexture, 0), i2.bindFramebuffer(36160, null);
  }
  function N2(t3, i3, n3) {
    if (e3.bindRenderbuffer(36161, t3), i3.depthBuffer && !i3.stencilBuffer) {
      let o3 = 33189;
      if (n3 || U2(i3)) {
        const t4 = i3.depthTexture;
        t4 && t4.isDepthTexture && (t4.type === We ? o3 = 36012 : t4.type === $e && (o3 = 33190));
        const n4 = z2(i3);
        U2(i3) ? d2.renderbufferStorageMultisampleEXT(36161, n4, o3, i3.width, i3.height) : e3.renderbufferStorageMultisample(36161, n4, o3, i3.width, i3.height);
      } else
        e3.renderbufferStorage(36161, o3, i3.width, i3.height);
      e3.framebufferRenderbuffer(36160, 36096, 36161, t3);
    } else if (i3.depthBuffer && i3.stencilBuffer) {
      const o3 = z2(i3);
      n3 && false === U2(i3) ? e3.renderbufferStorageMultisample(36161, o3, 35056, i3.width, i3.height) : U2(i3) ? d2.renderbufferStorageMultisampleEXT(36161, o3, 35056, i3.width, i3.height) : e3.renderbufferStorage(36161, 34041, i3.width, i3.height), e3.framebufferRenderbuffer(36160, 33306, 36161, t3);
    } else {
      const t4 = true === i3.isWebGLMultipleRenderTargets ? i3.texture : [i3.texture];
      for (let o3 = 0; o3 < t4.length; o3++) {
        const s3 = t4[o3], a3 = r2.convert(s3.format, s3.encoding), l3 = r2.convert(s3.type), c3 = x2(s3.internalFormat, a3, l3, s3.encoding), h3 = z2(i3);
        n3 && false === U2(i3) ? e3.renderbufferStorageMultisample(36161, h3, c3, i3.width, i3.height) : U2(i3) ? d2.renderbufferStorageMultisampleEXT(36161, h3, c3, i3.width, i3.height) : e3.renderbufferStorage(36161, c3, i3.width, i3.height);
      }
    }
    e3.bindRenderbuffer(36161, null);
  }
  function O2(t3) {
    const o3 = n2.get(t3), r3 = true === t3.isWebGLCubeRenderTarget;
    if (t3.depthTexture && !o3.__autoAllocateDepthBuffer) {
      if (r3)
        throw new Error("target.depthTexture not supported in Cube render targets");
      !function(t4, o4) {
        if (o4 && o4.isWebGLCubeRenderTarget)
          throw new Error("Depth Texture with cube render targets is not supported");
        if (i2.bindFramebuffer(36160, t4), !o4.depthTexture || !o4.depthTexture.isDepthTexture)
          throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        n2.get(o4.depthTexture).__webglTexture && o4.depthTexture.image.width === o4.width && o4.depthTexture.image.height === o4.height || (o4.depthTexture.image.width = o4.width, o4.depthTexture.image.height = o4.height, o4.depthTexture.needsUpdate = true), M2(o4.depthTexture, 0);
        const r4 = n2.get(o4.depthTexture).__webglTexture, s3 = z2(o4);
        if (o4.depthTexture.format === Ye)
          U2(o4) ? d2.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, r4, 0, s3) : e3.framebufferTexture2D(36160, 36096, 3553, r4, 0);
        else {
          if (o4.depthTexture.format !== Ke)
            throw new Error("Unknown depthTexture format");
          U2(o4) ? d2.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, r4, 0, s3) : e3.framebufferTexture2D(36160, 33306, 3553, r4, 0);
        }
      }(o3.__webglFramebuffer, t3);
    } else if (r3) {
      o3.__webglDepthbuffer = [];
      for (let n3 = 0; n3 < 6; n3++)
        i2.bindFramebuffer(36160, o3.__webglFramebuffer[n3]), o3.__webglDepthbuffer[n3] = e3.createRenderbuffer(), N2(o3.__webglDepthbuffer[n3], t3, false);
    } else
      i2.bindFramebuffer(36160, o3.__webglFramebuffer), o3.__webglDepthbuffer = e3.createRenderbuffer(), N2(o3.__webglDepthbuffer, t3, false);
    i2.bindFramebuffer(36160, null);
  }
  function z2(e4) {
    return Math.min(u2, e4.samples);
  }
  function U2(e4) {
    const i3 = n2.get(e4);
    return a2 && e4.samples > 0 && true === t2.has("WEBGL_multisampled_render_to_texture") && false !== i3.__useRenderToTexture;
  }
  function H2(e4, i3) {
    const n3 = e4.encoding, o3 = e4.format, r3 = e4.type;
    return true === e4.isCompressedTexture || true === e4.isVideoTexture || e4.format === It || n3 !== At && (n3 === bt ? false === a2 ? true === t2.has("EXT_sRGB") && o3 === Xe ? (e4.format = It, e4.minFilter = He, e4.generateMipmaps = false) : i3 = ii.sRGBToLinear(i3) : o3 === Xe && r3 === Ge || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", n3)), i3;
  }
  this.allocateTextureUnit = function() {
    const e4 = B2;
    return e4 >= l2 && console.warn("THREE.WebGLTextures: Trying to use " + e4 + " texture units while this GPU supports only " + l2), B2 += 1, e4;
  }, this.resetTextureUnits = function() {
    B2 = 0;
  }, this.setTexture2D = M2, this.setTexture2DArray = function(e4, t3) {
    const o3 = n2.get(e4);
    e4.version > 0 && o3.__version !== e4.version ? L2(o3, e4, t3) : i2.bindTexture(35866, o3.__webglTexture, 33984 + t3);
  }, this.setTexture3D = function(e4, t3) {
    const o3 = n2.get(e4);
    e4.version > 0 && o3.__version !== e4.version ? L2(o3, e4, t3) : i2.bindTexture(32879, o3.__webglTexture, 33984 + t3);
  }, this.setTextureCube = function(t3, o3) {
    const s3 = n2.get(t3);
    t3.version > 0 && s3.__version !== t3.version ? function(t4, o4, s4) {
      if (6 !== o4.image.length)
        return;
      const l3 = D2(t4, o4), h3 = o4.source;
      i2.bindTexture(34067, t4.__webglTexture, 33984 + s4);
      const u3 = n2.get(h3);
      if (h3.version !== u3.__version || true === l3) {
        i2.activeTexture(33984 + s4), e3.pixelStorei(37440, o4.flipY), e3.pixelStorei(37441, o4.premultiplyAlpha), e3.pixelStorei(3317, o4.unpackAlignment), e3.pixelStorei(37443, 0);
        const t5 = o4.isCompressedTexture || o4.image[0].isCompressedTexture, n3 = o4.image[0] && o4.image[0].isDataTexture, d3 = [];
        for (let e4 = 0; e4 < 6; e4++)
          d3[e4] = t5 || n3 ? n3 ? o4.image[e4].image : o4.image[e4] : A2(o4.image[e4], false, true, c2), d3[e4] = H2(o4, d3[e4]);
        const p3 = d3[0], _3 = b2(p3) || a2, g3 = r2.convert(o4.format, o4.encoding), m3 = r2.convert(o4.type), f3 = x2(o4.internalFormat, g3, m3, o4.encoding), v3 = a2 && true !== o4.isVideoTexture, S3 = void 0 === u3.__version || true === l3;
        let E3, I3 = C2(o4, p3, _3);
        if (P2(34067, o4, _3), t5) {
          v3 && S3 && i2.texStorage2D(34067, I3, f3, p3.width, p3.height);
          for (let e4 = 0; e4 < 6; e4++) {
            E3 = d3[e4].mipmaps;
            for (let t6 = 0; t6 < E3.length; t6++) {
              const n4 = E3[t6];
              o4.format !== Xe ? null !== g3 ? v3 ? i2.compressedTexSubImage2D(34069 + e4, t6, 0, 0, n4.width, n4.height, g3, n4.data) : i2.compressedTexImage2D(34069 + e4, t6, f3, n4.width, n4.height, 0, n4.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : v3 ? i2.texSubImage2D(34069 + e4, t6, 0, 0, n4.width, n4.height, g3, m3, n4.data) : i2.texImage2D(34069 + e4, t6, f3, n4.width, n4.height, 0, g3, m3, n4.data);
            }
          }
        } else {
          E3 = o4.mipmaps, v3 && S3 && (E3.length > 0 && I3++, i2.texStorage2D(34067, I3, f3, d3[0].width, d3[0].height));
          for (let e4 = 0; e4 < 6; e4++)
            if (n3) {
              v3 ? i2.texSubImage2D(34069 + e4, 0, 0, 0, d3[e4].width, d3[e4].height, g3, m3, d3[e4].data) : i2.texImage2D(34069 + e4, 0, f3, d3[e4].width, d3[e4].height, 0, g3, m3, d3[e4].data);
              for (let t6 = 0; t6 < E3.length; t6++) {
                const n4 = E3[t6].image[e4].image;
                v3 ? i2.texSubImage2D(34069 + e4, t6 + 1, 0, 0, n4.width, n4.height, g3, m3, n4.data) : i2.texImage2D(34069 + e4, t6 + 1, f3, n4.width, n4.height, 0, g3, m3, n4.data);
              }
            } else {
              v3 ? i2.texSubImage2D(34069 + e4, 0, 0, 0, g3, m3, d3[e4]) : i2.texImage2D(34069 + e4, 0, f3, g3, m3, d3[e4]);
              for (let t6 = 0; t6 < E3.length; t6++) {
                const n4 = E3[t6];
                v3 ? i2.texSubImage2D(34069 + e4, t6 + 1, 0, 0, g3, m3, n4.image[e4]) : i2.texImage2D(34069 + e4, t6 + 1, f3, g3, m3, n4.image[e4]);
              }
            }
        }
        y2(o4, _3) && w2(34067), u3.__version = h3.version, o4.onUpdate && o4.onUpdate(o4);
      }
      t4.__version = o4.version;
    }(s3, t3, o3) : i2.bindTexture(34067, s3.__webglTexture, 33984 + o3);
  }, this.rebindTextures = function(e4, t3, i3) {
    const o3 = n2.get(e4);
    void 0 !== t3 && F2(o3.__webglFramebuffer, e4, e4.texture, 36064, 3553), void 0 !== i3 && O2(e4);
  }, this.setupRenderTarget = function(t3) {
    const l3 = t3.texture, c3 = n2.get(t3), h3 = n2.get(l3);
    t3.addEventListener("dispose", I2), true !== t3.isWebGLMultipleRenderTargets && (void 0 === h3.__webglTexture && (h3.__webglTexture = e3.createTexture()), h3.__version = l3.version, s2.memory.textures++);
    const u3 = true === t3.isWebGLCubeRenderTarget, d3 = true === t3.isWebGLMultipleRenderTargets, p3 = b2(t3) || a2;
    if (u3) {
      c3.__webglFramebuffer = [];
      for (let t4 = 0; t4 < 6; t4++)
        c3.__webglFramebuffer[t4] = e3.createFramebuffer();
    } else {
      if (c3.__webglFramebuffer = e3.createFramebuffer(), d3)
        if (o2.drawBuffers) {
          const i3 = t3.texture;
          for (let t4 = 0, o3 = i3.length; t4 < o3; t4++) {
            const o4 = n2.get(i3[t4]);
            void 0 === o4.__webglTexture && (o4.__webglTexture = e3.createTexture(), s2.memory.textures++);
          }
        } else
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
      if (a2 && t3.samples > 0 && false === U2(t3)) {
        const n3 = d3 ? l3 : [l3];
        c3.__webglMultisampledFramebuffer = e3.createFramebuffer(), c3.__webglColorRenderbuffer = [], i2.bindFramebuffer(36160, c3.__webglMultisampledFramebuffer);
        for (let i3 = 0; i3 < n3.length; i3++) {
          const o3 = n3[i3];
          c3.__webglColorRenderbuffer[i3] = e3.createRenderbuffer(), e3.bindRenderbuffer(36161, c3.__webglColorRenderbuffer[i3]);
          const s3 = r2.convert(o3.format, o3.encoding), a3 = r2.convert(o3.type), l4 = x2(o3.internalFormat, s3, a3, o3.encoding, true === t3.isXRRenderTarget), h4 = z2(t3);
          e3.renderbufferStorageMultisample(36161, h4, l4, t3.width, t3.height), e3.framebufferRenderbuffer(36160, 36064 + i3, 36161, c3.__webglColorRenderbuffer[i3]);
        }
        e3.bindRenderbuffer(36161, null), t3.depthBuffer && (c3.__webglDepthRenderbuffer = e3.createRenderbuffer(), N2(c3.__webglDepthRenderbuffer, t3, true)), i2.bindFramebuffer(36160, null);
      }
    }
    if (u3) {
      i2.bindTexture(34067, h3.__webglTexture), P2(34067, l3, p3);
      for (let e4 = 0; e4 < 6; e4++)
        F2(c3.__webglFramebuffer[e4], t3, l3, 36064, 34069 + e4);
      y2(l3, p3) && w2(34067), i2.unbindTexture();
    } else if (d3) {
      const e4 = t3.texture;
      for (let o3 = 0, r3 = e4.length; o3 < r3; o3++) {
        const r4 = e4[o3], s3 = n2.get(r4);
        i2.bindTexture(3553, s3.__webglTexture), P2(3553, r4, p3), F2(c3.__webglFramebuffer, t3, r4, 36064 + o3, 3553), y2(r4, p3) && w2(3553);
      }
      i2.unbindTexture();
    } else {
      let e4 = 3553;
      (t3.isWebGL3DRenderTarget || t3.isWebGLArrayRenderTarget) && (a2 ? e4 = t3.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), i2.bindTexture(e4, h3.__webglTexture), P2(e4, l3, p3), F2(c3.__webglFramebuffer, t3, l3, 36064, e4), y2(l3, p3) && w2(e4), i2.unbindTexture();
    }
    t3.depthBuffer && O2(t3);
  }, this.updateRenderTargetMipmap = function(e4) {
    const t3 = b2(e4) || a2, o3 = true === e4.isWebGLMultipleRenderTargets ? e4.texture : [e4.texture];
    for (let r3 = 0, s3 = o3.length; r3 < s3; r3++) {
      const s4 = o3[r3];
      if (y2(s4, t3)) {
        const t4 = e4.isWebGLCubeRenderTarget ? 34067 : 3553, o4 = n2.get(s4).__webglTexture;
        i2.bindTexture(t4, o4), w2(t4), i2.unbindTexture();
      }
    }
  }, this.updateMultisampleRenderTarget = function(t3) {
    if (a2 && t3.samples > 0 && false === U2(t3)) {
      const o3 = t3.isWebGLMultipleRenderTargets ? t3.texture : [t3.texture], r3 = t3.width, s3 = t3.height;
      let a3 = 16384;
      const l3 = [], c3 = t3.stencilBuffer ? 33306 : 36096, h3 = n2.get(t3), u3 = true === t3.isWebGLMultipleRenderTargets;
      if (u3)
        for (let t4 = 0; t4 < o3.length; t4++)
          i2.bindFramebuffer(36160, h3.__webglMultisampledFramebuffer), e3.framebufferRenderbuffer(36160, 36064 + t4, 36161, null), i2.bindFramebuffer(36160, h3.__webglFramebuffer), e3.framebufferTexture2D(36009, 36064 + t4, 3553, null, 0);
      i2.bindFramebuffer(36008, h3.__webglMultisampledFramebuffer), i2.bindFramebuffer(36009, h3.__webglFramebuffer);
      for (let i3 = 0; i3 < o3.length; i3++) {
        l3.push(36064 + i3), t3.depthBuffer && l3.push(c3);
        const d3 = void 0 !== h3.__ignoreDepthValues && h3.__ignoreDepthValues;
        if (false === d3 && (t3.depthBuffer && (a3 |= 256), t3.stencilBuffer && (a3 |= 1024)), u3 && e3.framebufferRenderbuffer(36008, 36064, 36161, h3.__webglColorRenderbuffer[i3]), true === d3 && (e3.invalidateFramebuffer(36008, [c3]), e3.invalidateFramebuffer(36009, [c3])), u3) {
          const t4 = n2.get(o3[i3]).__webglTexture;
          e3.framebufferTexture2D(36009, 36064, 3553, t4, 0);
        }
        e3.blitFramebuffer(0, 0, r3, s3, 0, 0, r3, s3, a3, 9728), p2 && e3.invalidateFramebuffer(36008, l3);
      }
      if (i2.bindFramebuffer(36008, null), i2.bindFramebuffer(36009, null), u3)
        for (let t4 = 0; t4 < o3.length; t4++) {
          i2.bindFramebuffer(36160, h3.__webglMultisampledFramebuffer), e3.framebufferRenderbuffer(36160, 36064 + t4, 36161, h3.__webglColorRenderbuffer[t4]);
          const r4 = n2.get(o3[t4]).__webglTexture;
          i2.bindFramebuffer(36160, h3.__webglFramebuffer), e3.framebufferTexture2D(36009, 36064 + t4, 3553, r4, 0);
        }
      i2.bindFramebuffer(36009, h3.__webglMultisampledFramebuffer);
    }
  }, this.setupDepthRenderbuffer = O2, this.setupFrameBufferTexture = F2, this.useMultisampledRTT = U2;
}
function aa(e3, t2, i2) {
  const n2 = i2.isWebGL2;
  return { convert: function(i3, o2 = null) {
    let r2;
    if (i3 === Ge)
      return 5121;
    if (1017 === i3)
      return 32819;
    if (1018 === i3)
      return 32820;
    if (1010 === i3)
      return 5120;
    if (1011 === i3)
      return 5122;
    if (1012 === i3)
      return 5123;
    if (1013 === i3)
      return 5124;
    if (i3 === $e)
      return 5125;
    if (i3 === We)
      return 5126;
    if (i3 === qe)
      return n2 ? 5131 : (r2 = t2.get("OES_texture_half_float"), null !== r2 ? r2.HALF_FLOAT_OES : null);
    if (1021 === i3)
      return 6406;
    if (i3 === Xe)
      return 6408;
    if (1024 === i3)
      return 6409;
    if (1025 === i3)
      return 6410;
    if (i3 === Ye)
      return 6402;
    if (i3 === Ke)
      return 34041;
    if (i3 === It)
      return r2 = t2.get("EXT_sRGB"), null !== r2 ? r2.SRGB_ALPHA_EXT : null;
    if (i3 === Ze)
      return 6403;
    if (1029 === i3)
      return 36244;
    if (i3 === Je)
      return 33319;
    if (1031 === i3)
      return 33320;
    if (1033 === i3)
      return 36249;
    if (i3 === et || i3 === tt || i3 === it || i3 === nt)
      if (o2 === bt) {
        if (r2 = t2.get("WEBGL_compressed_texture_s3tc_srgb"), null === r2)
          return null;
        if (i3 === et)
          return r2.COMPRESSED_SRGB_S3TC_DXT1_EXT;
        if (i3 === tt)
          return r2.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
        if (i3 === it)
          return r2.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
        if (i3 === nt)
          return r2.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
      } else {
        if (r2 = t2.get("WEBGL_compressed_texture_s3tc"), null === r2)
          return null;
        if (i3 === et)
          return r2.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (i3 === tt)
          return r2.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (i3 === it)
          return r2.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (i3 === nt)
          return r2.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      }
    if (i3 === ot || 35841 === i3 || i3 === rt || 35843 === i3) {
      if (r2 = t2.get("WEBGL_compressed_texture_pvrtc"), null === r2)
        return null;
      if (i3 === ot)
        return r2.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
      if (35841 === i3)
        return r2.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
      if (i3 === rt)
        return r2.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
      if (35843 === i3)
        return r2.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
    }
    if (36196 === i3)
      return r2 = t2.get("WEBGL_compressed_texture_etc1"), null !== r2 ? r2.COMPRESSED_RGB_ETC1_WEBGL : null;
    if (i3 === st || i3 === at) {
      if (r2 = t2.get("WEBGL_compressed_texture_etc"), null === r2)
        return null;
      if (i3 === st)
        return o2 === bt ? r2.COMPRESSED_SRGB8_ETC2 : r2.COMPRESSED_RGB8_ETC2;
      if (i3 === at)
        return o2 === bt ? r2.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r2.COMPRESSED_RGBA8_ETC2_EAC;
    }
    if (i3 === lt || 37809 === i3 || 37810 === i3 || 37811 === i3 || 37812 === i3 || 37813 === i3 || 37814 === i3 || 37815 === i3 || 37816 === i3 || 37817 === i3 || 37818 === i3 || 37819 === i3 || 37820 === i3 || 37821 === i3) {
      if (r2 = t2.get("WEBGL_compressed_texture_astc"), null === r2)
        return null;
      if (i3 === lt)
        return o2 === bt ? r2.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r2.COMPRESSED_RGBA_ASTC_4x4_KHR;
      if (37809 === i3)
        return o2 === bt ? r2.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r2.COMPRESSED_RGBA_ASTC_5x4_KHR;
      if (37810 === i3)
        return o2 === bt ? r2.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r2.COMPRESSED_RGBA_ASTC_5x5_KHR;
      if (37811 === i3)
        return o2 === bt ? r2.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r2.COMPRESSED_RGBA_ASTC_6x5_KHR;
      if (37812 === i3)
        return o2 === bt ? r2.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r2.COMPRESSED_RGBA_ASTC_6x6_KHR;
      if (37813 === i3)
        return o2 === bt ? r2.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r2.COMPRESSED_RGBA_ASTC_8x5_KHR;
      if (37814 === i3)
        return o2 === bt ? r2.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r2.COMPRESSED_RGBA_ASTC_8x6_KHR;
      if (37815 === i3)
        return o2 === bt ? r2.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r2.COMPRESSED_RGBA_ASTC_8x8_KHR;
      if (37816 === i3)
        return o2 === bt ? r2.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r2.COMPRESSED_RGBA_ASTC_10x5_KHR;
      if (37817 === i3)
        return o2 === bt ? r2.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r2.COMPRESSED_RGBA_ASTC_10x6_KHR;
      if (37818 === i3)
        return o2 === bt ? r2.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r2.COMPRESSED_RGBA_ASTC_10x8_KHR;
      if (37819 === i3)
        return o2 === bt ? r2.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r2.COMPRESSED_RGBA_ASTC_10x10_KHR;
      if (37820 === i3)
        return o2 === bt ? r2.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r2.COMPRESSED_RGBA_ASTC_12x10_KHR;
      if (37821 === i3)
        return o2 === bt ? r2.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r2.COMPRESSED_RGBA_ASTC_12x12_KHR;
    }
    if (i3 === ct) {
      if (r2 = t2.get("EXT_texture_compression_bptc"), null === r2)
        return null;
      if (i3 === ct)
        return o2 === bt ? r2.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r2.COMPRESSED_RGBA_BPTC_UNORM_EXT;
    }
    if (36283 === i3 || 36284 === i3 || 36285 === i3 || 36286 === i3) {
      if (r2 = t2.get("EXT_texture_compression_rgtc"), null === r2)
        return null;
      if (i3 === ct)
        return r2.COMPRESSED_RED_RGTC1_EXT;
      if (36284 === i3)
        return r2.COMPRESSED_SIGNED_RED_RGTC1_EXT;
      if (36285 === i3)
        return r2.COMPRESSED_RED_GREEN_RGTC2_EXT;
      if (36286 === i3)
        return r2.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
    }
    return i3 === je ? n2 ? 34042 : (r2 = t2.get("WEBGL_depth_texture"), null !== r2 ? r2.UNSIGNED_INT_24_8_WEBGL : null) : void 0 !== e3[i3] ? e3[i3] : null;
  } };
}
class la extends Eo {
  constructor(e3 = []) {
    super(), this.isArrayCamera = true, this.cameras = e3;
  }
}
class ca extends _n {
  constructor() {
    super(), this.isGroup = true, this.type = "Group";
  }
}
const ha = { type: "move" };
class ua {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return null === this._hand && (this._hand = new ca(), this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = {}, this._hand.inputState = { pinching: false }), this._hand;
  }
  getTargetRaySpace() {
    return null === this._targetRay && (this._targetRay = new ca(), this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false, this._targetRay.hasLinearVelocity = false, this._targetRay.linearVelocity = new di(), this._targetRay.hasAngularVelocity = false, this._targetRay.angularVelocity = new di()), this._targetRay;
  }
  getGripSpace() {
    return null === this._grip && (this._grip = new ca(), this._grip.matrixAutoUpdate = false, this._grip.visible = false, this._grip.hasLinearVelocity = false, this._grip.linearVelocity = new di(), this._grip.hasAngularVelocity = false, this._grip.angularVelocity = new di()), this._grip;
  }
  dispatchEvent(e3) {
    return null !== this._targetRay && this._targetRay.dispatchEvent(e3), null !== this._grip && this._grip.dispatchEvent(e3), null !== this._hand && this._hand.dispatchEvent(e3), this;
  }
  connect(e3) {
    if (e3 && e3.hand) {
      const t2 = this._hand;
      if (t2)
        for (const i2 of e3.hand.values())
          this._getHandJoint(t2, i2);
    }
    return this.dispatchEvent({ type: "connected", data: e3 }), this;
  }
  disconnect(e3) {
    return this.dispatchEvent({ type: "disconnected", data: e3 }), null !== this._targetRay && (this._targetRay.visible = false), null !== this._grip && (this._grip.visible = false), null !== this._hand && (this._hand.visible = false), this;
  }
  update(e3, t2, i2) {
    let n2 = null, o2 = null, r2 = null;
    const s2 = this._targetRay, a2 = this._grip, l2 = this._hand;
    if (e3 && "visible-blurred" !== t2.session.visibilityState) {
      if (l2 && e3.hand) {
        r2 = true;
        for (const n4 of e3.hand.values()) {
          const e4 = t2.getJointPose(n4, i2), o4 = this._getHandJoint(l2, n4);
          null !== e4 && (o4.matrix.fromArray(e4.transform.matrix), o4.matrix.decompose(o4.position, o4.rotation, o4.scale), o4.jointRadius = e4.radius), o4.visible = null !== e4;
        }
        const n3 = l2.joints["index-finger-tip"], o3 = l2.joints["thumb-tip"], s3 = n3.position.distanceTo(o3.position), a3 = 0.02, c2 = 5e-3;
        l2.inputState.pinching && s3 > a3 + c2 ? (l2.inputState.pinching = false, this.dispatchEvent({ type: "pinchend", handedness: e3.handedness, target: this })) : !l2.inputState.pinching && s3 <= a3 - c2 && (l2.inputState.pinching = true, this.dispatchEvent({ type: "pinchstart", handedness: e3.handedness, target: this }));
      } else
        null !== a2 && e3.gripSpace && (o2 = t2.getPose(e3.gripSpace, i2), null !== o2 && (a2.matrix.fromArray(o2.transform.matrix), a2.matrix.decompose(a2.position, a2.rotation, a2.scale), o2.linearVelocity ? (a2.hasLinearVelocity = true, a2.linearVelocity.copy(o2.linearVelocity)) : a2.hasLinearVelocity = false, o2.angularVelocity ? (a2.hasAngularVelocity = true, a2.angularVelocity.copy(o2.angularVelocity)) : a2.hasAngularVelocity = false));
      null !== s2 && (n2 = t2.getPose(e3.targetRaySpace, i2), null === n2 && null !== o2 && (n2 = o2), null !== n2 && (s2.matrix.fromArray(n2.transform.matrix), s2.matrix.decompose(s2.position, s2.rotation, s2.scale), n2.linearVelocity ? (s2.hasLinearVelocity = true, s2.linearVelocity.copy(n2.linearVelocity)) : s2.hasLinearVelocity = false, n2.angularVelocity ? (s2.hasAngularVelocity = true, s2.angularVelocity.copy(n2.angularVelocity)) : s2.hasAngularVelocity = false, this.dispatchEvent(ha)));
    }
    return null !== s2 && (s2.visible = null !== n2), null !== a2 && (a2.visible = null !== o2), null !== l2 && (l2.visible = null !== r2), this;
  }
  _getHandJoint(e3, t2) {
    if (void 0 === e3.joints[t2.jointName]) {
      const i2 = new ca();
      i2.matrixAutoUpdate = false, i2.visible = false, e3.joints[t2.jointName] = i2, e3.add(i2);
    }
    return e3.joints[t2.jointName];
  }
}
class da extends si {
  constructor(e3, t2, i2, n2, o2, r2, s2, a2, l2, c2) {
    if ((c2 = void 0 !== c2 ? c2 : Ye) !== Ye && c2 !== Ke)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    void 0 === i2 && c2 === Ye && (i2 = $e), void 0 === i2 && c2 === Ke && (i2 = je), super(null, n2, o2, r2, s2, a2, c2, i2, l2), this.isDepthTexture = true, this.image = { width: e3, height: t2 }, this.magFilter = void 0 !== s2 ? s2 : Oe, this.minFilter = void 0 !== a2 ? a2 : Oe, this.flipY = false, this.generateMipmaps = false;
  }
}
class pa extends Tt {
  constructor(e3, t2) {
    super();
    const i2 = this;
    let n2 = null, o2 = 1, r2 = null, s2 = "local-floor", a2 = 1, l2 = null, c2 = null, h2 = null, u2 = null, d2 = null, p2 = null;
    const _2 = t2.getContextAttributes();
    let g2 = null, m2 = null;
    const f2 = [], v2 = [], A2 = /* @__PURE__ */ new Set(), b2 = /* @__PURE__ */ new Map(), y2 = new Eo();
    y2.layers.enable(1), y2.viewport = new ai();
    const w2 = new Eo();
    w2.layers.enable(2), w2.viewport = new ai();
    const x2 = [y2, w2], C2 = new la();
    C2.layers.enable(1), C2.layers.enable(2);
    let S2 = null, E2 = null;
    function I2(e4) {
      const t3 = v2.indexOf(e4.inputSource);
      if (-1 === t3)
        return;
      const i3 = f2[t3];
      void 0 !== i3 && i3.dispatchEvent({ type: e4.type, data: e4.inputSource });
    }
    function T2() {
      n2.removeEventListener("select", I2), n2.removeEventListener("selectstart", I2), n2.removeEventListener("selectend", I2), n2.removeEventListener("squeeze", I2), n2.removeEventListener("squeezestart", I2), n2.removeEventListener("squeezeend", I2), n2.removeEventListener("end", T2), n2.removeEventListener("inputsourceschange", B2);
      for (let e4 = 0; e4 < f2.length; e4++) {
        const t3 = v2[e4];
        null !== t3 && (v2[e4] = null, f2[e4].disconnect(t3));
      }
      S2 = null, E2 = null, e3.setRenderTarget(g2), d2 = null, u2 = null, h2 = null, n2 = null, m2 = null, D2.stop(), i2.isPresenting = false, i2.dispatchEvent({ type: "sessionend" });
    }
    function B2(e4) {
      for (let t3 = 0; t3 < e4.removed.length; t3++) {
        const i3 = e4.removed[t3], n3 = v2.indexOf(i3);
        n3 >= 0 && (v2[n3] = null, f2[n3].disconnect(i3));
      }
      for (let t3 = 0; t3 < e4.added.length; t3++) {
        const i3 = e4.added[t3];
        let n3 = v2.indexOf(i3);
        if (-1 === n3) {
          for (let e5 = 0; e5 < f2.length; e5++) {
            if (e5 >= v2.length) {
              v2.push(i3), n3 = e5;
              break;
            }
            if (null === v2[e5]) {
              v2[e5] = i3, n3 = e5;
              break;
            }
          }
          if (-1 === n3)
            break;
        }
        const o3 = f2[n3];
        o3 && o3.connect(i3);
      }
    }
    this.cameraAutoUpdate = true, this.enabled = false, this.isPresenting = false, this.getController = function(e4) {
      let t3 = f2[e4];
      return void 0 === t3 && (t3 = new ua(), f2[e4] = t3), t3.getTargetRaySpace();
    }, this.getControllerGrip = function(e4) {
      let t3 = f2[e4];
      return void 0 === t3 && (t3 = new ua(), f2[e4] = t3), t3.getGripSpace();
    }, this.getHand = function(e4) {
      let t3 = f2[e4];
      return void 0 === t3 && (t3 = new ua(), f2[e4] = t3), t3.getHandSpace();
    }, this.setFramebufferScaleFactor = function(e4) {
      o2 = e4, true === i2.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(e4) {
      s2 = e4, true === i2.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return l2 || r2;
    }, this.setReferenceSpace = function(e4) {
      l2 = e4;
    }, this.getBaseLayer = function() {
      return null !== u2 ? u2 : d2;
    }, this.getBinding = function() {
      return h2;
    }, this.getFrame = function() {
      return p2;
    }, this.getSession = function() {
      return n2;
    }, this.setSession = async function(c3) {
      if (n2 = c3, null !== n2) {
        if (g2 = e3.getRenderTarget(), n2.addEventListener("select", I2), n2.addEventListener("selectstart", I2), n2.addEventListener("selectend", I2), n2.addEventListener("squeeze", I2), n2.addEventListener("squeezestart", I2), n2.addEventListener("squeezeend", I2), n2.addEventListener("end", T2), n2.addEventListener("inputsourceschange", B2), true !== _2.xrCompatible && await t2.makeXRCompatible(), void 0 === n2.renderState.layers || false === e3.capabilities.isWebGL2) {
          const i3 = { antialias: void 0 !== n2.renderState.layers || _2.antialias, alpha: _2.alpha, depth: _2.depth, stencil: _2.stencil, framebufferScaleFactor: o2 };
          d2 = new XRWebGLLayer(n2, t2, i3), n2.updateRenderState({ baseLayer: d2 }), m2 = new li(d2.framebufferWidth, d2.framebufferHeight, { format: Xe, type: Ge, encoding: e3.outputEncoding, stencilBuffer: _2.stencil });
        } else {
          let i3 = null, r3 = null, s3 = null;
          _2.depth && (s3 = _2.stencil ? 35056 : 33190, i3 = _2.stencil ? Ke : Ye, r3 = _2.stencil ? je : $e);
          const a3 = { colorFormat: 32856, depthFormat: s3, scaleFactor: o2 };
          h2 = new XRWebGLBinding(n2, t2), u2 = h2.createProjectionLayer(a3), n2.updateRenderState({ layers: [u2] }), m2 = new li(u2.textureWidth, u2.textureHeight, { format: Xe, type: Ge, depthTexture: new da(u2.textureWidth, u2.textureHeight, r3, void 0, void 0, void 0, void 0, void 0, void 0, i3), stencilBuffer: _2.stencil, encoding: e3.outputEncoding, samples: _2.antialias ? 4 : 0 });
          e3.properties.get(m2).__ignoreDepthValues = u2.ignoreDepthValues;
        }
        m2.isXRRenderTarget = true, this.setFoveation(a2), l2 = null, r2 = await n2.requestReferenceSpace(s2), D2.setContext(n2), D2.start(), i2.isPresenting = true, i2.dispatchEvent({ type: "sessionstart" });
      }
    };
    const M2 = new di(), k2 = new di();
    function R2(e4, t3) {
      null === t3 ? e4.matrixWorld.copy(e4.matrix) : e4.matrixWorld.multiplyMatrices(t3.matrixWorld, e4.matrix), e4.matrixWorldInverse.copy(e4.matrixWorld).invert();
    }
    this.updateCamera = function(e4) {
      if (null === n2)
        return;
      C2.near = w2.near = y2.near = e4.near, C2.far = w2.far = y2.far = e4.far, S2 === C2.near && E2 === C2.far || (n2.updateRenderState({ depthNear: C2.near, depthFar: C2.far }), S2 = C2.near, E2 = C2.far);
      const t3 = e4.parent, i3 = C2.cameras;
      R2(C2, t3);
      for (let e5 = 0; e5 < i3.length; e5++)
        R2(i3[e5], t3);
      2 === i3.length ? function(e5, t4, i4) {
        M2.setFromMatrixPosition(t4.matrixWorld), k2.setFromMatrixPosition(i4.matrixWorld);
        const n3 = M2.distanceTo(k2), o3 = t4.projectionMatrix.elements, r3 = i4.projectionMatrix.elements, s3 = o3[14] / (o3[10] - 1), a3 = o3[14] / (o3[10] + 1), l3 = (o3[9] + 1) / o3[5], c3 = (o3[9] - 1) / o3[5], h3 = (o3[8] - 1) / o3[0], u3 = (r3[8] + 1) / r3[0], d3 = s3 * h3, p3 = s3 * u3, _3 = n3 / (-h3 + u3), g3 = _3 * -h3;
        t4.matrixWorld.decompose(e5.position, e5.quaternion, e5.scale), e5.translateX(g3), e5.translateZ(_3), e5.matrixWorld.compose(e5.position, e5.quaternion, e5.scale), e5.matrixWorldInverse.copy(e5.matrixWorld).invert();
        const m3 = s3 + _3, f3 = a3 + _3, v3 = d3 - g3, A3 = p3 + (n3 - g3), b3 = l3 * a3 / f3 * m3, y3 = c3 * a3 / f3 * m3;
        e5.projectionMatrix.makePerspective(v3, A3, b3, y3, m3, f3), e5.projectionMatrixInverse.copy(e5.projectionMatrix).invert();
      }(C2, y2, w2) : C2.projectionMatrix.copy(y2.projectionMatrix), function(e5, t4, i4) {
        null === i4 ? e5.matrix.copy(t4.matrixWorld) : (e5.matrix.copy(i4.matrixWorld), e5.matrix.invert(), e5.matrix.multiply(t4.matrixWorld));
        e5.matrix.decompose(e5.position, e5.quaternion, e5.scale), e5.updateMatrixWorld(true);
        const n3 = e5.children;
        for (let e6 = 0, t5 = n3.length; e6 < t5; e6++)
          n3[e6].updateMatrixWorld(true);
        e5.projectionMatrix.copy(t4.projectionMatrix), e5.projectionMatrixInverse.copy(t4.projectionMatrixInverse), e5.isPerspectiveCamera && (e5.fov = 2 * Rt * Math.atan(1 / e5.projectionMatrix.elements[5]), e5.zoom = 1);
      }(e4, C2, t3);
    }, this.getCamera = function() {
      return C2;
    }, this.getFoveation = function() {
      if (null !== u2 || null !== d2)
        return a2;
    }, this.setFoveation = function(e4) {
      a2 = e4, null !== u2 && (u2.fixedFoveation = e4), null !== d2 && void 0 !== d2.fixedFoveation && (d2.fixedFoveation = e4);
    }, this.getPlanes = function() {
      return A2;
    };
    let P2 = null;
    const D2 = new Oo();
    D2.setAnimationLoop(function(t3, n3) {
      if (c2 = n3.getViewerPose(l2 || r2), p2 = n3, null !== c2) {
        const t4 = c2.views;
        null !== d2 && (e3.setRenderTargetFramebuffer(m2, d2.framebuffer), e3.setRenderTarget(m2));
        let i3 = false;
        t4.length !== C2.cameras.length && (C2.cameras.length = 0, i3 = true);
        for (let n4 = 0; n4 < t4.length; n4++) {
          const o3 = t4[n4];
          let r3 = null;
          if (null !== d2)
            r3 = d2.getViewport(o3);
          else {
            const t5 = h2.getViewSubImage(u2, o3);
            r3 = t5.viewport, 0 === n4 && (e3.setRenderTargetTextures(m2, t5.colorTexture, u2.ignoreDepthValues ? void 0 : t5.depthStencilTexture), e3.setRenderTarget(m2));
          }
          let s3 = x2[n4];
          void 0 === s3 && (s3 = new Eo(), s3.layers.enable(n4), s3.viewport = new ai(), x2[n4] = s3), s3.matrix.fromArray(o3.transform.matrix), s3.matrix.decompose(s3.position, s3.quaternion, s3.scale), s3.projectionMatrix.fromArray(o3.projectionMatrix), s3.projectionMatrixInverse.copy(s3.projectionMatrix).invert(), s3.viewport.set(r3.x, r3.y, r3.width, r3.height), 0 === n4 && (C2.matrix.copy(s3.matrix), C2.matrix.decompose(C2.position, C2.quaternion, C2.scale)), true === i3 && C2.cameras.push(s3);
        }
      }
      for (let e4 = 0; e4 < f2.length; e4++) {
        const t4 = v2[e4], i3 = f2[e4];
        null !== t4 && void 0 !== i3 && i3.update(t4, n3, l2 || r2);
      }
      if (P2 && P2(t3, n3), n3.detectedPlanes) {
        i2.dispatchEvent({ type: "planesdetected", data: n3.detectedPlanes });
        let e4 = null;
        for (const t4 of A2)
          n3.detectedPlanes.has(t4) || (null === e4 && (e4 = []), e4.push(t4));
        if (null !== e4)
          for (const t4 of e4)
            A2.delete(t4), b2.delete(t4), i2.dispatchEvent({ type: "planeremoved", data: t4 });
        for (const e5 of n3.detectedPlanes)
          if (A2.has(e5)) {
            const t4 = b2.get(e5);
            e5.lastChangedTime > t4 && (b2.set(e5, e5.lastChangedTime), i2.dispatchEvent({ type: "planechanged", data: e5 }));
          } else
            A2.add(e5), b2.set(e5, n3.lastChangedTime), i2.dispatchEvent({ type: "planeadded", data: e5 });
      }
      p2 = null;
    }), this.setAnimationLoop = function(e4) {
      P2 = e4;
    }, this.dispose = function() {
    };
  }
}
function _a(e3, t2) {
  function i2(e4, t3) {
    true === e4.matrixAutoUpdate && e4.updateMatrix(), t3.value.copy(e4.matrix);
  }
  function n2(n3, o2) {
    n3.opacity.value = o2.opacity, o2.color && n3.diffuse.value.copy(o2.color), o2.emissive && n3.emissive.value.copy(o2.emissive).multiplyScalar(o2.emissiveIntensity), o2.map && (n3.map.value = o2.map, i2(o2.map, n3.mapTransform)), o2.alphaMap && (n3.alphaMap.value = o2.alphaMap, i2(o2.alphaMap, n3.alphaMapTransform)), o2.bumpMap && (n3.bumpMap.value = o2.bumpMap, i2(o2.bumpMap, n3.bumpMapTransform), n3.bumpScale.value = o2.bumpScale, o2.side === Ae && (n3.bumpScale.value *= -1)), o2.normalMap && (n3.normalMap.value = o2.normalMap, i2(o2.normalMap, n3.normalMapTransform), n3.normalScale.value.copy(o2.normalScale), o2.side === Ae && n3.normalScale.value.negate()), o2.displacementMap && (n3.displacementMap.value = o2.displacementMap, i2(o2.displacementMap, n3.displacementMapTransform), n3.displacementScale.value = o2.displacementScale, n3.displacementBias.value = o2.displacementBias), o2.emissiveMap && (n3.emissiveMap.value = o2.emissiveMap, i2(o2.emissiveMap, n3.emissiveMapTransform)), o2.specularMap && (n3.specularMap.value = o2.specularMap, i2(o2.specularMap, n3.specularMapTransform)), o2.alphaTest > 0 && (n3.alphaTest.value = o2.alphaTest);
    const r2 = t2.get(o2).envMap;
    if (r2 && (n3.envMap.value = r2, n3.flipEnvMap.value = r2.isCubeTexture && false === r2.isRenderTargetTexture ? -1 : 1, n3.reflectivity.value = o2.reflectivity, n3.ior.value = o2.ior, n3.refractionRatio.value = o2.refractionRatio), o2.lightMap) {
      n3.lightMap.value = o2.lightMap;
      const t3 = true === e3.useLegacyLights ? Math.PI : 1;
      n3.lightMapIntensity.value = o2.lightMapIntensity * t3, i2(o2.lightMap, n3.lightMapTransform);
    }
    o2.aoMap && (n3.aoMap.value = o2.aoMap, n3.aoMapIntensity.value = o2.aoMapIntensity, i2(o2.aoMap, n3.aoMapTransform));
  }
  return { refreshFogUniforms: function(t3, i3) {
    i3.color.getRGB(t3.fogColor.value, wo(e3)), i3.isFog ? (t3.fogNear.value = i3.near, t3.fogFar.value = i3.far) : i3.isFogExp2 && (t3.fogDensity.value = i3.density);
  }, refreshMaterialUniforms: function(e4, o2, r2, s2, a2) {
    o2.isMeshBasicMaterial || o2.isMeshLambertMaterial ? n2(e4, o2) : o2.isMeshToonMaterial ? (n2(e4, o2), function(e5, t3) {
      t3.gradientMap && (e5.gradientMap.value = t3.gradientMap);
    }(e4, o2)) : o2.isMeshPhongMaterial ? (n2(e4, o2), function(e5, t3) {
      e5.specular.value.copy(t3.specular), e5.shininess.value = Math.max(t3.shininess, 1e-4);
    }(e4, o2)) : o2.isMeshStandardMaterial ? (n2(e4, o2), function(e5, n3) {
      e5.metalness.value = n3.metalness, n3.metalnessMap && (e5.metalnessMap.value = n3.metalnessMap, i2(n3.metalnessMap, e5.metalnessMapTransform));
      e5.roughness.value = n3.roughness, n3.roughnessMap && (e5.roughnessMap.value = n3.roughnessMap, i2(n3.roughnessMap, e5.roughnessMapTransform));
      const o3 = t2.get(n3).envMap;
      o3 && (e5.envMapIntensity.value = n3.envMapIntensity);
    }(e4, o2), o2.isMeshPhysicalMaterial && function(e5, t3, n3) {
      e5.ior.value = t3.ior, t3.sheen > 0 && (e5.sheenColor.value.copy(t3.sheenColor).multiplyScalar(t3.sheen), e5.sheenRoughness.value = t3.sheenRoughness, t3.sheenColorMap && (e5.sheenColorMap.value = t3.sheenColorMap, i2(t3.sheenColorMap, e5.sheenColorMapTransform)), t3.sheenRoughnessMap && (e5.sheenRoughnessMap.value = t3.sheenRoughnessMap, i2(t3.sheenRoughnessMap, e5.sheenRoughnessMapTransform)));
      t3.clearcoat > 0 && (e5.clearcoat.value = t3.clearcoat, e5.clearcoatRoughness.value = t3.clearcoatRoughness, t3.clearcoatMap && (e5.clearcoatMap.value = t3.clearcoatMap, i2(t3.clearcoatMap, e5.clearcoatMapTransform)), t3.clearcoatRoughnessMap && (e5.clearcoatRoughnessMap.value = t3.clearcoatRoughnessMap, i2(t3.clearcoatRoughnessMap, e5.clearcoatRoughnessMapTransform)), t3.clearcoatNormalMap && (e5.clearcoatNormalMap.value = t3.clearcoatNormalMap, i2(t3.clearcoatNormalMap, e5.clearcoatNormalMapTransform), e5.clearcoatNormalScale.value.copy(t3.clearcoatNormalScale), t3.side === Ae && e5.clearcoatNormalScale.value.negate()));
      t3.iridescence > 0 && (e5.iridescence.value = t3.iridescence, e5.iridescenceIOR.value = t3.iridescenceIOR, e5.iridescenceThicknessMinimum.value = t3.iridescenceThicknessRange[0], e5.iridescenceThicknessMaximum.value = t3.iridescenceThicknessRange[1], t3.iridescenceMap && (e5.iridescenceMap.value = t3.iridescenceMap, i2(t3.iridescenceMap, e5.iridescenceMapTransform)), t3.iridescenceThicknessMap && (e5.iridescenceThicknessMap.value = t3.iridescenceThicknessMap, i2(t3.iridescenceThicknessMap, e5.iridescenceThicknessMapTransform)));
      t3.transmission > 0 && (e5.transmission.value = t3.transmission, e5.transmissionSamplerMap.value = n3.texture, e5.transmissionSamplerSize.value.set(n3.width, n3.height), t3.transmissionMap && (e5.transmissionMap.value = t3.transmissionMap, i2(t3.transmissionMap, e5.transmissionMapTransform)), e5.thickness.value = t3.thickness, t3.thicknessMap && (e5.thicknessMap.value = t3.thicknessMap, i2(t3.thicknessMap, e5.thicknessMapTransform)), e5.attenuationDistance.value = t3.attenuationDistance, e5.attenuationColor.value.copy(t3.attenuationColor));
      e5.specularIntensity.value = t3.specularIntensity, e5.specularColor.value.copy(t3.specularColor), t3.specularColorMap && (e5.specularColorMap.value = t3.specularColorMap, i2(t3.specularColorMap, e5.specularColorMapTransform));
      t3.specularIntensityMap && (e5.specularIntensityMap.value = t3.specularIntensityMap, i2(t3.specularIntensityMap, e5.specularIntensityMapTransform));
    }(e4, o2, a2)) : o2.isMeshMatcapMaterial ? (n2(e4, o2), function(e5, t3) {
      t3.matcap && (e5.matcap.value = t3.matcap);
    }(e4, o2)) : o2.isMeshDepthMaterial ? n2(e4, o2) : o2.isMeshDistanceMaterial ? (n2(e4, o2), function(e5, i3) {
      const n3 = t2.get(i3).light;
      e5.referencePosition.value.setFromMatrixPosition(n3.matrixWorld), e5.nearDistance.value = n3.shadow.camera.near, e5.farDistance.value = n3.shadow.camera.far;
    }(e4, o2)) : o2.isMeshNormalMaterial ? n2(e4, o2) : o2.isLineBasicMaterial ? (function(e5, t3) {
      e5.diffuse.value.copy(t3.color), e5.opacity.value = t3.opacity, t3.map && (e5.map.value = t3.map, i2(t3.map, e5.mapTransform));
    }(e4, o2), o2.isLineDashedMaterial && function(e5, t3) {
      e5.dashSize.value = t3.dashSize, e5.totalSize.value = t3.dashSize + t3.gapSize, e5.scale.value = t3.scale;
    }(e4, o2)) : o2.isPointsMaterial ? function(e5, t3, n3, o3) {
      e5.diffuse.value.copy(t3.color), e5.opacity.value = t3.opacity, e5.size.value = t3.size * n3, e5.scale.value = 0.5 * o3, t3.map && (e5.map.value = t3.map, i2(t3.map, e5.uvTransform));
      t3.alphaMap && (e5.alphaMap.value = t3.alphaMap);
      t3.alphaTest > 0 && (e5.alphaTest.value = t3.alphaTest);
    }(e4, o2, r2, s2) : o2.isSpriteMaterial ? function(e5, t3) {
      e5.diffuse.value.copy(t3.color), e5.opacity.value = t3.opacity, e5.rotation.value = t3.rotation, t3.map && (e5.map.value = t3.map, i2(t3.map, e5.mapTransform));
      t3.alphaMap && (e5.alphaMap.value = t3.alphaMap);
      t3.alphaTest > 0 && (e5.alphaTest.value = t3.alphaTest);
    }(e4, o2) : o2.isShadowMaterial ? (e4.color.value.copy(o2.color), e4.opacity.value = o2.opacity) : o2.isShaderMaterial && (o2.uniformsNeedUpdate = false);
  } };
}
function ga(e3, t2, i2, n2) {
  let o2 = {}, r2 = {}, s2 = [];
  const a2 = i2.isWebGL2 ? e3.getParameter(35375) : 0;
  function l2(e4, t3, i3) {
    const n3 = e4.value;
    if (void 0 === i3[t3]) {
      if ("number" == typeof n3)
        i3[t3] = n3;
      else {
        const e5 = Array.isArray(n3) ? n3 : [n3], o3 = [];
        for (let t4 = 0; t4 < e5.length; t4++)
          o3.push(e5[t4].clone());
        i3[t3] = o3;
      }
      return true;
    }
    if ("number" == typeof n3) {
      if (i3[t3] !== n3)
        return i3[t3] = n3, true;
    } else {
      const e5 = Array.isArray(i3[t3]) ? i3[t3] : [i3[t3]], o3 = Array.isArray(n3) ? n3 : [n3];
      for (let t4 = 0; t4 < e5.length; t4++) {
        const i4 = e5[t4];
        if (false === i4.equals(o3[t4]))
          return i4.copy(o3[t4]), true;
      }
    }
    return false;
  }
  function c2(e4) {
    const t3 = { boundary: 0, storage: 0 };
    return "number" == typeof e4 ? (t3.boundary = 4, t3.storage = 4) : e4.isVector2 ? (t3.boundary = 8, t3.storage = 8) : e4.isVector3 || e4.isColor ? (t3.boundary = 16, t3.storage = 12) : e4.isVector4 ? (t3.boundary = 16, t3.storage = 16) : e4.isMatrix3 ? (t3.boundary = 48, t3.storage = 48) : e4.isMatrix4 ? (t3.boundary = 64, t3.storage = 64) : e4.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", e4), t3;
  }
  function h2(t3) {
    const i3 = t3.target;
    i3.removeEventListener("dispose", h2);
    const n3 = s2.indexOf(i3.__bindingPointIndex);
    s2.splice(n3, 1), e3.deleteBuffer(o2[i3.id]), delete o2[i3.id], delete r2[i3.id];
  }
  return { bind: function(e4, t3) {
    const i3 = t3.program;
    n2.uniformBlockBinding(e4, i3);
  }, update: function(i3, u2) {
    let d2 = o2[i3.id];
    void 0 === d2 && (!function(e4) {
      const t3 = e4.uniforms;
      let i4 = 0;
      const n3 = 16;
      let o3 = 0;
      for (let e5 = 0, r3 = t3.length; e5 < r3; e5++) {
        const r4 = t3[e5], s3 = { boundary: 0, storage: 0 }, a3 = Array.isArray(r4.value) ? r4.value : [r4.value];
        for (let e6 = 0, t4 = a3.length; e6 < t4; e6++) {
          const t5 = c2(a3[e6]);
          s3.boundary += t5.boundary, s3.storage += t5.storage;
        }
        if (r4.__data = new Float32Array(s3.storage / Float32Array.BYTES_PER_ELEMENT), r4.__offset = i4, e5 > 0) {
          o3 = i4 % n3;
          0 !== o3 && n3 - o3 - s3.boundary < 0 && (i4 += n3 - o3, r4.__offset = i4);
        }
        i4 += s3.storage;
      }
      o3 = i4 % n3, o3 > 0 && (i4 += n3 - o3);
      e4.__size = i4, e4.__cache = {};
    }(i3), d2 = function(t3) {
      const i4 = function() {
        for (let e4 = 0; e4 < a2; e4++)
          if (-1 === s2.indexOf(e4))
            return s2.push(e4), e4;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
      }();
      t3.__bindingPointIndex = i4;
      const n3 = e3.createBuffer(), o3 = t3.__size, r3 = t3.usage;
      return e3.bindBuffer(35345, n3), e3.bufferData(35345, o3, r3), e3.bindBuffer(35345, null), e3.bindBufferBase(35345, i4, n3), n3;
    }(i3), o2[i3.id] = d2, i3.addEventListener("dispose", h2));
    const p2 = u2.program;
    n2.updateUBOMapping(i3, p2);
    const _2 = t2.render.frame;
    r2[i3.id] !== _2 && (!function(t3) {
      const i4 = o2[t3.id], n3 = t3.uniforms, r3 = t3.__cache;
      e3.bindBuffer(35345, i4);
      for (let t4 = 0, i5 = n3.length; t4 < i5; t4++) {
        const i6 = n3[t4];
        if (true === l2(i6, t4, r3)) {
          const t5 = i6.__offset, n4 = Array.isArray(i6.value) ? i6.value : [i6.value];
          let o3 = 0;
          for (let r4 = 0; r4 < n4.length; r4++) {
            const s3 = n4[r4], a3 = c2(s3);
            "number" == typeof s3 ? (i6.__data[0] = s3, e3.bufferSubData(35345, t5 + o3, i6.__data)) : s3.isMatrix3 ? (i6.__data[0] = s3.elements[0], i6.__data[1] = s3.elements[1], i6.__data[2] = s3.elements[2], i6.__data[3] = s3.elements[0], i6.__data[4] = s3.elements[3], i6.__data[5] = s3.elements[4], i6.__data[6] = s3.elements[5], i6.__data[7] = s3.elements[0], i6.__data[8] = s3.elements[6], i6.__data[9] = s3.elements[7], i6.__data[10] = s3.elements[8], i6.__data[11] = s3.elements[0]) : (s3.toArray(i6.__data, o3), o3 += a3.storage / Float32Array.BYTES_PER_ELEMENT);
          }
          e3.bufferSubData(35345, t5, i6.__data);
        }
      }
      e3.bindBuffer(35345, null);
    }(i3), r2[i3.id] = _2);
  }, dispose: function() {
    for (const t3 in o2)
      e3.deleteBuffer(o2[t3]);
    s2 = [], o2 = {}, r2 = {};
  } };
}
function ma() {
  const e3 = qt("canvas");
  return e3.style.display = "block", e3;
}
class fa {
  constructor(e3 = {}) {
    const { canvas: t2 = ma(), context: i2 = null, depth: n2 = true, stencil: o2 = true, alpha: r2 = false, antialias: s2 = false, premultipliedAlpha: a2 = true, preserveDrawingBuffer: l2 = false, powerPreference: c2 = "default", failIfMajorPerformanceCaveat: h2 = false } = e3;
    let u2;
    this.isWebGLRenderer = true, u2 = null !== i2 ? i2.getContextAttributes().alpha : r2;
    let d2 = null, p2 = null;
    const _2 = [], g2 = [];
    this.domElement = t2, this.debug = { checkShaderErrors: true, onShaderError: null }, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this.outputEncoding = At, this.useLegacyLights = true, this.toneMapping = Se, this.toneMappingExposure = 1;
    const m2 = this;
    let f2 = false, v2 = 0, A2 = 0, b2 = null, y2 = -1, w2 = null;
    const x2 = new ai(), C2 = new ai();
    let S2 = null, E2 = t2.width, I2 = t2.height, T2 = 1, B2 = null, M2 = null;
    const k2 = new ai(0, 0, E2, I2), R2 = new ai(0, 0, E2, I2);
    let P2 = false;
    const D2 = new No();
    let L2 = false, F2 = false, N2 = null;
    const O2 = new Qi(), z2 = new di(), U2 = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
    function H2() {
      return null === b2 ? T2 : 1;
    }
    let Q2, V2, G2, $2, W2, q2, j2, X2, Y2, K2, Z2, J2, ee2, te2, ie2, ne2, oe2, re2, se2, ae2, le2, ce2, he2, ue2, de2 = i2;
    function pe2(e4, i3) {
      for (let n3 = 0; n3 < e4.length; n3++) {
        const o3 = e4[n3], r3 = t2.getContext(o3, i3);
        if (null !== r3)
          return r3;
      }
      return null;
    }
    try {
      const e4 = { alpha: true, depth: n2, stencil: o2, antialias: s2, premultipliedAlpha: a2, preserveDrawingBuffer: l2, powerPreference: c2, failIfMajorPerformanceCaveat: h2 };
      if ("setAttribute" in t2 && t2.setAttribute("data-engine", `three.js r${_e}`), t2.addEventListener("webglcontextlost", fe2, false), t2.addEventListener("webglcontextrestored", ye2, false), t2.addEventListener("webglcontextcreationerror", we2, false), null === de2) {
        const t3 = ["webgl2", "webgl", "experimental-webgl"];
        if (true === m2.isWebGL1Renderer && t3.shift(), de2 = pe2(t3, e4), null === de2)
          throw pe2(t3) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
      void 0 === de2.getShaderPrecisionFormat && (de2.getShaderPrecisionFormat = function() {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
    } catch (e4) {
      throw console.error("THREE.WebGLRenderer: " + e4.message), e4;
    }
    function ge2() {
      Q2 = new pr(de2), V2 = new jo(de2, Q2, e3), Q2.init(V2), ce2 = new aa(de2, Q2, V2), G2 = new ra(de2, Q2, V2), $2 = new mr(), W2 = new $s(), q2 = new sa(de2, Q2, G2, W2, V2, ce2, $2), j2 = new Yo(m2), X2 = new dr(m2), Y2 = new zo(de2, V2), he2 = new Wo(de2, Q2, Y2, V2), K2 = new _r(de2, Y2, $2, he2), Z2 = new br(de2, K2, Y2, $2), se2 = new Ar(de2, V2, q2), ne2 = new Xo(W2), J2 = new Gs(m2, j2, X2, Q2, V2, he2, ne2), ee2 = new _a(m2, W2), te2 = new Xs(), ie2 = new ta(Q2, V2), re2 = new $o(m2, j2, X2, G2, Z2, u2, a2), oe2 = new oa(m2, Z2, V2), ue2 = new ga(de2, $2, V2, G2), ae2 = new qo(de2, Q2, $2, V2), le2 = new gr(de2, Q2, $2, V2), $2.programs = J2.programs, m2.capabilities = V2, m2.extensions = Q2, m2.properties = W2, m2.renderLists = te2, m2.shadowMap = oe2, m2.state = G2, m2.info = $2;
    }
    ge2();
    const me2 = new pa(m2, de2);
    function fe2(e4) {
      e4.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), f2 = true;
    }
    function ye2() {
      console.log("THREE.WebGLRenderer: Context Restored."), f2 = false;
      const e4 = $2.autoReset, t3 = oe2.enabled, i3 = oe2.autoUpdate, n3 = oe2.needsUpdate, o3 = oe2.type;
      ge2(), $2.autoReset = e4, oe2.enabled = t3, oe2.autoUpdate = i3, oe2.needsUpdate = n3, oe2.type = o3;
    }
    function we2(e4) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", e4.statusMessage);
    }
    function xe2(e4) {
      const t3 = e4.target;
      t3.removeEventListener("dispose", xe2), function(e5) {
        (function(e6) {
          const t4 = W2.get(e6).programs;
          void 0 !== t4 && (t4.forEach(function(e7) {
            J2.releaseProgram(e7);
          }), e6.isShaderMaterial && J2.releaseShaderCache(e6));
        })(e5), W2.remove(e5);
      }(t3);
    }
    this.xr = me2, this.getContext = function() {
      return de2;
    }, this.getContextAttributes = function() {
      return de2.getContextAttributes();
    }, this.forceContextLoss = function() {
      const e4 = Q2.get("WEBGL_lose_context");
      e4 && e4.loseContext();
    }, this.forceContextRestore = function() {
      const e4 = Q2.get("WEBGL_lose_context");
      e4 && e4.restoreContext();
    }, this.getPixelRatio = function() {
      return T2;
    }, this.setPixelRatio = function(e4) {
      void 0 !== e4 && (T2 = e4, this.setSize(E2, I2, false));
    }, this.getSize = function(e4) {
      return e4.set(E2, I2);
    }, this.setSize = function(e4, i3, n3 = true) {
      me2.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (E2 = e4, I2 = i3, t2.width = Math.floor(e4 * T2), t2.height = Math.floor(i3 * T2), true === n3 && (t2.style.width = e4 + "px", t2.style.height = i3 + "px"), this.setViewport(0, 0, e4, i3));
    }, this.getDrawingBufferSize = function(e4) {
      return e4.set(E2 * T2, I2 * T2).floor();
    }, this.setDrawingBufferSize = function(e4, i3, n3) {
      E2 = e4, I2 = i3, T2 = n3, t2.width = Math.floor(e4 * n3), t2.height = Math.floor(i3 * n3), this.setViewport(0, 0, e4, i3);
    }, this.getCurrentViewport = function(e4) {
      return e4.copy(x2);
    }, this.getViewport = function(e4) {
      return e4.copy(k2);
    }, this.setViewport = function(e4, t3, i3, n3) {
      e4.isVector4 ? k2.set(e4.x, e4.y, e4.z, e4.w) : k2.set(e4, t3, i3, n3), G2.viewport(x2.copy(k2).multiplyScalar(T2).floor());
    }, this.getScissor = function(e4) {
      return e4.copy(R2);
    }, this.setScissor = function(e4, t3, i3, n3) {
      e4.isVector4 ? R2.set(e4.x, e4.y, e4.z, e4.w) : R2.set(e4, t3, i3, n3), G2.scissor(C2.copy(R2).multiplyScalar(T2).floor());
    }, this.getScissorTest = function() {
      return P2;
    }, this.setScissorTest = function(e4) {
      G2.setScissorTest(P2 = e4);
    }, this.setOpaqueSort = function(e4) {
      B2 = e4;
    }, this.setTransparentSort = function(e4) {
      M2 = e4;
    }, this.getClearColor = function(e4) {
      return e4.copy(re2.getClearColor());
    }, this.setClearColor = function() {
      re2.setClearColor.apply(re2, arguments);
    }, this.getClearAlpha = function() {
      return re2.getClearAlpha();
    }, this.setClearAlpha = function() {
      re2.setClearAlpha.apply(re2, arguments);
    }, this.clear = function(e4 = true, t3 = true, i3 = true) {
      let n3 = 0;
      e4 && (n3 |= 16384), t3 && (n3 |= 256), i3 && (n3 |= 1024), de2.clear(n3);
    }, this.clearColor = function() {
      this.clear(true, false, false);
    }, this.clearDepth = function() {
      this.clear(false, true, false);
    }, this.clearStencil = function() {
      this.clear(false, false, true);
    }, this.dispose = function() {
      t2.removeEventListener("webglcontextlost", fe2, false), t2.removeEventListener("webglcontextrestored", ye2, false), t2.removeEventListener("webglcontextcreationerror", we2, false), te2.dispose(), ie2.dispose(), W2.dispose(), j2.dispose(), X2.dispose(), Z2.dispose(), he2.dispose(), ue2.dispose(), J2.dispose(), me2.dispose(), me2.removeEventListener("sessionstart", Ee2), me2.removeEventListener("sessionend", Ie2), N2 && (N2.dispose(), N2 = null), Te2.stop();
    }, this.renderBufferDirect = function(e4, t3, i3, n3, o3, r3) {
      null === t3 && (t3 = U2);
      const s3 = o3.isMesh && o3.matrixWorld.determinant() < 0, a3 = function(e5, t4, i4, n4, o4) {
        true !== t4.isScene && (t4 = U2);
        q2.resetTextureUnits();
        const r4 = t4.fog, s4 = n4.isMeshStandardMaterial ? t4.environment : null, a4 = null === b2 ? m2.outputEncoding : true === b2.isXRRenderTarget ? b2.texture.encoding : At, l4 = (n4.isMeshStandardMaterial ? X2 : j2).get(n4.envMap || s4), c4 = true === n4.vertexColors && !!i4.attributes.color && 4 === i4.attributes.color.itemSize, h4 = !!n4.normalMap && !!i4.attributes.tangent, u4 = !!i4.morphAttributes.position, d4 = !!i4.morphAttributes.normal, _4 = !!i4.morphAttributes.color, g4 = n4.toneMapped ? m2.toneMapping : Se, f4 = i4.morphAttributes.position || i4.morphAttributes.normal || i4.morphAttributes.color, v4 = void 0 !== f4 ? f4.length : 0, A3 = W2.get(n4), x3 = p2.state.lights;
        if (true === L2 && (true === F2 || e5 !== w2)) {
          const t5 = e5 === w2 && n4.id === y2;
          ne2.setState(n4, e5, t5);
        }
        let C3 = false;
        n4.version === A3.__version ? A3.needsLights && A3.lightsStateVersion !== x3.state.version || A3.outputEncoding !== a4 || o4.isInstancedMesh && false === A3.instancing ? C3 = true : o4.isInstancedMesh || true !== A3.instancing ? o4.isSkinnedMesh && false === A3.skinning ? C3 = true : o4.isSkinnedMesh || true !== A3.skinning ? A3.envMap !== l4 || true === n4.fog && A3.fog !== r4 ? C3 = true : void 0 === A3.numClippingPlanes || A3.numClippingPlanes === ne2.numPlanes && A3.numIntersection === ne2.numIntersection ? (A3.vertexAlphas !== c4 || A3.vertexTangents !== h4 || A3.morphTargets !== u4 || A3.morphNormals !== d4 || A3.morphColors !== _4 || A3.toneMapping !== g4 || true === V2.isWebGL2 && A3.morphTargetsCount !== v4) && (C3 = true) : C3 = true : C3 = true : C3 = true : (C3 = true, A3.__version = n4.version);
        let S3 = A3.currentProgram;
        true === C3 && (S3 = Pe2(n4, t4, o4));
        let E3 = false, B3 = false, M3 = false;
        const k3 = S3.getUniforms(), R3 = A3.uniforms;
        G2.useProgram(S3.program) && (E3 = true, B3 = true, M3 = true);
        n4.id !== y2 && (y2 = n4.id, B3 = true);
        if (E3 || w2 !== e5) {
          if (k3.setValue(de2, "projectionMatrix", e5.projectionMatrix), V2.logarithmicDepthBuffer && k3.setValue(de2, "logDepthBufFC", 2 / (Math.log(e5.far + 1) / Math.LN2)), w2 !== e5 && (w2 = e5, B3 = true, M3 = true), n4.isShaderMaterial || n4.isMeshPhongMaterial || n4.isMeshToonMaterial || n4.isMeshStandardMaterial || n4.envMap) {
            const t5 = k3.map.cameraPosition;
            void 0 !== t5 && t5.setValue(de2, z2.setFromMatrixPosition(e5.matrixWorld));
          }
          (n4.isMeshPhongMaterial || n4.isMeshToonMaterial || n4.isMeshLambertMaterial || n4.isMeshBasicMaterial || n4.isMeshStandardMaterial || n4.isShaderMaterial) && k3.setValue(de2, "isOrthographic", true === e5.isOrthographicCamera), (n4.isMeshPhongMaterial || n4.isMeshToonMaterial || n4.isMeshLambertMaterial || n4.isMeshBasicMaterial || n4.isMeshStandardMaterial || n4.isShaderMaterial || n4.isShadowMaterial || o4.isSkinnedMesh) && k3.setValue(de2, "viewMatrix", e5.matrixWorldInverse);
        }
        if (o4.isSkinnedMesh) {
          k3.setOptional(de2, o4, "bindMatrix"), k3.setOptional(de2, o4, "bindMatrixInverse");
          const e6 = o4.skeleton;
          e6 && (V2.floatVertexTextures ? (null === e6.boneTexture && e6.computeBoneTexture(), k3.setValue(de2, "boneTexture", e6.boneTexture, q2), k3.setValue(de2, "boneTextureSize", e6.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
        }
        const P3 = i4.morphAttributes;
        (void 0 !== P3.position || void 0 !== P3.normal || void 0 !== P3.color && true === V2.isWebGL2) && se2.update(o4, i4, S3);
        (B3 || A3.receiveShadow !== o4.receiveShadow) && (A3.receiveShadow = o4.receiveShadow, k3.setValue(de2, "receiveShadow", o4.receiveShadow));
        n4.isMeshGouraudMaterial && null !== n4.envMap && (R3.envMap.value = l4, R3.flipEnvMap.value = l4.isCubeTexture && false === l4.isRenderTargetTexture ? -1 : 1);
        B3 && (k3.setValue(de2, "toneMappingExposure", m2.toneMappingExposure), A3.needsLights && (O3 = M3, (D3 = R3).ambientLightColor.needsUpdate = O3, D3.lightProbe.needsUpdate = O3, D3.directionalLights.needsUpdate = O3, D3.directionalLightShadows.needsUpdate = O3, D3.pointLights.needsUpdate = O3, D3.pointLightShadows.needsUpdate = O3, D3.spotLights.needsUpdate = O3, D3.spotLightShadows.needsUpdate = O3, D3.rectAreaLights.needsUpdate = O3, D3.hemisphereLights.needsUpdate = O3), r4 && true === n4.fog && ee2.refreshFogUniforms(R3, r4), ee2.refreshMaterialUniforms(R3, n4, T2, I2, N2), Cs.upload(de2, A3.uniformsList, R3, q2));
        var D3, O3;
        n4.isShaderMaterial && true === n4.uniformsNeedUpdate && (Cs.upload(de2, A3.uniformsList, R3, q2), n4.uniformsNeedUpdate = false);
        n4.isSpriteMaterial && k3.setValue(de2, "center", o4.center);
        if (k3.setValue(de2, "modelViewMatrix", o4.modelViewMatrix), k3.setValue(de2, "normalMatrix", o4.normalMatrix), k3.setValue(de2, "modelMatrix", o4.matrixWorld), n4.isShaderMaterial || n4.isRawShaderMaterial) {
          const e6 = n4.uniformsGroups;
          for (let t5 = 0, i5 = e6.length; t5 < i5; t5++)
            if (V2.isWebGL2) {
              const i6 = e6[t5];
              ue2.update(i6, S3), ue2.bind(i6, S3);
            } else
              console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
        }
        return S3;
      }(e4, t3, i3, n3, o3);
      G2.setMaterial(n3, s3);
      let l3 = i3.index, c3 = 1;
      true === n3.wireframe && (l3 = K2.getWireframeAttribute(i3), c3 = 2);
      const h3 = i3.drawRange, u3 = i3.attributes.position;
      let d3 = h3.start * c3, _3 = (h3.start + h3.count) * c3;
      null !== r3 && (d3 = Math.max(d3, r3.start * c3), _3 = Math.min(_3, (r3.start + r3.count) * c3)), null !== l3 ? (d3 = Math.max(d3, 0), _3 = Math.min(_3, l3.count)) : null != u3 && (d3 = Math.max(d3, 0), _3 = Math.min(_3, u3.count));
      const g3 = _3 - d3;
      if (g3 < 0 || g3 === 1 / 0)
        return;
      let f3;
      he2.setup(o3, n3, a3, i3, l3);
      let v3 = ae2;
      if (null !== l3 && (f3 = Y2.get(l3), v3 = le2, v3.setIndex(f3)), o3.isMesh)
        true === n3.wireframe ? (G2.setLineWidth(n3.wireframeLinewidth * H2()), v3.setMode(1)) : v3.setMode(4);
      else if (o3.isLine) {
        let e5 = n3.linewidth;
        void 0 === e5 && (e5 = 1), G2.setLineWidth(e5 * H2()), o3.isLineSegments ? v3.setMode(1) : o3.isLineLoop ? v3.setMode(2) : v3.setMode(3);
      } else
        o3.isPoints ? v3.setMode(0) : o3.isSprite && v3.setMode(4);
      if (o3.isInstancedMesh)
        v3.renderInstances(d3, g3, o3.count);
      else if (i3.isInstancedBufferGeometry) {
        const e5 = void 0 !== i3._maxInstanceCount ? i3._maxInstanceCount : 1 / 0, t4 = Math.min(i3.instanceCount, e5);
        v3.renderInstances(d3, g3, t4);
      } else
        v3.render(d3, g3);
    }, this.compile = function(e4, t3) {
      function i3(e5, t4, i4) {
        true === e5.transparent && e5.side === be && false === e5.forceSinglePass ? (e5.side = Ae, e5.needsUpdate = true, Pe2(e5, t4, i4), e5.side = ve, e5.needsUpdate = true, Pe2(e5, t4, i4), e5.side = be) : Pe2(e5, t4, i4);
      }
      p2 = ie2.get(e4), p2.init(), g2.push(p2), e4.traverseVisible(function(e5) {
        e5.isLight && e5.layers.test(t3.layers) && (p2.pushLight(e5), e5.castShadow && p2.pushShadow(e5));
      }), p2.setupLights(m2.useLegacyLights), e4.traverse(function(t4) {
        const n3 = t4.material;
        if (n3)
          if (Array.isArray(n3))
            for (let o3 = 0; o3 < n3.length; o3++) {
              i3(n3[o3], e4, t4);
            }
          else
            i3(n3, e4, t4);
      }), g2.pop(), p2 = null;
    };
    let Ce2 = null;
    function Ee2() {
      Te2.stop();
    }
    function Ie2() {
      Te2.start();
    }
    const Te2 = new Oo();
    function Be2(e4, t3, i3, n3) {
      if (false === e4.visible)
        return;
      if (e4.layers.test(t3.layers)) {
        if (e4.isGroup)
          i3 = e4.renderOrder;
        else if (e4.isLOD)
          true === e4.autoUpdate && e4.update(t3);
        else if (e4.isLight)
          p2.pushLight(e4), e4.castShadow && p2.pushShadow(e4);
        else if (e4.isSprite) {
          if (!e4.frustumCulled || D2.intersectsSprite(e4)) {
            n3 && z2.setFromMatrixPosition(e4.matrixWorld).applyMatrix4(O2);
            const t4 = Z2.update(e4), o4 = e4.material;
            o4.visible && d2.push(e4, t4, o4, i3, z2.z, null);
          }
        } else if ((e4.isMesh || e4.isLine || e4.isPoints) && (e4.isSkinnedMesh && e4.skeleton.frame !== $2.render.frame && (e4.skeleton.update(), e4.skeleton.frame = $2.render.frame), !e4.frustumCulled || D2.intersectsObject(e4))) {
          n3 && z2.setFromMatrixPosition(e4.matrixWorld).applyMatrix4(O2);
          const t4 = Z2.update(e4), o4 = e4.material;
          if (Array.isArray(o4)) {
            const n4 = t4.groups;
            for (let r3 = 0, s3 = n4.length; r3 < s3; r3++) {
              const s4 = n4[r3], a3 = o4[s4.materialIndex];
              a3 && a3.visible && d2.push(e4, t4, a3, i3, z2.z, s4);
            }
          } else
            o4.visible && d2.push(e4, t4, o4, i3, z2.z, null);
        }
      }
      const o3 = e4.children;
      for (let e5 = 0, r3 = o3.length; e5 < r3; e5++)
        Be2(o3[e5], t3, i3, n3);
    }
    function Me2(e4, t3, i3, n3) {
      const o3 = e4.opaque, r3 = e4.transmissive, a3 = e4.transparent;
      p2.setupLightsView(i3), true === L2 && ne2.setGlobalState(m2.clippingPlanes, i3), r3.length > 0 && function(e5, t4, i4, n4) {
        if (null === N2) {
          const e6 = V2.isWebGL2;
          N2 = new li(1024, 1024, { generateMipmaps: true, type: Q2.has("EXT_color_buffer_half_float") ? qe : Ge, minFilter: Ve, samples: e6 && true === s2 ? 4 : 0 });
        }
        const o4 = m2.getRenderTarget();
        m2.setRenderTarget(N2), m2.clear();
        const r4 = m2.toneMapping;
        m2.toneMapping = Se, ke2(e5, i4, n4), q2.updateMultisampleRenderTarget(N2), q2.updateRenderTargetMipmap(N2);
        let a4 = false;
        for (let e6 = 0, o5 = t4.length; e6 < o5; e6++) {
          const o6 = t4[e6], r5 = o6.object, s3 = o6.geometry, l3 = o6.material, c3 = o6.group;
          if (l3.side === be && r5.layers.test(n4.layers)) {
            const e7 = l3.side;
            l3.side = Ae, l3.needsUpdate = true, Re2(r5, i4, n4, s3, l3, c3), l3.side = e7, l3.needsUpdate = true, a4 = true;
          }
        }
        true === a4 && (q2.updateMultisampleRenderTarget(N2), q2.updateRenderTargetMipmap(N2));
        m2.setRenderTarget(o4), m2.toneMapping = r4;
      }(o3, r3, t3, i3), n3 && G2.viewport(x2.copy(n3)), o3.length > 0 && ke2(o3, t3, i3), r3.length > 0 && ke2(r3, t3, i3), a3.length > 0 && ke2(a3, t3, i3), G2.buffers.depth.setTest(true), G2.buffers.depth.setMask(true), G2.buffers.color.setMask(true), G2.setPolygonOffset(false);
    }
    function ke2(e4, t3, i3) {
      const n3 = true === t3.isScene ? t3.overrideMaterial : null;
      for (let o3 = 0, r3 = e4.length; o3 < r3; o3++) {
        const r4 = e4[o3], s3 = r4.object, a3 = r4.geometry, l3 = null === n3 ? r4.material : n3, c3 = r4.group;
        s3.layers.test(i3.layers) && Re2(s3, t3, i3, a3, l3, c3);
      }
    }
    function Re2(e4, t3, i3, n3, o3, r3) {
      e4.onBeforeRender(m2, t3, i3, n3, o3, r3), e4.modelViewMatrix.multiplyMatrices(i3.matrixWorldInverse, e4.matrixWorld), e4.normalMatrix.getNormalMatrix(e4.modelViewMatrix), o3.onBeforeRender(m2, t3, i3, n3, e4, r3), true === o3.transparent && o3.side === be && false === o3.forceSinglePass ? (o3.side = Ae, o3.needsUpdate = true, m2.renderBufferDirect(i3, t3, n3, o3, e4, r3), o3.side = ve, o3.needsUpdate = true, m2.renderBufferDirect(i3, t3, n3, o3, e4, r3), o3.side = be) : m2.renderBufferDirect(i3, t3, n3, o3, e4, r3), e4.onAfterRender(m2, t3, i3, n3, o3, r3);
    }
    function Pe2(e4, t3, i3) {
      true !== t3.isScene && (t3 = U2);
      const n3 = W2.get(e4), o3 = p2.state.lights, r3 = p2.state.shadowsArray, s3 = o3.state.version, a3 = J2.getParameters(e4, o3.state, r3, t3, i3), l3 = J2.getProgramCacheKey(a3);
      let c3 = n3.programs;
      n3.environment = e4.isMeshStandardMaterial ? t3.environment : null, n3.fog = t3.fog, n3.envMap = (e4.isMeshStandardMaterial ? X2 : j2).get(e4.envMap || n3.environment), void 0 === c3 && (e4.addEventListener("dispose", xe2), c3 = /* @__PURE__ */ new Map(), n3.programs = c3);
      let h3 = c3.get(l3);
      if (void 0 !== h3) {
        if (n3.currentProgram === h3 && n3.lightsStateVersion === s3)
          return De2(e4, a3), h3;
      } else
        a3.uniforms = J2.getUniforms(e4), e4.onBuild(i3, a3, m2), e4.onBeforeCompile(a3, m2), h3 = J2.acquireProgram(a3, l3), c3.set(l3, h3), n3.uniforms = a3.uniforms;
      const u3 = n3.uniforms;
      (e4.isShaderMaterial || e4.isRawShaderMaterial) && true !== e4.clipping || (u3.clippingPlanes = ne2.uniform), De2(e4, a3), n3.needsLights = function(e5) {
        return e5.isMeshLambertMaterial || e5.isMeshToonMaterial || e5.isMeshPhongMaterial || e5.isMeshStandardMaterial || e5.isShadowMaterial || e5.isShaderMaterial && true === e5.lights;
      }(e4), n3.lightsStateVersion = s3, n3.needsLights && (u3.ambientLightColor.value = o3.state.ambient, u3.lightProbe.value = o3.state.probe, u3.directionalLights.value = o3.state.directional, u3.directionalLightShadows.value = o3.state.directionalShadow, u3.spotLights.value = o3.state.spot, u3.spotLightShadows.value = o3.state.spotShadow, u3.rectAreaLights.value = o3.state.rectArea, u3.ltc_1.value = o3.state.rectAreaLTC1, u3.ltc_2.value = o3.state.rectAreaLTC2, u3.pointLights.value = o3.state.point, u3.pointLightShadows.value = o3.state.pointShadow, u3.hemisphereLights.value = o3.state.hemi, u3.directionalShadowMap.value = o3.state.directionalShadowMap, u3.directionalShadowMatrix.value = o3.state.directionalShadowMatrix, u3.spotShadowMap.value = o3.state.spotShadowMap, u3.spotLightMatrix.value = o3.state.spotLightMatrix, u3.spotLightMap.value = o3.state.spotLightMap, u3.pointShadowMap.value = o3.state.pointShadowMap, u3.pointShadowMatrix.value = o3.state.pointShadowMatrix);
      const d3 = h3.getUniforms(), _3 = Cs.seqWithValue(d3.seq, u3);
      return n3.currentProgram = h3, n3.uniformsList = _3, h3;
    }
    function De2(e4, t3) {
      const i3 = W2.get(e4);
      i3.outputEncoding = t3.outputEncoding, i3.instancing = t3.instancing, i3.skinning = t3.skinning, i3.morphTargets = t3.morphTargets, i3.morphNormals = t3.morphNormals, i3.morphColors = t3.morphColors, i3.morphTargetsCount = t3.morphTargetsCount, i3.numClippingPlanes = t3.numClippingPlanes, i3.numIntersection = t3.numClipIntersection, i3.vertexAlphas = t3.vertexAlphas, i3.vertexTangents = t3.vertexTangents, i3.toneMapping = t3.toneMapping;
    }
    Te2.setAnimationLoop(function(e4) {
      Ce2 && Ce2(e4);
    }), "undefined" != typeof self && Te2.setContext(self), this.setAnimationLoop = function(e4) {
      Ce2 = e4, me2.setAnimationLoop(e4), null === e4 ? Te2.stop() : Te2.start();
    }, me2.addEventListener("sessionstart", Ee2), me2.addEventListener("sessionend", Ie2), this.render = function(e4, t3) {
      if (void 0 !== t3 && true !== t3.isCamera)
        return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      if (true === f2)
        return;
      true === e4.matrixWorldAutoUpdate && e4.updateMatrixWorld(), null === t3.parent && true === t3.matrixWorldAutoUpdate && t3.updateMatrixWorld(), true === me2.enabled && true === me2.isPresenting && (true === me2.cameraAutoUpdate && me2.updateCamera(t3), t3 = me2.getCamera()), true === e4.isScene && e4.onBeforeRender(m2, e4, t3, b2), p2 = ie2.get(e4, g2.length), p2.init(), g2.push(p2), O2.multiplyMatrices(t3.projectionMatrix, t3.matrixWorldInverse), D2.setFromProjectionMatrix(O2), F2 = this.localClippingEnabled, L2 = ne2.init(this.clippingPlanes, F2), d2 = te2.get(e4, _2.length), d2.init(), _2.push(d2), Be2(e4, t3, 0, m2.sortObjects), d2.finish(), true === m2.sortObjects && d2.sort(B2, M2), true === L2 && ne2.beginShadows();
      const i3 = p2.state.shadowsArray;
      if (oe2.render(i3, e4, t3), true === L2 && ne2.endShadows(), true === this.info.autoReset && this.info.reset(), re2.render(d2, e4), p2.setupLights(m2.useLegacyLights), t3.isArrayCamera) {
        const i4 = t3.cameras;
        for (let t4 = 0, n3 = i4.length; t4 < n3; t4++) {
          const n4 = i4[t4];
          Me2(d2, e4, n4, n4.viewport);
        }
      } else
        Me2(d2, e4, t3);
      null !== b2 && (q2.updateMultisampleRenderTarget(b2), q2.updateRenderTargetMipmap(b2)), true === e4.isScene && e4.onAfterRender(m2, e4, t3), he2.resetDefaultState(), y2 = -1, w2 = null, g2.pop(), p2 = g2.length > 0 ? g2[g2.length - 1] : null, _2.pop(), d2 = _2.length > 0 ? _2[_2.length - 1] : null;
    }, this.getActiveCubeFace = function() {
      return v2;
    }, this.getActiveMipmapLevel = function() {
      return A2;
    }, this.getRenderTarget = function() {
      return b2;
    }, this.setRenderTargetTextures = function(e4, t3, i3) {
      W2.get(e4.texture).__webglTexture = t3, W2.get(e4.depthTexture).__webglTexture = i3;
      const n3 = W2.get(e4);
      n3.__hasExternalTextures = true, n3.__hasExternalTextures && (n3.__autoAllocateDepthBuffer = void 0 === i3, n3.__autoAllocateDepthBuffer || true === Q2.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), n3.__useRenderToTexture = false));
    }, this.setRenderTargetFramebuffer = function(e4, t3) {
      const i3 = W2.get(e4);
      i3.__webglFramebuffer = t3, i3.__useDefaultFramebuffer = void 0 === t3;
    }, this.setRenderTarget = function(e4, t3 = 0, i3 = 0) {
      b2 = e4, v2 = t3, A2 = i3;
      let n3 = true, o3 = null, r3 = false, s3 = false;
      if (e4) {
        const i4 = W2.get(e4);
        void 0 !== i4.__useDefaultFramebuffer ? (G2.bindFramebuffer(36160, null), n3 = false) : void 0 === i4.__webglFramebuffer ? q2.setupRenderTarget(e4) : i4.__hasExternalTextures && q2.rebindTextures(e4, W2.get(e4.texture).__webglTexture, W2.get(e4.depthTexture).__webglTexture);
        const a3 = e4.texture;
        (a3.isData3DTexture || a3.isDataArrayTexture || a3.isCompressedArrayTexture) && (s3 = true);
        const l3 = W2.get(e4).__webglFramebuffer;
        e4.isWebGLCubeRenderTarget ? (o3 = l3[t3], r3 = true) : o3 = V2.isWebGL2 && e4.samples > 0 && false === q2.useMultisampledRTT(e4) ? W2.get(e4).__webglMultisampledFramebuffer : l3, x2.copy(e4.viewport), C2.copy(e4.scissor), S2 = e4.scissorTest;
      } else
        x2.copy(k2).multiplyScalar(T2).floor(), C2.copy(R2).multiplyScalar(T2).floor(), S2 = P2;
      if (G2.bindFramebuffer(36160, o3) && V2.drawBuffers && n3 && G2.drawBuffers(e4, o3), G2.viewport(x2), G2.scissor(C2), G2.setScissorTest(S2), r3) {
        const n4 = W2.get(e4.texture);
        de2.framebufferTexture2D(36160, 36064, 34069 + t3, n4.__webglTexture, i3);
      } else if (s3) {
        const n4 = W2.get(e4.texture), o4 = t3 || 0;
        de2.framebufferTextureLayer(36160, 36064, n4.__webglTexture, i3 || 0, o4);
      }
      y2 = -1;
    }, this.readRenderTargetPixels = function(e4, t3, i3, n3, o3, r3, s3) {
      if (!e4 || !e4.isWebGLRenderTarget)
        return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      let a3 = W2.get(e4).__webglFramebuffer;
      if (e4.isWebGLCubeRenderTarget && void 0 !== s3 && (a3 = a3[s3]), a3) {
        G2.bindFramebuffer(36160, a3);
        try {
          const s4 = e4.texture, a4 = s4.format, l3 = s4.type;
          if (a4 !== Xe && ce2.convert(a4) !== de2.getParameter(35739))
            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          const c3 = l3 === qe && (Q2.has("EXT_color_buffer_half_float") || V2.isWebGL2 && Q2.has("EXT_color_buffer_float"));
          if (!(l3 === Ge || ce2.convert(l3) === de2.getParameter(35738) || l3 === We && (V2.isWebGL2 || Q2.has("OES_texture_float") || Q2.has("WEBGL_color_buffer_float")) || c3))
            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          t3 >= 0 && t3 <= e4.width - n3 && i3 >= 0 && i3 <= e4.height - o3 && de2.readPixels(t3, i3, n3, o3, ce2.convert(a4), ce2.convert(l3), r3);
        } finally {
          const e5 = null !== b2 ? W2.get(b2).__webglFramebuffer : null;
          G2.bindFramebuffer(36160, e5);
        }
      }
    }, this.copyFramebufferToTexture = function(e4, t3, i3 = 0) {
      const n3 = Math.pow(2, -i3), o3 = Math.floor(t3.image.width * n3), r3 = Math.floor(t3.image.height * n3);
      q2.setTexture2D(t3, 0), de2.copyTexSubImage2D(3553, i3, 0, 0, e4.x, e4.y, o3, r3), G2.unbindTexture();
    }, this.copyTextureToTexture = function(e4, t3, i3, n3 = 0) {
      const o3 = t3.image.width, r3 = t3.image.height, s3 = ce2.convert(i3.format), a3 = ce2.convert(i3.type);
      q2.setTexture2D(i3, 0), de2.pixelStorei(37440, i3.flipY), de2.pixelStorei(37441, i3.premultiplyAlpha), de2.pixelStorei(3317, i3.unpackAlignment), t3.isDataTexture ? de2.texSubImage2D(3553, n3, e4.x, e4.y, o3, r3, s3, a3, t3.image.data) : t3.isCompressedTexture ? de2.compressedTexSubImage2D(3553, n3, e4.x, e4.y, t3.mipmaps[0].width, t3.mipmaps[0].height, s3, t3.mipmaps[0].data) : de2.texSubImage2D(3553, n3, e4.x, e4.y, s3, a3, t3.image), 0 === n3 && i3.generateMipmaps && de2.generateMipmap(3553), G2.unbindTexture();
    }, this.copyTextureToTexture3D = function(e4, t3, i3, n3, o3 = 0) {
      if (m2.isWebGL1Renderer)
        return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
      const r3 = e4.max.x - e4.min.x + 1, s3 = e4.max.y - e4.min.y + 1, a3 = e4.max.z - e4.min.z + 1, l3 = ce2.convert(n3.format), c3 = ce2.convert(n3.type);
      let h3;
      if (n3.isData3DTexture)
        q2.setTexture3D(n3, 0), h3 = 32879;
      else {
        if (!n3.isDataArrayTexture)
          return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        q2.setTexture2DArray(n3, 0), h3 = 35866;
      }
      de2.pixelStorei(37440, n3.flipY), de2.pixelStorei(37441, n3.premultiplyAlpha), de2.pixelStorei(3317, n3.unpackAlignment);
      const u3 = de2.getParameter(3314), d3 = de2.getParameter(32878), p3 = de2.getParameter(3316), _3 = de2.getParameter(3315), g3 = de2.getParameter(32877), f3 = i3.isCompressedTexture ? i3.mipmaps[0] : i3.image;
      de2.pixelStorei(3314, f3.width), de2.pixelStorei(32878, f3.height), de2.pixelStorei(3316, e4.min.x), de2.pixelStorei(3315, e4.min.y), de2.pixelStorei(32877, e4.min.z), i3.isDataTexture || i3.isData3DTexture ? de2.texSubImage3D(h3, o3, t3.x, t3.y, t3.z, r3, s3, a3, l3, c3, f3.data) : i3.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), de2.compressedTexSubImage3D(h3, o3, t3.x, t3.y, t3.z, r3, s3, a3, l3, f3.data)) : de2.texSubImage3D(h3, o3, t3.x, t3.y, t3.z, r3, s3, a3, l3, c3, f3), de2.pixelStorei(3314, u3), de2.pixelStorei(32878, d3), de2.pixelStorei(3316, p3), de2.pixelStorei(3315, _3), de2.pixelStorei(32877, g3), 0 === o3 && n3.generateMipmaps && de2.generateMipmap(h3), G2.unbindTexture();
    }, this.initTexture = function(e4) {
      e4.isCubeTexture ? q2.setTextureCube(e4, 0) : e4.isData3DTexture ? q2.setTexture3D(e4, 0) : e4.isDataArrayTexture || e4.isCompressedArrayTexture ? q2.setTexture2DArray(e4, 0) : q2.setTexture2D(e4, 0), G2.unbindTexture();
    }, this.resetState = function() {
      v2 = 0, A2 = 0, b2 = null, G2.reset(), he2.reset();
    }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get physicallyCorrectLights() {
    return console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), !this.useLegacyLights;
  }
  set physicallyCorrectLights(e3) {
    console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), this.useLegacyLights = !e3;
  }
}
(class extends fa {
}).prototype.isWebGL1Renderer = true;
class va extends _n {
  constructor() {
    super(), this.isScene = true, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e3, t2) {
    return super.copy(e3, t2), null !== e3.background && (this.background = e3.background.clone()), null !== e3.environment && (this.environment = e3.environment.clone()), null !== e3.fog && (this.fog = e3.fog.clone()), this.backgroundBlurriness = e3.backgroundBlurriness, this.backgroundIntensity = e3.backgroundIntensity, null !== e3.overrideMaterial && (this.overrideMaterial = e3.overrideMaterial.clone()), this.matrixAutoUpdate = e3.matrixAutoUpdate, this;
  }
  toJSON(e3) {
    const t2 = super.toJSON(e3);
    return null !== this.fog && (t2.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t2.object.backgroundBlurriness = this.backgroundBlurriness), 1 !== this.backgroundIntensity && (t2.object.backgroundIntensity = this.backgroundIntensity), t2;
  }
  get autoUpdate() {
    return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate;
  }
  set autoUpdate(e3) {
    console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate = e3;
  }
}
class Aa {
  constructor(e3, t2) {
    this.isInterleavedBuffer = true, this.array = e3, this.stride = t2, this.count = void 0 !== e3 ? e3.length / t2 : 0, this.usage = St, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = Pt();
  }
  onUploadCallback() {
  }
  set needsUpdate(e3) {
    true === e3 && this.version++;
  }
  setUsage(e3) {
    return this.usage = e3, this;
  }
  copy(e3) {
    return this.array = new e3.array.constructor(e3.array), this.count = e3.count, this.stride = e3.stride, this.usage = e3.usage, this;
  }
  copyAt(e3, t2, i2) {
    e3 *= this.stride, i2 *= t2.stride;
    for (let n2 = 0, o2 = this.stride; n2 < o2; n2++)
      this.array[e3 + n2] = t2.array[i2 + n2];
    return this;
  }
  set(e3, t2 = 0) {
    return this.array.set(e3, t2), this;
  }
  clone(e3) {
    void 0 === e3.arrayBuffers && (e3.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Pt()), void 0 === e3.arrayBuffers[this.array.buffer._uuid] && (e3.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t2 = new this.array.constructor(e3.arrayBuffers[this.array.buffer._uuid]), i2 = new this.constructor(t2, this.stride);
    return i2.setUsage(this.usage), i2;
  }
  onUpload(e3) {
    return this.onUploadCallback = e3, this;
  }
  toJSON(e3) {
    return void 0 === e3.arrayBuffers && (e3.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Pt()), void 0 === e3.arrayBuffers[this.array.buffer._uuid] && (e3.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride };
  }
}
const ba = new di();
class ya {
  constructor(e3, t2, i2, n2 = false) {
    this.isInterleavedBufferAttribute = true, this.name = "", this.data = e3, this.itemSize = t2, this.offset = i2, this.normalized = n2;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e3) {
    this.data.needsUpdate = e3;
  }
  applyMatrix4(e3) {
    for (let t2 = 0, i2 = this.data.count; t2 < i2; t2++)
      ba.fromBufferAttribute(this, t2), ba.applyMatrix4(e3), this.setXYZ(t2, ba.x, ba.y, ba.z);
    return this;
  }
  applyNormalMatrix(e3) {
    for (let t2 = 0, i2 = this.count; t2 < i2; t2++)
      ba.fromBufferAttribute(this, t2), ba.applyNormalMatrix(e3), this.setXYZ(t2, ba.x, ba.y, ba.z);
    return this;
  }
  transformDirection(e3) {
    for (let t2 = 0, i2 = this.count; t2 < i2; t2++)
      ba.fromBufferAttribute(this, t2), ba.transformDirection(e3), this.setXYZ(t2, ba.x, ba.y, ba.z);
    return this;
  }
  setX(e3, t2) {
    return this.normalized && (t2 = Ht(t2, this.array)), this.data.array[e3 * this.data.stride + this.offset] = t2, this;
  }
  setY(e3, t2) {
    return this.normalized && (t2 = Ht(t2, this.array)), this.data.array[e3 * this.data.stride + this.offset + 1] = t2, this;
  }
  setZ(e3, t2) {
    return this.normalized && (t2 = Ht(t2, this.array)), this.data.array[e3 * this.data.stride + this.offset + 2] = t2, this;
  }
  setW(e3, t2) {
    return this.normalized && (t2 = Ht(t2, this.array)), this.data.array[e3 * this.data.stride + this.offset + 3] = t2, this;
  }
  getX(e3) {
    let t2 = this.data.array[e3 * this.data.stride + this.offset];
    return this.normalized && (t2 = Ut(t2, this.array)), t2;
  }
  getY(e3) {
    let t2 = this.data.array[e3 * this.data.stride + this.offset + 1];
    return this.normalized && (t2 = Ut(t2, this.array)), t2;
  }
  getZ(e3) {
    let t2 = this.data.array[e3 * this.data.stride + this.offset + 2];
    return this.normalized && (t2 = Ut(t2, this.array)), t2;
  }
  getW(e3) {
    let t2 = this.data.array[e3 * this.data.stride + this.offset + 3];
    return this.normalized && (t2 = Ut(t2, this.array)), t2;
  }
  setXY(e3, t2, i2) {
    return e3 = e3 * this.data.stride + this.offset, this.normalized && (t2 = Ht(t2, this.array), i2 = Ht(i2, this.array)), this.data.array[e3 + 0] = t2, this.data.array[e3 + 1] = i2, this;
  }
  setXYZ(e3, t2, i2, n2) {
    return e3 = e3 * this.data.stride + this.offset, this.normalized && (t2 = Ht(t2, this.array), i2 = Ht(i2, this.array), n2 = Ht(n2, this.array)), this.data.array[e3 + 0] = t2, this.data.array[e3 + 1] = i2, this.data.array[e3 + 2] = n2, this;
  }
  setXYZW(e3, t2, i2, n2, o2) {
    return e3 = e3 * this.data.stride + this.offset, this.normalized && (t2 = Ht(t2, this.array), i2 = Ht(i2, this.array), n2 = Ht(n2, this.array), o2 = Ht(o2, this.array)), this.data.array[e3 + 0] = t2, this.data.array[e3 + 1] = i2, this.data.array[e3 + 2] = n2, this.data.array[e3 + 3] = o2, this;
  }
  clone(e3) {
    if (void 0 === e3) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const e4 = [];
      for (let t2 = 0; t2 < this.count; t2++) {
        const i2 = t2 * this.data.stride + this.offset;
        for (let t3 = 0; t3 < this.itemSize; t3++)
          e4.push(this.data.array[i2 + t3]);
      }
      return new Hn(new this.array.constructor(e4), this.itemSize, this.normalized);
    }
    return void 0 === e3.interleavedBuffers && (e3.interleavedBuffers = {}), void 0 === e3.interleavedBuffers[this.data.uuid] && (e3.interleavedBuffers[this.data.uuid] = this.data.clone(e3)), new ya(e3.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e3) {
    if (void 0 === e3) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const e4 = [];
      for (let t2 = 0; t2 < this.count; t2++) {
        const i2 = t2 * this.data.stride + this.offset;
        for (let t3 = 0; t3 < this.itemSize; t3++)
          e4.push(this.data.array[i2 + t3]);
      }
      return { itemSize: this.itemSize, type: this.array.constructor.name, array: e4, normalized: this.normalized };
    }
    return void 0 === e3.interleavedBuffers && (e3.interleavedBuffers = {}), void 0 === e3.interleavedBuffers[this.data.uuid] && (e3.interleavedBuffers[this.data.uuid] = this.data.toJSON(e3)), { isInterleavedBufferAttribute: true, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized };
  }
}
class wa extends Tn {
  constructor(e3) {
    super(), this.isSpriteMaterial = true, this.type = "SpriteMaterial", this.color = new Pn(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = true, this.transparent = true, this.fog = true, this.setValues(e3);
  }
  copy(e3) {
    return super.copy(e3), this.color.copy(e3.color), this.map = e3.map, this.alphaMap = e3.alphaMap, this.rotation = e3.rotation, this.sizeAttenuation = e3.sizeAttenuation, this.fog = e3.fog, this;
  }
}
let xa;
const Ca = new di(), Sa = new di(), Ea = new di(), Ia = new Vt(), Ta = new Vt(), Ba = new Qi(), Ma = new di(), ka = new di(), Ra = new di(), Pa = new Vt(), Da = new Vt(), La = new Vt();
class Fa extends _n {
  constructor(e3) {
    if (super(), this.isSprite = true, this.type = "Sprite", void 0 === xa) {
      xa = new Zn();
      const e4 = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]), t2 = new Aa(e4, 5);
      xa.setIndex([0, 1, 2, 0, 2, 3]), xa.setAttribute("position", new ya(t2, 3, 0, false)), xa.setAttribute("uv", new ya(t2, 2, 3, false));
    }
    this.geometry = xa, this.material = void 0 !== e3 ? e3 : new wa(), this.center = new Vt(0.5, 0.5);
  }
  raycast(e3, t2) {
    null === e3.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Sa.setFromMatrixScale(this.matrixWorld), Ba.copy(e3.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e3.camera.matrixWorldInverse, this.matrixWorld), Ea.setFromMatrixPosition(this.modelViewMatrix), e3.camera.isPerspectiveCamera && false === this.material.sizeAttenuation && Sa.multiplyScalar(-Ea.z);
    const i2 = this.material.rotation;
    let n2, o2;
    0 !== i2 && (o2 = Math.cos(i2), n2 = Math.sin(i2));
    const r2 = this.center;
    Na(Ma.set(-0.5, -0.5, 0), Ea, r2, Sa, n2, o2), Na(ka.set(0.5, -0.5, 0), Ea, r2, Sa, n2, o2), Na(Ra.set(0.5, 0.5, 0), Ea, r2, Sa, n2, o2), Pa.set(0, 0), Da.set(1, 0), La.set(1, 1);
    let s2 = e3.ray.intersectTriangle(Ma, ka, Ra, false, Ca);
    if (null === s2 && (Na(ka.set(-0.5, 0.5, 0), Ea, r2, Sa, n2, o2), Da.set(0, 1), s2 = e3.ray.intersectTriangle(Ma, Ra, ka, false, Ca), null === s2))
      return;
    const a2 = e3.ray.origin.distanceTo(Ca);
    a2 < e3.near || a2 > e3.far || t2.push({ distance: a2, point: Ca.clone(), uv: En.getInterpolation(Ca, Ma, ka, Ra, Pa, Da, La, new Vt()), face: null, object: this });
  }
  copy(e3, t2) {
    return super.copy(e3, t2), void 0 !== e3.center && this.center.copy(e3.center), this.material = e3.material, this;
  }
}
function Na(e3, t2, i2, n2, o2, r2) {
  Ia.subVectors(e3, i2).addScalar(0.5).multiply(n2), void 0 !== o2 ? (Ta.x = r2 * Ia.x - o2 * Ia.y, Ta.y = o2 * Ia.x + r2 * Ia.y) : Ta.copy(Ia), e3.copy(t2), e3.x += Ta.x, e3.y += Ta.y, e3.applyMatrix4(Ba);
}
const Oa = new di(), za = new ai(), Ua = new ai(), Ha = new di(), Qa = new Qi(), Va = new di();
class Ga extends fo {
  constructor(e3, t2) {
    super(e3, t2), this.isSkinnedMesh = true, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Qi(), this.bindMatrixInverse = new Qi(), this.boundingBox = null, this.boundingSphere = null;
  }
  computeBoundingBox() {
    const e3 = this.geometry;
    null === this.boundingBox && (this.boundingBox = new gi()), this.boundingBox.makeEmpty();
    const t2 = e3.getAttribute("position");
    for (let e4 = 0; e4 < t2.count; e4++)
      Va.fromBufferAttribute(t2, e4), this.applyBoneTransform(e4, Va), this.boundingBox.expandByPoint(Va);
  }
  computeBoundingSphere() {
    const e3 = this.geometry;
    null === this.boundingSphere && (this.boundingSphere = new Pi()), this.boundingSphere.makeEmpty();
    const t2 = e3.getAttribute("position");
    for (let e4 = 0; e4 < t2.count; e4++)
      Va.fromBufferAttribute(t2, e4), this.applyBoneTransform(e4, Va), this.boundingSphere.expandByPoint(Va);
  }
  copy(e3, t2) {
    return super.copy(e3, t2), this.bindMode = e3.bindMode, this.bindMatrix.copy(e3.bindMatrix), this.bindMatrixInverse.copy(e3.bindMatrixInverse), this.skeleton = e3.skeleton, this;
  }
  bind(e3, t2) {
    this.skeleton = e3, void 0 === t2 && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), t2 = this.matrixWorld), this.bindMatrix.copy(t2), this.bindMatrixInverse.copy(t2).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e3 = new ai(), t2 = this.geometry.attributes.skinWeight;
    for (let i2 = 0, n2 = t2.count; i2 < n2; i2++) {
      e3.fromBufferAttribute(t2, i2);
      const n3 = 1 / e3.manhattanLength();
      n3 !== 1 / 0 ? e3.multiplyScalar(n3) : e3.set(1, 0, 0, 0), t2.setXYZW(i2, e3.x, e3.y, e3.z, e3.w);
    }
  }
  updateMatrixWorld(e3) {
    super.updateMatrixWorld(e3), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }
  applyBoneTransform(e3, t2) {
    const i2 = this.skeleton, n2 = this.geometry;
    za.fromBufferAttribute(n2.attributes.skinIndex, e3), Ua.fromBufferAttribute(n2.attributes.skinWeight, e3), Oa.copy(t2).applyMatrix4(this.bindMatrix), t2.set(0, 0, 0);
    for (let e4 = 0; e4 < 4; e4++) {
      const n3 = Ua.getComponent(e4);
      if (0 !== n3) {
        const o2 = za.getComponent(e4);
        Qa.multiplyMatrices(i2.bones[o2].matrixWorld, i2.boneInverses[o2]), t2.addScaledVector(Ha.copy(Oa).applyMatrix4(Qa), n3);
      }
    }
    return t2.applyMatrix4(this.bindMatrixInverse);
  }
  boneTransform(e3, t2) {
    return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."), this.applyBoneTransform(e3, t2);
  }
}
class $a extends _n {
  constructor() {
    super(), this.isBone = true, this.type = "Bone";
  }
}
class Wa extends si {
  constructor(e3 = null, t2 = 1, i2 = 1, n2, o2, r2, s2, a2, l2 = 1003, c2 = 1003, h2, u2) {
    super(null, r2, s2, a2, l2, c2, n2, o2, h2, u2), this.isDataTexture = true, this.image = { data: e3, width: t2, height: i2 }, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
  }
}
const qa = new Qi(), ja = new Qi();
class Xa {
  constructor(e3 = [], t2 = []) {
    this.uuid = Pt(), this.bones = e3.slice(0), this.boneInverses = t2, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init();
  }
  init() {
    const e3 = this.bones, t2 = this.boneInverses;
    if (this.boneMatrices = new Float32Array(16 * e3.length), 0 === t2.length)
      this.calculateInverses();
    else if (e3.length !== t2.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let e4 = 0, t3 = this.bones.length; e4 < t3; e4++)
        this.boneInverses.push(new Qi());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e3 = 0, t2 = this.bones.length; e3 < t2; e3++) {
      const t3 = new Qi();
      this.bones[e3] && t3.copy(this.bones[e3].matrixWorld).invert(), this.boneInverses.push(t3);
    }
  }
  pose() {
    for (let e3 = 0, t2 = this.bones.length; e3 < t2; e3++) {
      const t3 = this.bones[e3];
      t3 && t3.matrixWorld.copy(this.boneInverses[e3]).invert();
    }
    for (let e3 = 0, t2 = this.bones.length; e3 < t2; e3++) {
      const t3 = this.bones[e3];
      t3 && (t3.parent && t3.parent.isBone ? (t3.matrix.copy(t3.parent.matrixWorld).invert(), t3.matrix.multiply(t3.matrixWorld)) : t3.matrix.copy(t3.matrixWorld), t3.matrix.decompose(t3.position, t3.quaternion, t3.scale));
    }
  }
  update() {
    const e3 = this.bones, t2 = this.boneInverses, i2 = this.boneMatrices, n2 = this.boneTexture;
    for (let n3 = 0, o2 = e3.length; n3 < o2; n3++) {
      const o3 = e3[n3] ? e3[n3].matrixWorld : ja;
      qa.multiplyMatrices(o3, t2[n3]), qa.toArray(i2, 16 * n3);
    }
    null !== n2 && (n2.needsUpdate = true);
  }
  clone() {
    return new Xa(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e3 = Math.sqrt(4 * this.bones.length);
    e3 = Ot(e3), e3 = Math.max(e3, 4);
    const t2 = new Float32Array(e3 * e3 * 4);
    t2.set(this.boneMatrices);
    const i2 = new Wa(t2, e3, e3, Xe, We);
    return i2.needsUpdate = true, this.boneMatrices = t2, this.boneTexture = i2, this.boneTextureSize = e3, this;
  }
  getBoneByName(e3) {
    for (let t2 = 0, i2 = this.bones.length; t2 < i2; t2++) {
      const i3 = this.bones[t2];
      if (i3.name === e3)
        return i3;
    }
  }
  dispose() {
    null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  fromJSON(e3, t2) {
    this.uuid = e3.uuid;
    for (let i2 = 0, n2 = e3.bones.length; i2 < n2; i2++) {
      const n3 = e3.bones[i2];
      let o2 = t2[n3];
      void 0 === o2 && (console.warn("THREE.Skeleton: No bone found with UUID:", n3), o2 = new $a()), this.bones.push(o2), this.boneInverses.push(new Qi().fromArray(e3.boneInverses[i2]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e3 = { metadata: { version: 4.5, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] };
    e3.uuid = this.uuid;
    const t2 = this.bones, i2 = this.boneInverses;
    for (let n2 = 0, o2 = t2.length; n2 < o2; n2++) {
      const o3 = t2[n2];
      e3.bones.push(o3.uuid);
      const r2 = i2[n2];
      e3.boneInverses.push(r2.toArray());
    }
    return e3;
  }
}
class Ya extends Hn {
  constructor(e3, t2, i2, n2 = 1) {
    super(e3, t2, i2), this.isInstancedBufferAttribute = true, this.meshPerAttribute = n2;
  }
  copy(e3) {
    return super.copy(e3), this.meshPerAttribute = e3.meshPerAttribute, this;
  }
  toJSON() {
    const e3 = super.toJSON();
    return e3.meshPerAttribute = this.meshPerAttribute, e3.isInstancedBufferAttribute = true, e3;
  }
}
const Ka = new Qi(), Za = new Qi(), Ja = [], el = new gi(), tl = new Qi(), il = new fo(), nl = new Pi();
class ol extends fo {
  constructor(e3, t2, i2) {
    super(e3, t2), this.isInstancedMesh = true, this.instanceMatrix = new Ya(new Float32Array(16 * i2), 16), this.instanceColor = null, this.count = i2, this.boundingBox = null, this.boundingSphere = null;
    for (let e4 = 0; e4 < i2; e4++)
      this.setMatrixAt(e4, tl);
  }
  computeBoundingBox() {
    const e3 = this.geometry, t2 = this.count;
    null === this.boundingBox && (this.boundingBox = new gi()), null === e3.boundingBox && e3.computeBoundingBox(), this.boundingBox.makeEmpty();
    for (let i2 = 0; i2 < t2; i2++)
      this.getMatrixAt(i2, Ka), el.copy(e3.boundingBox).applyMatrix4(Ka), this.boundingBox.union(el);
  }
  computeBoundingSphere() {
    const e3 = this.geometry, t2 = this.count;
    null === this.boundingSphere && (this.boundingSphere = new Pi()), null === e3.boundingSphere && e3.computeBoundingSphere(), this.boundingSphere.makeEmpty();
    for (let i2 = 0; i2 < t2; i2++)
      this.getMatrixAt(i2, Ka), nl.copy(e3.boundingSphere).applyMatrix4(Ka), this.boundingSphere.union(nl);
  }
  copy(e3, t2) {
    return super.copy(e3, t2), this.instanceMatrix.copy(e3.instanceMatrix), null !== e3.instanceColor && (this.instanceColor = e3.instanceColor.clone()), this.count = e3.count, this;
  }
  getColorAt(e3, t2) {
    t2.fromArray(this.instanceColor.array, 3 * e3);
  }
  getMatrixAt(e3, t2) {
    t2.fromArray(this.instanceMatrix.array, 16 * e3);
  }
  raycast(e3, t2) {
    const i2 = this.matrixWorld, n2 = this.count;
    if (il.geometry = this.geometry, il.material = this.material, void 0 !== il.material && (null === this.boundingSphere && this.computeBoundingSphere(), nl.copy(this.boundingSphere), nl.applyMatrix4(i2), false !== e3.ray.intersectsSphere(nl)))
      for (let o2 = 0; o2 < n2; o2++) {
        this.getMatrixAt(o2, Ka), Za.multiplyMatrices(i2, Ka), il.matrixWorld = Za, il.raycast(e3, Ja);
        for (let e4 = 0, i3 = Ja.length; e4 < i3; e4++) {
          const i4 = Ja[e4];
          i4.instanceId = o2, i4.object = this, t2.push(i4);
        }
        Ja.length = 0;
      }
  }
  setColorAt(e3, t2) {
    null === this.instanceColor && (this.instanceColor = new Ya(new Float32Array(3 * this.instanceMatrix.count), 3)), t2.toArray(this.instanceColor.array, 3 * e3);
  }
  setMatrixAt(e3, t2) {
    t2.toArray(this.instanceMatrix.array, 16 * e3);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class rl extends Tn {
  constructor(e3) {
    super(), this.isLineBasicMaterial = true, this.type = "LineBasicMaterial", this.color = new Pn(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = true, this.setValues(e3);
  }
  copy(e3) {
    return super.copy(e3), this.color.copy(e3.color), this.map = e3.map, this.linewidth = e3.linewidth, this.linecap = e3.linecap, this.linejoin = e3.linejoin, this.fog = e3.fog, this;
  }
}
const sl = new di(), al = new di(), ll = new Qi(), cl = new Hi(), hl = new Pi();
class ul extends _n {
  constructor(e3 = new Zn(), t2 = new rl()) {
    super(), this.isLine = true, this.type = "Line", this.geometry = e3, this.material = t2, this.updateMorphTargets();
  }
  copy(e3, t2) {
    return super.copy(e3, t2), this.material = e3.material, this.geometry = e3.geometry, this;
  }
  computeLineDistances() {
    const e3 = this.geometry;
    if (null === e3.index) {
      const t2 = e3.attributes.position, i2 = [0];
      for (let e4 = 1, n2 = t2.count; e4 < n2; e4++)
        sl.fromBufferAttribute(t2, e4 - 1), al.fromBufferAttribute(t2, e4), i2[e4] = i2[e4 - 1], i2[e4] += sl.distanceTo(al);
      e3.setAttribute("lineDistance", new Gn(i2, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e3, t2) {
    const i2 = this.geometry, n2 = this.matrixWorld, o2 = e3.params.Line.threshold, r2 = i2.drawRange;
    if (null === i2.boundingSphere && i2.computeBoundingSphere(), hl.copy(i2.boundingSphere), hl.applyMatrix4(n2), hl.radius += o2, false === e3.ray.intersectsSphere(hl))
      return;
    ll.copy(n2).invert(), cl.copy(e3.ray).applyMatrix4(ll);
    const s2 = o2 / ((this.scale.x + this.scale.y + this.scale.z) / 3), a2 = s2 * s2, l2 = new di(), c2 = new di(), h2 = new di(), u2 = new di(), d2 = this.isLineSegments ? 2 : 1, p2 = i2.index, _2 = i2.attributes.position;
    if (null !== p2) {
      for (let i3 = Math.max(0, r2.start), n3 = Math.min(p2.count, r2.start + r2.count) - 1; i3 < n3; i3 += d2) {
        const n4 = p2.getX(i3), o3 = p2.getX(i3 + 1);
        l2.fromBufferAttribute(_2, n4), c2.fromBufferAttribute(_2, o3);
        if (cl.distanceSqToSegment(l2, c2, u2, h2) > a2)
          continue;
        u2.applyMatrix4(this.matrixWorld);
        const r3 = e3.ray.origin.distanceTo(u2);
        r3 < e3.near || r3 > e3.far || t2.push({ distance: r3, point: h2.clone().applyMatrix4(this.matrixWorld), index: i3, face: null, faceIndex: null, object: this });
      }
    } else {
      for (let i3 = Math.max(0, r2.start), n3 = Math.min(_2.count, r2.start + r2.count) - 1; i3 < n3; i3 += d2) {
        l2.fromBufferAttribute(_2, i3), c2.fromBufferAttribute(_2, i3 + 1);
        if (cl.distanceSqToSegment(l2, c2, u2, h2) > a2)
          continue;
        u2.applyMatrix4(this.matrixWorld);
        const n4 = e3.ray.origin.distanceTo(u2);
        n4 < e3.near || n4 > e3.far || t2.push({ distance: n4, point: h2.clone().applyMatrix4(this.matrixWorld), index: i3, face: null, faceIndex: null, object: this });
      }
    }
  }
  updateMorphTargets() {
    const e3 = this.geometry.morphAttributes, t2 = Object.keys(e3);
    if (t2.length > 0) {
      const i2 = e3[t2[0]];
      if (void 0 !== i2) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let e4 = 0, t3 = i2.length; e4 < t3; e4++) {
          const t4 = i2[e4].name || String(e4);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[t4] = e4;
        }
      }
    }
  }
}
const dl = new di(), pl = new di();
class _l extends ul {
  constructor(e3, t2) {
    super(e3, t2), this.isLineSegments = true, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e3 = this.geometry;
    if (null === e3.index) {
      const t2 = e3.attributes.position, i2 = [];
      for (let e4 = 0, n2 = t2.count; e4 < n2; e4 += 2)
        dl.fromBufferAttribute(t2, e4), pl.fromBufferAttribute(t2, e4 + 1), i2[e4] = 0 === e4 ? 0 : i2[e4 - 1], i2[e4 + 1] = i2[e4] + dl.distanceTo(pl);
      e3.setAttribute("lineDistance", new Gn(i2, 1));
    } else
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class gl extends ul {
  constructor(e3, t2) {
    super(e3, t2), this.isLineLoop = true, this.type = "LineLoop";
  }
}
class ml extends Tn {
  constructor(e3) {
    super(), this.isPointsMaterial = true, this.type = "PointsMaterial", this.color = new Pn(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = true, this.fog = true, this.setValues(e3);
  }
  copy(e3) {
    return super.copy(e3), this.color.copy(e3.color), this.map = e3.map, this.alphaMap = e3.alphaMap, this.size = e3.size, this.sizeAttenuation = e3.sizeAttenuation, this.fog = e3.fog, this;
  }
}
const fl = new Qi(), vl = new Hi(), Al = new Pi(), bl = new di();
class yl extends _n {
  constructor(e3 = new Zn(), t2 = new ml()) {
    super(), this.isPoints = true, this.type = "Points", this.geometry = e3, this.material = t2, this.updateMorphTargets();
  }
  copy(e3, t2) {
    return super.copy(e3, t2), this.material = e3.material, this.geometry = e3.geometry, this;
  }
  raycast(e3, t2) {
    const i2 = this.geometry, n2 = this.matrixWorld, o2 = e3.params.Points.threshold, r2 = i2.drawRange;
    if (null === i2.boundingSphere && i2.computeBoundingSphere(), Al.copy(i2.boundingSphere), Al.applyMatrix4(n2), Al.radius += o2, false === e3.ray.intersectsSphere(Al))
      return;
    fl.copy(n2).invert(), vl.copy(e3.ray).applyMatrix4(fl);
    const s2 = o2 / ((this.scale.x + this.scale.y + this.scale.z) / 3), a2 = s2 * s2, l2 = i2.index, c2 = i2.attributes.position;
    if (null !== l2) {
      for (let i3 = Math.max(0, r2.start), o3 = Math.min(l2.count, r2.start + r2.count); i3 < o3; i3++) {
        const o4 = l2.getX(i3);
        bl.fromBufferAttribute(c2, o4), wl(bl, o4, a2, n2, e3, t2, this);
      }
    } else {
      for (let i3 = Math.max(0, r2.start), o3 = Math.min(c2.count, r2.start + r2.count); i3 < o3; i3++)
        bl.fromBufferAttribute(c2, i3), wl(bl, i3, a2, n2, e3, t2, this);
    }
  }
  updateMorphTargets() {
    const e3 = this.geometry.morphAttributes, t2 = Object.keys(e3);
    if (t2.length > 0) {
      const i2 = e3[t2[0]];
      if (void 0 !== i2) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let e4 = 0, t3 = i2.length; e4 < t3; e4++) {
          const t4 = i2[e4].name || String(e4);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[t4] = e4;
        }
      }
    }
  }
}
function wl(e3, t2, i2, n2, o2, r2, s2) {
  const a2 = vl.distanceSqToPoint(e3);
  if (a2 < i2) {
    const i3 = new di();
    vl.closestPointToPoint(e3, i3), i3.applyMatrix4(n2);
    const l2 = o2.ray.origin.distanceTo(i3);
    if (l2 < o2.near || l2 > o2.far)
      return;
    r2.push({ distance: l2, distanceToRay: Math.sqrt(a2), point: i3, index: t2, face: null, object: s2 });
  }
}
class xl extends si {
  constructor(e3, t2, i2, n2, o2, r2, s2, a2, l2) {
    super(e3, t2, i2, n2, o2, r2, s2, a2, l2), this.isVideoTexture = true, this.minFilter = void 0 !== r2 ? r2 : He, this.magFilter = void 0 !== o2 ? o2 : He, this.generateMipmaps = false;
    const c2 = this;
    "requestVideoFrameCallback" in e3 && e3.requestVideoFrameCallback(function t3() {
      c2.needsUpdate = true, e3.requestVideoFrameCallback(t3);
    });
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e3 = this.image;
    false === "requestVideoFrameCallback" in e3 && e3.readyState >= e3.HAVE_CURRENT_DATA && (this.needsUpdate = true);
  }
}
class Cl extends si {
  constructor(e3, t2, i2, n2, o2, r2, s2, a2, l2, c2, h2, u2) {
    super(null, r2, s2, a2, l2, c2, n2, o2, h2, u2), this.isCompressedTexture = true, this.image = { width: t2, height: i2 }, this.mipmaps = e3, this.flipY = false, this.generateMipmaps = false;
  }
}
class Sl extends Cl {
  constructor(e3, t2, i2, n2, o2, r2) {
    super(e3, t2, i2, o2, r2), this.isCompressedArrayTexture = true, this.image.depth = n2, this.wrapR = Fe;
  }
}
class El extends si {
  constructor(e3, t2, i2, n2, o2, r2, s2, a2, l2) {
    super(e3, t2, i2, n2, o2, r2, s2, a2, l2), this.isCanvasTexture = true, this.needsUpdate = true;
  }
}
class Il extends Zn {
  constructor(e3 = 1, t2 = 1, i2 = 1, n2 = 32, o2 = 1, r2 = false, s2 = 0, a2 = 2 * Math.PI) {
    super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: e3, radiusBottom: t2, height: i2, radialSegments: n2, heightSegments: o2, openEnded: r2, thetaStart: s2, thetaLength: a2 };
    const l2 = this;
    n2 = Math.floor(n2), o2 = Math.floor(o2);
    const c2 = [], h2 = [], u2 = [], d2 = [];
    let p2 = 0;
    const _2 = [], g2 = i2 / 2;
    let m2 = 0;
    function f2(i3) {
      const o3 = p2, r3 = new Vt(), _3 = new di();
      let f3 = 0;
      const v2 = true === i3 ? e3 : t2, A2 = true === i3 ? 1 : -1;
      for (let e4 = 1; e4 <= n2; e4++)
        h2.push(0, g2 * A2, 0), u2.push(0, A2, 0), d2.push(0.5, 0.5), p2++;
      const b2 = p2;
      for (let e4 = 0; e4 <= n2; e4++) {
        const t3 = e4 / n2 * a2 + s2, i4 = Math.cos(t3), o4 = Math.sin(t3);
        _3.x = v2 * o4, _3.y = g2 * A2, _3.z = v2 * i4, h2.push(_3.x, _3.y, _3.z), u2.push(0, A2, 0), r3.x = 0.5 * i4 + 0.5, r3.y = 0.5 * o4 * A2 + 0.5, d2.push(r3.x, r3.y), p2++;
      }
      for (let e4 = 0; e4 < n2; e4++) {
        const t3 = o3 + e4, n3 = b2 + e4;
        true === i3 ? c2.push(n3, n3 + 1, t3) : c2.push(n3 + 1, n3, t3), f3 += 3;
      }
      l2.addGroup(m2, f3, true === i3 ? 1 : 2), m2 += f3;
    }
    !function() {
      const r3 = new di(), f3 = new di();
      let v2 = 0;
      const A2 = (t2 - e3) / i2;
      for (let l3 = 0; l3 <= o2; l3++) {
        const c3 = [], m3 = l3 / o2, v3 = m3 * (t2 - e3) + e3;
        for (let e4 = 0; e4 <= n2; e4++) {
          const t3 = e4 / n2, o3 = t3 * a2 + s2, l4 = Math.sin(o3), _3 = Math.cos(o3);
          f3.x = v3 * l4, f3.y = -m3 * i2 + g2, f3.z = v3 * _3, h2.push(f3.x, f3.y, f3.z), r3.set(l4, A2, _3).normalize(), u2.push(r3.x, r3.y, r3.z), d2.push(t3, 1 - m3), c3.push(p2++);
        }
        _2.push(c3);
      }
      for (let e4 = 0; e4 < n2; e4++)
        for (let t3 = 0; t3 < o2; t3++) {
          const i3 = _2[t3][e4], n3 = _2[t3 + 1][e4], o3 = _2[t3 + 1][e4 + 1], r4 = _2[t3][e4 + 1];
          c2.push(i3, n3, r4), c2.push(n3, o3, r4), v2 += 6;
        }
      l2.addGroup(m2, v2, 0), m2 += v2;
    }(), false === r2 && (e3 > 0 && f2(true), t2 > 0 && f2(false)), this.setIndex(c2), this.setAttribute("position", new Gn(h2, 3)), this.setAttribute("normal", new Gn(u2, 3)), this.setAttribute("uv", new Gn(d2, 2));
  }
  copy(e3) {
    return super.copy(e3), this.parameters = Object.assign({}, e3.parameters), this;
  }
  static fromJSON(e3) {
    return new Il(e3.radiusTop, e3.radiusBottom, e3.height, e3.radialSegments, e3.heightSegments, e3.openEnded, e3.thetaStart, e3.thetaLength);
  }
}
class Tl extends Tn {
  constructor(e3) {
    super(), this.isMeshStandardMaterial = true, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Pn(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Pn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Vt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(e3);
  }
  copy(e3) {
    return super.copy(e3), this.defines = { STANDARD: "" }, this.color.copy(e3.color), this.roughness = e3.roughness, this.metalness = e3.metalness, this.map = e3.map, this.lightMap = e3.lightMap, this.lightMapIntensity = e3.lightMapIntensity, this.aoMap = e3.aoMap, this.aoMapIntensity = e3.aoMapIntensity, this.emissive.copy(e3.emissive), this.emissiveMap = e3.emissiveMap, this.emissiveIntensity = e3.emissiveIntensity, this.bumpMap = e3.bumpMap, this.bumpScale = e3.bumpScale, this.normalMap = e3.normalMap, this.normalMapType = e3.normalMapType, this.normalScale.copy(e3.normalScale), this.displacementMap = e3.displacementMap, this.displacementScale = e3.displacementScale, this.displacementBias = e3.displacementBias, this.roughnessMap = e3.roughnessMap, this.metalnessMap = e3.metalnessMap, this.alphaMap = e3.alphaMap, this.envMap = e3.envMap, this.envMapIntensity = e3.envMapIntensity, this.wireframe = e3.wireframe, this.wireframeLinewidth = e3.wireframeLinewidth, this.wireframeLinecap = e3.wireframeLinecap, this.wireframeLinejoin = e3.wireframeLinejoin, this.flatShading = e3.flatShading, this.fog = e3.fog, this;
  }
}
class Bl extends Tl {
  constructor(e3) {
    super(), this.isMeshPhysicalMaterial = true, this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Vt(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function() {
      return Dt(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
    }, set: function(e4) {
      this.ior = (1 + 0.4 * e4) / (1 - 0.4 * e4);
    } }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Pn(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Pn(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Pn(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._iridescence = 0, this._transmission = 0, this.setValues(e3);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e3) {
    this._sheen > 0 != e3 > 0 && this.version++, this._sheen = e3;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e3) {
    this._clearcoat > 0 != e3 > 0 && this.version++, this._clearcoat = e3;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e3) {
    this._iridescence > 0 != e3 > 0 && this.version++, this._iridescence = e3;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e3) {
    this._transmission > 0 != e3 > 0 && this.version++, this._transmission = e3;
  }
  copy(e3) {
    return super.copy(e3), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = e3.clearcoat, this.clearcoatMap = e3.clearcoatMap, this.clearcoatRoughness = e3.clearcoatRoughness, this.clearcoatRoughnessMap = e3.clearcoatRoughnessMap, this.clearcoatNormalMap = e3.clearcoatNormalMap, this.clearcoatNormalScale.copy(e3.clearcoatNormalScale), this.ior = e3.ior, this.iridescence = e3.iridescence, this.iridescenceMap = e3.iridescenceMap, this.iridescenceIOR = e3.iridescenceIOR, this.iridescenceThicknessRange = [...e3.iridescenceThicknessRange], this.iridescenceThicknessMap = e3.iridescenceThicknessMap, this.sheen = e3.sheen, this.sheenColor.copy(e3.sheenColor), this.sheenColorMap = e3.sheenColorMap, this.sheenRoughness = e3.sheenRoughness, this.sheenRoughnessMap = e3.sheenRoughnessMap, this.transmission = e3.transmission, this.transmissionMap = e3.transmissionMap, this.thickness = e3.thickness, this.thicknessMap = e3.thicknessMap, this.attenuationDistance = e3.attenuationDistance, this.attenuationColor.copy(e3.attenuationColor), this.specularIntensity = e3.specularIntensity, this.specularIntensityMap = e3.specularIntensityMap, this.specularColor.copy(e3.specularColor), this.specularColorMap = e3.specularColorMap, this;
  }
}
class Ml extends rl {
  constructor(e3) {
    super(), this.isLineDashedMaterial = true, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e3);
  }
  copy(e3) {
    return super.copy(e3), this.scale = e3.scale, this.dashSize = e3.dashSize, this.gapSize = e3.gapSize, this;
  }
}
function kl(e3, t2, i2) {
  return Pl(e3) ? new e3.constructor(e3.subarray(t2, void 0 !== i2 ? i2 : e3.length)) : e3.slice(t2, i2);
}
function Rl(e3, t2, i2) {
  return !e3 || !i2 && e3.constructor === t2 ? e3 : "number" == typeof t2.BYTES_PER_ELEMENT ? new t2(e3) : Array.prototype.slice.call(e3);
}
function Pl(e3) {
  return ArrayBuffer.isView(e3) && !(e3 instanceof DataView);
}
function Dl(e3) {
  const t2 = e3.length, i2 = new Array(t2);
  for (let e4 = 0; e4 !== t2; ++e4)
    i2[e4] = e4;
  return i2.sort(function(t3, i3) {
    return e3[t3] - e3[i3];
  }), i2;
}
function Ll(e3, t2, i2) {
  const n2 = e3.length, o2 = new e3.constructor(n2);
  for (let r2 = 0, s2 = 0; s2 !== n2; ++r2) {
    const n3 = i2[r2] * t2;
    for (let i3 = 0; i3 !== t2; ++i3)
      o2[s2++] = e3[n3 + i3];
  }
  return o2;
}
function Fl(e3, t2, i2, n2) {
  let o2 = 1, r2 = e3[0];
  for (; void 0 !== r2 && void 0 === r2[n2]; )
    r2 = e3[o2++];
  if (void 0 === r2)
    return;
  let s2 = r2[n2];
  if (void 0 !== s2)
    if (Array.isArray(s2))
      do {
        s2 = r2[n2], void 0 !== s2 && (t2.push(r2.time), i2.push.apply(i2, s2)), r2 = e3[o2++];
      } while (void 0 !== r2);
    else if (void 0 !== s2.toArray)
      do {
        s2 = r2[n2], void 0 !== s2 && (t2.push(r2.time), s2.toArray(i2, i2.length)), r2 = e3[o2++];
      } while (void 0 !== r2);
    else
      do {
        s2 = r2[n2], void 0 !== s2 && (t2.push(r2.time), i2.push(s2)), r2 = e3[o2++];
      } while (void 0 !== r2);
}
class Nl {
  constructor(e3, t2, i2, n2) {
    this.parameterPositions = e3, this._cachedIndex = 0, this.resultBuffer = void 0 !== n2 ? n2 : new t2.constructor(i2), this.sampleValues = t2, this.valueSize = i2, this.settings = null, this.DefaultSettings_ = {};
  }
  evaluate(e3) {
    const t2 = this.parameterPositions;
    let i2 = this._cachedIndex, n2 = t2[i2], o2 = t2[i2 - 1];
    e: {
      t: {
        let r2;
        i: {
          n:
            if (!(e3 < n2)) {
              for (let r3 = i2 + 2; ; ) {
                if (void 0 === n2) {
                  if (e3 < o2)
                    break n;
                  return i2 = t2.length, this._cachedIndex = i2, this.copySampleValue_(i2 - 1);
                }
                if (i2 === r3)
                  break;
                if (o2 = n2, n2 = t2[++i2], e3 < n2)
                  break t;
              }
              r2 = t2.length;
              break i;
            }
          if (e3 >= o2)
            break e;
          {
            const s2 = t2[1];
            e3 < s2 && (i2 = 2, o2 = s2);
            for (let r3 = i2 - 2; ; ) {
              if (void 0 === o2)
                return this._cachedIndex = 0, this.copySampleValue_(0);
              if (i2 === r3)
                break;
              if (n2 = o2, o2 = t2[--i2 - 1], e3 >= o2)
                break t;
            }
            r2 = i2, i2 = 0;
          }
        }
        for (; i2 < r2; ) {
          const n3 = i2 + r2 >>> 1;
          e3 < t2[n3] ? r2 = n3 : i2 = n3 + 1;
        }
        if (n2 = t2[i2], o2 = t2[i2 - 1], void 0 === o2)
          return this._cachedIndex = 0, this.copySampleValue_(0);
        if (void 0 === n2)
          return i2 = t2.length, this._cachedIndex = i2, this.copySampleValue_(i2 - 1);
      }
      this._cachedIndex = i2, this.intervalChanged_(i2, o2, n2);
    }
    return this.interpolate_(i2, o2, e3, n2);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e3) {
    const t2 = this.resultBuffer, i2 = this.sampleValues, n2 = this.valueSize, o2 = e3 * n2;
    for (let e4 = 0; e4 !== n2; ++e4)
      t2[e4] = i2[o2 + e4];
    return t2;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
class Ol extends Nl {
  constructor(e3, t2, i2, n2) {
    super(e3, t2, i2, n2), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: gt, endingEnd: gt };
  }
  intervalChanged_(e3, t2, i2) {
    const n2 = this.parameterPositions;
    let o2 = e3 - 2, r2 = e3 + 1, s2 = n2[o2], a2 = n2[r2];
    if (void 0 === s2)
      switch (this.getSettings_().endingStart) {
        case mt:
          o2 = e3, s2 = 2 * t2 - i2;
          break;
        case ft:
          o2 = n2.length - 2, s2 = t2 + n2[o2] - n2[o2 + 1];
          break;
        default:
          o2 = e3, s2 = i2;
      }
    if (void 0 === a2)
      switch (this.getSettings_().endingEnd) {
        case mt:
          r2 = e3, a2 = 2 * i2 - t2;
          break;
        case ft:
          r2 = 1, a2 = i2 + n2[1] - n2[0];
          break;
        default:
          r2 = e3 - 1, a2 = t2;
      }
    const l2 = 0.5 * (i2 - t2), c2 = this.valueSize;
    this._weightPrev = l2 / (t2 - s2), this._weightNext = l2 / (a2 - i2), this._offsetPrev = o2 * c2, this._offsetNext = r2 * c2;
  }
  interpolate_(e3, t2, i2, n2) {
    const o2 = this.resultBuffer, r2 = this.sampleValues, s2 = this.valueSize, a2 = e3 * s2, l2 = a2 - s2, c2 = this._offsetPrev, h2 = this._offsetNext, u2 = this._weightPrev, d2 = this._weightNext, p2 = (i2 - t2) / (n2 - t2), _2 = p2 * p2, g2 = _2 * p2, m2 = -u2 * g2 + 2 * u2 * _2 - u2 * p2, f2 = (1 + u2) * g2 + (-1.5 - 2 * u2) * _2 + (-0.5 + u2) * p2 + 1, v2 = (-1 - d2) * g2 + (1.5 + d2) * _2 + 0.5 * p2, A2 = d2 * g2 - d2 * _2;
    for (let e4 = 0; e4 !== s2; ++e4)
      o2[e4] = m2 * r2[c2 + e4] + f2 * r2[l2 + e4] + v2 * r2[a2 + e4] + A2 * r2[h2 + e4];
    return o2;
  }
}
class zl extends Nl {
  constructor(e3, t2, i2, n2) {
    super(e3, t2, i2, n2);
  }
  interpolate_(e3, t2, i2, n2) {
    const o2 = this.resultBuffer, r2 = this.sampleValues, s2 = this.valueSize, a2 = e3 * s2, l2 = a2 - s2, c2 = (i2 - t2) / (n2 - t2), h2 = 1 - c2;
    for (let e4 = 0; e4 !== s2; ++e4)
      o2[e4] = r2[l2 + e4] * h2 + r2[a2 + e4] * c2;
    return o2;
  }
}
class Ul extends Nl {
  constructor(e3, t2, i2, n2) {
    super(e3, t2, i2, n2);
  }
  interpolate_(e3) {
    return this.copySampleValue_(e3 - 1);
  }
}
class Hl {
  constructor(e3, t2, i2, n2) {
    if (void 0 === e3)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (void 0 === t2 || 0 === t2.length)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e3);
    this.name = e3, this.times = Rl(t2, this.TimeBufferType), this.values = Rl(i2, this.ValueBufferType), this.setInterpolation(n2 || this.DefaultInterpolation);
  }
  static toJSON(e3) {
    const t2 = e3.constructor;
    let i2;
    if (t2.toJSON !== this.toJSON)
      i2 = t2.toJSON(e3);
    else {
      i2 = { name: e3.name, times: Rl(e3.times, Array), values: Rl(e3.values, Array) };
      const t3 = e3.getInterpolation();
      t3 !== e3.DefaultInterpolation && (i2.interpolation = t3);
    }
    return i2.type = e3.ValueTypeName, i2;
  }
  InterpolantFactoryMethodDiscrete(e3) {
    return new Ul(this.times, this.values, this.getValueSize(), e3);
  }
  InterpolantFactoryMethodLinear(e3) {
    return new zl(this.times, this.values, this.getValueSize(), e3);
  }
  InterpolantFactoryMethodSmooth(e3) {
    return new Ol(this.times, this.values, this.getValueSize(), e3);
  }
  setInterpolation(e3) {
    let t2;
    switch (e3) {
      case dt:
        t2 = this.InterpolantFactoryMethodDiscrete;
        break;
      case pt:
        t2 = this.InterpolantFactoryMethodLinear;
        break;
      case _t:
        t2 = this.InterpolantFactoryMethodSmooth;
    }
    if (void 0 === t2) {
      const t3 = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (void 0 === this.createInterpolant) {
        if (e3 === this.DefaultInterpolation)
          throw new Error(t3);
        this.setInterpolation(this.DefaultInterpolation);
      }
      return console.warn("THREE.KeyframeTrack:", t3), this;
    }
    return this.createInterpolant = t2, this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return dt;
      case this.InterpolantFactoryMethodLinear:
        return pt;
      case this.InterpolantFactoryMethodSmooth:
        return _t;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e3) {
    if (0 !== e3) {
      const t2 = this.times;
      for (let i2 = 0, n2 = t2.length; i2 !== n2; ++i2)
        t2[i2] += e3;
    }
    return this;
  }
  scale(e3) {
    if (1 !== e3) {
      const t2 = this.times;
      for (let i2 = 0, n2 = t2.length; i2 !== n2; ++i2)
        t2[i2] *= e3;
    }
    return this;
  }
  trim(e3, t2) {
    const i2 = this.times, n2 = i2.length;
    let o2 = 0, r2 = n2 - 1;
    for (; o2 !== n2 && i2[o2] < e3; )
      ++o2;
    for (; -1 !== r2 && i2[r2] > t2; )
      --r2;
    if (++r2, 0 !== o2 || r2 !== n2) {
      o2 >= r2 && (r2 = Math.max(r2, 1), o2 = r2 - 1);
      const e4 = this.getValueSize();
      this.times = kl(i2, o2, r2), this.values = kl(this.values, o2 * e4, r2 * e4);
    }
    return this;
  }
  validate() {
    let e3 = true;
    const t2 = this.getValueSize();
    t2 - Math.floor(t2) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e3 = false);
    const i2 = this.times, n2 = this.values, o2 = i2.length;
    0 === o2 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e3 = false);
    let r2 = null;
    for (let t3 = 0; t3 !== o2; t3++) {
      const n3 = i2[t3];
      if ("number" == typeof n3 && isNaN(n3)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, t3, n3), e3 = false;
        break;
      }
      if (null !== r2 && r2 > n3) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, t3, n3, r2), e3 = false;
        break;
      }
      r2 = n3;
    }
    if (void 0 !== n2 && Pl(n2))
      for (let t3 = 0, i3 = n2.length; t3 !== i3; ++t3) {
        const i4 = n2[t3];
        if (isNaN(i4)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, t3, i4), e3 = false;
          break;
        }
      }
    return e3;
  }
  optimize() {
    const e3 = kl(this.times), t2 = kl(this.values), i2 = this.getValueSize(), n2 = this.getInterpolation() === _t, o2 = e3.length - 1;
    let r2 = 1;
    for (let s2 = 1; s2 < o2; ++s2) {
      let o3 = false;
      const a2 = e3[s2];
      if (a2 !== e3[s2 + 1] && (1 !== s2 || a2 !== e3[0]))
        if (n2)
          o3 = true;
        else {
          const e4 = s2 * i2, n3 = e4 - i2, r3 = e4 + i2;
          for (let s3 = 0; s3 !== i2; ++s3) {
            const i3 = t2[e4 + s3];
            if (i3 !== t2[n3 + s3] || i3 !== t2[r3 + s3]) {
              o3 = true;
              break;
            }
          }
        }
      if (o3) {
        if (s2 !== r2) {
          e3[r2] = e3[s2];
          const n3 = s2 * i2, o4 = r2 * i2;
          for (let e4 = 0; e4 !== i2; ++e4)
            t2[o4 + e4] = t2[n3 + e4];
        }
        ++r2;
      }
    }
    if (o2 > 0) {
      e3[r2] = e3[o2];
      for (let e4 = o2 * i2, n3 = r2 * i2, s2 = 0; s2 !== i2; ++s2)
        t2[n3 + s2] = t2[e4 + s2];
      ++r2;
    }
    return r2 !== e3.length ? (this.times = kl(e3, 0, r2), this.values = kl(t2, 0, r2 * i2)) : (this.times = e3, this.values = t2), this;
  }
  clone() {
    const e3 = kl(this.times, 0), t2 = kl(this.values, 0), i2 = new (0, this.constructor)(this.name, e3, t2);
    return i2.createInterpolant = this.createInterpolant, i2;
  }
}
Hl.prototype.TimeBufferType = Float32Array, Hl.prototype.ValueBufferType = Float32Array, Hl.prototype.DefaultInterpolation = pt;
class Ql extends Hl {
}
Ql.prototype.ValueTypeName = "bool", Ql.prototype.ValueBufferType = Array, Ql.prototype.DefaultInterpolation = dt, Ql.prototype.InterpolantFactoryMethodLinear = void 0, Ql.prototype.InterpolantFactoryMethodSmooth = void 0;
class Vl extends Hl {
}
Vl.prototype.ValueTypeName = "color";
class Gl extends Hl {
}
Gl.prototype.ValueTypeName = "number";
class $l extends Nl {
  constructor(e3, t2, i2, n2) {
    super(e3, t2, i2, n2);
  }
  interpolate_(e3, t2, i2, n2) {
    const o2 = this.resultBuffer, r2 = this.sampleValues, s2 = this.valueSize, a2 = (i2 - t2) / (n2 - t2);
    let l2 = e3 * s2;
    for (let e4 = l2 + s2; l2 !== e4; l2 += 4)
      ui.slerpFlat(o2, 0, r2, l2 - s2, r2, l2, a2);
    return o2;
  }
}
class Wl extends Hl {
  InterpolantFactoryMethodLinear(e3) {
    return new $l(this.times, this.values, this.getValueSize(), e3);
  }
}
Wl.prototype.ValueTypeName = "quaternion", Wl.prototype.DefaultInterpolation = pt, Wl.prototype.InterpolantFactoryMethodSmooth = void 0;
class ql extends Hl {
}
ql.prototype.ValueTypeName = "string", ql.prototype.ValueBufferType = Array, ql.prototype.DefaultInterpolation = dt, ql.prototype.InterpolantFactoryMethodLinear = void 0, ql.prototype.InterpolantFactoryMethodSmooth = void 0;
class jl extends Hl {
}
jl.prototype.ValueTypeName = "vector";
class Xl {
  constructor(e3, t2 = -1, i2, n2 = 2500) {
    this.name = e3, this.tracks = i2, this.duration = t2, this.blendMode = n2, this.uuid = Pt(), this.duration < 0 && this.resetDuration();
  }
  static parse(e3) {
    const t2 = [], i2 = e3.tracks, n2 = 1 / (e3.fps || 1);
    for (let e4 = 0, o3 = i2.length; e4 !== o3; ++e4)
      t2.push(Yl(i2[e4]).scale(n2));
    const o2 = new this(e3.name, e3.duration, t2, e3.blendMode);
    return o2.uuid = e3.uuid, o2;
  }
  static toJSON(e3) {
    const t2 = [], i2 = e3.tracks, n2 = { name: e3.name, duration: e3.duration, tracks: t2, uuid: e3.uuid, blendMode: e3.blendMode };
    for (let e4 = 0, n3 = i2.length; e4 !== n3; ++e4)
      t2.push(Hl.toJSON(i2[e4]));
    return n2;
  }
  static CreateFromMorphTargetSequence(e3, t2, i2, n2) {
    const o2 = t2.length, r2 = [];
    for (let e4 = 0; e4 < o2; e4++) {
      let s2 = [], a2 = [];
      s2.push((e4 + o2 - 1) % o2, e4, (e4 + 1) % o2), a2.push(0, 1, 0);
      const l2 = Dl(s2);
      s2 = Ll(s2, 1, l2), a2 = Ll(a2, 1, l2), n2 || 0 !== s2[0] || (s2.push(o2), a2.push(a2[0])), r2.push(new Gl(".morphTargetInfluences[" + t2[e4].name + "]", s2, a2).scale(1 / i2));
    }
    return new this(e3, -1, r2);
  }
  static findByName(e3, t2) {
    let i2 = e3;
    if (!Array.isArray(e3)) {
      const t3 = e3;
      i2 = t3.geometry && t3.geometry.animations || t3.animations;
    }
    for (let e4 = 0; e4 < i2.length; e4++)
      if (i2[e4].name === t2)
        return i2[e4];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e3, t2, i2) {
    const n2 = {}, o2 = /^([\w-]*?)([\d]+)$/;
    for (let t3 = 0, i3 = e3.length; t3 < i3; t3++) {
      const i4 = e3[t3], r3 = i4.name.match(o2);
      if (r3 && r3.length > 1) {
        const e4 = r3[1];
        let t4 = n2[e4];
        t4 || (n2[e4] = t4 = []), t4.push(i4);
      }
    }
    const r2 = [];
    for (const e4 in n2)
      r2.push(this.CreateFromMorphTargetSequence(e4, n2[e4], t2, i2));
    return r2;
  }
  static parseAnimation(e3, t2) {
    if (!e3)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const i2 = function(e4, t3, i3, n3, o3) {
      if (0 !== i3.length) {
        const r3 = [], s3 = [];
        Fl(i3, r3, s3, n3), 0 !== r3.length && o3.push(new e4(t3, r3, s3));
      }
    }, n2 = [], o2 = e3.name || "default", r2 = e3.fps || 30, s2 = e3.blendMode;
    let a2 = e3.length || -1;
    const l2 = e3.hierarchy || [];
    for (let e4 = 0; e4 < l2.length; e4++) {
      const o3 = l2[e4].keys;
      if (o3 && 0 !== o3.length)
        if (o3[0].morphTargets) {
          const e5 = {};
          let t3;
          for (t3 = 0; t3 < o3.length; t3++)
            if (o3[t3].morphTargets)
              for (let i3 = 0; i3 < o3[t3].morphTargets.length; i3++)
                e5[o3[t3].morphTargets[i3]] = -1;
          for (const i3 in e5) {
            const e6 = [], r3 = [];
            for (let n3 = 0; n3 !== o3[t3].morphTargets.length; ++n3) {
              const n4 = o3[t3];
              e6.push(n4.time), r3.push(n4.morphTarget === i3 ? 1 : 0);
            }
            n2.push(new Gl(".morphTargetInfluence[" + i3 + "]", e6, r3));
          }
          a2 = e5.length * r2;
        } else {
          const r3 = ".bones[" + t2[e4].name + "]";
          i2(jl, r3 + ".position", o3, "pos", n2), i2(Wl, r3 + ".quaternion", o3, "rot", n2), i2(jl, r3 + ".scale", o3, "scl", n2);
        }
    }
    if (0 === n2.length)
      return null;
    return new this(o2, a2, n2, s2);
  }
  resetDuration() {
    let e3 = 0;
    for (let t2 = 0, i2 = this.tracks.length; t2 !== i2; ++t2) {
      const i3 = this.tracks[t2];
      e3 = Math.max(e3, i3.times[i3.times.length - 1]);
    }
    return this.duration = e3, this;
  }
  trim() {
    for (let e3 = 0; e3 < this.tracks.length; e3++)
      this.tracks[e3].trim(0, this.duration);
    return this;
  }
  validate() {
    let e3 = true;
    for (let t2 = 0; t2 < this.tracks.length; t2++)
      e3 = e3 && this.tracks[t2].validate();
    return e3;
  }
  optimize() {
    for (let e3 = 0; e3 < this.tracks.length; e3++)
      this.tracks[e3].optimize();
    return this;
  }
  clone() {
    const e3 = [];
    for (let t2 = 0; t2 < this.tracks.length; t2++)
      e3.push(this.tracks[t2].clone());
    return new this.constructor(this.name, this.duration, e3, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function Yl(e3) {
  if (void 0 === e3.type)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const t2 = function(e4) {
    switch (e4.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return Gl;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return jl;
      case "color":
        return Vl;
      case "quaternion":
        return Wl;
      case "bool":
      case "boolean":
        return Ql;
      case "string":
        return ql;
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e4);
  }(e3.type);
  if (void 0 === e3.times) {
    const t3 = [], i2 = [];
    Fl(e3.keys, t3, i2, "value"), e3.times = t3, e3.values = i2;
  }
  return void 0 !== t2.parse ? t2.parse(e3) : new t2(e3.name, e3.times, e3.values, e3.interpolation);
}
const Kl = { enabled: false, files: {}, add: function(e3, t2) {
  false !== this.enabled && (this.files[e3] = t2);
}, get: function(e3) {
  if (false !== this.enabled)
    return this.files[e3];
}, remove: function(e3) {
  delete this.files[e3];
}, clear: function() {
  this.files = {};
} };
class Zl {
  constructor(e3, t2, i2) {
    const n2 = this;
    let o2, r2 = false, s2 = 0, a2 = 0;
    const l2 = [];
    this.onStart = void 0, this.onLoad = e3, this.onProgress = t2, this.onError = i2, this.itemStart = function(e4) {
      a2++, false === r2 && void 0 !== n2.onStart && n2.onStart(e4, s2, a2), r2 = true;
    }, this.itemEnd = function(e4) {
      s2++, void 0 !== n2.onProgress && n2.onProgress(e4, s2, a2), s2 === a2 && (r2 = false, void 0 !== n2.onLoad && n2.onLoad());
    }, this.itemError = function(e4) {
      void 0 !== n2.onError && n2.onError(e4);
    }, this.resolveURL = function(e4) {
      return o2 ? o2(e4) : e4;
    }, this.setURLModifier = function(e4) {
      return o2 = e4, this;
    }, this.addHandler = function(e4, t3) {
      return l2.push(e4, t3), this;
    }, this.removeHandler = function(e4) {
      const t3 = l2.indexOf(e4);
      return -1 !== t3 && l2.splice(t3, 2), this;
    }, this.getHandler = function(e4) {
      for (let t3 = 0, i3 = l2.length; t3 < i3; t3 += 2) {
        const i4 = l2[t3], n3 = l2[t3 + 1];
        if (i4.global && (i4.lastIndex = 0), i4.test(e4))
          return n3;
      }
      return null;
    };
  }
}
const Jl = new Zl();
class ec {
  constructor(e3) {
    this.manager = void 0 !== e3 ? e3 : Jl, this.crossOrigin = "anonymous", this.withCredentials = false, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e3, t2) {
    const i2 = this;
    return new Promise(function(n2, o2) {
      i2.load(e3, n2, t2, o2);
    });
  }
  parse() {
  }
  setCrossOrigin(e3) {
    return this.crossOrigin = e3, this;
  }
  setWithCredentials(e3) {
    return this.withCredentials = e3, this;
  }
  setPath(e3) {
    return this.path = e3, this;
  }
  setResourcePath(e3) {
    return this.resourcePath = e3, this;
  }
  setRequestHeader(e3) {
    return this.requestHeader = e3, this;
  }
}
const tc = {};
class ic extends Error {
  constructor(e3, t2) {
    super(e3), this.response = t2;
  }
}
class nc extends ec {
  constructor(e3) {
    super(e3);
  }
  load(e3, t2, i2, n2) {
    void 0 === e3 && (e3 = ""), void 0 !== this.path && (e3 = this.path + e3), e3 = this.manager.resolveURL(e3);
    const o2 = Kl.get(e3);
    if (void 0 !== o2)
      return this.manager.itemStart(e3), setTimeout(() => {
        t2 && t2(o2), this.manager.itemEnd(e3);
      }, 0), o2;
    if (void 0 !== tc[e3])
      return void tc[e3].push({ onLoad: t2, onProgress: i2, onError: n2 });
    tc[e3] = [], tc[e3].push({ onLoad: t2, onProgress: i2, onError: n2 });
    const r2 = new Request(e3, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin" }), s2 = this.mimeType, a2 = this.responseType;
    fetch(r2).then((t3) => {
      if (200 === t3.status || 0 === t3.status) {
        if (0 === t3.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === t3.body || void 0 === t3.body.getReader)
          return t3;
        const i3 = tc[e3], n3 = t3.body.getReader(), o3 = t3.headers.get("Content-Length") || t3.headers.get("X-File-Size"), r3 = o3 ? parseInt(o3) : 0, s3 = 0 !== r3;
        let a3 = 0;
        const l2 = new ReadableStream({ start(e4) {
          !function t4() {
            n3.read().then(({ done: n4, value: o4 }) => {
              if (n4)
                e4.close();
              else {
                a3 += o4.byteLength;
                const n5 = new ProgressEvent("progress", { lengthComputable: s3, loaded: a3, total: r3 });
                for (let e5 = 0, t5 = i3.length; e5 < t5; e5++) {
                  const t6 = i3[e5];
                  t6.onProgress && t6.onProgress(n5);
                }
                e4.enqueue(o4), t4();
              }
            });
          }();
        } });
        return new Response(l2);
      }
      throw new ic(`fetch for "${t3.url}" responded with ${t3.status}: ${t3.statusText}`, t3);
    }).then((e4) => {
      switch (a2) {
        case "arraybuffer":
          return e4.arrayBuffer();
        case "blob":
          return e4.blob();
        case "document":
          return e4.text().then((e5) => new DOMParser().parseFromString(e5, s2));
        case "json":
          return e4.json();
        default:
          if (void 0 === s2)
            return e4.text();
          {
            const t3 = /charset="?([^;"\s]*)"?/i.exec(s2), i3 = t3 && t3[1] ? t3[1].toLowerCase() : void 0, n3 = new TextDecoder(i3);
            return e4.arrayBuffer().then((e5) => n3.decode(e5));
          }
      }
    }).then((t3) => {
      Kl.add(e3, t3);
      const i3 = tc[e3];
      delete tc[e3];
      for (let e4 = 0, n3 = i3.length; e4 < n3; e4++) {
        const n4 = i3[e4];
        n4.onLoad && n4.onLoad(t3);
      }
    }).catch((t3) => {
      const i3 = tc[e3];
      if (void 0 === i3)
        throw this.manager.itemError(e3), t3;
      delete tc[e3];
      for (let e4 = 0, n3 = i3.length; e4 < n3; e4++) {
        const n4 = i3[e4];
        n4.onError && n4.onError(t3);
      }
      this.manager.itemError(e3);
    }).finally(() => {
      this.manager.itemEnd(e3);
    }), this.manager.itemStart(e3);
  }
  setResponseType(e3) {
    return this.responseType = e3, this;
  }
  setMimeType(e3) {
    return this.mimeType = e3, this;
  }
}
class oc extends ec {
  constructor(e3) {
    super(e3);
  }
  load(e3, t2, i2, n2) {
    void 0 !== this.path && (e3 = this.path + e3), e3 = this.manager.resolveURL(e3);
    const o2 = this, r2 = Kl.get(e3);
    if (void 0 !== r2)
      return o2.manager.itemStart(e3), setTimeout(function() {
        t2 && t2(r2), o2.manager.itemEnd(e3);
      }, 0), r2;
    const s2 = qt("img");
    function a2() {
      c2(), Kl.add(e3, this), t2 && t2(this), o2.manager.itemEnd(e3);
    }
    function l2(t3) {
      c2(), n2 && n2(t3), o2.manager.itemError(e3), o2.manager.itemEnd(e3);
    }
    function c2() {
      s2.removeEventListener("load", a2, false), s2.removeEventListener("error", l2, false);
    }
    return s2.addEventListener("load", a2, false), s2.addEventListener("error", l2, false), "data:" !== e3.slice(0, 5) && void 0 !== this.crossOrigin && (s2.crossOrigin = this.crossOrigin), o2.manager.itemStart(e3), s2.src = e3, s2;
  }
}
class rc extends ec {
  constructor(e3) {
    super(e3);
  }
  load(e3, t2, i2, n2) {
    const o2 = this, r2 = new Wa(), s2 = new nc(this.manager);
    return s2.setResponseType("arraybuffer"), s2.setRequestHeader(this.requestHeader), s2.setPath(this.path), s2.setWithCredentials(o2.withCredentials), s2.load(e3, function(e4) {
      const i3 = o2.parse(e4);
      i3 && (void 0 !== i3.image ? r2.image = i3.image : void 0 !== i3.data && (r2.image.width = i3.width, r2.image.height = i3.height, r2.image.data = i3.data), r2.wrapS = void 0 !== i3.wrapS ? i3.wrapS : Fe, r2.wrapT = void 0 !== i3.wrapT ? i3.wrapT : Fe, r2.magFilter = void 0 !== i3.magFilter ? i3.magFilter : He, r2.minFilter = void 0 !== i3.minFilter ? i3.minFilter : He, r2.anisotropy = void 0 !== i3.anisotropy ? i3.anisotropy : 1, void 0 !== i3.encoding && (r2.encoding = i3.encoding), void 0 !== i3.flipY && (r2.flipY = i3.flipY), void 0 !== i3.format && (r2.format = i3.format), void 0 !== i3.type && (r2.type = i3.type), void 0 !== i3.mipmaps && (r2.mipmaps = i3.mipmaps, r2.minFilter = Ve), 1 === i3.mipmapCount && (r2.minFilter = He), void 0 !== i3.generateMipmaps && (r2.generateMipmaps = i3.generateMipmaps), r2.needsUpdate = true, t2 && t2(r2, i3));
    }, i2, n2), r2;
  }
}
class sc extends ec {
  constructor(e3) {
    super(e3);
  }
  load(e3, t2, i2, n2) {
    const o2 = new si(), r2 = new oc(this.manager);
    return r2.setCrossOrigin(this.crossOrigin), r2.setPath(this.path), r2.load(e3, function(e4) {
      o2.image = e4, o2.needsUpdate = true, void 0 !== t2 && t2(o2);
    }, i2, n2), o2;
  }
}
class ac extends _n {
  constructor(e3, t2 = 1) {
    super(), this.isLight = true, this.type = "Light", this.color = new Pn(e3), this.intensity = t2;
  }
  dispose() {
  }
  copy(e3, t2) {
    return super.copy(e3, t2), this.color.copy(e3.color), this.intensity = e3.intensity, this;
  }
  toJSON(e3) {
    const t2 = super.toJSON(e3);
    return t2.object.color = this.color.getHex(), t2.object.intensity = this.intensity, void 0 !== this.groundColor && (t2.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t2.object.distance = this.distance), void 0 !== this.angle && (t2.object.angle = this.angle), void 0 !== this.decay && (t2.object.decay = this.decay), void 0 !== this.penumbra && (t2.object.penumbra = this.penumbra), void 0 !== this.shadow && (t2.object.shadow = this.shadow.toJSON()), t2;
  }
}
const lc = new Qi(), cc = new di(), hc = new di();
class uc {
  constructor(e3) {
    this.camera = e3, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Vt(512, 512), this.map = null, this.mapPass = null, this.matrix = new Qi(), this.autoUpdate = true, this.needsUpdate = false, this._frustum = new No(), this._frameExtents = new Vt(1, 1), this._viewportCount = 1, this._viewports = [new ai(0, 0, 1, 1)];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e3) {
    const t2 = this.camera, i2 = this.matrix;
    cc.setFromMatrixPosition(e3.matrixWorld), t2.position.copy(cc), hc.setFromMatrixPosition(e3.target.matrixWorld), t2.lookAt(hc), t2.updateMatrixWorld(), lc.multiplyMatrices(t2.projectionMatrix, t2.matrixWorldInverse), this._frustum.setFromProjectionMatrix(lc), i2.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), i2.multiply(lc);
  }
  getViewport(e3) {
    return this._viewports[e3];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e3) {
    return this.camera = e3.camera.clone(), this.bias = e3.bias, this.radius = e3.radius, this.mapSize.copy(e3.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e3 = {};
    return 0 !== this.bias && (e3.bias = this.bias), 0 !== this.normalBias && (e3.normalBias = this.normalBias), 1 !== this.radius && (e3.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e3.mapSize = this.mapSize.toArray()), e3.camera = this.camera.toJSON(false).object, delete e3.camera.matrix, e3;
  }
}
class dc extends uc {
  constructor() {
    super(new Eo(50, 1, 0.5, 500)), this.isSpotLightShadow = true, this.focus = 1;
  }
  updateMatrices(e3) {
    const t2 = this.camera, i2 = 2 * Rt * e3.angle * this.focus, n2 = this.mapSize.width / this.mapSize.height, o2 = e3.distance || t2.far;
    i2 === t2.fov && n2 === t2.aspect && o2 === t2.far || (t2.fov = i2, t2.aspect = n2, t2.far = o2, t2.updateProjectionMatrix()), super.updateMatrices(e3);
  }
  copy(e3) {
    return super.copy(e3), this.focus = e3.focus, this;
  }
}
class pc extends ac {
  constructor(e3, t2, i2 = 0, n2 = Math.PI / 3, o2 = 0, r2 = 2) {
    super(e3, t2), this.isSpotLight = true, this.type = "SpotLight", this.position.copy(_n.DEFAULT_UP), this.updateMatrix(), this.target = new _n(), this.distance = i2, this.angle = n2, this.penumbra = o2, this.decay = r2, this.map = null, this.shadow = new dc();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e3) {
    this.intensity = e3 / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e3, t2) {
    return super.copy(e3, t2), this.distance = e3.distance, this.angle = e3.angle, this.penumbra = e3.penumbra, this.decay = e3.decay, this.target = e3.target.clone(), this.shadow = e3.shadow.clone(), this;
  }
}
const _c = new Qi(), gc = new di(), mc = new di();
class fc extends uc {
  constructor() {
    super(new Eo(90, 1, 0.5, 500)), this.isPointLightShadow = true, this._frameExtents = new Vt(4, 2), this._viewportCount = 6, this._viewports = [new ai(2, 1, 1, 1), new ai(0, 1, 1, 1), new ai(3, 1, 1, 1), new ai(1, 1, 1, 1), new ai(3, 0, 1, 1), new ai(1, 0, 1, 1)], this._cubeDirections = [new di(1, 0, 0), new di(-1, 0, 0), new di(0, 0, 1), new di(0, 0, -1), new di(0, 1, 0), new di(0, -1, 0)], this._cubeUps = [new di(0, 1, 0), new di(0, 1, 0), new di(0, 1, 0), new di(0, 1, 0), new di(0, 0, 1), new di(0, 0, -1)];
  }
  updateMatrices(e3, t2 = 0) {
    const i2 = this.camera, n2 = this.matrix, o2 = e3.distance || i2.far;
    o2 !== i2.far && (i2.far = o2, i2.updateProjectionMatrix()), gc.setFromMatrixPosition(e3.matrixWorld), i2.position.copy(gc), mc.copy(i2.position), mc.add(this._cubeDirections[t2]), i2.up.copy(this._cubeUps[t2]), i2.lookAt(mc), i2.updateMatrixWorld(), n2.makeTranslation(-gc.x, -gc.y, -gc.z), _c.multiplyMatrices(i2.projectionMatrix, i2.matrixWorldInverse), this._frustum.setFromProjectionMatrix(_c);
  }
}
class vc extends ac {
  constructor(e3, t2, i2 = 0, n2 = 2) {
    super(e3, t2), this.isPointLight = true, this.type = "PointLight", this.distance = i2, this.decay = n2, this.shadow = new fc();
  }
  get power() {
    return 4 * this.intensity * Math.PI;
  }
  set power(e3) {
    this.intensity = e3 / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e3, t2) {
    return super.copy(e3, t2), this.distance = e3.distance, this.decay = e3.decay, this.shadow = e3.shadow.clone(), this;
  }
}
class Ac extends uc {
  constructor() {
    super(new Ko(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = true;
  }
}
class bc extends ac {
  constructor(e3, t2) {
    super(e3, t2), this.isDirectionalLight = true, this.type = "DirectionalLight", this.position.copy(_n.DEFAULT_UP), this.updateMatrix(), this.target = new _n(), this.shadow = new Ac();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e3) {
    return super.copy(e3), this.target = e3.target.clone(), this.shadow = e3.shadow.clone(), this;
  }
}
class yc {
  constructor() {
    this.isSphericalHarmonics3 = true, this.coefficients = [];
    for (let e3 = 0; e3 < 9; e3++)
      this.coefficients.push(new di());
  }
  set(e3) {
    for (let t2 = 0; t2 < 9; t2++)
      this.coefficients[t2].copy(e3[t2]);
    return this;
  }
  zero() {
    for (let e3 = 0; e3 < 9; e3++)
      this.coefficients[e3].set(0, 0, 0);
    return this;
  }
  getAt(e3, t2) {
    const i2 = e3.x, n2 = e3.y, o2 = e3.z, r2 = this.coefficients;
    return t2.copy(r2[0]).multiplyScalar(0.282095), t2.addScaledVector(r2[1], 0.488603 * n2), t2.addScaledVector(r2[2], 0.488603 * o2), t2.addScaledVector(r2[3], 0.488603 * i2), t2.addScaledVector(r2[4], i2 * n2 * 1.092548), t2.addScaledVector(r2[5], n2 * o2 * 1.092548), t2.addScaledVector(r2[6], 0.315392 * (3 * o2 * o2 - 1)), t2.addScaledVector(r2[7], i2 * o2 * 1.092548), t2.addScaledVector(r2[8], 0.546274 * (i2 * i2 - n2 * n2)), t2;
  }
  getIrradianceAt(e3, t2) {
    const i2 = e3.x, n2 = e3.y, o2 = e3.z, r2 = this.coefficients;
    return t2.copy(r2[0]).multiplyScalar(0.886227), t2.addScaledVector(r2[1], 1.023328 * n2), t2.addScaledVector(r2[2], 1.023328 * o2), t2.addScaledVector(r2[3], 1.023328 * i2), t2.addScaledVector(r2[4], 0.858086 * i2 * n2), t2.addScaledVector(r2[5], 0.858086 * n2 * o2), t2.addScaledVector(r2[6], 0.743125 * o2 * o2 - 0.247708), t2.addScaledVector(r2[7], 0.858086 * i2 * o2), t2.addScaledVector(r2[8], 0.429043 * (i2 * i2 - n2 * n2)), t2;
  }
  add(e3) {
    for (let t2 = 0; t2 < 9; t2++)
      this.coefficients[t2].add(e3.coefficients[t2]);
    return this;
  }
  addScaledSH(e3, t2) {
    for (let i2 = 0; i2 < 9; i2++)
      this.coefficients[i2].addScaledVector(e3.coefficients[i2], t2);
    return this;
  }
  scale(e3) {
    for (let t2 = 0; t2 < 9; t2++)
      this.coefficients[t2].multiplyScalar(e3);
    return this;
  }
  lerp(e3, t2) {
    for (let i2 = 0; i2 < 9; i2++)
      this.coefficients[i2].lerp(e3.coefficients[i2], t2);
    return this;
  }
  equals(e3) {
    for (let t2 = 0; t2 < 9; t2++)
      if (!this.coefficients[t2].equals(e3.coefficients[t2]))
        return false;
    return true;
  }
  copy(e3) {
    return this.set(e3.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e3, t2 = 0) {
    const i2 = this.coefficients;
    for (let n2 = 0; n2 < 9; n2++)
      i2[n2].fromArray(e3, t2 + 3 * n2);
    return this;
  }
  toArray(e3 = [], t2 = 0) {
    const i2 = this.coefficients;
    for (let n2 = 0; n2 < 9; n2++)
      i2[n2].toArray(e3, t2 + 3 * n2);
    return e3;
  }
  static getBasisAt(e3, t2) {
    const i2 = e3.x, n2 = e3.y, o2 = e3.z;
    t2[0] = 0.282095, t2[1] = 0.488603 * n2, t2[2] = 0.488603 * o2, t2[3] = 0.488603 * i2, t2[4] = 1.092548 * i2 * n2, t2[5] = 1.092548 * n2 * o2, t2[6] = 0.315392 * (3 * o2 * o2 - 1), t2[7] = 1.092548 * i2 * o2, t2[8] = 0.546274 * (i2 * i2 - n2 * n2);
  }
}
class wc extends ac {
  constructor(e3 = new yc(), t2 = 1) {
    super(void 0, t2), this.isLightProbe = true, this.sh = e3;
  }
  copy(e3) {
    return super.copy(e3), this.sh.copy(e3.sh), this;
  }
  fromJSON(e3) {
    return this.intensity = e3.intensity, this.sh.fromArray(e3.sh), this;
  }
  toJSON(e3) {
    const t2 = super.toJSON(e3);
    return t2.object.sh = this.sh.toArray(), t2;
  }
}
class xc {
  static decodeText(e3) {
    if ("undefined" != typeof TextDecoder)
      return new TextDecoder().decode(e3);
    let t2 = "";
    for (let i2 = 0, n2 = e3.length; i2 < n2; i2++)
      t2 += String.fromCharCode(e3[i2]);
    try {
      return decodeURIComponent(escape(t2));
    } catch (e4) {
      return t2;
    }
  }
  static extractUrlBase(e3) {
    const t2 = e3.lastIndexOf("/");
    return -1 === t2 ? "./" : e3.slice(0, t2 + 1);
  }
  static resolveURL(e3, t2) {
    return "string" != typeof e3 || "" === e3 ? "" : (/^https?:\/\//i.test(t2) && /^\//.test(e3) && (t2 = t2.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e3) || /^data:.*,.*$/i.test(e3) || /^blob:.*$/i.test(e3) ? e3 : t2 + e3);
  }
}
class Cc extends ec {
  constructor(e3) {
    super(e3), this.isImageBitmapLoader = true, "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
  }
  setOptions(e3) {
    return this.options = e3, this;
  }
  load(e3, t2, i2, n2) {
    void 0 === e3 && (e3 = ""), void 0 !== this.path && (e3 = this.path + e3), e3 = this.manager.resolveURL(e3);
    const o2 = this, r2 = Kl.get(e3);
    if (void 0 !== r2)
      return o2.manager.itemStart(e3), setTimeout(function() {
        t2 && t2(r2), o2.manager.itemEnd(e3);
      }, 0), r2;
    const s2 = {};
    s2.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", s2.headers = this.requestHeader, fetch(e3, s2).then(function(e4) {
      return e4.blob();
    }).then(function(e4) {
      return createImageBitmap(e4, Object.assign(o2.options, { colorSpaceConversion: "none" }));
    }).then(function(i3) {
      Kl.add(e3, i3), t2 && t2(i3), o2.manager.itemEnd(e3);
    }).catch(function(t3) {
      n2 && n2(t3), o2.manager.itemError(e3), o2.manager.itemEnd(e3);
    }), o2.manager.itemStart(e3);
  }
}
class Sc {
  constructor(e3, t2, i2) {
    let n2, o2, r2;
    switch (this.binding = e3, this.valueSize = i2, t2) {
      case "quaternion":
        n2 = this._slerp, o2 = this._slerpAdditive, r2 = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * i2), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        n2 = this._select, o2 = this._select, r2 = this._setAdditiveIdentityOther, this.buffer = new Array(5 * i2);
        break;
      default:
        n2 = this._lerp, o2 = this._lerpAdditive, r2 = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * i2);
    }
    this._mixBufferRegion = n2, this._mixBufferRegionAdditive = o2, this._setIdentity = r2, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  accumulate(e3, t2) {
    const i2 = this.buffer, n2 = this.valueSize, o2 = e3 * n2 + n2;
    let r2 = this.cumulativeWeight;
    if (0 === r2) {
      for (let e4 = 0; e4 !== n2; ++e4)
        i2[o2 + e4] = i2[e4];
      r2 = t2;
    } else {
      r2 += t2;
      const e4 = t2 / r2;
      this._mixBufferRegion(i2, o2, 0, e4, n2);
    }
    this.cumulativeWeight = r2;
  }
  accumulateAdditive(e3) {
    const t2 = this.buffer, i2 = this.valueSize, n2 = i2 * this._addIndex;
    0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(t2, n2, 0, e3, i2), this.cumulativeWeightAdditive += e3;
  }
  apply(e3) {
    const t2 = this.valueSize, i2 = this.buffer, n2 = e3 * t2 + t2, o2 = this.cumulativeWeight, r2 = this.cumulativeWeightAdditive, s2 = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, o2 < 1) {
      const e4 = t2 * this._origIndex;
      this._mixBufferRegion(i2, n2, e4, 1 - o2, t2);
    }
    r2 > 0 && this._mixBufferRegionAdditive(i2, n2, this._addIndex * t2, 1, t2);
    for (let e4 = t2, o3 = t2 + t2; e4 !== o3; ++e4)
      if (i2[e4] !== i2[e4 + t2]) {
        s2.setValue(i2, n2);
        break;
      }
  }
  saveOriginalState() {
    const e3 = this.binding, t2 = this.buffer, i2 = this.valueSize, n2 = i2 * this._origIndex;
    e3.getValue(t2, n2);
    for (let e4 = i2, o2 = n2; e4 !== o2; ++e4)
      t2[e4] = t2[n2 + e4 % i2];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  restoreOriginalState() {
    const e3 = 3 * this.valueSize;
    this.binding.setValue(this.buffer, e3);
  }
  _setAdditiveIdentityNumeric() {
    const e3 = this._addIndex * this.valueSize, t2 = e3 + this.valueSize;
    for (let i2 = e3; i2 < t2; i2++)
      this.buffer[i2] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const e3 = this._origIndex * this.valueSize, t2 = this._addIndex * this.valueSize;
    for (let i2 = 0; i2 < this.valueSize; i2++)
      this.buffer[t2 + i2] = this.buffer[e3 + i2];
  }
  _select(e3, t2, i2, n2, o2) {
    if (n2 >= 0.5)
      for (let n3 = 0; n3 !== o2; ++n3)
        e3[t2 + n3] = e3[i2 + n3];
  }
  _slerp(e3, t2, i2, n2) {
    ui.slerpFlat(e3, t2, e3, t2, e3, i2, n2);
  }
  _slerpAdditive(e3, t2, i2, n2, o2) {
    const r2 = this._workIndex * o2;
    ui.multiplyQuaternionsFlat(e3, r2, e3, t2, e3, i2), ui.slerpFlat(e3, t2, e3, t2, e3, r2, n2);
  }
  _lerp(e3, t2, i2, n2, o2) {
    const r2 = 1 - n2;
    for (let s2 = 0; s2 !== o2; ++s2) {
      const o3 = t2 + s2;
      e3[o3] = e3[o3] * r2 + e3[i2 + s2] * n2;
    }
  }
  _lerpAdditive(e3, t2, i2, n2, o2) {
    for (let r2 = 0; r2 !== o2; ++r2) {
      const o3 = t2 + r2;
      e3[o3] = e3[o3] + e3[i2 + r2] * n2;
    }
  }
}
const Ec = "\\[\\]\\.:\\/", Ic = new RegExp("[" + Ec + "]", "g"), Tc = "[^" + Ec + "]", Bc = "[^" + Ec.replace("\\.", "") + "]", Mc = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", Tc) + /(WCOD+)?/.source.replace("WCOD", Bc) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Tc) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Tc) + "$"), kc = ["material", "materials", "bones", "map"];
class Rc {
  constructor(e3, t2, i2) {
    this.path = t2, this.parsedPath = i2 || Rc.parseTrackName(t2), this.node = Rc.findNode(e3, this.parsedPath.nodeName), this.rootNode = e3, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  static create(e3, t2, i2) {
    return e3 && e3.isAnimationObjectGroup ? new Rc.Composite(e3, t2, i2) : new Rc(e3, t2, i2);
  }
  static sanitizeNodeName(e3) {
    return e3.replace(/\s/g, "_").replace(Ic, "");
  }
  static parseTrackName(e3) {
    const t2 = Mc.exec(e3);
    if (null === t2)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e3);
    const i2 = { nodeName: t2[2], objectName: t2[3], objectIndex: t2[4], propertyName: t2[5], propertyIndex: t2[6] }, n2 = i2.nodeName && i2.nodeName.lastIndexOf(".");
    if (void 0 !== n2 && -1 !== n2) {
      const e4 = i2.nodeName.substring(n2 + 1);
      -1 !== kc.indexOf(e4) && (i2.nodeName = i2.nodeName.substring(0, n2), i2.objectName = e4);
    }
    if (null === i2.propertyName || 0 === i2.propertyName.length)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e3);
    return i2;
  }
  static findNode(e3, t2) {
    if (void 0 === t2 || "" === t2 || "." === t2 || -1 === t2 || t2 === e3.name || t2 === e3.uuid)
      return e3;
    if (e3.skeleton) {
      const i2 = e3.skeleton.getBoneByName(t2);
      if (void 0 !== i2)
        return i2;
    }
    if (e3.children) {
      const i2 = function(e4) {
        for (let n3 = 0; n3 < e4.length; n3++) {
          const o2 = e4[n3];
          if (o2.name === t2 || o2.uuid === t2)
            return o2;
          const r2 = i2(o2.children);
          if (r2)
            return r2;
        }
        return null;
      }, n2 = i2(e3.children);
      if (n2)
        return n2;
    }
    return null;
  }
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  _getValue_direct(e3, t2) {
    e3[t2] = this.targetObject[this.propertyName];
  }
  _getValue_array(e3, t2) {
    const i2 = this.resolvedProperty;
    for (let n2 = 0, o2 = i2.length; n2 !== o2; ++n2)
      e3[t2++] = i2[n2];
  }
  _getValue_arrayElement(e3, t2) {
    e3[t2] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e3, t2) {
    this.resolvedProperty.toArray(e3, t2);
  }
  _setValue_direct(e3, t2) {
    this.targetObject[this.propertyName] = e3[t2];
  }
  _setValue_direct_setNeedsUpdate(e3, t2) {
    this.targetObject[this.propertyName] = e3[t2], this.targetObject.needsUpdate = true;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e3, t2) {
    this.targetObject[this.propertyName] = e3[t2], this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_array(e3, t2) {
    const i2 = this.resolvedProperty;
    for (let n2 = 0, o2 = i2.length; n2 !== o2; ++n2)
      i2[n2] = e3[t2++];
  }
  _setValue_array_setNeedsUpdate(e3, t2) {
    const i2 = this.resolvedProperty;
    for (let n2 = 0, o2 = i2.length; n2 !== o2; ++n2)
      i2[n2] = e3[t2++];
    this.targetObject.needsUpdate = true;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e3, t2) {
    const i2 = this.resolvedProperty;
    for (let n2 = 0, o2 = i2.length; n2 !== o2; ++n2)
      i2[n2] = e3[t2++];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_arrayElement(e3, t2) {
    this.resolvedProperty[this.propertyIndex] = e3[t2];
  }
  _setValue_arrayElement_setNeedsUpdate(e3, t2) {
    this.resolvedProperty[this.propertyIndex] = e3[t2], this.targetObject.needsUpdate = true;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e3, t2) {
    this.resolvedProperty[this.propertyIndex] = e3[t2], this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_fromArray(e3, t2) {
    this.resolvedProperty.fromArray(e3, t2);
  }
  _setValue_fromArray_setNeedsUpdate(e3, t2) {
    this.resolvedProperty.fromArray(e3, t2), this.targetObject.needsUpdate = true;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e3, t2) {
    this.resolvedProperty.fromArray(e3, t2), this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _getValue_unbound(e3, t2) {
    this.bind(), this.getValue(e3, t2);
  }
  _setValue_unbound(e3, t2) {
    this.bind(), this.setValue(e3, t2);
  }
  bind() {
    let e3 = this.node;
    const t2 = this.parsedPath, i2 = t2.objectName, n2 = t2.propertyName;
    let o2 = t2.propertyIndex;
    if (e3 || (e3 = Rc.findNode(this.rootNode, t2.nodeName), this.node = e3), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e3)
      return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
    if (i2) {
      let n3 = t2.objectIndex;
      switch (i2) {
        case "materials":
          if (!e3.material)
            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
          if (!e3.material.materials)
            return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
          e3 = e3.material.materials;
          break;
        case "bones":
          if (!e3.skeleton)
            return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
          e3 = e3.skeleton.bones;
          for (let t3 = 0; t3 < e3.length; t3++)
            if (e3[t3].name === n3) {
              n3 = t3;
              break;
            }
          break;
        case "map":
          if ("map" in e3) {
            e3 = e3.map;
            break;
          }
          if (!e3.material)
            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
          if (!e3.material.map)
            return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
          e3 = e3.material.map;
          break;
        default:
          if (void 0 === e3[i2])
            return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
          e3 = e3[i2];
      }
      if (void 0 !== n3) {
        if (void 0 === e3[n3])
          return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e3);
        e3 = e3[n3];
      }
    }
    const r2 = e3[n2];
    if (void 0 === r2) {
      const i3 = t2.nodeName;
      return void console.error("THREE.PropertyBinding: Trying to update property for track: " + i3 + "." + n2 + " but it wasn't found.", e3);
    }
    let s2 = this.Versioning.None;
    this.targetObject = e3, void 0 !== e3.needsUpdate ? s2 = this.Versioning.NeedsUpdate : void 0 !== e3.matrixWorldNeedsUpdate && (s2 = this.Versioning.MatrixWorldNeedsUpdate);
    let a2 = this.BindingType.Direct;
    if (void 0 !== o2) {
      if ("morphTargetInfluences" === n2) {
        if (!e3.geometry)
          return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
        if (!e3.geometry.morphAttributes)
          return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
        void 0 !== e3.morphTargetDictionary[o2] && (o2 = e3.morphTargetDictionary[o2]);
      }
      a2 = this.BindingType.ArrayElement, this.resolvedProperty = r2, this.propertyIndex = o2;
    } else
      void 0 !== r2.fromArray && void 0 !== r2.toArray ? (a2 = this.BindingType.HasFromToArray, this.resolvedProperty = r2) : Array.isArray(r2) ? (a2 = this.BindingType.EntireArray, this.resolvedProperty = r2) : this.propertyName = n2;
    this.getValue = this.GetterByBindingType[a2], this.setValue = this.SetterByBindingTypeAndVersioning[a2][s2];
  }
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
Rc.Composite = class {
  constructor(e3, t2, i2) {
    const n2 = i2 || Rc.parseTrackName(t2);
    this._targetGroup = e3, this._bindings = e3.subscribe_(t2, n2);
  }
  getValue(e3, t2) {
    this.bind();
    const i2 = this._targetGroup.nCachedObjects_, n2 = this._bindings[i2];
    void 0 !== n2 && n2.getValue(e3, t2);
  }
  setValue(e3, t2) {
    const i2 = this._bindings;
    for (let n2 = this._targetGroup.nCachedObjects_, o2 = i2.length; n2 !== o2; ++n2)
      i2[n2].setValue(e3, t2);
  }
  bind() {
    const e3 = this._bindings;
    for (let t2 = this._targetGroup.nCachedObjects_, i2 = e3.length; t2 !== i2; ++t2)
      e3[t2].bind();
  }
  unbind() {
    const e3 = this._bindings;
    for (let t2 = this._targetGroup.nCachedObjects_, i2 = e3.length; t2 !== i2; ++t2)
      e3[t2].unbind();
  }
}, Rc.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Rc.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, Rc.prototype.GetterByBindingType = [Rc.prototype._getValue_direct, Rc.prototype._getValue_array, Rc.prototype._getValue_arrayElement, Rc.prototype._getValue_toArray], Rc.prototype.SetterByBindingTypeAndVersioning = [[Rc.prototype._setValue_direct, Rc.prototype._setValue_direct_setNeedsUpdate, Rc.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Rc.prototype._setValue_array, Rc.prototype._setValue_array_setNeedsUpdate, Rc.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Rc.prototype._setValue_arrayElement, Rc.prototype._setValue_arrayElement_setNeedsUpdate, Rc.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Rc.prototype._setValue_fromArray, Rc.prototype._setValue_fromArray_setNeedsUpdate, Rc.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
class Pc {
  constructor(e3, t2, i2 = null, n2 = t2.blendMode) {
    this._mixer = e3, this._clip = t2, this._localRoot = i2, this.blendMode = n2;
    const o2 = t2.tracks, r2 = o2.length, s2 = new Array(r2), a2 = { endingStart: gt, endingEnd: gt };
    for (let e4 = 0; e4 !== r2; ++e4) {
      const t3 = o2[e4].createInterpolant(null);
      s2[e4] = t3, t3.settings = a2;
    }
    this._interpolantSettings = a2, this._interpolants = s2, this._propertyBindings = new Array(r2), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = ht, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = false, this.enabled = true, this.clampWhenFinished = false, this.zeroSlopeAtStart = true, this.zeroSlopeAtEnd = true;
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return this.paused = false, this.enabled = true, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this);
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e3) {
    return this._startTime = e3, this;
  }
  setLoop(e3, t2) {
    return this.loop = e3, this.repetitions = t2, this;
  }
  setEffectiveWeight(e3) {
    return this.weight = e3, this._effectiveWeight = this.enabled ? e3 : 0, this.stopFading();
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e3) {
    return this._scheduleFading(e3, 0, 1);
  }
  fadeOut(e3) {
    return this._scheduleFading(e3, 1, 0);
  }
  crossFadeFrom(e3, t2, i2) {
    if (e3.fadeOut(t2), this.fadeIn(t2), i2) {
      const i3 = this._clip.duration, n2 = e3._clip.duration, o2 = n2 / i3, r2 = i3 / n2;
      e3.warp(1, o2, t2), this.warp(r2, 1, t2);
    }
    return this;
  }
  crossFadeTo(e3, t2, i2) {
    return e3.crossFadeFrom(this, t2, i2);
  }
  stopFading() {
    const e3 = this._weightInterpolant;
    return null !== e3 && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e3)), this;
  }
  setEffectiveTimeScale(e3) {
    return this.timeScale = e3, this._effectiveTimeScale = this.paused ? 0 : e3, this.stopWarping();
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e3) {
    return this.timeScale = this._clip.duration / e3, this.stopWarping();
  }
  syncWith(e3) {
    return this.time = e3.time, this.timeScale = e3.timeScale, this.stopWarping();
  }
  halt(e3) {
    return this.warp(this._effectiveTimeScale, 0, e3);
  }
  warp(e3, t2, i2) {
    const n2 = this._mixer, o2 = n2.time, r2 = this.timeScale;
    let s2 = this._timeScaleInterpolant;
    null === s2 && (s2 = n2._lendControlInterpolant(), this._timeScaleInterpolant = s2);
    const a2 = s2.parameterPositions, l2 = s2.sampleValues;
    return a2[0] = o2, a2[1] = o2 + i2, l2[0] = e3 / r2, l2[1] = t2 / r2, this;
  }
  stopWarping() {
    const e3 = this._timeScaleInterpolant;
    return null !== e3 && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e3)), this;
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(e3, t2, i2, n2) {
    if (!this.enabled)
      return void this._updateWeight(e3);
    const o2 = this._startTime;
    if (null !== o2) {
      const n3 = (e3 - o2) * i2;
      n3 < 0 || 0 === i2 ? t2 = 0 : (this._startTime = null, t2 = i2 * n3);
    }
    t2 *= this._updateTimeScale(e3);
    const r2 = this._updateTime(t2), s2 = this._updateWeight(e3);
    if (s2 > 0) {
      const e4 = this._interpolants, t3 = this._propertyBindings;
      if (2501 === this.blendMode)
        for (let i3 = 0, n3 = e4.length; i3 !== n3; ++i3)
          e4[i3].evaluate(r2), t3[i3].accumulateAdditive(s2);
      else
        for (let i3 = 0, o3 = e4.length; i3 !== o3; ++i3)
          e4[i3].evaluate(r2), t3[i3].accumulate(n2, s2);
    }
  }
  _updateWeight(e3) {
    let t2 = 0;
    if (this.enabled) {
      t2 = this.weight;
      const i2 = this._weightInterpolant;
      if (null !== i2) {
        const n2 = i2.evaluate(e3)[0];
        t2 *= n2, e3 > i2.parameterPositions[1] && (this.stopFading(), 0 === n2 && (this.enabled = false));
      }
    }
    return this._effectiveWeight = t2, t2;
  }
  _updateTimeScale(e3) {
    let t2 = 0;
    if (!this.paused) {
      t2 = this.timeScale;
      const i2 = this._timeScaleInterpolant;
      if (null !== i2) {
        t2 *= i2.evaluate(e3)[0], e3 > i2.parameterPositions[1] && (this.stopWarping(), 0 === t2 ? this.paused = true : this.timeScale = t2);
      }
    }
    return this._effectiveTimeScale = t2, t2;
  }
  _updateTime(e3) {
    const t2 = this._clip.duration, i2 = this.loop;
    let n2 = this.time + e3, o2 = this._loopCount;
    const r2 = i2 === ut;
    if (0 === e3)
      return -1 === o2 ? n2 : r2 && 1 == (1 & o2) ? t2 - n2 : n2;
    if (2200 === i2) {
      -1 === o2 && (this._loopCount = 0, this._setEndings(true, true, false));
      e: {
        if (n2 >= t2)
          n2 = t2;
        else {
          if (!(n2 < 0)) {
            this.time = n2;
            break e;
          }
          n2 = 0;
        }
        this.clampWhenFinished ? this.paused = true : this.enabled = false, this.time = n2, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e3 < 0 ? -1 : 1 });
      }
    } else {
      if (-1 === o2 && (e3 >= 0 ? (o2 = 0, this._setEndings(true, 0 === this.repetitions, r2)) : this._setEndings(0 === this.repetitions, true, r2)), n2 >= t2 || n2 < 0) {
        const i3 = Math.floor(n2 / t2);
        n2 -= t2 * i3, o2 += Math.abs(i3);
        const s2 = this.repetitions - o2;
        if (s2 <= 0)
          this.clampWhenFinished ? this.paused = true : this.enabled = false, n2 = e3 > 0 ? t2 : 0, this.time = n2, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e3 > 0 ? 1 : -1 });
        else {
          if (1 === s2) {
            const t3 = e3 < 0;
            this._setEndings(t3, !t3, r2);
          } else
            this._setEndings(false, false, r2);
          this._loopCount = o2, this.time = n2, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: i3 });
        }
      } else
        this.time = n2;
      if (r2 && 1 == (1 & o2))
        return t2 - n2;
    }
    return n2;
  }
  _setEndings(e3, t2, i2) {
    const n2 = this._interpolantSettings;
    i2 ? (n2.endingStart = mt, n2.endingEnd = mt) : (n2.endingStart = e3 ? this.zeroSlopeAtStart ? mt : gt : ft, n2.endingEnd = t2 ? this.zeroSlopeAtEnd ? mt : gt : ft);
  }
  _scheduleFading(e3, t2, i2) {
    const n2 = this._mixer, o2 = n2.time;
    let r2 = this._weightInterpolant;
    null === r2 && (r2 = n2._lendControlInterpolant(), this._weightInterpolant = r2);
    const s2 = r2.parameterPositions, a2 = r2.sampleValues;
    return s2[0] = o2, a2[0] = t2, s2[1] = o2 + e3, a2[1] = i2, this;
  }
}
const Dc = new Float32Array(1);
class Lc extends Tt {
  constructor(e3) {
    super(), this._root = e3, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }
  _bindAction(e3, t2) {
    const i2 = e3._localRoot || this._root, n2 = e3._clip.tracks, o2 = n2.length, r2 = e3._propertyBindings, s2 = e3._interpolants, a2 = i2.uuid, l2 = this._bindingsByRootAndName;
    let c2 = l2[a2];
    void 0 === c2 && (c2 = {}, l2[a2] = c2);
    for (let e4 = 0; e4 !== o2; ++e4) {
      const o3 = n2[e4], l3 = o3.name;
      let h2 = c2[l3];
      if (void 0 !== h2)
        ++h2.referenceCount, r2[e4] = h2;
      else {
        if (h2 = r2[e4], void 0 !== h2) {
          null === h2._cacheIndex && (++h2.referenceCount, this._addInactiveBinding(h2, a2, l3));
          continue;
        }
        const n3 = t2 && t2._propertyBindings[e4].binding.parsedPath;
        h2 = new Sc(Rc.create(i2, l3, n3), o3.ValueTypeName, o3.getValueSize()), ++h2.referenceCount, this._addInactiveBinding(h2, a2, l3), r2[e4] = h2;
      }
      s2[e4].resultBuffer = h2.buffer;
    }
  }
  _activateAction(e3) {
    if (!this._isActiveAction(e3)) {
      if (null === e3._cacheIndex) {
        const t3 = (e3._localRoot || this._root).uuid, i2 = e3._clip.uuid, n2 = this._actionsByClip[i2];
        this._bindAction(e3, n2 && n2.knownActions[0]), this._addInactiveAction(e3, i2, t3);
      }
      const t2 = e3._propertyBindings;
      for (let e4 = 0, i2 = t2.length; e4 !== i2; ++e4) {
        const i3 = t2[e4];
        0 == i3.useCount++ && (this._lendBinding(i3), i3.saveOriginalState());
      }
      this._lendAction(e3);
    }
  }
  _deactivateAction(e3) {
    if (this._isActiveAction(e3)) {
      const t2 = e3._propertyBindings;
      for (let e4 = 0, i2 = t2.length; e4 !== i2; ++e4) {
        const i3 = t2[e4];
        0 == --i3.useCount && (i3.restoreOriginalState(), this._takeBackBinding(i3));
      }
      this._takeBackAction(e3);
    }
  }
  _initMemoryManager() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const e3 = this;
    this.stats = { actions: { get total() {
      return e3._actions.length;
    }, get inUse() {
      return e3._nActiveActions;
    } }, bindings: { get total() {
      return e3._bindings.length;
    }, get inUse() {
      return e3._nActiveBindings;
    } }, controlInterpolants: { get total() {
      return e3._controlInterpolants.length;
    }, get inUse() {
      return e3._nActiveControlInterpolants;
    } } };
  }
  _isActiveAction(e3) {
    const t2 = e3._cacheIndex;
    return null !== t2 && t2 < this._nActiveActions;
  }
  _addInactiveAction(e3, t2, i2) {
    const n2 = this._actions, o2 = this._actionsByClip;
    let r2 = o2[t2];
    if (void 0 === r2)
      r2 = { knownActions: [e3], actionByRoot: {} }, e3._byClipCacheIndex = 0, o2[t2] = r2;
    else {
      const t3 = r2.knownActions;
      e3._byClipCacheIndex = t3.length, t3.push(e3);
    }
    e3._cacheIndex = n2.length, n2.push(e3), r2.actionByRoot[i2] = e3;
  }
  _removeInactiveAction(e3) {
    const t2 = this._actions, i2 = t2[t2.length - 1], n2 = e3._cacheIndex;
    i2._cacheIndex = n2, t2[n2] = i2, t2.pop(), e3._cacheIndex = null;
    const o2 = e3._clip.uuid, r2 = this._actionsByClip, s2 = r2[o2], a2 = s2.knownActions, l2 = a2[a2.length - 1], c2 = e3._byClipCacheIndex;
    l2._byClipCacheIndex = c2, a2[c2] = l2, a2.pop(), e3._byClipCacheIndex = null;
    delete s2.actionByRoot[(e3._localRoot || this._root).uuid], 0 === a2.length && delete r2[o2], this._removeInactiveBindingsForAction(e3);
  }
  _removeInactiveBindingsForAction(e3) {
    const t2 = e3._propertyBindings;
    for (let e4 = 0, i2 = t2.length; e4 !== i2; ++e4) {
      const i3 = t2[e4];
      0 == --i3.referenceCount && this._removeInactiveBinding(i3);
    }
  }
  _lendAction(e3) {
    const t2 = this._actions, i2 = e3._cacheIndex, n2 = this._nActiveActions++, o2 = t2[n2];
    e3._cacheIndex = n2, t2[n2] = e3, o2._cacheIndex = i2, t2[i2] = o2;
  }
  _takeBackAction(e3) {
    const t2 = this._actions, i2 = e3._cacheIndex, n2 = --this._nActiveActions, o2 = t2[n2];
    e3._cacheIndex = n2, t2[n2] = e3, o2._cacheIndex = i2, t2[i2] = o2;
  }
  _addInactiveBinding(e3, t2, i2) {
    const n2 = this._bindingsByRootAndName, o2 = this._bindings;
    let r2 = n2[t2];
    void 0 === r2 && (r2 = {}, n2[t2] = r2), r2[i2] = e3, e3._cacheIndex = o2.length, o2.push(e3);
  }
  _removeInactiveBinding(e3) {
    const t2 = this._bindings, i2 = e3.binding, n2 = i2.rootNode.uuid, o2 = i2.path, r2 = this._bindingsByRootAndName, s2 = r2[n2], a2 = t2[t2.length - 1], l2 = e3._cacheIndex;
    a2._cacheIndex = l2, t2[l2] = a2, t2.pop(), delete s2[o2], 0 === Object.keys(s2).length && delete r2[n2];
  }
  _lendBinding(e3) {
    const t2 = this._bindings, i2 = e3._cacheIndex, n2 = this._nActiveBindings++, o2 = t2[n2];
    e3._cacheIndex = n2, t2[n2] = e3, o2._cacheIndex = i2, t2[i2] = o2;
  }
  _takeBackBinding(e3) {
    const t2 = this._bindings, i2 = e3._cacheIndex, n2 = --this._nActiveBindings, o2 = t2[n2];
    e3._cacheIndex = n2, t2[n2] = e3, o2._cacheIndex = i2, t2[i2] = o2;
  }
  _lendControlInterpolant() {
    const e3 = this._controlInterpolants, t2 = this._nActiveControlInterpolants++;
    let i2 = e3[t2];
    return void 0 === i2 && (i2 = new zl(new Float32Array(2), new Float32Array(2), 1, Dc), i2.__cacheIndex = t2, e3[t2] = i2), i2;
  }
  _takeBackControlInterpolant(e3) {
    const t2 = this._controlInterpolants, i2 = e3.__cacheIndex, n2 = --this._nActiveControlInterpolants, o2 = t2[n2];
    e3.__cacheIndex = n2, t2[n2] = e3, o2.__cacheIndex = i2, t2[i2] = o2;
  }
  clipAction(e3, t2, i2) {
    const n2 = t2 || this._root, o2 = n2.uuid;
    let r2 = "string" == typeof e3 ? Xl.findByName(n2, e3) : e3;
    const s2 = null !== r2 ? r2.uuid : e3, a2 = this._actionsByClip[s2];
    let l2 = null;
    if (void 0 === i2 && (i2 = null !== r2 ? r2.blendMode : vt), void 0 !== a2) {
      const e4 = a2.actionByRoot[o2];
      if (void 0 !== e4 && e4.blendMode === i2)
        return e4;
      l2 = a2.knownActions[0], null === r2 && (r2 = l2._clip);
    }
    if (null === r2)
      return null;
    const c2 = new Pc(this, r2, t2, i2);
    return this._bindAction(c2, l2), this._addInactiveAction(c2, s2, o2), c2;
  }
  existingAction(e3, t2) {
    const i2 = t2 || this._root, n2 = i2.uuid, o2 = "string" == typeof e3 ? Xl.findByName(i2, e3) : e3, r2 = o2 ? o2.uuid : e3, s2 = this._actionsByClip[r2];
    return void 0 !== s2 && s2.actionByRoot[n2] || null;
  }
  stopAllAction() {
    const e3 = this._actions;
    for (let t2 = this._nActiveActions - 1; t2 >= 0; --t2)
      e3[t2].stop();
    return this;
  }
  update(e3) {
    e3 *= this.timeScale;
    const t2 = this._actions, i2 = this._nActiveActions, n2 = this.time += e3, o2 = Math.sign(e3), r2 = this._accuIndex ^= 1;
    for (let s3 = 0; s3 !== i2; ++s3) {
      t2[s3]._update(n2, e3, o2, r2);
    }
    const s2 = this._bindings, a2 = this._nActiveBindings;
    for (let e4 = 0; e4 !== a2; ++e4)
      s2[e4].apply(r2);
    return this;
  }
  setTime(e3) {
    this.time = 0;
    for (let e4 = 0; e4 < this._actions.length; e4++)
      this._actions[e4].time = 0;
    return this.update(e3);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(e3) {
    const t2 = this._actions, i2 = e3.uuid, n2 = this._actionsByClip, o2 = n2[i2];
    if (void 0 !== o2) {
      const e4 = o2.knownActions;
      for (let i3 = 0, n3 = e4.length; i3 !== n3; ++i3) {
        const n4 = e4[i3];
        this._deactivateAction(n4);
        const o3 = n4._cacheIndex, r2 = t2[t2.length - 1];
        n4._cacheIndex = null, n4._byClipCacheIndex = null, r2._cacheIndex = o3, t2[o3] = r2, t2.pop(), this._removeInactiveBindingsForAction(n4);
      }
      delete n2[i2];
    }
  }
  uncacheRoot(e3) {
    const t2 = e3.uuid, i2 = this._actionsByClip;
    for (const e4 in i2) {
      const n3 = i2[e4].actionByRoot[t2];
      void 0 !== n3 && (this._deactivateAction(n3), this._removeInactiveAction(n3));
    }
    const n2 = this._bindingsByRootAndName[t2];
    if (void 0 !== n2)
      for (const e4 in n2) {
        const t3 = n2[e4];
        t3.restoreOriginalState(), this._removeInactiveBinding(t3);
      }
  }
  uncacheAction(e3, t2) {
    const i2 = this.existingAction(e3, t2);
    null !== i2 && (this._deactivateAction(i2), this._removeInactiveAction(i2));
  }
}
class Fc {
  constructor(e3, t2, i2 = 0, n2 = 1 / 0) {
    this.ray = new Hi(e3, t2), this.near = i2, this.far = n2, this.camera = null, this.layers = new Ji(), this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} };
  }
  set(e3, t2) {
    this.ray.set(e3, t2);
  }
  setFromCamera(e3, t2) {
    t2.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t2.matrixWorld), this.ray.direction.set(e3.x, e3.y, 0.5).unproject(t2).sub(this.ray.origin).normalize(), this.camera = t2) : t2.isOrthographicCamera ? (this.ray.origin.set(e3.x, e3.y, (t2.near + t2.far) / (t2.near - t2.far)).unproject(t2), this.ray.direction.set(0, 0, -1).transformDirection(t2.matrixWorld), this.camera = t2) : console.error("THREE.Raycaster: Unsupported camera type: " + t2.type);
  }
  intersectObject(e3, t2 = true, i2 = []) {
    return Oc(e3, this, i2, t2), i2.sort(Nc), i2;
  }
  intersectObjects(e3, t2 = true, i2 = []) {
    for (let n2 = 0, o2 = e3.length; n2 < o2; n2++)
      Oc(e3[n2], this, i2, t2);
    return i2.sort(Nc), i2;
  }
}
function Nc(e3, t2) {
  return e3.distance - t2.distance;
}
function Oc(e3, t2, i2, n2) {
  if (e3.layers.test(t2.layers) && e3.raycast(t2, i2), true === n2) {
    const n3 = e3.children;
    for (let e4 = 0, o2 = n3.length; e4 < o2; e4++)
      Oc(n3[e4], t2, i2, true);
  }
}
class zc {
  constructor(e3 = 1, t2 = 0, i2 = 0) {
    return this.radius = e3, this.phi = t2, this.theta = i2, this;
  }
  set(e3, t2, i2) {
    return this.radius = e3, this.phi = t2, this.theta = i2, this;
  }
  copy(e3) {
    return this.radius = e3.radius, this.phi = e3.phi, this.theta = e3.theta, this;
  }
  makeSafe() {
    const e3 = 1e-6;
    return this.phi = Math.max(e3, Math.min(Math.PI - e3, this.phi)), this;
  }
  setFromVector3(e3) {
    return this.setFromCartesianCoords(e3.x, e3.y, e3.z);
  }
  setFromCartesianCoords(e3, t2, i2) {
    return this.radius = Math.sqrt(e3 * e3 + t2 * t2 + i2 * i2), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e3, i2), this.phi = Math.acos(Dt(t2 / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Uc = new di();
let Hc, Qc;
class Vc extends _n {
  constructor(e3 = new di(0, 0, 1), t2 = new di(0, 0, 0), i2 = 1, n2 = 16776960, o2 = 0.2 * i2, r2 = 0.2 * o2) {
    super(), this.type = "ArrowHelper", void 0 === Hc && (Hc = new Zn(), Hc.setAttribute("position", new Gn([0, 0, 0, 0, 1, 0], 3)), Qc = new Il(0, 0.5, 1, 5, 1), Qc.translate(0, -0.5, 0)), this.position.copy(t2), this.line = new ul(Hc, new rl({ color: n2, toneMapped: false })), this.line.matrixAutoUpdate = false, this.add(this.line), this.cone = new fo(Qc, new Ln({ color: n2, toneMapped: false })), this.cone.matrixAutoUpdate = false, this.add(this.cone), this.setDirection(e3), this.setLength(i2, o2, r2);
  }
  setDirection(e3) {
    if (e3.y > 0.99999)
      this.quaternion.set(0, 0, 0, 1);
    else if (e3.y < -0.99999)
      this.quaternion.set(1, 0, 0, 0);
    else {
      Uc.set(e3.z, 0, -e3.x).normalize();
      const t2 = Math.acos(e3.y);
      this.quaternion.setFromAxisAngle(Uc, t2);
    }
  }
  setLength(e3, t2 = 0.2 * e3, i2 = 0.2 * t2) {
    this.line.scale.set(1, Math.max(1e-4, e3 - t2), 1), this.line.updateMatrix(), this.cone.scale.set(i2, t2, i2), this.cone.position.y = e3, this.cone.updateMatrix();
  }
  setColor(e3) {
    this.line.material.color.set(e3), this.cone.material.color.set(e3);
  }
  copy(e3) {
    return super.copy(e3, false), this.line.copy(e3.line), this.cone.copy(e3.cone), this;
  }
  dispose() {
    this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
  }
}
"undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: _e } })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = _e);
const Gc = null != navigator.xr && null != self.XRSession && null != navigator.xr.isSessionSupported, $c = Gc && null != self.XRSession.prototype.requestHitTestSource, Wc = null != self.ResizeObserver, qc = null != self.IntersectionObserver, jc = $c;
(() => {
  const e3 = navigator.userAgent || navigator.vendor || self.opera;
  let t2 = false;
  (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e3) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e3.substr(0, 4))) && (t2 = true);
})();
const Xc = /android/i.test(navigator.userAgent), Yc = /iPad|iPhone|iPod/.test(navigator.userAgent) && !self.MSStream || "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1, Kc = /firefox/i.test(navigator.userAgent), Zc = /OculusBrowser/.test(navigator.userAgent), Jc = Xc && !Kc && !Zc, eh = Boolean(window.webkit && window.webkit.messageHandlers), th = (() => {
  if (Yc) {
    if (eh)
      return Boolean(/CriOS\/|EdgiOS\/|FxiOS\/|GSA\/|DuckDuckGo\//.test(navigator.userAgent));
    {
      const e3 = document.createElement("a");
      return Boolean(e3.relList && e3.relList.supports && e3.relList.supports("ar"));
    }
  }
  return false;
})(), ih = (e3) => e3 && "null" !== e3 ? oh(e3) : null, nh = () => {
  if (jc)
    return;
  const e3 = [];
  throw Gc || e3.push("WebXR Device API"), $c || e3.push("WebXR Hit Test API"), new Error(`The following APIs are required for AR, but are missing in this browser: ${e3.join(", ")}`);
}, oh = (e3) => new URL(e3, window.location.toString()).toString(), rh = (e3, t2) => {
  let i2 = null;
  return (...n2) => {
    null != i2 && self.clearTimeout(i2), i2 = self.setTimeout(() => {
      i2 = null, e3(...n2);
    }, t2);
  };
}, sh = (e3, t2, i2) => Math.max(t2, Math.min(i2, e3)), ah = (() => {
  const e3 = (() => {
    var e4;
    if (null === (e4 = document.documentElement.getAttribute("itemtype")) || void 0 === e4 ? void 0 : e4.includes("schema.org/SearchResultsPage"))
      return true;
    const t2 = null != document.head ? Array.from(document.head.querySelectorAll("meta")) : [];
    for (const e5 of t2)
      if ("viewport" === e5.name)
        return true;
    return false;
  })();
  return e3 || console.warn('No <meta name="viewport"> detected; <model-viewer> will cap pixel density at 1.'), () => e3 ? window.devicePixelRatio : 1;
})(), lh = (() => {
  const e3 = new RegExp("[?&]model-viewer-debug-mode(&|$)");
  return () => self.ModelViewerElement && self.ModelViewerElement.debugMode || self.location && self.location.search && self.location.search.match(e3);
})();
var ch = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
const hh = Symbol("currentEnvironmentMap"), uh = Symbol("currentBackground"), dh = Symbol("updateEnvironment"), ph = Symbol("cancelEnvironmentUpdate"), _h = z`
<svg xmlns="http://www.w3.org/2000/svg" width="24px" height="24px" viewBox="0 0 24 24" fill="#000000">
    <!-- NOTE(cdata): This SVG filter is a stop-gap until we can implement
         support for dynamic re-coloring of UI components -->
    <defs>
      <filter id="drop-shadow" x="-100%" y="-100%" width="300%" height="300%">
        <feGaussianBlur in="SourceAlpha" stdDeviation="1"/>
        <feOffset dx="0" dy="0" result="offsetblur"/>
        <feFlood flood-color="#000000"/>
        <feComposite in2="offsetblur" operator="in"/>
        <feMerge>
          <feMergeNode/>
          <feMergeNode in="SourceGraphic"/>
        </feMerge>
      </filter>
    </defs>
    <path filter="url(#drop-shadow)" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
</svg>`, gh = z`
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="36">
    <defs>
        <path id="A" d="M.001.232h24.997V36H.001z" />
    </defs>
    <g transform="translate(-11 -4)" fill="none" fill-rule="evenodd">
        <path fill-opacity="0" fill="#fff" d="M0 0h44v44H0z" />
        <g transform="translate(11 3)">
            <path d="M8.733 11.165c.04-1.108.766-2.027 1.743-2.307a2.54 2.54 0 0 1 .628-.089c.16 0 .314.017.463.044 1.088.2 1.9 1.092 1.9 2.16v8.88h1.26c2.943-1.39 5-4.45 5-8.025a9.01 9.01 0 0 0-1.9-5.56l-.43-.5c-.765-.838-1.683-1.522-2.712-2-1.057-.49-2.226-.77-3.46-.77s-2.4.278-3.46.77c-1.03.478-1.947 1.162-2.71 2l-.43.5a9.01 9.01 0 0 0-1.9 5.56 9.04 9.04 0 0 0 .094 1.305c.03.21.088.41.13.617l.136.624c.083.286.196.56.305.832l.124.333a8.78 8.78 0 0 0 .509.953l.065.122a8.69 8.69 0 0 0 3.521 3.191l1.11.537v-9.178z" fill-opacity=".5" fill="#e4e4e4" />
            <path d="M22.94 26.218l-2.76 7.74c-.172.485-.676.8-1.253.8H12.24c-1.606 0-3.092-.68-3.98-1.82-1.592-2.048-3.647-3.822-6.11-5.27-.095-.055-.15-.137-.152-.23-.004-.1.046-.196.193-.297.56-.393 1.234-.6 1.926-.6a3.43 3.43 0 0 1 .691.069l4.922.994V10.972c0-.663.615-1.203 1.37-1.203s1.373.54 1.373 1.203v9.882h2.953c.273 0 .533.073.757.21l6.257 3.874c.027.017.045.042.07.06.41.296.586.77.426 1.22M4.1 16.614c-.024-.04-.042-.083-.065-.122a8.69 8.69 0 0 1-.509-.953c-.048-.107-.08-.223-.124-.333l-.305-.832c-.058-.202-.09-.416-.136-.624l-.13-.617a9.03 9.03 0 0 1-.094-1.305c0-2.107.714-4.04 1.9-5.56l.43-.5c.764-.84 1.682-1.523 2.71-2 1.058-.49 2.226-.77 3.46-.77s2.402.28 3.46.77c1.03.477 1.947 1.16 2.712 2l.428.5a9 9 0 0 1 1.901 5.559c0 3.577-2.056 6.636-5 8.026h-1.26v-8.882c0-1.067-.822-1.96-1.9-2.16-.15-.028-.304-.044-.463-.044-.22 0-.427.037-.628.09-.977.28-1.703 1.198-1.743 2.306v9.178l-1.11-.537C6.18 19.098 4.96 18 4.1 16.614M22.97 24.09l-6.256-3.874c-.102-.063-.218-.098-.33-.144 2.683-1.8 4.354-4.855 4.354-8.243 0-.486-.037-.964-.104-1.43a9.97 9.97 0 0 0-1.57-4.128l-.295-.408-.066-.092a10.05 10.05 0 0 0-.949-1.078c-.342-.334-.708-.643-1.094-.922-1.155-.834-2.492-1.412-3.94-1.65l-.732-.088-.748-.03a9.29 9.29 0 0 0-1.482.119c-1.447.238-2.786.816-3.94 1.65a9.33 9.33 0 0 0-.813.686 9.59 9.59 0 0 0-.845.877l-.385.437-.36.5-.288.468-.418.778-.04.09c-.593 1.28-.93 2.71-.93 4.222 0 3.832 2.182 7.342 5.56 8.938l1.437.68v4.946L5 25.64a4.44 4.44 0 0 0-.888-.086c-.017 0-.034.003-.05.003-.252.004-.503.033-.75.08a5.08 5.08 0 0 0-.237.056c-.193.046-.382.107-.568.18-.075.03-.15.057-.225.1-.25.114-.494.244-.723.405a1.31 1.31 0 0 0-.566 1.122 1.28 1.28 0 0 0 .645 1.051C4 29.925 5.96 31.614 7.473 33.563a5.06 5.06 0 0 0 .434.491c1.086 1.082 2.656 1.713 4.326 1.715h6.697c.748-.001 1.43-.333 1.858-.872.142-.18.256-.38.336-.602l2.757-7.74c.094-.26.13-.53.112-.794s-.088-.52-.203-.76a2.19 2.19 0 0 0-.821-.91" fill-opacity=".6" fill="#000" />
            <path d="M22.444 24.94l-6.257-3.874a1.45 1.45 0 0 0-.757-.211h-2.953v-9.88c0-.663-.616-1.203-1.373-1.203s-1.37.54-1.37 1.203v16.643l-4.922-.994a3.44 3.44 0 0 0-.692-.069 3.35 3.35 0 0 0-1.925.598c-.147.102-.198.198-.194.298.004.094.058.176.153.23 2.462 1.448 4.517 3.22 6.11 5.27.887 1.14 2.373 1.82 3.98 1.82h6.686c.577 0 1.08-.326 1.253-.8l2.76-7.74c.16-.448-.017-.923-.426-1.22-.025-.02-.043-.043-.07-.06z" fill="#fff" />
            <g transform="translate(0 .769)">
                <mask id="B" fill="#fff">
                    <use xlink:href="#A" />
                </mask>
                <path d="M23.993 24.992a1.96 1.96 0 0 1-.111.794l-2.758 7.74c-.08.22-.194.423-.336.602-.427.54-1.11.87-1.857.872h-6.698c-1.67-.002-3.24-.633-4.326-1.715-.154-.154-.3-.318-.434-.49C5.96 30.846 4 29.157 1.646 27.773c-.385-.225-.626-.618-.645-1.05a1.31 1.31 0 0 1 .566-1.122 4.56 4.56 0 0 1 .723-.405l.225-.1a4.3 4.3 0 0 1 .568-.18l.237-.056c.248-.046.5-.075.75-.08.018 0 .034-.003.05-.003.303-.001.597.027.89.086l3.722.752V20.68l-1.436-.68c-3.377-1.596-5.56-5.106-5.56-8.938 0-1.51.336-2.94.93-4.222.015-.03.025-.06.04-.09.127-.267.268-.525.418-.778.093-.16.186-.316.288-.468.063-.095.133-.186.2-.277L3.773 5c.118-.155.26-.29.385-.437.266-.3.544-.604.845-.877a9.33 9.33 0 0 1 .813-.686C6.97 2.167 8.31 1.59 9.757 1.35a9.27 9.27 0 0 1 1.481-.119 8.82 8.82 0 0 1 .748.031c.247.02.49.05.733.088 1.448.238 2.786.816 3.94 1.65.387.28.752.588 1.094.922a9.94 9.94 0 0 1 .949 1.078l.066.092c.102.133.203.268.295.408a9.97 9.97 0 0 1 1.571 4.128c.066.467.103.945.103 1.43 0 3.388-1.67 6.453-4.353 8.243.11.046.227.08.33.144l6.256 3.874c.37.23.645.55.82.9.115.24.185.498.203.76m.697-1.195c-.265-.55-.677-1.007-1.194-1.326l-5.323-3.297c2.255-2.037 3.564-4.97 3.564-8.114 0-2.19-.637-4.304-1.84-6.114-.126-.188-.26-.37-.4-.552-.645-.848-1.402-1.6-2.252-2.204C15.472.91 13.393.232 11.238.232A10.21 10.21 0 0 0 5.23 2.19c-.848.614-1.606 1.356-2.253 2.205-.136.18-.272.363-.398.55C1.374 6.756.737 8.87.737 11.06c0 4.218 2.407 8.08 6.133 9.842l.863.41v3.092l-2.525-.51c-.356-.07-.717-.106-1.076-.106a5.45 5.45 0 0 0-3.14.996c-.653.46-1.022 1.202-.99 1.983a2.28 2.28 0 0 0 1.138 1.872c2.24 1.318 4.106 2.923 5.543 4.772 1.26 1.62 3.333 2.59 5.55 2.592h6.698c1.42-.001 2.68-.86 3.134-2.138l2.76-7.74c.272-.757.224-1.584-.134-2.325" fill-opacity=".05" fill="#000" mask="url(#B)" />
            </g>
        </g>
    </g>
</svg>`, mh = z`
<svg version="1.1" id="view_x5F_in_x5F_AR_x5F_icon"
	 xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="24px" height="24px"
	 viewBox="0 0 24 24" enable-background="new 0 0 24 24" xml:space="preserve">
<rect id="Bounding_Box" x="0" y="0" fill="none" width="24" height="24"/>
<g id="Art_layer">
	<path d="M3,4c0-0.55,0.45-1,1-1h2V1H4C2.35,1,1,2.35,1,4v2h2V4z"/>
	<path d="M20,3c0.55,0,1,0.45,1,1v2h2V4c0-1.65-1.35-3-3-3h-2v2H20z"/>
	<path d="M4,21c-0.55,0-1-0.45-1-1v-2H1v2c0,1.65,1.35,3,3,3h2v-2H4z"/>
	<path d="M20,21c0.55,0,1-0.45,1-1v-2h2v2c0,1.65-1.35,3-3,3h-2v-2H20z"/>
	<g>
		<path d="M18.25,7.6l-5.5-3.18c-0.46-0.27-1.04-0.27-1.5,0L5.75,7.6C5.29,7.87,5,8.36,5,8.9v6.35c0,0.54,0.29,1.03,0.75,1.3
			l5.5,3.18c0.46,0.27,1.04,0.27,1.5,0l5.5-3.18c0.46-0.27,0.75-0.76,0.75-1.3V8.9C19,8.36,18.71,7.87,18.25,7.6z M7,14.96v-4.62
			l4,2.32v4.61L7,14.96z M12,10.93L8,8.61l4-2.31l4,2.31L12,10.93z M13,17.27v-4.61l4-2.32v4.62L13,17.27z"/>
	</g>
</g>
</svg>`, fh = z`
<style>
:host {
  display: block;
  position: relative;
  contain: strict;
  width: 300px;
  height: 150px;
}

.container {
  position: relative;
  overflow: hidden;
}

.userInput {
  width: 100%;
  height: 100%;
  display: none;
  position: relative;
  outline-offset: -1px;
  outline-width: 1px;
}

canvas {
  position: absolute;
  display: none;
  pointer-events: none;
  /* NOTE(cdata): Chrome 76 and below apparently have a bug
   * that causes our canvas not to display pixels unless it is
   * on its own render layer
   * @see https://github.com/google/model-viewer/pull/755#issuecomment-536597893
   */
  transform: translateZ(0);
}

.show {
  display: block;
}

/* Adapted from HTML5 Boilerplate
 *
 * @see https://github.com/h5bp/html5-boilerplate/blob/ceb4620c78fc82e13534fc44202a3f168754873f/dist/css/main.css#L122-L133 */
.screen-reader-only {
  border: 0;
  left: 0;
  top: 0;
  clip: rect(0, 0, 0, 0);
  height: 1px;
  margin: -1px;
  overflow: hidden;
  padding: 0;
  position: absolute;
  white-space: nowrap;
  width: 1px;
  pointer-events: none;
}

.slot {
  position: absolute;
  pointer-events: none;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.slot > * {
  pointer-events: initial;
}

.annotation-wrapper ::slotted(*) {
  opacity: var(--max-hotspot-opacity, 1);
  transition: opacity 0.3s;
}

.pointer-tumbling .annotation-wrapper ::slotted(*) {
  pointer-events: none;
}

.annotation-wrapper ::slotted(*) {
  pointer-events: initial;
}

.annotation-wrapper.hide ::slotted(*) {
  opacity: var(--min-hotspot-opacity, 0.25);
}

.slot.poster {
  display: none;
  background-color: inherit;
}

.slot.poster.show {
  display: inherit;
}

.slot.poster > * {
  pointer-events: initial;
}

.slot.poster:not(.show) > * {
  pointer-events: none;
}

#default-poster {
  width: 100%;
  height: 100%;
  /* The default poster is a <button> so we need to set display
   * to prevent it from being affected by text-align: */
  display: block;
  position: absolute;
  border: none;
  padding: 0;
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
  background-color: #fff0;
}

#default-progress-bar {
  display: block;
  position: relative;
  width: 100%;
  height: 100%;
  pointer-events: none;
  overflow: hidden;
}

#default-progress-bar > .bar {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: var(--progress-bar-height, 5px);
  background-color: var(--progress-bar-color, rgba(0, 0, 0, 0.4));
  transition: transform 0.09s;
  transform-origin: top left;
  transform: scaleX(0);
  overflow: hidden;
}

#default-progress-bar > .bar.hide {
  transition: opacity 0.3s 1s;
  opacity: 0;
}

.centered {
  align-items: center;
  justify-content: center;
}

.cover {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
}

.slot.interaction-prompt {
  display: var(--interaction-prompt-display, flex);
  overflow: hidden;
  opacity: 0;
  will-change: opacity;
  transition: opacity 0.3s;
}

.slot.interaction-prompt.visible {
  opacity: 1;
}

.animated-container {
  will-change: transform, opacity;
  opacity: 0;
  transition: opacity 0.3s;
}

.slot.interaction-prompt > * {
  pointer-events: none;
}

.slot.ar-button {
  -moz-user-select: none;
  -webkit-tap-highlight-color: transparent;
  user-select: none;

  display: var(--ar-button-display, block);
}

.slot.ar-button:not(.enabled) {
  display: none;
}

.fab {
  display: flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
  width: 40px;
  height: 40px;
  cursor: pointer;
  background-color: #fff;
  box-shadow: 0px 0px 4px rgba(0, 0, 0, 0.15);
  border-radius: 100px;
}

.fab > * {
  opacity: 0.87;
}

#default-ar-button {
  position: absolute;
  bottom: 16px;
  right: 16px;
  transform: scale(var(--ar-button-scale, 1));
  transform-origin: bottom right;
}

.slot.pan-target {
  display: block;
  position: absolute;
  width: 0;
  height: 0;
  left: 50%;
  top: 50%;
  transform: translate3d(-50%, -50%, 0);
  background-color: transparent;
  opacity: 0;
  transition: opacity 0.3s;
}

#default-pan-target {
  width: 6px;
  height: 6px;
  border-radius: 6px;
  border: 1px solid white;
  box-shadow: 0px 0px 2px 1px rgba(0, 0, 0, 0.8);
}

.slot.default {
  pointer-events: none;
}

.slot.progress-bar {
  pointer-events: none;
}

.slot.exit-webxr-ar-button {
  pointer-events: none;
}

.slot.exit-webxr-ar-button:not(.enabled) {
  display: none;
}

#default-exit-webxr-ar-button {
  display: flex;
  align-items: center;
  justify-content: center;
  position: absolute;
  top: env(safe-area-inset-top, 16px);
  right: 16px;
  width: 40px;
  height: 40px;
  box-sizing: border-box;
}

#default-exit-webxr-ar-button > svg {
  fill: #fff;
}
</style>
<div class="container">
  <div class="userInput" tabindex="0" role="img"
      aria-label="3D model">
      <div class="slot canvas">
        <slot name="canvas">
          <canvas></canvas>
        </slot>
      </div>

  </div>

  <!-- NOTE(cdata): We need to wrap slots because browsers without ShadowDOM
        will have their <slot> elements removed by ShadyCSS -->
  <div class="slot poster">
    <slot name="poster">
      <button type="button" id="default-poster" aria-hidden="true" aria-label="Loading 3D model"></button>
    </slot>
  </div>

  <div class="slot ar-button">
    <slot name="ar-button">
      <a id="default-ar-button" part="default-ar-button" class="fab"
          tabindex="2"
          aria-label="View in your space">
        ${mh}
      </a>
    </slot>
  </div>

  <div class="slot pan-target">
    <slot name="pan-target">
      <div id="default-pan-target">
      </div>
    </slot>
  </div>

  <div class="slot interaction-prompt cover centered">
    <div id="prompt" class="animated-container">
      <slot name="interaction-prompt" aria-hidden="true">
        ${gh}
      </slot>
    </div>
  </div>

  <div id="finger0" class="animated-container cover">
    <slot name="finger0" aria-hidden="true">
    </slot>
  </div>
  <div id="finger1" class="animated-container cover">
    <slot name="finger1" aria-hidden="true">
    </slot>
  </div>

  <div class="slot default">
    <slot></slot>

    <div class="slot progress-bar">
      <slot name="progress-bar">
        <div id="default-progress-bar" aria-hidden="true">
          <div class="bar" part="default-progress-bar"></div>
        </div>
      </slot>
    </div>

    <div class="slot exit-webxr-ar-button">
      <slot name="exit-webxr-ar-button">
        <a id="default-exit-webxr-ar-button" part="default-exit-webxr-ar-button"
            tabindex="3"
            aria-label="Exit AR"
            aria-hidden="true">
          ${_h}
        </a>
      </slot>
    </div>
  </div>
</div>
<div class="screen-reader-only" role="region" aria-label="Live announcements">
  <span id="status" role="status"></span>
</div>`, vh = /* @__PURE__ */ new WeakMap();
function Ah() {
  let e3, t2;
  function i2(e4, t3, i3, n2, o2, r2) {
    const s2 = r2.num_components(), a2 = i3.num_points() * s2, l2 = a2 * o2.BYTES_PER_ELEMENT, c2 = function(e5, t4) {
      switch (t4) {
        case Float32Array:
          return e5.DT_FLOAT32;
        case Int8Array:
          return e5.DT_INT8;
        case Int16Array:
          return e5.DT_INT16;
        case Int32Array:
          return e5.DT_INT32;
        case Uint8Array:
          return e5.DT_UINT8;
        case Uint16Array:
          return e5.DT_UINT16;
        case Uint32Array:
          return e5.DT_UINT32;
      }
    }(e4, o2), h2 = e4._malloc(l2);
    t3.GetAttributeDataArrayForAllPoints(i3, r2, c2, l2, h2);
    const u2 = new o2(e4.HEAPF32.buffer, h2, a2).slice();
    return e4._free(h2), { name: n2, array: u2, itemSize: s2 };
  }
  onmessage = function(n2) {
    const o2 = n2.data;
    switch (o2.type) {
      case "init":
        e3 = o2.decoderConfig, t2 = new Promise(function(t3) {
          e3.onModuleLoaded = function(e4) {
            t3({ draco: e4 });
          }, DracoDecoderModule(e3);
        });
        break;
      case "decode":
        const n3 = o2.buffer, r2 = o2.taskConfig;
        t2.then((e4) => {
          const t3 = e4.draco, s2 = new t3.Decoder();
          try {
            const e5 = function(e6, t4, n4, o3) {
              const r3 = o3.attributeIDs, s3 = o3.attributeTypes;
              let a3, l2;
              const c2 = t4.GetEncodedGeometryType(n4);
              if (c2 === e6.TRIANGULAR_MESH)
                a3 = new e6.Mesh(), l2 = t4.DecodeArrayToMesh(n4, n4.byteLength, a3);
              else {
                if (c2 !== e6.POINT_CLOUD)
                  throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                a3 = new e6.PointCloud(), l2 = t4.DecodeArrayToPointCloud(n4, n4.byteLength, a3);
              }
              if (!l2.ok() || 0 === a3.ptr)
                throw new Error("THREE.DRACOLoader: Decoding failed: " + l2.error_msg());
              const h2 = { index: null, attributes: [] };
              for (const n5 in r3) {
                const l3 = self[s3[n5]];
                let c3, u2;
                if (o3.useUniqueIDs)
                  u2 = r3[n5], c3 = t4.GetAttributeByUniqueId(a3, u2);
                else {
                  if (u2 = t4.GetAttributeId(a3, e6[r3[n5]]), -1 === u2)
                    continue;
                  c3 = t4.GetAttribute(a3, u2);
                }
                const d2 = i2(e6, t4, a3, n5, l3, c3);
                "color" === n5 && (d2.vertexColorSpace = o3.vertexColorSpace), h2.attributes.push(d2);
              }
              c2 === e6.TRIANGULAR_MESH && (h2.index = function(e7, t5, i3) {
                const n5 = i3.num_faces(), o4 = 3 * n5, r4 = 4 * o4, s4 = e7._malloc(r4);
                t5.GetTrianglesUInt32Array(i3, r4, s4);
                const a4 = new Uint32Array(e7.HEAPF32.buffer, s4, o4).slice();
                return e7._free(s4), { array: a4, itemSize: 1 };
              }(e6, t4, a3));
              return e6.destroy(a3), h2;
            }(t3, s2, new Int8Array(n3), r2), a2 = e5.attributes.map((e6) => e6.array.buffer);
            e5.index && a2.push(e5.index.array.buffer), self.postMessage({ type: "decode", id: o2.id, geometry: e5 }, a2);
          } catch (e5) {
            console.error(e5), self.postMessage({ type: "error", id: o2.id, error: e5.message });
          } finally {
            t3.destroy(s2);
          }
        });
    }
  };
}
function bh(e3, t2) {
  if (0 === t2)
    return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), e3;
  if (2 === t2 || 1 === t2) {
    let i2 = e3.getIndex();
    if (null === i2) {
      const t3 = [], n3 = e3.getAttribute("position");
      if (void 0 === n3)
        return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e3;
      for (let e4 = 0; e4 < n3.count; e4++)
        t3.push(e4);
      e3.setIndex(t3), i2 = e3.getIndex();
    }
    const n2 = i2.count - 2, o2 = [];
    if (2 === t2)
      for (let e4 = 1; e4 <= n2; e4++)
        o2.push(i2.getX(0)), o2.push(i2.getX(e4)), o2.push(i2.getX(e4 + 1));
    else
      for (let e4 = 0; e4 < n2; e4++)
        e4 % 2 == 0 ? (o2.push(i2.getX(e4)), o2.push(i2.getX(e4 + 1)), o2.push(i2.getX(e4 + 2))) : (o2.push(i2.getX(e4 + 2)), o2.push(i2.getX(e4 + 1)), o2.push(i2.getX(e4)));
    o2.length / 3 !== n2 && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const r2 = e3.clone();
    return r2.setIndex(o2), r2.clearGroups(), r2;
  }
  return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", t2), e3;
}
class yh extends ec {
  constructor(e3) {
    super(e3), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(e4) {
      return new Ih(e4);
    }), this.register(function(e4) {
      return new Dh(e4);
    }), this.register(function(e4) {
      return new Lh(e4);
    }), this.register(function(e4) {
      return new Fh(e4);
    }), this.register(function(e4) {
      return new Bh(e4);
    }), this.register(function(e4) {
      return new Mh(e4);
    }), this.register(function(e4) {
      return new kh(e4);
    }), this.register(function(e4) {
      return new Rh(e4);
    }), this.register(function(e4) {
      return new Eh(e4);
    }), this.register(function(e4) {
      return new Ph(e4);
    }), this.register(function(e4) {
      return new Th(e4);
    }), this.register(function(e4) {
      return new Ch(e4);
    }), this.register(function(e4) {
      return new Nh(e4);
    }), this.register(function(e4) {
      return new Oh(e4);
    });
  }
  load(e3, t2, i2, n2) {
    const o2 = this;
    let r2;
    r2 = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : xc.extractUrlBase(e3), this.manager.itemStart(e3);
    const s2 = function(t3) {
      n2 ? n2(t3) : console.error(t3), o2.manager.itemError(e3), o2.manager.itemEnd(e3);
    }, a2 = new nc(this.manager);
    a2.setPath(this.path), a2.setResponseType("arraybuffer"), a2.setRequestHeader(this.requestHeader), a2.setWithCredentials(this.withCredentials), a2.load(e3, function(i3) {
      try {
        o2.parse(i3, r2, function(i4) {
          t2(i4), o2.manager.itemEnd(e3);
        }, s2);
      } catch (e4) {
        s2(e4);
      }
    }, i2, s2);
  }
  setDRACOLoader(e3) {
    return this.dracoLoader = e3, this;
  }
  setDDSLoader() {
    throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
  }
  setKTX2Loader(e3) {
    return this.ktx2Loader = e3, this;
  }
  setMeshoptDecoder(e3) {
    return this.meshoptDecoder = e3, this;
  }
  register(e3) {
    return -1 === this.pluginCallbacks.indexOf(e3) && this.pluginCallbacks.push(e3), this;
  }
  unregister(e3) {
    return -1 !== this.pluginCallbacks.indexOf(e3) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e3), 1), this;
  }
  parse(e3, t2, i2, n2) {
    let o2;
    const r2 = {}, s2 = {}, a2 = new TextDecoder();
    if ("string" == typeof e3)
      o2 = JSON.parse(e3);
    else if (e3 instanceof ArrayBuffer) {
      if (a2.decode(new Uint8Array(e3, 0, 4)) === zh) {
        try {
          r2[xh.KHR_BINARY_GLTF] = new Qh(e3);
        } catch (e4) {
          return void (n2 && n2(e4));
        }
        o2 = JSON.parse(r2[xh.KHR_BINARY_GLTF].content);
      } else
        o2 = JSON.parse(a2.decode(e3));
    } else
      o2 = e3;
    if (void 0 === o2.asset || o2.asset.version[0] < 2)
      return void (n2 && n2(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
    const l2 = new _u(o2, { path: t2 || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder });
    l2.fileLoader.setRequestHeader(this.requestHeader);
    for (let e4 = 0; e4 < this.pluginCallbacks.length; e4++) {
      const t3 = this.pluginCallbacks[e4](l2);
      s2[t3.name] = t3, r2[t3.name] = true;
    }
    if (o2.extensionsUsed)
      for (let e4 = 0; e4 < o2.extensionsUsed.length; ++e4) {
        const t3 = o2.extensionsUsed[e4], i3 = o2.extensionsRequired || [];
        switch (t3) {
          case xh.KHR_MATERIALS_UNLIT:
            r2[t3] = new Sh();
            break;
          case xh.KHR_DRACO_MESH_COMPRESSION:
            r2[t3] = new Vh(o2, this.dracoLoader);
            break;
          case xh.KHR_TEXTURE_TRANSFORM:
            r2[t3] = new Gh();
            break;
          case xh.KHR_MESH_QUANTIZATION:
            r2[t3] = new $h();
            break;
          default:
            i3.indexOf(t3) >= 0 && void 0 === s2[t3] && console.warn('THREE.GLTFLoader: Unknown extension "' + t3 + '".');
        }
      }
    l2.setExtensions(r2), l2.setPlugins(s2), l2.parse(i2, n2);
  }
  parseAsync(e3, t2) {
    const i2 = this;
    return new Promise(function(n2, o2) {
      i2.parse(e3, t2, n2, o2);
    });
  }
}
function wh() {
  let e3 = {};
  return { get: function(t2) {
    return e3[t2];
  }, add: function(t2, i2) {
    e3[t2] = i2;
  }, remove: function(t2) {
    delete e3[t2];
  }, removeAll: function() {
    e3 = {};
  } };
}
const xh = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_IOR: "KHR_materials_ior", KHR_MATERIALS_SHEEN: "KHR_materials_sheen", KHR_MATERIALS_SPECULAR: "KHR_materials_specular", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_MATERIALS_VOLUME: "KHR_materials_volume", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_TEXTURE_AVIF: "EXT_texture_avif", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression", EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing" };
class Ch {
  constructor(e3) {
    this.parser = e3, this.name = xh.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const e3 = this.parser, t2 = this.parser.json.nodes || [];
    for (let i2 = 0, n2 = t2.length; i2 < n2; i2++) {
      const n3 = t2[i2];
      n3.extensions && n3.extensions[this.name] && void 0 !== n3.extensions[this.name].light && e3._addNodeRef(this.cache, n3.extensions[this.name].light);
    }
  }
  _loadLight(e3) {
    const t2 = this.parser, i2 = "light:" + e3;
    let n2 = t2.cache.get(i2);
    if (n2)
      return n2;
    const o2 = t2.json, r2 = ((o2.extensions && o2.extensions[this.name] || {}).lights || [])[e3];
    let s2;
    const a2 = new Pn(16777215);
    void 0 !== r2.color && a2.fromArray(r2.color);
    const l2 = void 0 !== r2.range ? r2.range : 0;
    switch (r2.type) {
      case "directional":
        s2 = new bc(a2), s2.target.position.set(0, 0, -1), s2.add(s2.target);
        break;
      case "point":
        s2 = new vc(a2), s2.distance = l2;
        break;
      case "spot":
        s2 = new pc(a2), s2.distance = l2, r2.spot = r2.spot || {}, r2.spot.innerConeAngle = void 0 !== r2.spot.innerConeAngle ? r2.spot.innerConeAngle : 0, r2.spot.outerConeAngle = void 0 !== r2.spot.outerConeAngle ? r2.spot.outerConeAngle : Math.PI / 4, s2.angle = r2.spot.outerConeAngle, s2.penumbra = 1 - r2.spot.innerConeAngle / r2.spot.outerConeAngle, s2.target.position.set(0, 0, -1), s2.add(s2.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + r2.type);
    }
    return s2.position.set(0, 0, 0), s2.decay = 2, lu(s2, r2), void 0 !== r2.intensity && (s2.intensity = r2.intensity), s2.name = t2.createUniqueName(r2.name || "light_" + e3), n2 = Promise.resolve(s2), t2.cache.add(i2, n2), n2;
  }
  getDependency(e3, t2) {
    if ("light" === e3)
      return this._loadLight(t2);
  }
  createNodeAttachment(e3) {
    const t2 = this, i2 = this.parser, n2 = i2.json.nodes[e3], o2 = (n2.extensions && n2.extensions[this.name] || {}).light;
    return void 0 === o2 ? null : this._loadLight(o2).then(function(e4) {
      return i2._getNodeRef(t2.cache, o2, e4);
    });
  }
}
let Sh = class {
  constructor() {
    this.name = xh.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return Ln;
  }
  extendParams(e3, t2, i2) {
    const n2 = [];
    e3.color = new Pn(1, 1, 1), e3.opacity = 1;
    const o2 = t2.pbrMetallicRoughness;
    if (o2) {
      if (Array.isArray(o2.baseColorFactor)) {
        const t3 = o2.baseColorFactor;
        e3.color.fromArray(t3), e3.opacity = t3[3];
      }
      void 0 !== o2.baseColorTexture && n2.push(i2.assignTexture(e3, "map", o2.baseColorTexture, bt));
    }
    return Promise.all(n2);
  }
}, Eh = class {
  constructor(e3) {
    this.parser = e3, this.name = xh.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(e3, t2) {
    const i2 = this.parser.json.materials[e3];
    if (!i2.extensions || !i2.extensions[this.name])
      return Promise.resolve();
    const n2 = i2.extensions[this.name].emissiveStrength;
    return void 0 !== n2 && (t2.emissiveIntensity = n2), Promise.resolve();
  }
}, Ih = class {
  constructor(e3) {
    this.parser = e3, this.name = xh.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(e3) {
    const t2 = this.parser.json.materials[e3];
    return t2.extensions && t2.extensions[this.name] ? Bl : null;
  }
  extendMaterialParams(e3, t2) {
    const i2 = this.parser, n2 = i2.json.materials[e3];
    if (!n2.extensions || !n2.extensions[this.name])
      return Promise.resolve();
    const o2 = [], r2 = n2.extensions[this.name];
    if (void 0 !== r2.clearcoatFactor && (t2.clearcoat = r2.clearcoatFactor), void 0 !== r2.clearcoatTexture && o2.push(i2.assignTexture(t2, "clearcoatMap", r2.clearcoatTexture)), void 0 !== r2.clearcoatRoughnessFactor && (t2.clearcoatRoughness = r2.clearcoatRoughnessFactor), void 0 !== r2.clearcoatRoughnessTexture && o2.push(i2.assignTexture(t2, "clearcoatRoughnessMap", r2.clearcoatRoughnessTexture)), void 0 !== r2.clearcoatNormalTexture && (o2.push(i2.assignTexture(t2, "clearcoatNormalMap", r2.clearcoatNormalTexture)), void 0 !== r2.clearcoatNormalTexture.scale)) {
      const e4 = r2.clearcoatNormalTexture.scale;
      t2.clearcoatNormalScale = new Vt(e4, e4);
    }
    return Promise.all(o2);
  }
}, Th = class {
  constructor(e3) {
    this.parser = e3, this.name = xh.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(e3) {
    const t2 = this.parser.json.materials[e3];
    return t2.extensions && t2.extensions[this.name] ? Bl : null;
  }
  extendMaterialParams(e3, t2) {
    const i2 = this.parser, n2 = i2.json.materials[e3];
    if (!n2.extensions || !n2.extensions[this.name])
      return Promise.resolve();
    const o2 = [], r2 = n2.extensions[this.name];
    return void 0 !== r2.iridescenceFactor && (t2.iridescence = r2.iridescenceFactor), void 0 !== r2.iridescenceTexture && o2.push(i2.assignTexture(t2, "iridescenceMap", r2.iridescenceTexture)), void 0 !== r2.iridescenceIor && (t2.iridescenceIOR = r2.iridescenceIor), void 0 === t2.iridescenceThicknessRange && (t2.iridescenceThicknessRange = [100, 400]), void 0 !== r2.iridescenceThicknessMinimum && (t2.iridescenceThicknessRange[0] = r2.iridescenceThicknessMinimum), void 0 !== r2.iridescenceThicknessMaximum && (t2.iridescenceThicknessRange[1] = r2.iridescenceThicknessMaximum), void 0 !== r2.iridescenceThicknessTexture && o2.push(i2.assignTexture(t2, "iridescenceThicknessMap", r2.iridescenceThicknessTexture)), Promise.all(o2);
  }
}, Bh = class {
  constructor(e3) {
    this.parser = e3, this.name = xh.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(e3) {
    const t2 = this.parser.json.materials[e3];
    return t2.extensions && t2.extensions[this.name] ? Bl : null;
  }
  extendMaterialParams(e3, t2) {
    const i2 = this.parser, n2 = i2.json.materials[e3];
    if (!n2.extensions || !n2.extensions[this.name])
      return Promise.resolve();
    const o2 = [];
    t2.sheenColor = new Pn(0, 0, 0), t2.sheenRoughness = 0, t2.sheen = 1;
    const r2 = n2.extensions[this.name];
    return void 0 !== r2.sheenColorFactor && t2.sheenColor.fromArray(r2.sheenColorFactor), void 0 !== r2.sheenRoughnessFactor && (t2.sheenRoughness = r2.sheenRoughnessFactor), void 0 !== r2.sheenColorTexture && o2.push(i2.assignTexture(t2, "sheenColorMap", r2.sheenColorTexture, bt)), void 0 !== r2.sheenRoughnessTexture && o2.push(i2.assignTexture(t2, "sheenRoughnessMap", r2.sheenRoughnessTexture)), Promise.all(o2);
  }
}, Mh = class {
  constructor(e3) {
    this.parser = e3, this.name = xh.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(e3) {
    const t2 = this.parser.json.materials[e3];
    return t2.extensions && t2.extensions[this.name] ? Bl : null;
  }
  extendMaterialParams(e3, t2) {
    const i2 = this.parser, n2 = i2.json.materials[e3];
    if (!n2.extensions || !n2.extensions[this.name])
      return Promise.resolve();
    const o2 = [], r2 = n2.extensions[this.name];
    return void 0 !== r2.transmissionFactor && (t2.transmission = r2.transmissionFactor), void 0 !== r2.transmissionTexture && o2.push(i2.assignTexture(t2, "transmissionMap", r2.transmissionTexture)), Promise.all(o2);
  }
}, kh = class {
  constructor(e3) {
    this.parser = e3, this.name = xh.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(e3) {
    const t2 = this.parser.json.materials[e3];
    return t2.extensions && t2.extensions[this.name] ? Bl : null;
  }
  extendMaterialParams(e3, t2) {
    const i2 = this.parser, n2 = i2.json.materials[e3];
    if (!n2.extensions || !n2.extensions[this.name])
      return Promise.resolve();
    const o2 = [], r2 = n2.extensions[this.name];
    t2.thickness = void 0 !== r2.thicknessFactor ? r2.thicknessFactor : 0, void 0 !== r2.thicknessTexture && o2.push(i2.assignTexture(t2, "thicknessMap", r2.thicknessTexture)), t2.attenuationDistance = r2.attenuationDistance || 1 / 0;
    const s2 = r2.attenuationColor || [1, 1, 1];
    return t2.attenuationColor = new Pn(s2[0], s2[1], s2[2]), Promise.all(o2);
  }
}, Rh = class {
  constructor(e3) {
    this.parser = e3, this.name = xh.KHR_MATERIALS_IOR;
  }
  getMaterialType(e3) {
    const t2 = this.parser.json.materials[e3];
    return t2.extensions && t2.extensions[this.name] ? Bl : null;
  }
  extendMaterialParams(e3, t2) {
    const i2 = this.parser.json.materials[e3];
    if (!i2.extensions || !i2.extensions[this.name])
      return Promise.resolve();
    const n2 = i2.extensions[this.name];
    return t2.ior = void 0 !== n2.ior ? n2.ior : 1.5, Promise.resolve();
  }
}, Ph = class {
  constructor(e3) {
    this.parser = e3, this.name = xh.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(e3) {
    const t2 = this.parser.json.materials[e3];
    return t2.extensions && t2.extensions[this.name] ? Bl : null;
  }
  extendMaterialParams(e3, t2) {
    const i2 = this.parser, n2 = i2.json.materials[e3];
    if (!n2.extensions || !n2.extensions[this.name])
      return Promise.resolve();
    const o2 = [], r2 = n2.extensions[this.name];
    t2.specularIntensity = void 0 !== r2.specularFactor ? r2.specularFactor : 1, void 0 !== r2.specularTexture && o2.push(i2.assignTexture(t2, "specularIntensityMap", r2.specularTexture));
    const s2 = r2.specularColorFactor || [1, 1, 1];
    return t2.specularColor = new Pn(s2[0], s2[1], s2[2]), void 0 !== r2.specularColorTexture && o2.push(i2.assignTexture(t2, "specularColorMap", r2.specularColorTexture, bt)), Promise.all(o2);
  }
};
class Dh {
  constructor(e3) {
    this.parser = e3, this.name = xh.KHR_TEXTURE_BASISU;
  }
  loadTexture(e3) {
    const t2 = this.parser, i2 = t2.json, n2 = i2.textures[e3];
    if (!n2.extensions || !n2.extensions[this.name])
      return null;
    const o2 = n2.extensions[this.name], r2 = t2.options.ktx2Loader;
    if (!r2) {
      if (i2.extensionsRequired && i2.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return t2.loadTextureImage(e3, o2.source, r2);
  }
}
class Lh {
  constructor(e3) {
    this.parser = e3, this.name = xh.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(e3) {
    const t2 = this.name, i2 = this.parser, n2 = i2.json, o2 = n2.textures[e3];
    if (!o2.extensions || !o2.extensions[t2])
      return null;
    const r2 = o2.extensions[t2], s2 = n2.images[r2.source];
    let a2 = i2.textureLoader;
    if (s2.uri) {
      const e4 = i2.options.manager.getHandler(s2.uri);
      null !== e4 && (a2 = e4);
    }
    return this.detectSupport().then(function(o3) {
      if (o3)
        return i2.loadTextureImage(e3, r2.source, a2);
      if (n2.extensionsRequired && n2.extensionsRequired.indexOf(t2) >= 0)
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return i2.loadTexture(e3);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e3) {
      const t2 = new Image();
      t2.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t2.onload = t2.onerror = function() {
        e3(1 === t2.height);
      };
    })), this.isSupported;
  }
}
class Fh {
  constructor(e3) {
    this.parser = e3, this.name = xh.EXT_TEXTURE_AVIF, this.isSupported = null;
  }
  loadTexture(e3) {
    const t2 = this.name, i2 = this.parser, n2 = i2.json, o2 = n2.textures[e3];
    if (!o2.extensions || !o2.extensions[t2])
      return null;
    const r2 = o2.extensions[t2], s2 = n2.images[r2.source];
    let a2 = i2.textureLoader;
    if (s2.uri) {
      const e4 = i2.options.manager.getHandler(s2.uri);
      null !== e4 && (a2 = e4);
    }
    return this.detectSupport().then(function(o3) {
      if (o3)
        return i2.loadTextureImage(e3, r2.source, a2);
      if (n2.extensionsRequired && n2.extensionsRequired.indexOf(t2) >= 0)
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      return i2.loadTexture(e3);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e3) {
      const t2 = new Image();
      t2.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t2.onload = t2.onerror = function() {
        e3(1 === t2.height);
      };
    })), this.isSupported;
  }
}
class Nh {
  constructor(e3) {
    this.name = xh.EXT_MESHOPT_COMPRESSION, this.parser = e3;
  }
  loadBufferView(e3) {
    const t2 = this.parser.json, i2 = t2.bufferViews[e3];
    if (i2.extensions && i2.extensions[this.name]) {
      const e4 = i2.extensions[this.name], n2 = this.parser.getDependency("buffer", e4.buffer), o2 = this.parser.options.meshoptDecoder;
      if (!o2 || !o2.supported) {
        if (t2.extensionsRequired && t2.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return n2.then(function(t3) {
        const i3 = e4.byteOffset || 0, n3 = e4.byteLength || 0, r2 = e4.count, s2 = e4.byteStride, a2 = new Uint8Array(t3, i3, n3);
        return o2.decodeGltfBufferAsync ? o2.decodeGltfBufferAsync(r2, s2, a2, e4.mode, e4.filter).then(function(e5) {
          return e5.buffer;
        }) : o2.ready.then(function() {
          const t4 = new ArrayBuffer(r2 * s2);
          return o2.decodeGltfBuffer(new Uint8Array(t4), r2, s2, a2, e4.mode, e4.filter), t4;
        });
      });
    }
    return null;
  }
}
class Oh {
  constructor(e3) {
    this.name = xh.EXT_MESH_GPU_INSTANCING, this.parser = e3;
  }
  createNodeMesh(e3) {
    const t2 = this.parser.json, i2 = t2.nodes[e3];
    if (!i2.extensions || !i2.extensions[this.name] || void 0 === i2.mesh)
      return null;
    const n2 = t2.meshes[i2.mesh];
    for (const e4 of n2.primitives)
      if (e4.mode !== Xh.TRIANGLES && e4.mode !== Xh.TRIANGLE_STRIP && e4.mode !== Xh.TRIANGLE_FAN && void 0 !== e4.mode)
        return null;
    const o2 = i2.extensions[this.name].attributes, r2 = [], s2 = {};
    for (const e4 in o2)
      r2.push(this.parser.getDependency("accessor", o2[e4]).then((t3) => (s2[e4] = t3, s2[e4])));
    return r2.length < 1 ? null : (r2.push(this.parser.createNodeMesh(e3)), Promise.all(r2).then((e4) => {
      const t3 = e4.pop(), i3 = t3.isGroup ? t3.children : [t3], n3 = e4[0].count, o3 = [];
      for (const e5 of i3) {
        const t4 = new Qi(), i4 = new di(), r3 = new ui(), a2 = new di(1, 1, 1), l2 = new ol(e5.geometry, e5.material, n3);
        for (let e6 = 0; e6 < n3; e6++)
          s2.TRANSLATION && i4.fromBufferAttribute(s2.TRANSLATION, e6), s2.ROTATION && r3.fromBufferAttribute(s2.ROTATION, e6), s2.SCALE && a2.fromBufferAttribute(s2.SCALE, e6), l2.setMatrixAt(e6, t4.compose(i4, r3, a2));
        for (const t5 in s2)
          "TRANSLATION" !== t5 && "ROTATION" !== t5 && "SCALE" !== t5 && e5.geometry.setAttribute(t5, s2[t5]);
        _n.prototype.copy.call(l2, e5), this.parser.assignFinalMaterial(l2), o3.push(l2);
      }
      return t3.isGroup ? (t3.clear(), t3.add(...o3), t3) : o3[0];
    }));
  }
}
const zh = "glTF", Uh = 1313821514, Hh = 5130562;
class Qh {
  constructor(e3) {
    this.name = xh.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const t2 = new DataView(e3, 0, 12), i2 = new TextDecoder();
    if (this.header = { magic: i2.decode(new Uint8Array(e3.slice(0, 4))), version: t2.getUint32(4, true), length: t2.getUint32(8, true) }, this.header.magic !== zh)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const n2 = this.header.length - 12, o2 = new DataView(e3, 12);
    let r2 = 0;
    for (; r2 < n2; ) {
      const t3 = o2.getUint32(r2, true);
      r2 += 4;
      const n3 = o2.getUint32(r2, true);
      if (r2 += 4, n3 === Uh) {
        const n4 = new Uint8Array(e3, 12 + r2, t3);
        this.content = i2.decode(n4);
      } else if (n3 === Hh) {
        const i3 = 12 + r2;
        this.body = e3.slice(i3, i3 + t3);
      }
      r2 += t3;
    }
    if (null === this.content)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class Vh {
  constructor(e3, t2) {
    if (!t2)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = xh.KHR_DRACO_MESH_COMPRESSION, this.json = e3, this.dracoLoader = t2, this.dracoLoader.preload();
  }
  decodePrimitive(e3, t2) {
    const i2 = this.json, n2 = this.dracoLoader, o2 = e3.extensions[this.name].bufferView, r2 = e3.extensions[this.name].attributes, s2 = {}, a2 = {}, l2 = {};
    for (const e4 in r2) {
      const t3 = eu[e4] || e4.toLowerCase();
      s2[t3] = r2[e4];
    }
    for (const t3 in e3.attributes) {
      const n3 = eu[t3] || t3.toLowerCase();
      if (void 0 !== r2[t3]) {
        const o3 = i2.accessors[e3.attributes[t3]], r3 = Yh[o3.componentType];
        l2[n3] = r3.name, a2[n3] = true === o3.normalized;
      }
    }
    return t2.getDependency("bufferView", o2).then(function(e4) {
      return new Promise(function(t3) {
        n2.decodeDracoFile(e4, function(e5) {
          for (const t4 in e5.attributes) {
            const i3 = e5.attributes[t4], n3 = a2[t4];
            void 0 !== n3 && (i3.normalized = n3);
          }
          t3(e5);
        }, s2, l2);
      });
    });
  }
}
class Gh {
  constructor() {
    this.name = xh.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e3, t2) {
    return void 0 !== t2.texCoord && t2.texCoord !== e3.channel || void 0 !== t2.offset || void 0 !== t2.rotation || void 0 !== t2.scale ? (e3 = e3.clone(), void 0 !== t2.texCoord && (e3.channel = t2.texCoord), void 0 !== t2.offset && e3.offset.fromArray(t2.offset), void 0 !== t2.rotation && (e3.rotation = t2.rotation), void 0 !== t2.scale && e3.repeat.fromArray(t2.scale), e3.needsUpdate = true, e3) : e3;
  }
}
class $h {
  constructor() {
    this.name = xh.KHR_MESH_QUANTIZATION;
  }
}
class Wh extends Nl {
  constructor(e3, t2, i2, n2) {
    super(e3, t2, i2, n2);
  }
  copySampleValue_(e3) {
    const t2 = this.resultBuffer, i2 = this.sampleValues, n2 = this.valueSize, o2 = e3 * n2 * 3 + n2;
    for (let e4 = 0; e4 !== n2; e4++)
      t2[e4] = i2[o2 + e4];
    return t2;
  }
  interpolate_(e3, t2, i2, n2) {
    const o2 = this.resultBuffer, r2 = this.sampleValues, s2 = this.valueSize, a2 = 2 * s2, l2 = 3 * s2, c2 = n2 - t2, h2 = (i2 - t2) / c2, u2 = h2 * h2, d2 = u2 * h2, p2 = e3 * l2, _2 = p2 - l2, g2 = -2 * d2 + 3 * u2, m2 = d2 - u2, f2 = 1 - g2, v2 = m2 - u2 + h2;
    for (let e4 = 0; e4 !== s2; e4++) {
      const t3 = r2[_2 + e4 + s2], i3 = r2[_2 + e4 + a2] * c2, n3 = r2[p2 + e4 + s2], l3 = r2[p2 + e4] * c2;
      o2[e4] = f2 * t3 + v2 * i3 + g2 * n3 + m2 * l3;
    }
    return o2;
  }
}
const qh = new ui();
class jh extends Wh {
  interpolate_(e3, t2, i2, n2) {
    const o2 = super.interpolate_(e3, t2, i2, n2);
    return qh.fromArray(o2).normalize().toArray(o2), o2;
  }
}
const Xh = { FLOAT: 5126, FLOAT_MAT3: 35675, FLOAT_MAT4: 35676, FLOAT_VEC2: 35664, FLOAT_VEC3: 35665, FLOAT_VEC4: 35666, LINEAR: 9729, REPEAT: 10497, SAMPLER_2D: 35678, POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6, UNSIGNED_BYTE: 5121, UNSIGNED_SHORT: 5123 }, Yh = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, Kh = { 9728: Oe, 9729: He, 9984: ze, 9985: Qe, 9986: Ue, 9987: Ve }, Zh = { 33071: Fe, 33648: Ne, 10497: Le }, Jh = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, eu = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv2", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" }, tu = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, iu = { CUBICSPLINE: void 0, LINEAR: pt, STEP: dt }, nu = "OPAQUE", ou = "MASK", ru = "BLEND";
function su(e3) {
  return void 0 === e3.DefaultMaterial && (e3.DefaultMaterial = new Tl({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: false, depthTest: true, side: ve })), e3.DefaultMaterial;
}
function au(e3, t2, i2) {
  for (const n2 in i2.extensions)
    void 0 === e3[n2] && (t2.userData.gltfExtensions = t2.userData.gltfExtensions || {}, t2.userData.gltfExtensions[n2] = i2.extensions[n2]);
}
function lu(e3, t2) {
  void 0 !== t2.extras && ("object" == typeof t2.extras ? Object.assign(e3.userData, t2.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t2.extras));
}
function cu(e3, t2) {
  if (e3.updateMorphTargets(), void 0 !== t2.weights)
    for (let i2 = 0, n2 = t2.weights.length; i2 < n2; i2++)
      e3.morphTargetInfluences[i2] = t2.weights[i2];
  if (t2.extras && Array.isArray(t2.extras.targetNames)) {
    const i2 = t2.extras.targetNames;
    if (e3.morphTargetInfluences.length === i2.length) {
      e3.morphTargetDictionary = {};
      for (let t3 = 0, n2 = i2.length; t3 < n2; t3++)
        e3.morphTargetDictionary[i2[t3]] = t3;
    } else
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function hu(e3) {
  const t2 = e3.extensions && e3.extensions[xh.KHR_DRACO_MESH_COMPRESSION];
  let i2;
  return i2 = t2 ? "draco:" + t2.bufferView + ":" + t2.indices + ":" + uu(t2.attributes) : e3.indices + ":" + uu(e3.attributes) + ":" + e3.mode, i2;
}
function uu(e3) {
  let t2 = "";
  const i2 = Object.keys(e3).sort();
  for (let n2 = 0, o2 = i2.length; n2 < o2; n2++)
    t2 += i2[n2] + ":" + e3[i2[n2]] + ";";
  return t2;
}
function du(e3) {
  switch (e3) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
const pu = new Qi();
class _u {
  constructor(e3 = {}, t2 = {}) {
    this.json = e3, this.extensions = {}, this.plugins = {}, this.options = t2, this.cache = new wh(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
    let i2 = false, n2 = false, o2 = -1;
    "undefined" != typeof navigator && (i2 = true === /^((?!chrome|android).)*safari/i.test(navigator.userAgent), n2 = navigator.userAgent.indexOf("Firefox") > -1, o2 = n2 ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), "undefined" == typeof createImageBitmap || i2 || n2 && o2 < 98 ? this.textureLoader = new sc(this.options.manager) : this.textureLoader = new Cc(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new nc(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(true);
  }
  setExtensions(e3) {
    this.extensions = e3;
  }
  setPlugins(e3) {
    this.plugins = e3;
  }
  parse(e3, t2) {
    const i2 = this, n2 = this.json, o2 = this.extensions;
    this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(e4) {
      return e4._markDefs && e4._markDefs();
    }), Promise.all(this._invokeAll(function(e4) {
      return e4.beforeRoot && e4.beforeRoot();
    })).then(function() {
      return Promise.all([i2.getDependencies("scene"), i2.getDependencies("animation"), i2.getDependencies("camera")]);
    }).then(function(t3) {
      const r2 = { scene: t3[0][n2.scene || 0], scenes: t3[0], animations: t3[1], cameras: t3[2], asset: n2.asset, parser: i2, userData: {} };
      au(o2, r2, n2), lu(r2, n2), Promise.all(i2._invokeAll(function(e4) {
        return e4.afterRoot && e4.afterRoot(r2);
      })).then(function() {
        e3(r2);
      });
    }).catch(t2);
  }
  _markDefs() {
    const e3 = this.json.nodes || [], t2 = this.json.skins || [], i2 = this.json.meshes || [];
    for (let i3 = 0, n2 = t2.length; i3 < n2; i3++) {
      const n3 = t2[i3].joints;
      for (let t3 = 0, i4 = n3.length; t3 < i4; t3++)
        e3[n3[t3]].isBone = true;
    }
    for (let t3 = 0, n2 = e3.length; t3 < n2; t3++) {
      const n3 = e3[t3];
      void 0 !== n3.mesh && (this._addNodeRef(this.meshCache, n3.mesh), void 0 !== n3.skin && (i2[n3.mesh].isSkinnedMesh = true)), void 0 !== n3.camera && this._addNodeRef(this.cameraCache, n3.camera);
    }
  }
  _addNodeRef(e3, t2) {
    void 0 !== t2 && (void 0 === e3.refs[t2] && (e3.refs[t2] = e3.uses[t2] = 0), e3.refs[t2]++);
  }
  _getNodeRef(e3, t2, i2) {
    if (e3.refs[t2] <= 1)
      return i2;
    const n2 = i2.clone(), o2 = (e4, t3) => {
      const i3 = this.associations.get(e4);
      null != i3 && this.associations.set(t3, i3);
      for (const [i4, n3] of e4.children.entries())
        o2(n3, t3.children[i4]);
    };
    return o2(i2, n2), n2.name += "_instance_" + e3.uses[t2]++, n2;
  }
  _invokeOne(e3) {
    const t2 = Object.values(this.plugins);
    t2.push(this);
    for (let i2 = 0; i2 < t2.length; i2++) {
      const n2 = e3(t2[i2]);
      if (n2)
        return n2;
    }
    return null;
  }
  _invokeAll(e3) {
    const t2 = Object.values(this.plugins);
    t2.unshift(this);
    const i2 = [];
    for (let n2 = 0; n2 < t2.length; n2++) {
      const o2 = e3(t2[n2]);
      o2 && i2.push(o2);
    }
    return i2;
  }
  getDependency(e3, t2) {
    const i2 = e3 + ":" + t2;
    let n2 = this.cache.get(i2);
    if (!n2) {
      switch (e3) {
        case "scene":
          n2 = this.loadScene(t2);
          break;
        case "node":
          n2 = this._invokeOne(function(e4) {
            return e4.loadNode && e4.loadNode(t2);
          });
          break;
        case "mesh":
          n2 = this._invokeOne(function(e4) {
            return e4.loadMesh && e4.loadMesh(t2);
          });
          break;
        case "accessor":
          n2 = this.loadAccessor(t2);
          break;
        case "bufferView":
          n2 = this._invokeOne(function(e4) {
            return e4.loadBufferView && e4.loadBufferView(t2);
          });
          break;
        case "buffer":
          n2 = this.loadBuffer(t2);
          break;
        case "material":
          n2 = this._invokeOne(function(e4) {
            return e4.loadMaterial && e4.loadMaterial(t2);
          });
          break;
        case "texture":
          n2 = this._invokeOne(function(e4) {
            return e4.loadTexture && e4.loadTexture(t2);
          });
          break;
        case "skin":
          n2 = this.loadSkin(t2);
          break;
        case "animation":
          n2 = this._invokeOne(function(e4) {
            return e4.loadAnimation && e4.loadAnimation(t2);
          });
          break;
        case "camera":
          n2 = this.loadCamera(t2);
          break;
        default:
          if (n2 = this._invokeOne(function(i3) {
            return i3 != this && i3.getDependency && i3.getDependency(e3, t2);
          }), !n2)
            throw new Error("Unknown type: " + e3);
      }
      this.cache.add(i2, n2);
    }
    return n2;
  }
  getDependencies(e3) {
    let t2 = this.cache.get(e3);
    if (!t2) {
      const i2 = this, n2 = this.json[e3 + ("mesh" === e3 ? "es" : "s")] || [];
      t2 = Promise.all(n2.map(function(t3, n3) {
        return i2.getDependency(e3, n3);
      })), this.cache.add(e3, t2);
    }
    return t2;
  }
  loadBuffer(e3) {
    const t2 = this.json.buffers[e3], i2 = this.fileLoader;
    if (t2.type && "arraybuffer" !== t2.type)
      throw new Error("THREE.GLTFLoader: " + t2.type + " buffer type is not supported.");
    if (void 0 === t2.uri && 0 === e3)
      return Promise.resolve(this.extensions[xh.KHR_BINARY_GLTF].body);
    const n2 = this.options;
    return new Promise(function(e4, o2) {
      i2.load(xc.resolveURL(t2.uri, n2.path), e4, void 0, function() {
        o2(new Error('THREE.GLTFLoader: Failed to load buffer "' + t2.uri + '".'));
      });
    });
  }
  loadBufferView(e3) {
    const t2 = this.json.bufferViews[e3];
    return this.getDependency("buffer", t2.buffer).then(function(e4) {
      const i2 = t2.byteLength || 0, n2 = t2.byteOffset || 0;
      return e4.slice(n2, n2 + i2);
    });
  }
  loadAccessor(e3) {
    const t2 = this, i2 = this.json, n2 = this.json.accessors[e3];
    if (void 0 === n2.bufferView && void 0 === n2.sparse) {
      const e4 = Jh[n2.type], t3 = Yh[n2.componentType], i3 = true === n2.normalized, o3 = new t3(n2.count * e4);
      return Promise.resolve(new Hn(o3, e4, i3));
    }
    const o2 = [];
    return void 0 !== n2.bufferView ? o2.push(this.getDependency("bufferView", n2.bufferView)) : o2.push(null), void 0 !== n2.sparse && (o2.push(this.getDependency("bufferView", n2.sparse.indices.bufferView)), o2.push(this.getDependency("bufferView", n2.sparse.values.bufferView))), Promise.all(o2).then(function(e4) {
      const o3 = e4[0], r2 = Jh[n2.type], s2 = Yh[n2.componentType], a2 = s2.BYTES_PER_ELEMENT, l2 = a2 * r2, c2 = n2.byteOffset || 0, h2 = void 0 !== n2.bufferView ? i2.bufferViews[n2.bufferView].byteStride : void 0, u2 = true === n2.normalized;
      let d2, p2;
      if (h2 && h2 !== l2) {
        const e5 = Math.floor(c2 / h2), i3 = "InterleavedBuffer:" + n2.bufferView + ":" + n2.componentType + ":" + e5 + ":" + n2.count;
        let l3 = t2.cache.get(i3);
        l3 || (d2 = new s2(o3, e5 * h2, n2.count * h2 / a2), l3 = new Aa(d2, h2 / a2), t2.cache.add(i3, l3)), p2 = new ya(l3, r2, c2 % h2 / a2, u2);
      } else
        d2 = null === o3 ? new s2(n2.count * r2) : new s2(o3, c2, n2.count * r2), p2 = new Hn(d2, r2, u2);
      if (void 0 !== n2.sparse) {
        const t3 = Jh.SCALAR, i3 = Yh[n2.sparse.indices.componentType], a3 = n2.sparse.indices.byteOffset || 0, l3 = n2.sparse.values.byteOffset || 0, c3 = new i3(e4[1], a3, n2.sparse.count * t3), h3 = new s2(e4[2], l3, n2.sparse.count * r2);
        null !== o3 && (p2 = new Hn(p2.array.slice(), p2.itemSize, p2.normalized));
        for (let e5 = 0, t4 = c3.length; e5 < t4; e5++) {
          const t5 = c3[e5];
          if (p2.setX(t5, h3[e5 * r2]), r2 >= 2 && p2.setY(t5, h3[e5 * r2 + 1]), r2 >= 3 && p2.setZ(t5, h3[e5 * r2 + 2]), r2 >= 4 && p2.setW(t5, h3[e5 * r2 + 3]), r2 >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return p2;
    });
  }
  loadTexture(e3) {
    const t2 = this.json, i2 = this.options, n2 = t2.textures[e3].source, o2 = t2.images[n2];
    let r2 = this.textureLoader;
    if (o2.uri) {
      const e4 = i2.manager.getHandler(o2.uri);
      null !== e4 && (r2 = e4);
    }
    return this.loadTextureImage(e3, n2, r2);
  }
  loadTextureImage(e3, t2, i2) {
    const n2 = this, o2 = this.json, r2 = o2.textures[e3], s2 = o2.images[t2], a2 = (s2.uri || s2.bufferView) + ":" + r2.sampler;
    if (this.textureCache[a2])
      return this.textureCache[a2];
    const l2 = this.loadImageSource(t2, i2).then(function(t3) {
      t3.flipY = false, t3.name = r2.name || s2.name || "", "" === t3.name && "string" == typeof s2.uri && false === s2.uri.startsWith("data:image/") && (t3.name = s2.uri);
      const i3 = (o2.samplers || {})[r2.sampler] || {};
      return t3.magFilter = Kh[i3.magFilter] || He, t3.minFilter = Kh[i3.minFilter] || Ve, t3.wrapS = Zh[i3.wrapS] || Le, t3.wrapT = Zh[i3.wrapT] || Le, n2.associations.set(t3, { textures: e3 }), t3;
    }).catch(function() {
      return null;
    });
    return this.textureCache[a2] = l2, l2;
  }
  loadImageSource(e3, t2) {
    const i2 = this, n2 = this.json, o2 = this.options;
    if (void 0 !== this.sourceCache[e3])
      return this.sourceCache[e3].then((e4) => e4.clone());
    const r2 = n2.images[e3], s2 = self.URL || self.webkitURL;
    let a2 = r2.uri || "", l2 = false;
    if (void 0 !== r2.bufferView)
      a2 = i2.getDependency("bufferView", r2.bufferView).then(function(e4) {
        l2 = true;
        const t3 = new Blob([e4], { type: r2.mimeType });
        return a2 = s2.createObjectURL(t3), a2;
      });
    else if (void 0 === r2.uri)
      throw new Error("THREE.GLTFLoader: Image " + e3 + " is missing URI and bufferView");
    const c2 = Promise.resolve(a2).then(function(e4) {
      return new Promise(function(i3, n3) {
        let r3 = i3;
        true === t2.isImageBitmapLoader && (r3 = function(e5) {
          const t3 = new si(e5);
          t3.needsUpdate = true, i3(t3);
        }), t2.load(xc.resolveURL(e4, o2.path), r3, void 0, n3);
      });
    }).then(function(e4) {
      var t3;
      return true === l2 && s2.revokeObjectURL(a2), e4.userData.mimeType = r2.mimeType || ((t3 = r2.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === t3.search(/^data\:image\/jpeg/) ? "image/jpeg" : t3.search(/\.webp($|\?)/i) > 0 || 0 === t3.search(/^data\:image\/webp/) ? "image/webp" : "image/png"), e4;
    }).catch(function(e4) {
      throw console.error("THREE.GLTFLoader: Couldn't load texture", a2), e4;
    });
    return this.sourceCache[e3] = c2, c2;
  }
  assignTexture(e3, t2, i2, n2) {
    const o2 = this;
    return this.getDependency("texture", i2.index).then(function(r2) {
      if (!r2)
        return null;
      if (void 0 !== i2.texCoord && i2.texCoord > 0 && ((r2 = r2.clone()).channel = i2.texCoord), o2.extensions[xh.KHR_TEXTURE_TRANSFORM]) {
        const e4 = void 0 !== i2.extensions ? i2.extensions[xh.KHR_TEXTURE_TRANSFORM] : void 0;
        if (e4) {
          const t3 = o2.associations.get(r2);
          r2 = o2.extensions[xh.KHR_TEXTURE_TRANSFORM].extendTexture(r2, e4), o2.associations.set(r2, t3);
        }
      }
      return void 0 !== n2 && (r2.encoding = n2), e3[t2] = r2, r2;
    });
  }
  assignFinalMaterial(e3) {
    const t2 = e3.geometry;
    let i2 = e3.material;
    const n2 = void 0 === t2.attributes.tangent, o2 = void 0 !== t2.attributes.color, r2 = void 0 === t2.attributes.normal;
    if (e3.isPoints) {
      const e4 = "PointsMaterial:" + i2.uuid;
      let t3 = this.cache.get(e4);
      t3 || (t3 = new ml(), Tn.prototype.copy.call(t3, i2), t3.color.copy(i2.color), t3.map = i2.map, t3.sizeAttenuation = false, this.cache.add(e4, t3)), i2 = t3;
    } else if (e3.isLine) {
      const e4 = "LineBasicMaterial:" + i2.uuid;
      let t3 = this.cache.get(e4);
      t3 || (t3 = new rl(), Tn.prototype.copy.call(t3, i2), t3.color.copy(i2.color), t3.map = i2.map, this.cache.add(e4, t3)), i2 = t3;
    }
    if (n2 || o2 || r2) {
      let e4 = "ClonedMaterial:" + i2.uuid + ":";
      n2 && (e4 += "derivative-tangents:"), o2 && (e4 += "vertex-colors:"), r2 && (e4 += "flat-shading:");
      let t3 = this.cache.get(e4);
      t3 || (t3 = i2.clone(), o2 && (t3.vertexColors = true), r2 && (t3.flatShading = true), n2 && (t3.normalScale && (t3.normalScale.y *= -1), t3.clearcoatNormalScale && (t3.clearcoatNormalScale.y *= -1)), this.cache.add(e4, t3), this.associations.set(t3, this.associations.get(i2))), i2 = t3;
    }
    e3.material = i2;
  }
  getMaterialType() {
    return Tl;
  }
  loadMaterial(e3) {
    const t2 = this, i2 = this.json, n2 = this.extensions, o2 = i2.materials[e3];
    let r2;
    const s2 = {}, a2 = [];
    if ((o2.extensions || {})[xh.KHR_MATERIALS_UNLIT]) {
      const e4 = n2[xh.KHR_MATERIALS_UNLIT];
      r2 = e4.getMaterialType(), a2.push(e4.extendParams(s2, o2, t2));
    } else {
      const i3 = o2.pbrMetallicRoughness || {};
      if (s2.color = new Pn(1, 1, 1), s2.opacity = 1, Array.isArray(i3.baseColorFactor)) {
        const e4 = i3.baseColorFactor;
        s2.color.fromArray(e4), s2.opacity = e4[3];
      }
      void 0 !== i3.baseColorTexture && a2.push(t2.assignTexture(s2, "map", i3.baseColorTexture, bt)), s2.metalness = void 0 !== i3.metallicFactor ? i3.metallicFactor : 1, s2.roughness = void 0 !== i3.roughnessFactor ? i3.roughnessFactor : 1, void 0 !== i3.metallicRoughnessTexture && (a2.push(t2.assignTexture(s2, "metalnessMap", i3.metallicRoughnessTexture)), a2.push(t2.assignTexture(s2, "roughnessMap", i3.metallicRoughnessTexture))), r2 = this._invokeOne(function(t3) {
        return t3.getMaterialType && t3.getMaterialType(e3);
      }), a2.push(Promise.all(this._invokeAll(function(t3) {
        return t3.extendMaterialParams && t3.extendMaterialParams(e3, s2);
      })));
    }
    true === o2.doubleSided && (s2.side = be);
    const l2 = o2.alphaMode || nu;
    if (l2 === ru ? (s2.transparent = true, s2.depthWrite = false) : (s2.transparent = false, l2 === ou && (s2.alphaTest = void 0 !== o2.alphaCutoff ? o2.alphaCutoff : 0.5)), void 0 !== o2.normalTexture && r2 !== Ln && (a2.push(t2.assignTexture(s2, "normalMap", o2.normalTexture)), s2.normalScale = new Vt(1, 1), void 0 !== o2.normalTexture.scale)) {
      const e4 = o2.normalTexture.scale;
      s2.normalScale.set(e4, e4);
    }
    return void 0 !== o2.occlusionTexture && r2 !== Ln && (a2.push(t2.assignTexture(s2, "aoMap", o2.occlusionTexture)), void 0 !== o2.occlusionTexture.strength && (s2.aoMapIntensity = o2.occlusionTexture.strength)), void 0 !== o2.emissiveFactor && r2 !== Ln && (s2.emissive = new Pn().fromArray(o2.emissiveFactor)), void 0 !== o2.emissiveTexture && r2 !== Ln && a2.push(t2.assignTexture(s2, "emissiveMap", o2.emissiveTexture, bt)), Promise.all(a2).then(function() {
      const i3 = new r2(s2);
      return o2.name && (i3.name = o2.name), lu(i3, o2), t2.associations.set(i3, { materials: e3 }), o2.extensions && au(n2, i3, o2), i3;
    });
  }
  createUniqueName(e3) {
    const t2 = Rc.sanitizeNodeName(e3 || "");
    let i2 = t2;
    for (let e4 = 1; this.nodeNamesUsed[i2]; ++e4)
      i2 = t2 + "_" + e4;
    return this.nodeNamesUsed[i2] = true, i2;
  }
  loadGeometries(e3) {
    const t2 = this, i2 = this.extensions, n2 = this.primitiveCache;
    function o2(e4) {
      return i2[xh.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e4, t2).then(function(i3) {
        return gu(i3, e4, t2);
      });
    }
    const r2 = [];
    for (let i3 = 0, s2 = e3.length; i3 < s2; i3++) {
      const s3 = e3[i3], a2 = hu(s3), l2 = n2[a2];
      if (l2)
        r2.push(l2.promise);
      else {
        let e4;
        e4 = s3.extensions && s3.extensions[xh.KHR_DRACO_MESH_COMPRESSION] ? o2(s3) : gu(new Zn(), s3, t2), n2[a2] = { primitive: s3, promise: e4 }, r2.push(e4);
      }
    }
    return Promise.all(r2);
  }
  loadMesh(e3) {
    const t2 = this, i2 = this.json, n2 = this.extensions, o2 = i2.meshes[e3], r2 = o2.primitives, s2 = [];
    for (let e4 = 0, t3 = r2.length; e4 < t3; e4++) {
      const t4 = void 0 === r2[e4].material ? su(this.cache) : this.getDependency("material", r2[e4].material);
      s2.push(t4);
    }
    return s2.push(t2.loadGeometries(r2)), Promise.all(s2).then(function(i3) {
      const s3 = i3.slice(0, i3.length - 1), a2 = i3[i3.length - 1], l2 = [];
      for (let i4 = 0, c3 = a2.length; i4 < c3; i4++) {
        const c4 = a2[i4], h2 = r2[i4];
        let u2;
        const d2 = s3[i4];
        if (h2.mode === Xh.TRIANGLES || h2.mode === Xh.TRIANGLE_STRIP || h2.mode === Xh.TRIANGLE_FAN || void 0 === h2.mode)
          u2 = true === o2.isSkinnedMesh ? new Ga(c4, d2) : new fo(c4, d2), true === u2.isSkinnedMesh && u2.normalizeSkinWeights(), h2.mode === Xh.TRIANGLE_STRIP ? u2.geometry = bh(u2.geometry, 1) : h2.mode === Xh.TRIANGLE_FAN && (u2.geometry = bh(u2.geometry, 2));
        else if (h2.mode === Xh.LINES)
          u2 = new _l(c4, d2);
        else if (h2.mode === Xh.LINE_STRIP)
          u2 = new ul(c4, d2);
        else if (h2.mode === Xh.LINE_LOOP)
          u2 = new gl(c4, d2);
        else {
          if (h2.mode !== Xh.POINTS)
            throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + h2.mode);
          u2 = new yl(c4, d2);
        }
        Object.keys(u2.geometry.morphAttributes).length > 0 && cu(u2, o2), u2.name = t2.createUniqueName(o2.name || "mesh_" + e3), lu(u2, o2), h2.extensions && au(n2, u2, h2), t2.assignFinalMaterial(u2), l2.push(u2);
      }
      for (let i4 = 0, n3 = l2.length; i4 < n3; i4++)
        t2.associations.set(l2[i4], { meshes: e3, primitives: i4 });
      if (1 === l2.length)
        return l2[0];
      const c2 = new ca();
      t2.associations.set(c2, { meshes: e3 });
      for (let e4 = 0, t3 = l2.length; e4 < t3; e4++)
        c2.add(l2[e4]);
      return c2;
    });
  }
  loadCamera(e3) {
    let t2;
    const i2 = this.json.cameras[e3], n2 = i2[i2.type];
    if (n2)
      return "perspective" === i2.type ? t2 = new Eo(Qt.radToDeg(n2.yfov), n2.aspectRatio || 1, n2.znear || 1, n2.zfar || 2e6) : "orthographic" === i2.type && (t2 = new Ko(-n2.xmag, n2.xmag, n2.ymag, -n2.ymag, n2.znear, n2.zfar)), i2.name && (t2.name = this.createUniqueName(i2.name)), lu(t2, i2), Promise.resolve(t2);
    console.warn("THREE.GLTFLoader: Missing camera parameters.");
  }
  loadSkin(e3) {
    const t2 = this.json.skins[e3], i2 = [];
    for (let e4 = 0, n2 = t2.joints.length; e4 < n2; e4++)
      i2.push(this._loadNodeShallow(t2.joints[e4]));
    return void 0 !== t2.inverseBindMatrices ? i2.push(this.getDependency("accessor", t2.inverseBindMatrices)) : i2.push(null), Promise.all(i2).then(function(e4) {
      const i3 = e4.pop(), n2 = e4, o2 = [], r2 = [];
      for (let e5 = 0, s2 = n2.length; e5 < s2; e5++) {
        const s3 = n2[e5];
        if (s3) {
          o2.push(s3);
          const t3 = new Qi();
          null !== i3 && t3.fromArray(i3.array, 16 * e5), r2.push(t3);
        } else
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t2.joints[e5]);
      }
      return new Xa(o2, r2);
    });
  }
  loadAnimation(e3) {
    const t2 = this.json.animations[e3], i2 = t2.name ? t2.name : "animation_" + e3, n2 = [], o2 = [], r2 = [], s2 = [], a2 = [];
    for (let e4 = 0, i3 = t2.channels.length; e4 < i3; e4++) {
      const i4 = t2.channels[e4], l2 = t2.samplers[i4.sampler], c2 = i4.target, h2 = c2.node, u2 = void 0 !== t2.parameters ? t2.parameters[l2.input] : l2.input, d2 = void 0 !== t2.parameters ? t2.parameters[l2.output] : l2.output;
      void 0 !== c2.node && (n2.push(this.getDependency("node", h2)), o2.push(this.getDependency("accessor", u2)), r2.push(this.getDependency("accessor", d2)), s2.push(l2), a2.push(c2));
    }
    return Promise.all([Promise.all(n2), Promise.all(o2), Promise.all(r2), Promise.all(s2), Promise.all(a2)]).then(function(e4) {
      const t3 = e4[0], n3 = e4[1], o3 = e4[2], r3 = e4[3], s3 = e4[4], a3 = [];
      for (let e5 = 0, i3 = t3.length; e5 < i3; e5++) {
        const i4 = t3[e5], l2 = n3[e5], c2 = o3[e5], h2 = r3[e5], u2 = s3[e5];
        if (void 0 === i4)
          continue;
        let d2;
        switch (i4.updateMatrix(), tu[u2.path]) {
          case tu.weights:
            d2 = Gl;
            break;
          case tu.rotation:
            d2 = Wl;
            break;
          default:
            d2 = jl;
        }
        const p2 = i4.name ? i4.name : i4.uuid, _2 = void 0 !== h2.interpolation ? iu[h2.interpolation] : pt, g2 = [];
        tu[u2.path] === tu.weights ? i4.traverse(function(e6) {
          e6.morphTargetInfluences && g2.push(e6.name ? e6.name : e6.uuid);
        }) : g2.push(p2);
        let m2 = c2.array;
        if (c2.normalized) {
          const e6 = du(m2.constructor), t4 = new Float32Array(m2.length);
          for (let i5 = 0, n4 = m2.length; i5 < n4; i5++)
            t4[i5] = m2[i5] * e6;
          m2 = t4;
        }
        for (let e6 = 0, t4 = g2.length; e6 < t4; e6++) {
          const t5 = new d2(g2[e6] + "." + tu[u2.path], l2.array, m2, _2);
          "CUBICSPLINE" === h2.interpolation && (t5.createInterpolant = function(e7) {
            return new (this instanceof Wl ? jh : Wh)(this.times, this.values, this.getValueSize() / 3, e7);
          }, t5.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true), a3.push(t5);
        }
      }
      return new Xl(i2, void 0, a3);
    });
  }
  createNodeMesh(e3) {
    const t2 = this.json, i2 = this, n2 = t2.nodes[e3];
    return void 0 === n2.mesh ? null : i2.getDependency("mesh", n2.mesh).then(function(e4) {
      const t3 = i2._getNodeRef(i2.meshCache, n2.mesh, e4);
      return void 0 !== n2.weights && t3.traverse(function(e5) {
        if (e5.isMesh)
          for (let t4 = 0, i3 = n2.weights.length; t4 < i3; t4++)
            e5.morphTargetInfluences[t4] = n2.weights[t4];
      }), t3;
    });
  }
  loadNode(e3) {
    const t2 = this, i2 = this.json.nodes[e3], n2 = t2._loadNodeShallow(e3), o2 = [], r2 = i2.children || [];
    for (let e4 = 0, i3 = r2.length; e4 < i3; e4++)
      o2.push(t2.getDependency("node", r2[e4]));
    const s2 = void 0 === i2.skin ? Promise.resolve(null) : t2.getDependency("skin", i2.skin);
    return Promise.all([n2, Promise.all(o2), s2]).then(function(e4) {
      const t3 = e4[0], i3 = e4[1], n3 = e4[2];
      null !== n3 && t3.traverse(function(e5) {
        e5.isSkinnedMesh && e5.bind(n3, pu);
      });
      for (let e5 = 0, n4 = i3.length; e5 < n4; e5++)
        t3.add(i3[e5]);
      return t3;
    });
  }
  _loadNodeShallow(e3) {
    const t2 = this.json, i2 = this.extensions, n2 = this;
    if (void 0 !== this.nodeCache[e3])
      return this.nodeCache[e3];
    const o2 = t2.nodes[e3], r2 = o2.name ? n2.createUniqueName(o2.name) : "", s2 = [], a2 = n2._invokeOne(function(t3) {
      return t3.createNodeMesh && t3.createNodeMesh(e3);
    });
    return a2 && s2.push(a2), void 0 !== o2.camera && s2.push(n2.getDependency("camera", o2.camera).then(function(e4) {
      return n2._getNodeRef(n2.cameraCache, o2.camera, e4);
    })), n2._invokeAll(function(t3) {
      return t3.createNodeAttachment && t3.createNodeAttachment(e3);
    }).forEach(function(e4) {
      s2.push(e4);
    }), this.nodeCache[e3] = Promise.all(s2).then(function(t3) {
      let s3;
      if (s3 = true === o2.isBone ? new $a() : t3.length > 1 ? new ca() : 1 === t3.length ? t3[0] : new _n(), s3 !== t3[0])
        for (let e4 = 0, i3 = t3.length; e4 < i3; e4++)
          s3.add(t3[e4]);
      if (o2.name && (s3.userData.name = o2.name, s3.name = r2), lu(s3, o2), o2.extensions && au(i2, s3, o2), void 0 !== o2.matrix) {
        const e4 = new Qi();
        e4.fromArray(o2.matrix), s3.applyMatrix4(e4);
      } else
        void 0 !== o2.translation && s3.position.fromArray(o2.translation), void 0 !== o2.rotation && s3.quaternion.fromArray(o2.rotation), void 0 !== o2.scale && s3.scale.fromArray(o2.scale);
      return n2.associations.has(s3) || n2.associations.set(s3, {}), n2.associations.get(s3).nodes = e3, s3;
    }), this.nodeCache[e3];
  }
  loadScene(e3) {
    const t2 = this.extensions, i2 = this.json.scenes[e3], n2 = this, o2 = new ca();
    i2.name && (o2.name = n2.createUniqueName(i2.name)), lu(o2, i2), i2.extensions && au(t2, o2, i2);
    const r2 = i2.nodes || [], s2 = [];
    for (let e4 = 0, t3 = r2.length; e4 < t3; e4++)
      s2.push(n2.getDependency("node", r2[e4]));
    return Promise.all(s2).then(function(e4) {
      for (let t3 = 0, i3 = e4.length; t3 < i3; t3++)
        o2.add(e4[t3]);
      return n2.associations = ((e5) => {
        const t3 = /* @__PURE__ */ new Map();
        for (const [e6, i3] of n2.associations)
          (e6 instanceof Tn || e6 instanceof si) && t3.set(e6, i3);
        return e5.traverse((e6) => {
          const i3 = n2.associations.get(e6);
          null != i3 && t3.set(e6, i3);
        }), t3;
      })(o2), o2;
    });
  }
}
function gu(e3, t2, i2) {
  const n2 = t2.attributes, o2 = [];
  function r2(t3, n3) {
    return i2.getDependency("accessor", t3).then(function(t4) {
      e3.setAttribute(n3, t4);
    });
  }
  for (const t3 in n2) {
    const i3 = eu[t3] || t3.toLowerCase();
    i3 in e3.attributes || o2.push(r2(n2[t3], i3));
  }
  if (void 0 !== t2.indices && !e3.index) {
    const n3 = i2.getDependency("accessor", t2.indices).then(function(t3) {
      e3.setIndex(t3);
    });
    o2.push(n3);
  }
  return lu(e3, t2), function(e4, t3, i3) {
    const n3 = t3.attributes, o3 = new gi();
    if (void 0 === n3.POSITION)
      return;
    {
      const e5 = i3.json.accessors[n3.POSITION], t4 = e5.min, r4 = e5.max;
      if (void 0 === t4 || void 0 === r4)
        return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      if (o3.set(new di(t4[0], t4[1], t4[2]), new di(r4[0], r4[1], r4[2])), e5.normalized) {
        const t5 = du(Yh[e5.componentType]);
        o3.min.multiplyScalar(t5), o3.max.multiplyScalar(t5);
      }
    }
    const r3 = t3.targets;
    if (void 0 !== r3) {
      const e5 = new di(), t4 = new di();
      for (let n4 = 0, o4 = r3.length; n4 < o4; n4++) {
        const o5 = r3[n4];
        if (void 0 !== o5.POSITION) {
          const n5 = i3.json.accessors[o5.POSITION], r4 = n5.min, s3 = n5.max;
          if (void 0 !== r4 && void 0 !== s3) {
            if (t4.setX(Math.max(Math.abs(r4[0]), Math.abs(s3[0]))), t4.setY(Math.max(Math.abs(r4[1]), Math.abs(s3[1]))), t4.setZ(Math.max(Math.abs(r4[2]), Math.abs(s3[2]))), n5.normalized) {
              const e6 = du(Yh[n5.componentType]);
              t4.multiplyScalar(e6);
            }
            e5.max(t4);
          } else
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        }
      }
      o3.expandByVector(e5);
    }
    e4.boundingBox = o3;
    const s2 = new Pi();
    o3.getCenter(s2.center), s2.radius = o3.min.distanceTo(o3.max) / 2, e4.boundingSphere = s2;
  }(e3, t2, i2), Promise.all(o2).then(function() {
    return void 0 !== t2.targets ? function(e4, t3, i3) {
      let n3 = false, o3 = false, r3 = false;
      for (let e5 = 0, i4 = t3.length; e5 < i4; e5++) {
        const i5 = t3[e5];
        if (void 0 !== i5.POSITION && (n3 = true), void 0 !== i5.NORMAL && (o3 = true), void 0 !== i5.COLOR_0 && (r3 = true), n3 && o3 && r3)
          break;
      }
      if (!n3 && !o3 && !r3)
        return Promise.resolve(e4);
      const s2 = [], a2 = [], l2 = [];
      for (let c2 = 0, h2 = t3.length; c2 < h2; c2++) {
        const h3 = t3[c2];
        if (n3) {
          const t4 = void 0 !== h3.POSITION ? i3.getDependency("accessor", h3.POSITION) : e4.attributes.position;
          s2.push(t4);
        }
        if (o3) {
          const t4 = void 0 !== h3.NORMAL ? i3.getDependency("accessor", h3.NORMAL) : e4.attributes.normal;
          a2.push(t4);
        }
        if (r3) {
          const t4 = void 0 !== h3.COLOR_0 ? i3.getDependency("accessor", h3.COLOR_0) : e4.attributes.color;
          l2.push(t4);
        }
      }
      return Promise.all([Promise.all(s2), Promise.all(a2), Promise.all(l2)]).then(function(t4) {
        const i4 = t4[0], s3 = t4[1], a3 = t4[2];
        return n3 && (e4.morphAttributes.position = i4), o3 && (e4.morphAttributes.normal = s3), r3 && (e4.morphAttributes.color = a3), e4.morphTargetsRelative = true, e4;
      });
    }(e3, t2.targets, i2) : e3;
  });
}
class mu {
  constructor(e3 = 4) {
    this.pool = e3, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0;
  }
  _initWorker(e3) {
    if (!this.workers[e3]) {
      const t2 = this.workerCreator();
      t2.addEventListener("message", this._onMessage.bind(this, e3)), this.workers[e3] = t2;
    }
  }
  _getIdleWorker() {
    for (let e3 = 0; e3 < this.pool; e3++)
      if (!(this.workerStatus & 1 << e3))
        return e3;
    return -1;
  }
  _onMessage(e3, t2) {
    const i2 = this.workersResolve[e3];
    if (i2 && i2(t2), this.queue.length) {
      const { resolve: t3, msg: i3, transfer: n2 } = this.queue.shift();
      this.workersResolve[e3] = t3, this.workers[e3].postMessage(i3, n2);
    } else
      this.workerStatus ^= 1 << e3;
  }
  setWorkerCreator(e3) {
    this.workerCreator = e3;
  }
  setWorkerLimit(e3) {
    this.pool = e3;
  }
  postMessage(e3, t2) {
    return new Promise((i2) => {
      const n2 = this._getIdleWorker();
      -1 !== n2 ? (this._initWorker(n2), this.workerStatus |= 1 << n2, this.workersResolve[n2] = i2, this.workers[n2].postMessage(e3, t2)) : this.queue.push({ resolve: i2, msg: e3, transfer: t2 });
    });
  }
  dispose() {
    this.workers.forEach((e3) => e3.terminate()), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0;
  }
}
class fu {
  constructor() {
    this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{ vendorId: 0, descriptorType: 0, descriptorBlockSize: 0, versionNumber: 2, colorModel: 0, colorPrimaries: 1, transferFunction: 2, flags: 0, texelBlockDimension: [0, 0, 0, 0], bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0], samples: [] }], this.keyValue = {}, this.globalData = null;
  }
}
class vu {
  constructor(e3, t2, i2, n2) {
    this._dataView = new DataView(e3.buffer, e3.byteOffset + t2, i2), this._littleEndian = n2, this._offset = 0;
  }
  _nextUint8() {
    const e3 = this._dataView.getUint8(this._offset);
    return this._offset += 1, e3;
  }
  _nextUint16() {
    const e3 = this._dataView.getUint16(this._offset, this._littleEndian);
    return this._offset += 2, e3;
  }
  _nextUint32() {
    const e3 = this._dataView.getUint32(this._offset, this._littleEndian);
    return this._offset += 4, e3;
  }
  _nextUint64() {
    const e3 = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
    return this._offset += 8, e3;
  }
  _nextInt32() {
    const e3 = this._dataView.getInt32(this._offset, this._littleEndian);
    return this._offset += 4, e3;
  }
  _skip(e3) {
    return this._offset += e3, this;
  }
  _scan(e3, t2 = 0) {
    const i2 = this._offset;
    let n2 = 0;
    for (; this._dataView.getUint8(this._offset) !== t2 && n2 < e3; )
      n2++, this._offset++;
    return n2 < e3 && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + i2, n2);
  }
}
const Au = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
function bu(e3) {
  return "undefined" != typeof TextDecoder ? new TextDecoder().decode(e3) : Buffer.from(e3).toString("utf8");
}
let yu, wu, xu;
const Cu = { env: { emscripten_notify_memory_growth: function(e3) {
  xu = new Uint8Array(wu.exports.memory.buffer);
} } };
class Su {
  init() {
    return yu || (yu = "undefined" != typeof fetch ? fetch("data:application/wasm;base64," + Eu).then((e3) => e3.arrayBuffer()).then((e3) => WebAssembly.instantiate(e3, Cu)).then(this._init) : WebAssembly.instantiate(Buffer.from(Eu, "base64"), Cu).then(this._init), yu);
  }
  _init(e3) {
    wu = e3.instance, Cu.env.emscripten_notify_memory_growth(0);
  }
  decode(e3, t2 = 0) {
    if (!wu)
      throw new Error("ZSTDDecoder: Await .init() before decoding.");
    const i2 = e3.byteLength, n2 = wu.exports.malloc(i2);
    xu.set(e3, n2), t2 = t2 || Number(wu.exports.ZSTD_findDecompressedSize(n2, i2));
    const o2 = wu.exports.malloc(t2), r2 = wu.exports.ZSTD_decompress(o2, t2, n2, i2), s2 = xu.slice(o2, o2 + r2);
    return wu.exports.free(n2), wu.exports.free(o2), s2;
  }
}
const Eu = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ", Iu = /* @__PURE__ */ new WeakMap();
let Tu, Bu = 0;
class Mu extends ec {
  constructor(e3) {
    super(e3), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new mu(), this.workerSourceURL = "", this.workerConfig = null, "undefined" != typeof MSC_TRANSCODER && console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.');
  }
  setTranscoderPath(e3) {
    return this.transcoderPath = e3, this;
  }
  setWorkerLimit(e3) {
    return this.workerPool.setWorkerLimit(e3), this;
  }
  detectSupport(e3) {
    return this.workerConfig = { astcSupported: e3.extensions.has("WEBGL_compressed_texture_astc"), etc1Supported: e3.extensions.has("WEBGL_compressed_texture_etc1"), etc2Supported: e3.extensions.has("WEBGL_compressed_texture_etc"), dxtSupported: e3.extensions.has("WEBGL_compressed_texture_s3tc"), bptcSupported: e3.extensions.has("EXT_texture_compression_bptc"), pvrtcSupported: e3.extensions.has("WEBGL_compressed_texture_pvrtc") || e3.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc") }, e3.capabilities.isWebGL2 && (this.workerConfig.etc1Supported = false), this;
  }
  init() {
    if (!this.transcoderPending) {
      const e3 = new nc(this.manager);
      e3.setPath(this.transcoderPath), e3.setWithCredentials(this.withCredentials);
      const t2 = e3.loadAsync("basis_transcoder.js"), i2 = new nc(this.manager);
      i2.setPath(this.transcoderPath), i2.setResponseType("arraybuffer"), i2.setWithCredentials(this.withCredentials);
      const n2 = i2.loadAsync("basis_transcoder.wasm");
      this.transcoderPending = Promise.all([t2, n2]).then(([e4, t3]) => {
        const i3 = Mu.BasisWorker.toString(), n3 = ["/* constants */", "let _EngineFormat = " + JSON.stringify(Mu.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(Mu.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(Mu.BasisFormat), "/* basis_transcoder.js */", e4, "/* worker */", i3.substring(i3.indexOf("{") + 1, i3.lastIndexOf("}"))].join("\n");
        this.workerSourceURL = URL.createObjectURL(new Blob([n3])), this.transcoderBinary = t3, this.workerPool.setWorkerCreator(() => {
          const e5 = new Worker(this.workerSourceURL), t4 = this.transcoderBinary.slice(0);
          return e5.postMessage({ type: "init", config: this.workerConfig, transcoderBinary: t4 }, [t4]), e5;
        });
      }), Bu > 0 && console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."), Bu++;
    }
    return this.transcoderPending;
  }
  load(e3, t2, i2, n2) {
    if (null === this.workerConfig)
      throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
    const o2 = new nc(this.manager);
    o2.setResponseType("arraybuffer"), o2.setWithCredentials(this.withCredentials), o2.load(e3, (e4) => {
      if (Iu.has(e4)) {
        return Iu.get(e4).promise.then(t2).catch(n2);
      }
      this._createTexture(e4).then((e5) => t2 ? t2(e5) : null).catch(n2);
    }, i2, n2);
  }
  _createTextureFrom(e3, t2) {
    const { mipmaps: i2, width: n2, height: o2, format: r2, type: s2, error: a2, dfdTransferFn: l2, dfdFlags: c2 } = e3;
    if ("error" === s2)
      return Promise.reject(a2);
    const h2 = t2.layerCount > 1 ? new Sl(i2, n2, o2, t2.layerCount, r2, Ge) : new Cl(i2, n2, o2, r2, Ge);
    return h2.minFilter = 1 === i2.length ? He : Ve, h2.magFilter = He, h2.generateMipmaps = false, h2.needsUpdate = true, h2.encoding = 2 === l2 ? bt : At, h2.premultiplyAlpha = !!(1 & c2), h2;
  }
  async _createTexture(e3, t2 = {}) {
    const i2 = function(e4) {
      const t3 = new Uint8Array(e4.buffer, e4.byteOffset, Au.length);
      if (t3[0] !== Au[0] || t3[1] !== Au[1] || t3[2] !== Au[2] || t3[3] !== Au[3] || t3[4] !== Au[4] || t3[5] !== Au[5] || t3[6] !== Au[6] || t3[7] !== Au[7] || t3[8] !== Au[8] || t3[9] !== Au[9] || t3[10] !== Au[10] || t3[11] !== Au[11])
        throw new Error("Missing KTX 2.0 identifier.");
      const i3 = new fu(), n3 = 17 * Uint32Array.BYTES_PER_ELEMENT, o3 = new vu(e4, Au.length, n3, true);
      i3.vkFormat = o3._nextUint32(), i3.typeSize = o3._nextUint32(), i3.pixelWidth = o3._nextUint32(), i3.pixelHeight = o3._nextUint32(), i3.pixelDepth = o3._nextUint32(), i3.layerCount = o3._nextUint32(), i3.faceCount = o3._nextUint32();
      const r2 = o3._nextUint32();
      i3.supercompressionScheme = o3._nextUint32();
      const s2 = o3._nextUint32(), a2 = o3._nextUint32(), l2 = o3._nextUint32(), c2 = o3._nextUint32(), h2 = o3._nextUint64(), u2 = o3._nextUint64(), d2 = new vu(e4, Au.length + n3, 3 * r2 * 8, true);
      for (let t4 = 0; t4 < r2; t4++)
        i3.levels.push({ levelData: new Uint8Array(e4.buffer, e4.byteOffset + d2._nextUint64(), d2._nextUint64()), uncompressedByteLength: d2._nextUint64() });
      const p2 = new vu(e4, s2, a2, true), _2 = { vendorId: p2._skip(4)._nextUint16(), descriptorType: p2._nextUint16(), versionNumber: p2._nextUint16(), descriptorBlockSize: p2._nextUint16(), colorModel: p2._nextUint8(), colorPrimaries: p2._nextUint8(), transferFunction: p2._nextUint8(), flags: p2._nextUint8(), texelBlockDimension: [p2._nextUint8(), p2._nextUint8(), p2._nextUint8(), p2._nextUint8()], bytesPlane: [p2._nextUint8(), p2._nextUint8(), p2._nextUint8(), p2._nextUint8(), p2._nextUint8(), p2._nextUint8(), p2._nextUint8(), p2._nextUint8()], samples: [] }, g2 = (_2.descriptorBlockSize / 4 - 6) / 4;
      for (let e5 = 0; e5 < g2; e5++) {
        const t4 = { bitOffset: p2._nextUint16(), bitLength: p2._nextUint8(), channelType: p2._nextUint8(), samplePosition: [p2._nextUint8(), p2._nextUint8(), p2._nextUint8(), p2._nextUint8()], sampleLower: -1 / 0, sampleUpper: 1 / 0 };
        64 & t4.channelType ? (t4.sampleLower = p2._nextInt32(), t4.sampleUpper = p2._nextInt32()) : (t4.sampleLower = p2._nextUint32(), t4.sampleUpper = p2._nextUint32()), _2.samples[e5] = t4;
      }
      i3.dataFormatDescriptor.length = 0, i3.dataFormatDescriptor.push(_2);
      const m2 = new vu(e4, l2, c2, true);
      for (; m2._offset < c2; ) {
        const e5 = m2._nextUint32(), t4 = m2._scan(e5), n4 = bu(t4), o4 = m2._scan(e5 - t4.byteLength);
        i3.keyValue[n4] = n4.match(/^ktx/i) ? bu(o4) : o4, m2._offset % 4 && m2._skip(4 - m2._offset % 4);
      }
      if (u2 <= 0)
        return i3;
      const f2 = new vu(e4, h2, u2, true), v2 = f2._nextUint16(), A2 = f2._nextUint16(), b2 = f2._nextUint32(), y2 = f2._nextUint32(), w2 = f2._nextUint32(), x2 = f2._nextUint32(), C2 = [];
      for (let e5 = 0; e5 < r2; e5++)
        C2.push({ imageFlags: f2._nextUint32(), rgbSliceByteOffset: f2._nextUint32(), rgbSliceByteLength: f2._nextUint32(), alphaSliceByteOffset: f2._nextUint32(), alphaSliceByteLength: f2._nextUint32() });
      const S2 = h2 + f2._offset, E2 = S2 + b2, I2 = E2 + y2, T2 = I2 + w2, B2 = new Uint8Array(e4.buffer, e4.byteOffset + S2, b2), M2 = new Uint8Array(e4.buffer, e4.byteOffset + E2, y2), k2 = new Uint8Array(e4.buffer, e4.byteOffset + I2, w2), R2 = new Uint8Array(e4.buffer, e4.byteOffset + T2, x2);
      return i3.globalData = { endpointCount: v2, selectorCount: A2, imageDescs: C2, endpointsData: B2, selectorsData: M2, tablesData: k2, extendedData: R2 }, i3;
    }(new Uint8Array(e3));
    if (0 !== i2.vkFormat)
      return async function(e4) {
        const { vkFormat: t3, pixelWidth: i3, pixelHeight: n3, pixelDepth: o3 } = e4;
        if (void 0 === ku[t3])
          throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
        const r2 = e4.levels[0];
        let s2, a2;
        if (0 === e4.supercompressionScheme)
          s2 = r2.levelData;
        else {
          if (2 !== e4.supercompressionScheme)
            throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
          Tu || (Tu = new Promise(async (e5) => {
            const t4 = new Su();
            await t4.init(), e5(t4);
          })), s2 = (await Tu).decode(r2.levelData, r2.uncompressedByteLength);
        }
        a2 = Ru[t3] === We ? new Float32Array(s2.buffer, s2.byteOffset, s2.byteLength / Float32Array.BYTES_PER_ELEMENT) : Ru[t3] === qe ? new Uint16Array(s2.buffer, s2.byteOffset, s2.byteLength / Uint16Array.BYTES_PER_ELEMENT) : s2;
        const l2 = 0 === o3 ? new Wa(a2, i3, n3) : new hi(a2, i3, n3, o3);
        return l2.type = Ru[t3], l2.format = ku[t3], l2.encoding = Pu[t3] || At, l2.needsUpdate = true, Promise.resolve(l2);
      }(i2);
    const n2 = t2, o2 = this.init().then(() => this.workerPool.postMessage({ type: "transcode", buffer: e3, taskConfig: n2 }, [e3])).then((e4) => this._createTextureFrom(e4.data, i2));
    return Iu.set(e3, { promise: o2 }), o2;
  }
  dispose() {
    return this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), Bu--, this;
  }
}
Mu.BasisFormat = { ETC1S: 0, UASTC_4x4: 1 }, Mu.TranscoderFormat = { ETC1: 0, ETC2: 1, BC1: 2, BC3: 3, BC4: 4, BC5: 5, BC7_M6_OPAQUE_ONLY: 6, BC7_M5: 7, PVRTC1_4_RGB: 8, PVRTC1_4_RGBA: 9, ASTC_4x4: 10, ATC_RGB: 11, ATC_RGBA_INTERPOLATED_ALPHA: 12, RGBA32: 13, RGB565: 14, BGR565: 15, RGBA4444: 16 }, Mu.EngineFormat = { RGBAFormat: Xe, RGBA_ASTC_4x4_Format: lt, RGBA_BPTC_Format: ct, RGBA_ETC2_EAC_Format: at, RGBA_PVRTC_4BPPV1_Format: rt, RGBA_S3TC_DXT5_Format: nt, RGB_ETC1_Format: 36196, RGB_ETC2_Format: st, RGB_PVRTC_4BPPV1_Format: ot, RGB_S3TC_DXT1_Format: et }, Mu.BasisWorker = function() {
  let e3, t2, i2;
  const n2 = _EngineFormat, o2 = _TranscoderFormat, r2 = _BasisFormat;
  self.addEventListener("message", function(s3) {
    const u2 = s3.data;
    switch (u2.type) {
      case "init":
        e3 = u2.config, d2 = u2.transcoderBinary, t2 = new Promise((e4) => {
          i2 = { wasmBinary: d2, onRuntimeInitialized: e4 }, BASIS(i2);
        }).then(() => {
          i2.initializeBasis(), void 0 === i2.KTX2File && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.");
        });
        break;
      case "transcode":
        t2.then(() => {
          try {
            const { width: t3, height: s4, hasAlpha: d3, mipmaps: p2, format: _2, dfdTransferFn: g2, dfdFlags: m2 } = function(t4) {
              const s5 = new i2.KTX2File(new Uint8Array(t4));
              function u3() {
                s5.close(), s5.delete();
              }
              if (!s5.isValid())
                throw u3(), new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");
              const d4 = s5.isUASTC() ? r2.UASTC_4x4 : r2.ETC1S, p3 = s5.getWidth(), _3 = s5.getHeight(), g3 = s5.getLayers() || 1, m3 = s5.getLevels(), f3 = s5.getHasAlpha(), v2 = s5.getDFDTransferFunc(), A2 = s5.getDFDFlags(), { transcoderFormat: b2, engineFormat: y2 } = function(t5, i3, s6, h3) {
                let u4, d5;
                const p4 = t5 === r2.ETC1S ? a2 : l2;
                for (let n3 = 0; n3 < p4.length; n3++) {
                  const o3 = p4[n3];
                  if (e3[o3.if] && (o3.basisFormat.includes(t5) && !(h3 && o3.transcoderFormat.length < 2) && (!o3.needsPowerOfTwo || c2(i3) && c2(s6))))
                    return u4 = o3.transcoderFormat[h3 ? 1 : 0], d5 = o3.engineFormat[h3 ? 1 : 0], { transcoderFormat: u4, engineFormat: d5 };
                }
                return console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."), u4 = o2.RGBA32, d5 = n2.RGBAFormat, { transcoderFormat: u4, engineFormat: d5 };
              }(d4, p3, _3, f3);
              if (!p3 || !_3 || !m3)
                throw u3(), new Error("THREE.KTX2Loader:	Invalid texture");
              if (!s5.startTranscoding())
                throw u3(), new Error("THREE.KTX2Loader: .startTranscoding failed");
              const w2 = [];
              for (let e4 = 0; e4 < m3; e4++) {
                const t5 = [];
                let i3, n3;
                for (let o3 = 0; o3 < g3; o3++) {
                  const r3 = s5.getImageLevelInfo(e4, o3, 0);
                  i3 = r3.origWidth < 4 ? r3.origWidth : r3.width, n3 = r3.origHeight < 4 ? r3.origHeight : r3.height;
                  const a3 = new Uint8Array(s5.getImageTranscodedSizeInBytes(e4, o3, 0, b2));
                  if (!s5.transcodeImage(a3, e4, o3, 0, b2, 0, -1, -1))
                    throw u3(), new Error("THREE.KTX2Loader: .transcodeImage failed.");
                  t5.push(a3);
                }
                w2.push({ data: h2(t5), width: i3, height: n3 });
              }
              return u3(), { width: p3, height: _3, hasAlpha: f3, mipmaps: w2, format: y2, dfdTransferFn: v2, dfdFlags: A2 };
            }(u2.buffer), f2 = [];
            for (let e4 = 0; e4 < p2.length; ++e4)
              f2.push(p2[e4].data.buffer);
            self.postMessage({ type: "transcode", id: u2.id, width: t3, height: s4, hasAlpha: d3, mipmaps: p2, format: _2, dfdTransferFn: g2, dfdFlags: m2 }, f2);
          } catch (e4) {
            console.error(e4), self.postMessage({ type: "error", id: u2.id, error: e4.message });
          }
        });
    }
    var d2;
  });
  const s2 = [{ if: "astcSupported", basisFormat: [r2.UASTC_4x4], transcoderFormat: [o2.ASTC_4x4, o2.ASTC_4x4], engineFormat: [n2.RGBA_ASTC_4x4_Format, n2.RGBA_ASTC_4x4_Format], priorityETC1S: 1 / 0, priorityUASTC: 1, needsPowerOfTwo: false }, { if: "bptcSupported", basisFormat: [r2.ETC1S, r2.UASTC_4x4], transcoderFormat: [o2.BC7_M5, o2.BC7_M5], engineFormat: [n2.RGBA_BPTC_Format, n2.RGBA_BPTC_Format], priorityETC1S: 3, priorityUASTC: 2, needsPowerOfTwo: false }, { if: "dxtSupported", basisFormat: [r2.ETC1S, r2.UASTC_4x4], transcoderFormat: [o2.BC1, o2.BC3], engineFormat: [n2.RGB_S3TC_DXT1_Format, n2.RGBA_S3TC_DXT5_Format], priorityETC1S: 4, priorityUASTC: 5, needsPowerOfTwo: false }, { if: "etc2Supported", basisFormat: [r2.ETC1S, r2.UASTC_4x4], transcoderFormat: [o2.ETC1, o2.ETC2], engineFormat: [n2.RGB_ETC2_Format, n2.RGBA_ETC2_EAC_Format], priorityETC1S: 1, priorityUASTC: 3, needsPowerOfTwo: false }, { if: "etc1Supported", basisFormat: [r2.ETC1S, r2.UASTC_4x4], transcoderFormat: [o2.ETC1], engineFormat: [n2.RGB_ETC1_Format], priorityETC1S: 2, priorityUASTC: 4, needsPowerOfTwo: false }, { if: "pvrtcSupported", basisFormat: [r2.ETC1S, r2.UASTC_4x4], transcoderFormat: [o2.PVRTC1_4_RGB, o2.PVRTC1_4_RGBA], engineFormat: [n2.RGB_PVRTC_4BPPV1_Format, n2.RGBA_PVRTC_4BPPV1_Format], priorityETC1S: 5, priorityUASTC: 6, needsPowerOfTwo: true }], a2 = s2.sort(function(e4, t3) {
    return e4.priorityETC1S - t3.priorityETC1S;
  }), l2 = s2.sort(function(e4, t3) {
    return e4.priorityUASTC - t3.priorityUASTC;
  });
  function c2(e4) {
    return e4 <= 2 || 0 == (e4 & e4 - 1) && 0 !== e4;
  }
  function h2(e4) {
    let t3 = 0;
    for (const i4 of e4)
      t3 += i4.byteLength;
    const i3 = new Uint8Array(t3);
    let n3 = 0;
    for (const t4 of e4)
      i3.set(t4, n3), n3 += t4.byteLength;
    return i3;
  }
};
const ku = { 109: Xe, 97: Xe, 37: Xe, 43: Xe, 103: Je, 83: Je, 16: Je, 22: Je, 100: Ze, 76: Ze, 15: Ze, 9: Ze }, Ru = { 109: We, 97: qe, 37: Ge, 43: Ge, 103: We, 83: qe, 16: Ge, 22: Ge, 100: We, 76: qe, 15: Ge, 9: Ge }, Pu = { 43: bt, 22: bt, 15: bt };
var Du, Lu;
const Fu = Symbol("retainerCount"), Nu = Symbol("recentlyUsed"), Ou = Symbol("evict"), zu = Symbol("evictionThreshold"), Uu = Symbol("cache");
class Hu {
  constructor(e3, t2 = 5) {
    this[Du] = /* @__PURE__ */ new Map(), this[Lu] = [], this[Uu] = e3, this[zu] = t2;
  }
  set evictionThreshold(e3) {
    this[zu] = e3, this[Ou]();
  }
  get evictionThreshold() {
    return this[zu];
  }
  get cache() {
    return this[Uu];
  }
  retainerCount(e3) {
    return this[Fu].get(e3) || 0;
  }
  reset() {
    this[Fu].clear(), this[Nu] = [];
  }
  retain(e3) {
    this[Fu].has(e3) || this[Fu].set(e3, 0), this[Fu].set(e3, this[Fu].get(e3) + 1);
    const t2 = this[Nu].indexOf(e3);
    -1 !== t2 && this[Nu].splice(t2, 1), this[Nu].unshift(e3), this[Ou]();
  }
  release(e3) {
    this[Fu].has(e3) && this[Fu].set(e3, Math.max(this[Fu].get(e3) - 1, 0)), this[Ou]();
  }
  [(Du = Fu, Lu = Nu, Ou)]() {
    if (!(this[Nu].length < this[zu]))
      for (let e3 = this[Nu].length - 1; e3 >= this[zu]; --e3) {
        const t2 = this[Nu][e3];
        0 === this[Fu].get(t2) && (this[Uu].delete(t2), this[Nu].splice(e3, 1));
      }
  }
}
const Qu = (e3) => {
  const t2 = /* @__PURE__ */ new Map();
  for (const i2 of e3.mappings)
    for (const e4 of i2.variants)
      t2.set(e4, { material: null, gltfMaterialIndex: i2.material });
  return t2;
};
class Vu {
  constructor(e3) {
    this.parser = e3, this.name = "KHR_materials_variants";
  }
  afterRoot(e3) {
    const t2 = this.parser, i2 = t2.json;
    if (void 0 === i2.extensions || void 0 === i2.extensions[this.name])
      return null;
    const n2 = ((e4) => {
      const t3 = [], i3 = /* @__PURE__ */ new Set();
      for (const n3 of e4) {
        let e5 = n3, o2 = 0;
        for (; i3.has(e5); )
          e5 = n3 + "." + ++o2;
        i3.add(e5), t3.push(e5);
      }
      return t3;
    })((i2.extensions[this.name].variants || []).map((e4) => e4.name));
    for (const n3 of e3.scenes)
      n3.traverse((e4) => {
        const n4 = e4;
        if (!n4.material)
          return;
        const o2 = t2.associations.get(n4);
        if (null == o2 || null == o2.meshes || null == o2.primitives)
          return;
        const r2 = i2.meshes[o2.meshes].primitives[o2.primitives].extensions;
        r2 && r2[this.name] && (n4.userData.variantMaterials = Qu(r2[this.name]));
      });
    return e3.userData.variants = n2, Promise.resolve();
  }
}
var Gu, $u;
si.DEFAULT_ANISOTROPY = 4;
const Wu = /* @__PURE__ */ new Map(), qu = /* @__PURE__ */ new Map();
let ju;
const Xu = new class extends ec {
  constructor(e3) {
    super(e3), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = { position: "POSITION", normal: "NORMAL", color: "COLOR", uv: "TEX_COORD" }, this.defaultAttributeTypes = { position: "Float32Array", normal: "Float32Array", color: "Float32Array", uv: "Float32Array" };
  }
  setDecoderPath(e3) {
    return this.decoderPath = e3, this;
  }
  setDecoderConfig(e3) {
    return this.decoderConfig = e3, this;
  }
  setWorkerLimit(e3) {
    return this.workerLimit = e3, this;
  }
  load(e3, t2, i2, n2) {
    const o2 = new nc(this.manager);
    o2.setPath(this.path), o2.setResponseType("arraybuffer"), o2.setRequestHeader(this.requestHeader), o2.setWithCredentials(this.withCredentials), o2.load(e3, (e4) => {
      this.parse(e4, t2, n2);
    }, i2, n2);
  }
  parse(e3, t2, i2) {
    this.decodeDracoFile(e3, t2, null, null, yt).catch(i2);
  }
  decodeDracoFile(e3, t2, i2, n2, o2 = wt) {
    const r2 = { attributeIDs: i2 || this.defaultAttributeIDs, attributeTypes: n2 || this.defaultAttributeTypes, useUniqueIDs: !!i2, vertexColorSpace: o2 };
    return this.decodeGeometry(e3, r2).then(t2);
  }
  decodeGeometry(e3, t2) {
    const i2 = JSON.stringify(t2);
    if (vh.has(e3)) {
      const t3 = vh.get(e3);
      if (t3.key === i2)
        return t3.promise;
      if (0 === e3.byteLength)
        throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.");
    }
    let n2;
    const o2 = this.workerNextTaskID++, r2 = e3.byteLength, s2 = this._getWorker(o2, r2).then((i3) => (n2 = i3, new Promise((i4, r3) => {
      n2._callbacks[o2] = { resolve: i4, reject: r3 }, n2.postMessage({ type: "decode", id: o2, taskConfig: t2, buffer: e3 }, [e3]);
    }))).then((e4) => this._createGeometry(e4.geometry));
    return s2.catch(() => true).then(() => {
      n2 && o2 && this._releaseTask(n2, o2);
    }), vh.set(e3, { key: i2, promise: s2 }), s2;
  }
  _createGeometry(e3) {
    const t2 = new Zn();
    e3.index && t2.setIndex(new Hn(e3.index.array, 1));
    for (let i2 = 0; i2 < e3.attributes.length; i2++) {
      const n2 = e3.attributes[i2], o2 = n2.name, r2 = n2.array, s2 = n2.itemSize, a2 = new Hn(r2, s2);
      "color" === o2 && this._assignVertexColorSpace(a2, n2.vertexColorSpace), t2.setAttribute(o2, a2);
    }
    return t2;
  }
  _assignVertexColorSpace(e3, t2) {
    if (t2 !== yt)
      return;
    const i2 = new Pn();
    for (let t3 = 0, n2 = e3.count; t3 < n2; t3++)
      i2.fromBufferAttribute(e3, t3).convertSRGBToLinear(), e3.setXYZ(t3, i2.r, i2.g, i2.b);
  }
  _loadLibrary(e3, t2) {
    const i2 = new nc(this.manager);
    return i2.setPath(this.decoderPath), i2.setResponseType(t2), i2.setWithCredentials(this.withCredentials), new Promise((t3, n2) => {
      i2.load(e3, t3, void 0, n2);
    });
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending)
      return this.decoderPending;
    const e3 = "object" != typeof WebAssembly || "js" === this.decoderConfig.type, t2 = [];
    return e3 ? t2.push(this._loadLibrary("draco_decoder.js", "text")) : (t2.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t2.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t2).then((t3) => {
      const i2 = t3[0];
      e3 || (this.decoderConfig.wasmBinary = t3[1]);
      const n2 = Ah.toString(), o2 = ["/* draco decoder */", i2, "", "/* worker */", n2.substring(n2.indexOf("{") + 1, n2.lastIndexOf("}"))].join("\n");
      this.workerSourceURL = URL.createObjectURL(new Blob([o2]));
    }), this.decoderPending;
  }
  _getWorker(e3, t2) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const e4 = new Worker(this.workerSourceURL);
        e4._callbacks = {}, e4._taskCosts = {}, e4._taskLoad = 0, e4.postMessage({ type: "init", decoderConfig: this.decoderConfig }), e4.onmessage = function(t3) {
          const i3 = t3.data;
          switch (i3.type) {
            case "decode":
              e4._callbacks[i3.id].resolve(i3);
              break;
            case "error":
              e4._callbacks[i3.id].reject(i3);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + i3.type + '"');
          }
        }, this.workerPool.push(e4);
      } else
        this.workerPool.sort(function(e4, t3) {
          return e4._taskLoad > t3._taskLoad ? -1 : 1;
        });
      const i2 = this.workerPool[this.workerPool.length - 1];
      return i2._taskCosts[e3] = t2, i2._taskLoad += t2, i2;
    });
  }
  _releaseTask(e3, t2) {
    e3._taskLoad -= e3._taskCosts[t2], delete e3._callbacks[t2], delete e3._taskCosts[t2];
  }
  debug() {
    console.log("Task load: ", this.workerPool.map((e3) => e3._taskLoad));
  }
  dispose() {
    for (let e3 = 0; e3 < this.workerPool.length; ++e3)
      this.workerPool[e3].terminate();
    return this.workerPool.length = 0, "" !== this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), this;
  }
}();
let Yu;
const Ku = new Mu();
let Zu, Ju;
const ed = Symbol("loader"), td = Symbol("evictionPolicy"), id = Symbol("GLTFInstance");
class nd extends Tt {
  constructor(e3) {
    super(), this[$u] = new yh().register((e4) => new Vu(e4)), this[id] = e3, this[ed].setDRACOLoader(Xu), this[ed].setKTX2Loader(Ku);
  }
  static setDRACODecoderLocation(e3) {
    ju = e3, Xu.setDecoderPath(e3);
  }
  static getDRACODecoderLocation() {
    return ju;
  }
  static setKTX2TranscoderLocation(e3) {
    Yu = e3, Ku.setTranscoderPath(e3);
  }
  static getKTX2TranscoderLocation() {
    return Yu;
  }
  static setMeshoptDecoderLocation(e3) {
    var t2;
    Zu !== e3 && (Zu = e3, Ju = (t2 = e3, new Promise((e4, i2) => {
      const n2 = document.createElement("script");
      document.body.appendChild(n2), n2.onload = e4, n2.onerror = i2, n2.async = true, n2.src = t2;
    })).then(() => MeshoptDecoder.ready).then(() => MeshoptDecoder));
  }
  static getMeshoptDecoderLocation() {
    return Zu;
  }
  static initializeKTX2Loader(e3) {
    Ku.detectSupport(e3);
  }
  static get cache() {
    return Wu;
  }
  static clearCache() {
    Wu.forEach((e3, t2) => {
      this.delete(t2);
    }), this[td].reset();
  }
  static has(e3) {
    return Wu.has(e3);
  }
  static async delete(e3) {
    if (!this.has(e3))
      return;
    const t2 = Wu.get(e3);
    qu.delete(e3), Wu.delete(e3);
    (await t2).dispose();
  }
  static hasFinishedLoading(e3) {
    return !!qu.get(e3);
  }
  get [(Gu = td, $u = ed, td)]() {
    return this.constructor[td];
  }
  async preload(e3, t2, i2 = () => {
  }) {
    if (this[ed].setWithCredentials(nd.withCredentials), this.dispatchEvent({ type: "preload", element: t2, src: e3 }), !Wu.has(e3)) {
      null != Ju && this[ed].setMeshoptDecoder(await Ju);
      const t3 = ((e4, t4, i3 = () => {
      }) => {
        const n3 = (e5) => {
          const t5 = e5.loaded / e5.total;
          i3(Math.max(0, Math.min(1, isFinite(t5) ? t5 : 1)));
        };
        return new Promise((i4, o3) => {
          t4.load(e4, i4, n3, o3);
        });
      })(e3, this[ed], (e4) => {
        i2(0.8 * e4);
      }), n2 = this[id], o2 = t3.then((e4) => n2.prepare(e4)).then((e4) => (i2(0.9), new n2(e4))).catch((e4) => (console.error(e4), new n2()));
      Wu.set(e3, o2);
    }
    await Wu.get(e3), qu.set(e3, true), i2 && i2(1);
  }
  async load(e3, t2, i2 = () => {
  }) {
    await this.preload(e3, t2, i2);
    const n2 = await Wu.get(e3), o2 = await n2.clone();
    return this[td].retain(e3), o2.dispose = () => {
      this[td].release(e3);
    }, o2;
  }
}
nd[Gu] = new Hu(nd);
class od extends _n {
  constructor(e3 = document.createElement("div")) {
    super(), this.isCSS2DObject = true, this.element = e3, this.element.style.position = "absolute", this.element.style.userSelect = "none", this.element.setAttribute("draggable", false), this.center = new Vt(0.5, 0.5), this.addEventListener("removed", function() {
      this.traverse(function(e4) {
        e4.element instanceof Element && null !== e4.element.parentNode && e4.element.parentNode.removeChild(e4.element);
      });
    });
  }
  copy(e3, t2) {
    return super.copy(e3, t2), this.element = e3.element.cloneNode(true), this.center = e3.center, this;
  }
}
const rd = new di(), sd = new Qi(), ad = new Qi(), ld = new di(), cd = new di();
class hd {
  constructor(e3 = {}) {
    const t2 = this;
    let i2, n2, o2, r2;
    const s2 = { objects: /* @__PURE__ */ new WeakMap() }, a2 = void 0 !== e3.element ? e3.element : document.createElement("div");
    function l2(e4, i3, n3) {
      if (e4.isCSS2DObject) {
        rd.setFromMatrixPosition(e4.matrixWorld), rd.applyMatrix4(ad);
        const l3 = true === e4.visible && rd.z >= -1 && rd.z <= 1 && true === e4.layers.test(n3.layers);
        if (e4.element.style.display = true === l3 ? "" : "none", true === l3) {
          e4.onBeforeRender(t2, i3, n3);
          const s3 = e4.element;
          s3.style.transform = "translate(" + -100 * e4.center.x + "%," + -100 * e4.center.y + "%)translate(" + (rd.x * o2 + o2) + "px," + (-rd.y * r2 + r2) + "px)", s3.parentNode !== a2 && a2.appendChild(s3), e4.onAfterRender(t2, i3, n3);
        }
        const h2 = { distanceToCameraSquared: c2(n3, e4) };
        s2.objects.set(e4, h2);
      }
      for (let t3 = 0, o3 = e4.children.length; t3 < o3; t3++)
        l2(e4.children[t3], i3, n3);
    }
    function c2(e4, t3) {
      return ld.setFromMatrixPosition(e4.matrixWorld), cd.setFromMatrixPosition(t3.matrixWorld), ld.distanceToSquared(cd);
    }
    a2.style.overflow = "hidden", this.domElement = a2, this.getSize = function() {
      return { width: i2, height: n2 };
    }, this.render = function(e4, t3) {
      true === e4.matrixWorldAutoUpdate && e4.updateMatrixWorld(), null === t3.parent && true === t3.matrixWorldAutoUpdate && t3.updateMatrixWorld(), sd.copy(t3.matrixWorldInverse), ad.multiplyMatrices(t3.projectionMatrix, sd), l2(e4, e4, t3), function(e5) {
        const t4 = function(e6) {
          const t5 = [];
          return e6.traverse(function(e7) {
            e7.isCSS2DObject && t5.push(e7);
          }), t5;
        }(e5).sort(function(e6, t5) {
          if (e6.renderOrder !== t5.renderOrder)
            return t5.renderOrder - e6.renderOrder;
          return s2.objects.get(e6).distanceToCameraSquared - s2.objects.get(t5).distanceToCameraSquared;
        }), i3 = t4.length;
        for (let e6 = 0, n3 = t4.length; e6 < n3; e6++)
          t4[e6].element.style.zIndex = i3 - e6;
      }(e4);
    }, this.setSize = function(e4, t3) {
      i2 = e4, n2 = t3, o2 = i2 / 2, r2 = n2 / 2, a2.style.width = e4 + "px", a2.style.height = t3 + "px";
    };
  }
}
function ud(e3, t2, i2) {
  let n2 = i2;
  const o2 = new di();
  return e3.updateWorldMatrix(true, true), e3.traverseVisible((e4) => {
    const { geometry: i3 } = e4;
    if (void 0 !== i3) {
      const { position: r2 } = i3.attributes;
      if (void 0 !== r2)
        for (let i4 = 0, s2 = r2.count; i4 < s2; i4++)
          e4.isMesh ? e4.getVertexPosition(i4, o2) : o2.fromBufferAttribute(r2, i4), e4.isSkinnedMesh || o2.applyMatrix4(e4.matrixWorld), n2 = t2(n2, o2);
    }
  }), n2;
}
const dd = { POSITION: ["byte", "byte normalized", "unsigned byte", "unsigned byte normalized", "short", "short normalized", "unsigned short", "unsigned short normalized"], NORMAL: ["byte normalized", "short normalized"], TANGENT: ["byte normalized", "short normalized"], TEXCOORD: ["byte", "byte normalized", "unsigned byte", "short", "short normalized", "unsigned short"] };
class pd {
  constructor() {
    this.pluginCallbacks = [], this.register(function(e3) {
      return new qd(e3);
    }), this.register(function(e3) {
      return new jd(e3);
    }), this.register(function(e3) {
      return new Kd(e3);
    }), this.register(function(e3) {
      return new Zd(e3);
    }), this.register(function(e3) {
      return new Jd(e3);
    }), this.register(function(e3) {
      return new ep(e3);
    }), this.register(function(e3) {
      return new Xd(e3);
    }), this.register(function(e3) {
      return new Yd(e3);
    }), this.register(function(e3) {
      return new tp(e3);
    }), this.register(function(e3) {
      return new ip(e3);
    });
  }
  register(e3) {
    return -1 === this.pluginCallbacks.indexOf(e3) && this.pluginCallbacks.push(e3), this;
  }
  unregister(e3) {
    return -1 !== this.pluginCallbacks.indexOf(e3) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e3), 1), this;
  }
  parse(e3, t2, i2, n2) {
    const o2 = new Wd(), r2 = [];
    for (let e4 = 0, t3 = this.pluginCallbacks.length; e4 < t3; e4++)
      r2.push(this.pluginCallbacks[e4](o2));
    o2.setPlugins(r2), o2.write(e3, t2, n2).catch(i2);
  }
  parseAsync(e3, t2) {
    const i2 = this;
    return new Promise(function(n2, o2) {
      i2.parse(e3, n2, o2, t2);
    });
  }
}
const _d = 0, gd = 1, md = 2, fd = 3, vd = 4, Ad = 5120, bd = 5121, yd = 5122, wd = 5123, xd = 5124, Cd = 5125, Sd = 5126, Ed = 34962, Id = 34963, Td = 9728, Bd = 9729, Md = 9984, kd = 9985, Rd = 9986, Pd = 9987, Dd = 33071, Ld = 33648, Fd = 10497, Nd = "KHR_mesh_quantization", Od = {};
Od[1003] = Td, Od[1004] = Md, Od[1005] = Rd, Od[1006] = Bd, Od[1007] = kd, Od[1008] = Pd, Od[1001] = Dd, Od[1e3] = Fd, Od[1002] = Ld;
const zd = { scale: "scale", position: "translation", quaternion: "rotation", morphTargetInfluences: "weights" }, Ud = new Pn();
function Hd(e3, t2) {
  return e3.length === t2.length && e3.every(function(e4, i2) {
    return e4 === t2[i2];
  });
}
function Qd(e3) {
  return 4 * Math.ceil(e3 / 4);
}
function Vd(e3, t2 = 0) {
  const i2 = Qd(e3.byteLength);
  if (i2 !== e3.byteLength) {
    const n2 = new Uint8Array(i2);
    if (n2.set(new Uint8Array(e3)), 0 !== t2)
      for (let o2 = e3.byteLength; o2 < i2; o2++)
        n2[o2] = t2;
    return n2.buffer;
  }
  return e3;
}
function Gd() {
  return "undefined" == typeof document && "undefined" != typeof OffscreenCanvas ? new OffscreenCanvas(1, 1) : document.createElement("canvas");
}
function $d(e3, t2) {
  if (void 0 !== e3.toBlob)
    return new Promise((i3) => e3.toBlob(i3, t2));
  let i2;
  return "image/jpeg" === t2 ? i2 = 0.92 : "image/webp" === t2 && (i2 = 0.8), e3.convertToBlob({ type: t2, quality: i2 });
}
class Wd {
  constructor() {
    this.plugins = [], this.options = {}, this.pending = [], this.buffers = [], this.byteOffset = 0, this.buffers = [], this.nodeMap = /* @__PURE__ */ new Map(), this.skins = [], this.extensionsUsed = {}, this.extensionsRequired = {}, this.uids = /* @__PURE__ */ new Map(), this.uid = 0, this.json = { asset: { version: "2.0", generator: "THREE.GLTFExporter" } }, this.cache = { meshes: /* @__PURE__ */ new Map(), attributes: /* @__PURE__ */ new Map(), attributesNormalized: /* @__PURE__ */ new Map(), materials: /* @__PURE__ */ new Map(), textures: /* @__PURE__ */ new Map(), images: /* @__PURE__ */ new Map() };
  }
  setPlugins(e3) {
    this.plugins = e3;
  }
  async write(e3, t2, i2 = {}) {
    this.options = Object.assign({ binary: false, trs: false, onlyVisible: true, maxTextureSize: 1 / 0, animations: [], includeCustomExtensions: false }, i2), this.options.animations.length > 0 && (this.options.trs = true), this.processInput(e3), await Promise.all(this.pending);
    const n2 = this, o2 = n2.buffers, r2 = n2.json;
    i2 = n2.options;
    const s2 = n2.extensionsUsed, a2 = n2.extensionsRequired, l2 = new Blob(o2, { type: "application/octet-stream" }), c2 = Object.keys(s2), h2 = Object.keys(a2);
    if (c2.length > 0 && (r2.extensionsUsed = c2), h2.length > 0 && (r2.extensionsRequired = h2), r2.buffers && r2.buffers.length > 0 && (r2.buffers[0].byteLength = l2.size), true === i2.binary) {
      const e4 = new FileReader();
      e4.readAsArrayBuffer(l2), e4.onloadend = function() {
        const i3 = Vd(e4.result), n3 = new DataView(new ArrayBuffer(8));
        n3.setUint32(0, i3.byteLength, true), n3.setUint32(4, 5130562, true);
        const o3 = Vd((s3 = JSON.stringify(r2), new TextEncoder().encode(s3).buffer), 32);
        var s3;
        const a3 = new DataView(new ArrayBuffer(8));
        a3.setUint32(0, o3.byteLength, true), a3.setUint32(4, 1313821514, true);
        const l3 = new ArrayBuffer(12), c3 = new DataView(l3);
        c3.setUint32(0, 1179937895, true), c3.setUint32(4, 2, true);
        const h3 = 12 + a3.byteLength + o3.byteLength + n3.byteLength + i3.byteLength;
        c3.setUint32(8, h3, true);
        const u2 = new Blob([l3, a3, o3, n3, i3], { type: "application/octet-stream" }), d2 = new FileReader();
        d2.readAsArrayBuffer(u2), d2.onloadend = function() {
          t2(d2.result);
        };
      };
    } else if (r2.buffers && r2.buffers.length > 0) {
      const e4 = new FileReader();
      e4.readAsDataURL(l2), e4.onloadend = function() {
        const i3 = e4.result;
        r2.buffers[0].uri = i3, t2(r2);
      };
    } else
      t2(r2);
  }
  serializeUserData(e3, t2) {
    if (0 === Object.keys(e3.userData).length)
      return;
    const i2 = this.options, n2 = this.extensionsUsed;
    try {
      const o2 = JSON.parse(JSON.stringify(e3.userData));
      if (i2.includeCustomExtensions && o2.gltfExtensions) {
        void 0 === t2.extensions && (t2.extensions = {});
        for (const e4 in o2.gltfExtensions)
          t2.extensions[e4] = o2.gltfExtensions[e4], n2[e4] = true;
        delete o2.gltfExtensions;
      }
      Object.keys(o2).length > 0 && (t2.extras = o2);
    } catch (t3) {
      console.warn("THREE.GLTFExporter: userData of '" + e3.name + "' won't be serialized because of JSON.stringify error - " + t3.message);
    }
  }
  getUID(e3, t2 = false) {
    if (false === this.uids.has(e3)) {
      const t3 = /* @__PURE__ */ new Map();
      t3.set(true, this.uid++), t3.set(false, this.uid++), this.uids.set(e3, t3);
    }
    return this.uids.get(e3).get(t2);
  }
  isNormalizedNormalAttribute(e3) {
    if (this.cache.attributesNormalized.has(e3))
      return false;
    const t2 = new di();
    for (let i2 = 0, n2 = e3.count; i2 < n2; i2++)
      if (Math.abs(t2.fromBufferAttribute(e3, i2).length() - 1) > 5e-4)
        return false;
    return true;
  }
  createNormalizedNormalAttribute(e3) {
    const t2 = this.cache;
    if (t2.attributesNormalized.has(e3))
      return t2.attributesNormalized.get(e3);
    const i2 = e3.clone(), n2 = new di();
    for (let e4 = 0, t3 = i2.count; e4 < t3; e4++)
      n2.fromBufferAttribute(i2, e4), 0 === n2.x && 0 === n2.y && 0 === n2.z ? n2.setX(1) : n2.normalize(), i2.setXYZ(e4, n2.x, n2.y, n2.z);
    return t2.attributesNormalized.set(e3, i2), i2;
  }
  applyTextureTransform(e3, t2) {
    let i2 = false;
    const n2 = {};
    0 === t2.offset.x && 0 === t2.offset.y || (n2.offset = t2.offset.toArray(), i2 = true), 0 !== t2.rotation && (n2.rotation = t2.rotation, i2 = true), 1 === t2.repeat.x && 1 === t2.repeat.y || (n2.scale = t2.repeat.toArray(), i2 = true), i2 && (e3.extensions = e3.extensions || {}, e3.extensions.KHR_texture_transform = n2, this.extensionsUsed.KHR_texture_transform = true);
  }
  buildMetalRoughTexture(e3, t2) {
    if (e3 === t2)
      return e3;
    function i2(e4) {
      return e4.encoding === bt ? function(e5) {
        return e5 < 0.04045 ? 0.0773993808 * e5 : Math.pow(0.9478672986 * e5 + 0.0521327014, 2.4);
      } : function(e5) {
        return e5;
      };
    }
    console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.");
    const n2 = e3 ? e3.image : null, o2 = t2 ? t2.image : null, r2 = Math.max(n2 ? n2.width : 0, o2 ? o2.width : 0), s2 = Math.max(n2 ? n2.height : 0, o2 ? o2.height : 0), a2 = Gd();
    a2.width = r2, a2.height = s2;
    const l2 = a2.getContext("2d");
    l2.fillStyle = "#00ffff", l2.fillRect(0, 0, r2, s2);
    const c2 = l2.getImageData(0, 0, r2, s2);
    if (n2) {
      l2.drawImage(n2, 0, 0, r2, s2);
      const t3 = i2(e3), o3 = l2.getImageData(0, 0, r2, s2).data;
      for (let e4 = 2; e4 < o3.length; e4 += 4)
        c2.data[e4] = 256 * t3(o3[e4] / 256);
    }
    if (o2) {
      l2.drawImage(o2, 0, 0, r2, s2);
      const e4 = i2(t2), n3 = l2.getImageData(0, 0, r2, s2).data;
      for (let t3 = 1; t3 < n3.length; t3 += 4)
        c2.data[t3] = 256 * e4(n3[t3] / 256);
    }
    l2.putImageData(c2, 0, 0);
    const h2 = (e3 || t2).clone();
    return h2.source = new ni(a2), h2.encoding = At, h2;
  }
  processBuffer(e3) {
    const t2 = this.json, i2 = this.buffers;
    return t2.buffers || (t2.buffers = [{ byteLength: 0 }]), i2.push(e3), 0;
  }
  processBufferView(e3, t2, i2, n2, o2) {
    const r2 = this.json;
    let s2;
    switch (r2.bufferViews || (r2.bufferViews = []), t2) {
      case Ad:
      case bd:
        s2 = 1;
        break;
      case yd:
      case wd:
        s2 = 2;
        break;
      default:
        s2 = 4;
    }
    const a2 = Qd(n2 * e3.itemSize * s2), l2 = new DataView(new ArrayBuffer(a2));
    let c2 = 0;
    for (let o3 = i2; o3 < i2 + n2; o3++)
      for (let i3 = 0; i3 < e3.itemSize; i3++) {
        let n3;
        e3.itemSize > 4 ? n3 = e3.array[o3 * e3.itemSize + i3] : (0 === i3 ? n3 = e3.getX(o3) : 1 === i3 ? n3 = e3.getY(o3) : 2 === i3 ? n3 = e3.getZ(o3) : 3 === i3 && (n3 = e3.getW(o3)), true === e3.normalized && (n3 = Qt.normalize(n3, e3.array))), t2 === Sd ? l2.setFloat32(c2, n3, true) : t2 === xd ? l2.setInt32(c2, n3, true) : t2 === Cd ? l2.setUint32(c2, n3, true) : t2 === yd ? l2.setInt16(c2, n3, true) : t2 === wd ? l2.setUint16(c2, n3, true) : t2 === Ad ? l2.setInt8(c2, n3) : t2 === bd && l2.setUint8(c2, n3), c2 += s2;
      }
    const h2 = { buffer: this.processBuffer(l2.buffer), byteOffset: this.byteOffset, byteLength: a2 };
    void 0 !== o2 && (h2.target = o2), o2 === Ed && (h2.byteStride = e3.itemSize * s2), this.byteOffset += a2, r2.bufferViews.push(h2);
    return { id: r2.bufferViews.length - 1, byteLength: 0 };
  }
  processBufferViewImage(e3) {
    const t2 = this, i2 = t2.json;
    return i2.bufferViews || (i2.bufferViews = []), new Promise(function(n2) {
      const o2 = new FileReader();
      o2.readAsArrayBuffer(e3), o2.onloadend = function() {
        const e4 = Vd(o2.result), r2 = { buffer: t2.processBuffer(e4), byteOffset: t2.byteOffset, byteLength: e4.byteLength };
        t2.byteOffset += e4.byteLength, n2(i2.bufferViews.push(r2) - 1);
      };
    });
  }
  processAccessor(e3, t2, i2, n2) {
    const o2 = this.json;
    let r2;
    if (e3.array.constructor === Float32Array)
      r2 = Sd;
    else if (e3.array.constructor === Int32Array)
      r2 = xd;
    else if (e3.array.constructor === Uint32Array)
      r2 = Cd;
    else if (e3.array.constructor === Int16Array)
      r2 = yd;
    else if (e3.array.constructor === Uint16Array)
      r2 = wd;
    else if (e3.array.constructor === Int8Array)
      r2 = Ad;
    else {
      if (e3.array.constructor !== Uint8Array)
        throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type.");
      r2 = bd;
    }
    if (void 0 === i2 && (i2 = 0), void 0 === n2 && (n2 = e3.count), 0 === n2)
      return null;
    const s2 = function(e4, t3, i3) {
      const n3 = { min: new Array(e4.itemSize).fill(Number.POSITIVE_INFINITY), max: new Array(e4.itemSize).fill(Number.NEGATIVE_INFINITY) };
      for (let o3 = t3; o3 < t3 + i3; o3++)
        for (let t4 = 0; t4 < e4.itemSize; t4++) {
          let i4;
          e4.itemSize > 4 ? i4 = e4.array[o3 * e4.itemSize + t4] : (0 === t4 ? i4 = e4.getX(o3) : 1 === t4 ? i4 = e4.getY(o3) : 2 === t4 ? i4 = e4.getZ(o3) : 3 === t4 && (i4 = e4.getW(o3)), true === e4.normalized && (i4 = Qt.normalize(i4, e4.array))), n3.min[t4] = Math.min(n3.min[t4], i4), n3.max[t4] = Math.max(n3.max[t4], i4);
        }
      return n3;
    }(e3, i2, n2);
    let a2;
    void 0 !== t2 && (a2 = e3 === t2.index ? Id : Ed);
    const l2 = this.processBufferView(e3, r2, i2, n2, a2), c2 = { bufferView: l2.id, byteOffset: l2.byteOffset, componentType: r2, count: n2, max: s2.max, min: s2.min, type: { 1: "SCALAR", 2: "VEC2", 3: "VEC3", 4: "VEC4", 9: "MAT3", 16: "MAT4" }[e3.itemSize] };
    return true === e3.normalized && (c2.normalized = true), o2.accessors || (o2.accessors = []), o2.accessors.push(c2) - 1;
  }
  processImage(e3, t2, i2, n2 = "image/png") {
    if (null !== e3) {
      const o2 = this, r2 = o2.cache, s2 = o2.json, a2 = o2.options, l2 = o2.pending;
      r2.images.has(e3) || r2.images.set(e3, {});
      const c2 = r2.images.get(e3), h2 = n2 + ":flipY/" + i2.toString();
      if (void 0 !== c2[h2])
        return c2[h2];
      s2.images || (s2.images = []);
      const u2 = { mimeType: n2 }, d2 = Gd();
      d2.width = Math.min(e3.width, a2.maxTextureSize), d2.height = Math.min(e3.height, a2.maxTextureSize);
      const p2 = d2.getContext("2d");
      if (true === i2 && (p2.translate(0, d2.height), p2.scale(1, -1)), void 0 !== e3.data) {
        t2 !== Xe && console.error("GLTFExporter: Only RGBAFormat is supported."), (e3.width > a2.maxTextureSize || e3.height > a2.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", e3);
        const i3 = new Uint8ClampedArray(e3.height * e3.width * 4);
        for (let t3 = 0; t3 < i3.length; t3 += 4)
          i3[t3 + 0] = e3.data[t3 + 0], i3[t3 + 1] = e3.data[t3 + 1], i3[t3 + 2] = e3.data[t3 + 2], i3[t3 + 3] = e3.data[t3 + 3];
        p2.putImageData(new ImageData(i3, e3.width, e3.height), 0, 0);
      } else
        p2.drawImage(e3, 0, 0, d2.width, d2.height);
      true === a2.binary ? l2.push($d(d2, n2).then((e4) => o2.processBufferViewImage(e4)).then((e4) => {
        u2.bufferView = e4;
      })) : void 0 !== d2.toDataURL ? u2.uri = d2.toDataURL(n2) : l2.push($d(d2, n2).then((e4) => new FileReader().readAsDataURL(e4)).then((e4) => {
        u2.uri = e4;
      }));
      const _2 = s2.images.push(u2) - 1;
      return c2[h2] = _2, _2;
    }
    throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.");
  }
  processSampler(e3) {
    const t2 = this.json;
    t2.samplers || (t2.samplers = []);
    const i2 = { magFilter: Od[e3.magFilter], minFilter: Od[e3.minFilter], wrapS: Od[e3.wrapS], wrapT: Od[e3.wrapT] };
    return t2.samplers.push(i2) - 1;
  }
  processTexture(e3) {
    const t2 = this.cache, i2 = this.json;
    if (t2.textures.has(e3))
      return t2.textures.get(e3);
    i2.textures || (i2.textures = []);
    let n2 = e3.userData.mimeType;
    "image/webp" === n2 && (n2 = "image/png");
    const o2 = { sampler: this.processSampler(e3), source: this.processImage(e3.image, e3.format, e3.flipY, n2) };
    e3.name && (o2.name = e3.name), this._invokeAll(function(t3) {
      t3.writeTexture && t3.writeTexture(e3, o2);
    });
    const r2 = i2.textures.push(o2) - 1;
    return t2.textures.set(e3, r2), r2;
  }
  processMaterial(e3) {
    const t2 = this.cache, i2 = this.json;
    if (t2.materials.has(e3))
      return t2.materials.get(e3);
    if (e3.isShaderMaterial)
      return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."), null;
    i2.materials || (i2.materials = []);
    const n2 = { pbrMetallicRoughness: {} };
    true !== e3.isMeshStandardMaterial && true !== e3.isMeshBasicMaterial && console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
    const o2 = e3.color.toArray().concat([e3.opacity]);
    if (Hd(o2, [1, 1, 1, 1]) || (n2.pbrMetallicRoughness.baseColorFactor = o2), e3.isMeshStandardMaterial ? (n2.pbrMetallicRoughness.metallicFactor = e3.metalness, n2.pbrMetallicRoughness.roughnessFactor = e3.roughness) : (n2.pbrMetallicRoughness.metallicFactor = 0.5, n2.pbrMetallicRoughness.roughnessFactor = 0.5), e3.metalnessMap || e3.roughnessMap) {
      const t3 = this.buildMetalRoughTexture(e3.metalnessMap, e3.roughnessMap), i3 = { index: this.processTexture(t3) };
      this.applyTextureTransform(i3, t3), n2.pbrMetallicRoughness.metallicRoughnessTexture = i3;
    }
    if (e3.map) {
      const t3 = { index: this.processTexture(e3.map) };
      this.applyTextureTransform(t3, e3.map), n2.pbrMetallicRoughness.baseColorTexture = t3;
    }
    if (e3.emissive) {
      const t3 = e3.emissive;
      if (Math.max(t3.r, t3.g, t3.b) > 0 && (n2.emissiveFactor = e3.emissive.toArray()), e3.emissiveMap) {
        const t4 = { index: this.processTexture(e3.emissiveMap) };
        this.applyTextureTransform(t4, e3.emissiveMap), n2.emissiveTexture = t4;
      }
    }
    if (e3.normalMap) {
      const t3 = { index: this.processTexture(e3.normalMap) };
      e3.normalScale && 1 !== e3.normalScale.x && (t3.scale = e3.normalScale.x), this.applyTextureTransform(t3, e3.normalMap), n2.normalTexture = t3;
    }
    if (e3.aoMap) {
      const t3 = { index: this.processTexture(e3.aoMap), texCoord: 1 };
      1 !== e3.aoMapIntensity && (t3.strength = e3.aoMapIntensity), this.applyTextureTransform(t3, e3.aoMap), n2.occlusionTexture = t3;
    }
    e3.transparent ? n2.alphaMode = "BLEND" : e3.alphaTest > 0 && (n2.alphaMode = "MASK", n2.alphaCutoff = e3.alphaTest), e3.side === be && (n2.doubleSided = true), "" !== e3.name && (n2.name = e3.name), this.serializeUserData(e3, n2), this._invokeAll(function(t3) {
      t3.writeMaterial && t3.writeMaterial(e3, n2);
    });
    const r2 = i2.materials.push(n2) - 1;
    return t2.materials.set(e3, r2), r2;
  }
  processMesh(e3) {
    const t2 = this.cache, i2 = this.json, n2 = [e3.geometry.uuid];
    if (Array.isArray(e3.material))
      for (let t3 = 0, i3 = e3.material.length; t3 < i3; t3++)
        n2.push(e3.material[t3].uuid);
    else
      n2.push(e3.material.uuid);
    const o2 = n2.join(":");
    if (t2.meshes.has(o2))
      return t2.meshes.get(o2);
    const r2 = e3.geometry;
    let s2;
    s2 = e3.isLineSegments ? gd : e3.isLineLoop ? md : e3.isLine ? fd : e3.isPoints ? _d : e3.material.wireframe ? gd : vd;
    const a2 = {}, l2 = {}, c2 = [], h2 = [], u2 = { uv: "TEXCOORD_0", uv2: "TEXCOORD_1", color: "COLOR_0", skinWeight: "WEIGHTS_0", skinIndex: "JOINTS_0" }, d2 = r2.getAttribute("normal");
    void 0 === d2 || this.isNormalizedNormalAttribute(d2) || (console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."), r2.setAttribute("normal", this.createNormalizedNormalAttribute(d2)));
    let p2 = null;
    for (let e4 in r2.attributes) {
      if ("morph" === e4.slice(0, 5))
        continue;
      const i3 = r2.attributes[e4];
      e4 = u2[e4] || e4.toUpperCase();
      if (/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(e4) || (e4 = "_" + e4), t2.attributes.has(this.getUID(i3))) {
        l2[e4] = t2.attributes.get(this.getUID(i3));
        continue;
      }
      p2 = null;
      const n3 = i3.array;
      "JOINTS_0" !== e4 || n3 instanceof Uint16Array || n3 instanceof Uint8Array || (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'), p2 = new Hn(new Uint16Array(n3), i3.itemSize, i3.normalized));
      const o3 = this.processAccessor(p2 || i3, r2);
      null !== o3 && (e4.startsWith("_") || this.detectMeshQuantization(e4, i3), l2[e4] = o3, t2.attributes.set(this.getUID(i3), o3));
    }
    if (void 0 !== d2 && r2.setAttribute("normal", d2), 0 === Object.keys(l2).length)
      return null;
    if (void 0 !== e3.morphTargetInfluences && e3.morphTargetInfluences.length > 0) {
      const i3 = [], n3 = [], o3 = {};
      if (void 0 !== e3.morphTargetDictionary)
        for (const t3 in e3.morphTargetDictionary)
          o3[e3.morphTargetDictionary[t3]] = t3;
      for (let s3 = 0; s3 < e3.morphTargetInfluences.length; ++s3) {
        const a3 = {};
        let l3 = false;
        for (const e4 in r2.morphAttributes) {
          if ("position" !== e4 && "normal" !== e4) {
            l3 || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."), l3 = true);
            continue;
          }
          const i4 = r2.morphAttributes[e4][s3], n4 = e4.toUpperCase(), o4 = r2.attributes[e4];
          if (t2.attributes.has(this.getUID(i4, true))) {
            a3[n4] = t2.attributes.get(this.getUID(i4, true));
            continue;
          }
          const c3 = i4.clone();
          if (!r2.morphTargetsRelative)
            for (let e5 = 0, t3 = i4.count; e5 < t3; e5++)
              for (let t4 = 0; t4 < i4.itemSize; t4++)
                0 === t4 && c3.setX(e5, i4.getX(e5) - o4.getX(e5)), 1 === t4 && c3.setY(e5, i4.getY(e5) - o4.getY(e5)), 2 === t4 && c3.setZ(e5, i4.getZ(e5) - o4.getZ(e5)), 3 === t4 && c3.setW(e5, i4.getW(e5) - o4.getW(e5));
          a3[n4] = this.processAccessor(c3, r2), t2.attributes.set(this.getUID(o4, true), a3[n4]);
        }
        h2.push(a3), i3.push(e3.morphTargetInfluences[s3]), void 0 !== e3.morphTargetDictionary && n3.push(o3[s3]);
      }
      a2.weights = i3, n3.length > 0 && (a2.extras = {}, a2.extras.targetNames = n3);
    }
    const _2 = Array.isArray(e3.material);
    if (_2 && 0 === r2.groups.length)
      return null;
    const g2 = _2 ? e3.material : [e3.material], m2 = _2 ? r2.groups : [{ materialIndex: 0, start: void 0, count: void 0 }];
    for (let e4 = 0, i3 = m2.length; e4 < i3; e4++) {
      const i4 = { mode: s2, attributes: l2 };
      if (this.serializeUserData(r2, i4), h2.length > 0 && (i4.targets = h2), null !== r2.index) {
        let n4 = this.getUID(r2.index);
        void 0 === m2[e4].start && void 0 === m2[e4].count || (n4 += ":" + m2[e4].start + ":" + m2[e4].count), t2.attributes.has(n4) ? i4.indices = t2.attributes.get(n4) : (i4.indices = this.processAccessor(r2.index, r2, m2[e4].start, m2[e4].count), t2.attributes.set(n4, i4.indices)), null === i4.indices && delete i4.indices;
      }
      const n3 = this.processMaterial(g2[m2[e4].materialIndex]);
      null !== n3 && (i4.material = n3), c2.push(i4);
    }
    a2.primitives = c2, i2.meshes || (i2.meshes = []), this._invokeAll(function(t3) {
      t3.writeMesh && t3.writeMesh(e3, a2);
    });
    const f2 = i2.meshes.push(a2) - 1;
    return t2.meshes.set(o2, f2), f2;
  }
  detectMeshQuantization(e3, t2) {
    if (this.extensionsUsed[Nd])
      return;
    let i2;
    switch (t2.array.constructor) {
      case Int8Array:
        i2 = "byte";
        break;
      case Uint8Array:
        i2 = "unsigned byte";
        break;
      case Int16Array:
        i2 = "short";
        break;
      case Uint16Array:
        i2 = "unsigned short";
        break;
      default:
        return;
    }
    t2.normalized && (i2 += " normalized");
    const n2 = e3.split("_", 1)[0];
    dd[n2] && dd[n2].includes(i2) && (this.extensionsUsed[Nd] = true, this.extensionsRequired[Nd] = true);
  }
  processCamera(e3) {
    const t2 = this.json;
    t2.cameras || (t2.cameras = []);
    const i2 = e3.isOrthographicCamera, n2 = { type: i2 ? "orthographic" : "perspective" };
    return i2 ? n2.orthographic = { xmag: 2 * e3.right, ymag: 2 * e3.top, zfar: e3.far <= 0 ? 1e-3 : e3.far, znear: e3.near < 0 ? 0 : e3.near } : n2.perspective = { aspectRatio: e3.aspect, yfov: Qt.degToRad(e3.fov), zfar: e3.far <= 0 ? 1e-3 : e3.far, znear: e3.near < 0 ? 0 : e3.near }, "" !== e3.name && (n2.name = e3.type), t2.cameras.push(n2) - 1;
  }
  processAnimation(e3, t2) {
    const i2 = this.json, n2 = this.nodeMap;
    i2.animations || (i2.animations = []);
    const o2 = (e3 = pd.Utils.mergeMorphTargetTracks(e3.clone(), t2)).tracks, r2 = [], s2 = [];
    for (let e4 = 0; e4 < o2.length; ++e4) {
      const i3 = o2[e4], a2 = Rc.parseTrackName(i3.name);
      let l2 = Rc.findNode(t2, a2.nodeName);
      const c2 = zd[a2.propertyName];
      if ("bones" === a2.objectName && (l2 = true === l2.isSkinnedMesh ? l2.skeleton.getBoneByName(a2.objectIndex) : void 0), !l2 || !c2)
        return console.warn('THREE.GLTFExporter: Could not export animation track "%s".', i3.name), null;
      const h2 = 1;
      let u2, d2 = i3.values.length / i3.times.length;
      c2 === zd.morphTargetInfluences && (d2 /= l2.morphTargetInfluences.length), true === i3.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ? (u2 = "CUBICSPLINE", d2 /= 3) : u2 = i3.getInterpolation() === dt ? "STEP" : "LINEAR", s2.push({ input: this.processAccessor(new Hn(i3.times, h2)), output: this.processAccessor(new Hn(i3.values, d2)), interpolation: u2 }), r2.push({ sampler: s2.length - 1, target: { node: n2.get(l2), path: c2 } });
    }
    return i2.animations.push({ name: e3.name || "clip_" + i2.animations.length, samplers: s2, channels: r2 }), i2.animations.length - 1;
  }
  processSkin(e3) {
    const t2 = this.json, i2 = this.nodeMap, n2 = t2.nodes[i2.get(e3)], o2 = e3.skeleton;
    if (void 0 === o2)
      return null;
    const r2 = e3.skeleton.bones[0];
    if (void 0 === r2)
      return null;
    const s2 = [], a2 = new Float32Array(16 * o2.bones.length), l2 = new Qi();
    for (let t3 = 0; t3 < o2.bones.length; ++t3)
      s2.push(i2.get(o2.bones[t3])), l2.copy(o2.boneInverses[t3]), l2.multiply(e3.bindMatrix).toArray(a2, 16 * t3);
    void 0 === t2.skins && (t2.skins = []), t2.skins.push({ inverseBindMatrices: this.processAccessor(new Hn(a2, 16)), joints: s2, skeleton: i2.get(r2) });
    return n2.skin = t2.skins.length - 1;
  }
  processNode(e3) {
    const t2 = this.json, i2 = this.options, n2 = this.nodeMap;
    t2.nodes || (t2.nodes = []);
    const o2 = {};
    if (i2.trs) {
      const t3 = e3.quaternion.toArray(), i3 = e3.position.toArray(), n3 = e3.scale.toArray();
      Hd(t3, [0, 0, 0, 1]) || (o2.rotation = t3), Hd(i3, [0, 0, 0]) || (o2.translation = i3), Hd(n3, [1, 1, 1]) || (o2.scale = n3);
    } else
      e3.matrixAutoUpdate && e3.updateMatrix(), false === Hd(e3.matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) && (o2.matrix = e3.matrix.elements);
    if ("" !== e3.name && (o2.name = String(e3.name)), this.serializeUserData(e3, o2), e3.isMesh || e3.isLine || e3.isPoints) {
      const t3 = this.processMesh(e3);
      null !== t3 && (o2.mesh = t3);
    } else
      e3.isCamera && (o2.camera = this.processCamera(e3));
    if (e3.isSkinnedMesh && this.skins.push(e3), e3.children.length > 0) {
      const t3 = [];
      for (let n3 = 0, o3 = e3.children.length; n3 < o3; n3++) {
        const o4 = e3.children[n3];
        if (o4.visible || false === i2.onlyVisible) {
          const e4 = this.processNode(o4);
          null !== e4 && t3.push(e4);
        }
      }
      t3.length > 0 && (o2.children = t3);
    }
    this._invokeAll(function(t3) {
      t3.writeNode && t3.writeNode(e3, o2);
    });
    const r2 = t2.nodes.push(o2) - 1;
    return n2.set(e3, r2), r2;
  }
  processScene(e3) {
    const t2 = this.json, i2 = this.options;
    t2.scenes || (t2.scenes = [], t2.scene = 0);
    const n2 = {};
    "" !== e3.name && (n2.name = e3.name), t2.scenes.push(n2);
    const o2 = [];
    for (let t3 = 0, n3 = e3.children.length; t3 < n3; t3++) {
      const n4 = e3.children[t3];
      if (n4.visible || false === i2.onlyVisible) {
        const e4 = this.processNode(n4);
        null !== e4 && o2.push(e4);
      }
    }
    o2.length > 0 && (n2.nodes = o2), this.serializeUserData(e3, n2);
  }
  processObjects(e3) {
    const t2 = new va();
    t2.name = "AuxScene";
    for (let i2 = 0; i2 < e3.length; i2++)
      t2.children.push(e3[i2]);
    this.processScene(t2);
  }
  processInput(e3) {
    const t2 = this.options;
    e3 = e3 instanceof Array ? e3 : [e3], this._invokeAll(function(t3) {
      t3.beforeParse && t3.beforeParse(e3);
    });
    const i2 = [];
    for (let t3 = 0; t3 < e3.length; t3++)
      e3[t3] instanceof va ? this.processScene(e3[t3]) : i2.push(e3[t3]);
    i2.length > 0 && this.processObjects(i2);
    for (let e4 = 0; e4 < this.skins.length; ++e4)
      this.processSkin(this.skins[e4]);
    for (let i3 = 0; i3 < t2.animations.length; ++i3)
      this.processAnimation(t2.animations[i3], e3[0]);
    this._invokeAll(function(t3) {
      t3.afterParse && t3.afterParse(e3);
    });
  }
  _invokeAll(e3) {
    for (let t2 = 0, i2 = this.plugins.length; t2 < i2; t2++)
      e3(this.plugins[t2]);
  }
}
class qd {
  constructor(e3) {
    this.writer = e3, this.name = "KHR_lights_punctual";
  }
  writeNode(e3, t2) {
    if (!e3.isLight)
      return;
    if (!e3.isDirectionalLight && !e3.isPointLight && !e3.isSpotLight)
      return void console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", e3);
    const i2 = this.writer, n2 = i2.json, o2 = i2.extensionsUsed, r2 = {};
    e3.name && (r2.name = e3.name), r2.color = e3.color.toArray(), r2.intensity = e3.intensity, e3.isDirectionalLight ? r2.type = "directional" : e3.isPointLight ? (r2.type = "point", e3.distance > 0 && (r2.range = e3.distance)) : e3.isSpotLight && (r2.type = "spot", e3.distance > 0 && (r2.range = e3.distance), r2.spot = {}, r2.spot.innerConeAngle = (e3.penumbra - 1) * e3.angle * -1, r2.spot.outerConeAngle = e3.angle), void 0 !== e3.decay && 2 !== e3.decay && console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."), !e3.target || e3.target.parent === e3 && 0 === e3.target.position.x && 0 === e3.target.position.y && -1 === e3.target.position.z || console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."), o2[this.name] || (n2.extensions = n2.extensions || {}, n2.extensions[this.name] = { lights: [] }, o2[this.name] = true);
    const s2 = n2.extensions[this.name].lights;
    s2.push(r2), t2.extensions = t2.extensions || {}, t2.extensions[this.name] = { light: s2.length - 1 };
  }
}
class jd {
  constructor(e3) {
    this.writer = e3, this.name = "KHR_materials_unlit";
  }
  writeMaterial(e3, t2) {
    if (!e3.isMeshBasicMaterial)
      return;
    const i2 = this.writer.extensionsUsed;
    t2.extensions = t2.extensions || {}, t2.extensions[this.name] = {}, i2[this.name] = true, t2.pbrMetallicRoughness.metallicFactor = 0, t2.pbrMetallicRoughness.roughnessFactor = 0.9;
  }
}
class Xd {
  constructor(e3) {
    this.writer = e3, this.name = "KHR_materials_clearcoat";
  }
  writeMaterial(e3, t2) {
    if (!e3.isMeshPhysicalMaterial || 0 === e3.clearcoat)
      return;
    const i2 = this.writer, n2 = i2.extensionsUsed, o2 = {};
    if (o2.clearcoatFactor = e3.clearcoat, e3.clearcoatMap) {
      const t3 = { index: i2.processTexture(e3.clearcoatMap) };
      i2.applyTextureTransform(t3, e3.clearcoatMap), o2.clearcoatTexture = t3;
    }
    if (o2.clearcoatRoughnessFactor = e3.clearcoatRoughness, e3.clearcoatRoughnessMap) {
      const t3 = { index: i2.processTexture(e3.clearcoatRoughnessMap) };
      i2.applyTextureTransform(t3, e3.clearcoatRoughnessMap), o2.clearcoatRoughnessTexture = t3;
    }
    if (e3.clearcoatNormalMap) {
      const t3 = { index: i2.processTexture(e3.clearcoatNormalMap) };
      i2.applyTextureTransform(t3, e3.clearcoatNormalMap), o2.clearcoatNormalTexture = t3;
    }
    t2.extensions = t2.extensions || {}, t2.extensions[this.name] = o2, n2[this.name] = true;
  }
}
class Yd {
  constructor(e3) {
    this.writer = e3, this.name = "KHR_materials_iridescence";
  }
  writeMaterial(e3, t2) {
    if (!e3.isMeshPhysicalMaterial || 0 === e3.iridescence)
      return;
    const i2 = this.writer, n2 = i2.extensionsUsed, o2 = {};
    if (o2.iridescenceFactor = e3.iridescence, e3.iridescenceMap) {
      const t3 = { index: i2.processTexture(e3.iridescenceMap) };
      i2.applyTextureTransform(t3, e3.iridescenceMap), o2.iridescenceTexture = t3;
    }
    if (o2.iridescenceIor = e3.iridescenceIOR, o2.iridescenceThicknessMinimum = e3.iridescenceThicknessRange[0], o2.iridescenceThicknessMaximum = e3.iridescenceThicknessRange[1], e3.iridescenceThicknessMap) {
      const t3 = { index: i2.processTexture(e3.iridescenceThicknessMap) };
      i2.applyTextureTransform(t3, e3.iridescenceThicknessMap), o2.iridescenceThicknessTexture = t3;
    }
    t2.extensions = t2.extensions || {}, t2.extensions[this.name] = o2, n2[this.name] = true;
  }
}
class Kd {
  constructor(e3) {
    this.writer = e3, this.name = "KHR_materials_transmission";
  }
  writeMaterial(e3, t2) {
    if (!e3.isMeshPhysicalMaterial || 0 === e3.transmission)
      return;
    const i2 = this.writer, n2 = i2.extensionsUsed, o2 = {};
    if (o2.transmissionFactor = e3.transmission, e3.transmissionMap) {
      const t3 = { index: i2.processTexture(e3.transmissionMap) };
      i2.applyTextureTransform(t3, e3.transmissionMap), o2.transmissionTexture = t3;
    }
    t2.extensions = t2.extensions || {}, t2.extensions[this.name] = o2, n2[this.name] = true;
  }
}
class Zd {
  constructor(e3) {
    this.writer = e3, this.name = "KHR_materials_volume";
  }
  writeMaterial(e3, t2) {
    if (!e3.isMeshPhysicalMaterial || 0 === e3.transmission)
      return;
    const i2 = this.writer, n2 = i2.extensionsUsed, o2 = {};
    if (o2.thicknessFactor = e3.thickness, e3.thicknessMap) {
      const t3 = { index: i2.processTexture(e3.thicknessMap) };
      i2.applyTextureTransform(t3, e3.thicknessMap), o2.thicknessTexture = t3;
    }
    o2.attenuationDistance = e3.attenuationDistance, o2.attenuationColor = e3.attenuationColor.toArray(), t2.extensions = t2.extensions || {}, t2.extensions[this.name] = o2, n2[this.name] = true;
  }
}
class Jd {
  constructor(e3) {
    this.writer = e3, this.name = "KHR_materials_ior";
  }
  writeMaterial(e3, t2) {
    if (!e3.isMeshPhysicalMaterial || 1.5 === e3.ior)
      return;
    const i2 = this.writer.extensionsUsed, n2 = {};
    n2.ior = e3.ior, t2.extensions = t2.extensions || {}, t2.extensions[this.name] = n2, i2[this.name] = true;
  }
}
class ep {
  constructor(e3) {
    this.writer = e3, this.name = "KHR_materials_specular";
  }
  writeMaterial(e3, t2) {
    if (!e3.isMeshPhysicalMaterial || 1 === e3.specularIntensity && e3.specularColor.equals(Ud) && !e3.specularIntensityMap && !e3.specularColorTexture)
      return;
    const i2 = this.writer, n2 = i2.extensionsUsed, o2 = {};
    if (e3.specularIntensityMap) {
      const t3 = { index: i2.processTexture(e3.specularIntensityMap) };
      i2.applyTextureTransform(t3, e3.specularIntensityMap), o2.specularTexture = t3;
    }
    if (e3.specularColorMap) {
      const t3 = { index: i2.processTexture(e3.specularColorMap) };
      i2.applyTextureTransform(t3, e3.specularColorMap), o2.specularColorTexture = t3;
    }
    o2.specularFactor = e3.specularIntensity, o2.specularColorFactor = e3.specularColor.toArray(), t2.extensions = t2.extensions || {}, t2.extensions[this.name] = o2, n2[this.name] = true;
  }
}
class tp {
  constructor(e3) {
    this.writer = e3, this.name = "KHR_materials_sheen";
  }
  writeMaterial(e3, t2) {
    if (!e3.isMeshPhysicalMaterial || 0 == e3.sheen)
      return;
    const i2 = this.writer, n2 = i2.extensionsUsed, o2 = {};
    if (e3.sheenRoughnessMap) {
      const t3 = { index: i2.processTexture(e3.sheenRoughnessMap) };
      i2.applyTextureTransform(t3, e3.sheenRoughnessMap), o2.sheenRoughnessTexture = t3;
    }
    if (e3.sheenColorMap) {
      const t3 = { index: i2.processTexture(e3.sheenColorMap) };
      i2.applyTextureTransform(t3, e3.sheenColorMap), o2.sheenColorTexture = t3;
    }
    o2.sheenRoughnessFactor = e3.sheenRoughness, o2.sheenColorFactor = e3.sheenColor.toArray(), t2.extensions = t2.extensions || {}, t2.extensions[this.name] = o2, n2[this.name] = true;
  }
}
class ip {
  constructor(e3) {
    this.writer = e3, this.name = "KHR_materials_emissive_strength";
  }
  writeMaterial(e3, t2) {
    if (!e3.isMeshStandardMaterial || 1 === e3.emissiveIntensity)
      return;
    const i2 = this.writer.extensionsUsed, n2 = {};
    n2.emissiveStrength = e3.emissiveIntensity, t2.extensions = t2.extensions || {}, t2.extensions[this.name] = n2, i2[this.name] = true;
  }
}
pd.Utils = { insertKeyframe: function(e3, t2) {
  const i2 = 1e-3, n2 = e3.getValueSize(), o2 = new e3.TimeBufferType(e3.times.length + 1), r2 = new e3.ValueBufferType(e3.values.length + n2), s2 = e3.createInterpolant(new e3.ValueBufferType(n2));
  let a2;
  if (0 === e3.times.length) {
    o2[0] = t2;
    for (let e4 = 0; e4 < n2; e4++)
      r2[e4] = 0;
    a2 = 0;
  } else if (t2 < e3.times[0]) {
    if (Math.abs(e3.times[0] - t2) < i2)
      return 0;
    o2[0] = t2, o2.set(e3.times, 1), r2.set(s2.evaluate(t2), 0), r2.set(e3.values, n2), a2 = 0;
  } else if (t2 > e3.times[e3.times.length - 1]) {
    if (Math.abs(e3.times[e3.times.length - 1] - t2) < i2)
      return e3.times.length - 1;
    o2[o2.length - 1] = t2, o2.set(e3.times, 0), r2.set(e3.values, 0), r2.set(s2.evaluate(t2), e3.values.length), a2 = o2.length - 1;
  } else
    for (let l2 = 0; l2 < e3.times.length; l2++) {
      if (Math.abs(e3.times[l2] - t2) < i2)
        return l2;
      if (e3.times[l2] < t2 && e3.times[l2 + 1] > t2) {
        o2.set(e3.times.slice(0, l2 + 1), 0), o2[l2 + 1] = t2, o2.set(e3.times.slice(l2 + 1), l2 + 2), r2.set(e3.values.slice(0, (l2 + 1) * n2), 0), r2.set(s2.evaluate(t2), (l2 + 1) * n2), r2.set(e3.values.slice((l2 + 1) * n2), (l2 + 2) * n2), a2 = l2 + 1;
        break;
      }
    }
  return e3.times = o2, e3.values = r2, a2;
}, mergeMorphTargetTracks: function(e3, t2) {
  const i2 = [], n2 = {}, o2 = e3.tracks;
  for (let e4 = 0; e4 < o2.length; ++e4) {
    let r2 = o2[e4];
    const s2 = Rc.parseTrackName(r2.name), a2 = Rc.findNode(t2, s2.nodeName);
    if ("morphTargetInfluences" !== s2.propertyName || void 0 === s2.propertyIndex) {
      i2.push(r2);
      continue;
    }
    if (r2.createInterpolant !== r2.InterpolantFactoryMethodDiscrete && r2.createInterpolant !== r2.InterpolantFactoryMethodLinear) {
      if (r2.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)
        throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
      console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."), r2 = r2.clone(), r2.setInterpolation(pt);
    }
    const l2 = a2.morphTargetInfluences.length, c2 = a2.morphTargetDictionary[s2.propertyIndex];
    if (void 0 === c2)
      throw new Error("THREE.GLTFExporter: Morph target name not found: " + s2.propertyIndex);
    let h2;
    if (void 0 === n2[a2.uuid]) {
      h2 = r2.clone();
      const e5 = new h2.ValueBufferType(l2 * h2.times.length);
      for (let t3 = 0; t3 < h2.times.length; t3++)
        e5[t3 * l2 + c2] = h2.values[t3];
      h2.name = (s2.nodeName || "") + ".morphTargetInfluences", h2.values = e5, n2[a2.uuid] = h2, i2.push(h2);
      continue;
    }
    const u2 = r2.createInterpolant(new r2.ValueBufferType(1));
    h2 = n2[a2.uuid];
    for (let e5 = 0; e5 < h2.times.length; e5++)
      h2.values[e5 * l2 + c2] = u2.evaluate(h2.times[e5]);
    for (let e5 = 0; e5 < r2.times.length; e5++) {
      const t3 = this.insertKeyframe(h2, r2.times[e5]);
      h2.values[t3 * l2 + c2] = r2.values[e5];
    }
  }
  return e3.tracks = i2, e3;
} };
const np = (e3) => void 0 !== e3.material && e3.userData && e3.userData.variantMaterials && !!Array.from(e3.userData.variantMaterials.values()).filter((e4) => op(e4.material)), op = (e3) => e3 && e3.isMaterial && !Array.isArray(e3);
class rp {
  constructor(e3) {
    this.writer = e3, this.name = "KHR_materials_variants", this.variantNames = [];
  }
  beforeParse(e3) {
    const t2 = /* @__PURE__ */ new Set();
    for (const i2 of e3)
      i2.traverse((e4) => {
        if (!np(e4))
          return;
        const i3 = e4.userData.variantMaterials, n2 = e4.userData.variantData;
        for (const [e5, o2] of n2) {
          const n3 = i3.get(o2.index);
          n3 && op(n3.material) && t2.add(e5);
        }
      });
    t2.forEach((e4) => this.variantNames.push(e4));
  }
  writeMesh(e3, t2) {
    if (!np(e3))
      return;
    const i2 = e3.userData, n2 = i2.variantMaterials, o2 = i2.variantData, r2 = /* @__PURE__ */ new Map(), s2 = /* @__PURE__ */ new Map(), a2 = Array.from(o2.values()).sort((e4, t3) => e4.index - t3.index);
    for (const [e4, t3] of a2.entries())
      s2.set(t3.index, e4);
    for (const e4 of o2.values()) {
      const t3 = n2.get(e4.index);
      if (!t3 || !op(t3.material))
        continue;
      const i3 = this.writer.processMaterial(t3.material);
      r2.has(i3) || r2.set(i3, { material: i3, variants: [] }), r2.get(i3).variants.push(s2.get(e4.index));
    }
    const l2 = Array.from(r2.values()).map((e4) => e4.variants.sort((e5, t3) => e5 - t3) && e4).sort((e4, t3) => e4.material - t3.material);
    if (0 === l2.length)
      return;
    const c2 = op(i2.originalMaterial) ? this.writer.processMaterial(i2.originalMaterial) : -1;
    for (const e4 of t2.primitives)
      c2 >= 0 && (e4.material = c2), e4.extensions = e4.extensions || {}, e4.extensions[this.name] = { mappings: l2 };
  }
  afterParse() {
    if (0 === this.variantNames.length)
      return;
    const e3 = this.writer.json;
    e3.extensions = e3.extensions || {};
    const t2 = this.variantNames.map((e4) => ({ name: e4 }));
    e3.extensions[this.name] = { variants: t2 }, this.writer.extensionsUsed[this.name] = true;
  }
}
class sp {
  constructor(e3, t2, i2, n2, o2) {
    this.xrLight = e3, this.renderer = t2, this.lightProbe = i2, this.xrWebGLBinding = null, this.estimationStartCallback = o2, this.frameCallback = this.onXRFrame.bind(this);
    const r2 = t2.xr.getSession();
    if (n2 && "XRWebGLBinding" in window) {
      const i3 = new Mo(16);
      e3.environment = i3.texture;
      const n3 = t2.getContext();
      switch (r2.preferredReflectionFormat) {
        case "srgba8":
          n3.getExtension("EXT_sRGB");
          break;
        case "rgba16f":
          n3.getExtension("OES_texture_half_float");
      }
      this.xrWebGLBinding = new XRWebGLBinding(r2, n3), this.lightProbe.addEventListener("reflectionchange", () => {
        this.updateReflection();
      });
    }
    r2.requestAnimationFrame(this.frameCallback);
  }
  updateReflection() {
    const e3 = this.renderer.properties.get(this.xrLight.environment);
    if (e3) {
      const t2 = this.xrWebGLBinding.getReflectionCubeMap(this.lightProbe);
      t2 && (e3.__webglTexture = t2, this.xrLight.environment.needsPMREMUpdate = true);
    }
  }
  onXRFrame(e3, t2) {
    if (!this.xrLight)
      return;
    t2.session.requestAnimationFrame(this.frameCallback);
    const i2 = t2.getLightEstimate(this.lightProbe);
    if (i2) {
      this.xrLight.lightProbe.sh.fromArray(i2.sphericalHarmonicsCoefficients), this.xrLight.lightProbe.intensity = 1;
      const e4 = Math.max(1, Math.max(i2.primaryLightIntensity.x, Math.max(i2.primaryLightIntensity.y, i2.primaryLightIntensity.z)));
      this.xrLight.directionalLight.color.setRGB(i2.primaryLightIntensity.x / e4, i2.primaryLightIntensity.y / e4, i2.primaryLightIntensity.z / e4), this.xrLight.directionalLight.intensity = e4, this.xrLight.directionalLight.position.copy(i2.primaryLightDirection), this.estimationStartCallback && (this.estimationStartCallback(), this.estimationStartCallback = null);
    }
  }
  dispose() {
    this.xrLight = null, this.renderer = null, this.lightProbe = null, this.xrWebGLBinding = null;
  }
}
class ap extends ca {
  constructor(e3, t2 = true) {
    super(), this.lightProbe = new wc(), this.lightProbe.intensity = 0, this.add(this.lightProbe), this.directionalLight = new bc(), this.directionalLight.intensity = 0, this.add(this.directionalLight), this.environment = null;
    let i2 = null, n2 = false;
    e3.xr.addEventListener("sessionstart", () => {
      const o2 = e3.xr.getSession();
      "requestLightProbe" in o2 && o2.requestLightProbe({ reflectionFormat: o2.preferredReflectionFormat }).then((o3) => {
        i2 = new sp(this, e3, o3, t2, () => {
          n2 = true, this.dispatchEvent({ type: "estimationstart" });
        });
      });
    }), e3.xr.addEventListener("sessionend", () => {
      i2 && (i2.dispose(), i2 = null), n2 && this.dispatchEvent({ type: "estimationend" });
    }), this.dispose = () => {
      i2 && (i2.dispose(), i2 = null), this.remove(this.lightProbe), this.lightProbe = null, this.remove(this.directionalLight), this.directionalLight = null, this.environment = null;
    };
  }
}
class lp {
  constructor(e3 = 50) {
    this.velocity = 0, this.naturalFrequency = 0, this.setDecayTime(e3);
  }
  setDecayTime(e3) {
    this.naturalFrequency = 1 / Math.max(1e-3, e3);
  }
  update(e3, t2, i2, n2) {
    const o2 = 2e-4 * this.naturalFrequency;
    if (null == e3 || 0 === n2)
      return t2;
    if (e3 === t2 && 0 === this.velocity)
      return t2;
    if (i2 < 0)
      return e3;
    const r2 = e3 - t2, s2 = this.velocity + this.naturalFrequency * r2, a2 = r2 + i2 * s2, l2 = Math.exp(-this.naturalFrequency * i2), c2 = (s2 - this.naturalFrequency * a2) * l2, h2 = -this.naturalFrequency * (c2 + s2 * l2);
    return Math.abs(c2) < o2 * Math.abs(n2) && h2 * r2 >= 0 ? (this.velocity = 0, t2) : (this.velocity = c2, t2 + a2 * l2);
  }
}
const cp = 0.2, hp = Math.PI / 24, up = new Vt(), dp = (e3, t2, i2) => {
  let n2 = t2 > 0 ? i2 > 0 ? 0 : -Math.PI / 2 : i2 > 0 ? Math.PI / 2 : Math.PI;
  for (let o2 = 0; o2 <= 12; ++o2)
    e3.push(t2 + 0.17 * Math.cos(n2), i2 + 0.17 * Math.sin(n2), 0, t2 + cp * Math.cos(n2), i2 + cp * Math.sin(n2), 0), n2 += hp;
};
class pp extends fo {
  constructor(e3, t2) {
    const i2 = new Zn(), n2 = [], o2 = [], { size: r2, boundingBox: s2 } = e3, a2 = r2.x / 2, l2 = ("back" === t2 ? r2.y : r2.z) / 2;
    dp(o2, a2, l2), dp(o2, -a2, l2), dp(o2, -a2, -l2), dp(o2, a2, -l2);
    const c2 = o2.length / 3;
    for (let e4 = 0; e4 < c2 - 2; e4 += 2)
      n2.push(e4, e4 + 1, e4 + 3, e4, e4 + 3, e4 + 2);
    const h2 = c2 - 2;
    n2.push(h2, h2 + 1, 1, h2, 1, 0), i2.setAttribute("position", new Gn(o2, 3)), i2.setIndex(n2), super(i2), this.side = t2;
    const u2 = this.material;
    switch (u2.side = be, u2.transparent = true, u2.opacity = 0, this.goalOpacity = 0, this.opacityDamper = new lp(), this.hitPlane = new fo(new Uo(2 * (a2 + cp), 2 * (l2 + cp))), this.hitPlane.visible = false, this.hitPlane.material.side = be, this.add(this.hitPlane), s2.getCenter(this.position), t2) {
      case "bottom":
        this.rotateX(-Math.PI / 2), this.shadowHeight = s2.min.y, this.position.y = this.shadowHeight;
        break;
      case "back":
        this.shadowHeight = s2.min.z, this.position.z = this.shadowHeight;
    }
    e3.target.add(this), this.offsetHeight = 0;
  }
  getHit(e3, t2, i2) {
    up.set(t2, -i2), this.hitPlane.visible = true;
    const n2 = e3.positionAndNormalFromPoint(up, this.hitPlane);
    return this.hitPlane.visible = false, null == n2 ? null : n2.position;
  }
  getExpandedHit(e3, t2, i2) {
    this.hitPlane.scale.set(1e3, 1e3, 1e3), this.hitPlane.updateMatrixWorld();
    const n2 = this.getHit(e3, t2, i2);
    return this.hitPlane.scale.set(1, 1, 1), n2;
  }
  set offsetHeight(e3) {
    e3 -= 1e-3, "back" === this.side ? this.position.z = this.shadowHeight + e3 : this.position.y = this.shadowHeight + e3;
  }
  get offsetHeight() {
    return "back" === this.side ? this.position.z - this.shadowHeight : this.position.y - this.shadowHeight;
  }
  set show(e3) {
    this.goalOpacity = e3 ? 0.75 : 0;
  }
  updateOpacity(e3) {
    const t2 = this.material;
    t2.opacity = this.opacityDamper.update(t2.opacity, this.goalOpacity, e3, 1), this.visible = t2.opacity > 0;
  }
  dispose() {
    var e3;
    const { geometry: t2, material: i2 } = this.hitPlane;
    t2.dispose(), i2.dispose(), this.geometry.dispose(), this.material.dispose(), null === (e3 = this.parent) || void 0 === e3 || e3.remove(this);
  }
}
const _p = (e3, t2) => ({ type: "number", number: e3, unit: t2 }), gp = (() => {
  const e3 = {};
  return (t2) => {
    const i2 = t2;
    if (i2 in e3)
      return e3[i2];
    const n2 = [];
    let o2 = 0;
    for (; t2; ) {
      if (++o2 > 1e3) {
        t2 = "";
        break;
      }
      const e4 = mp(t2), i3 = e4.nodes[0];
      if (null == i3 || 0 === i3.terms.length)
        break;
      n2.push(i3), t2 = e4.remainingInput;
    }
    return e3[i2] = n2;
  };
})(), mp = (() => {
  const e3 = /^(\-\-|[a-z\u0240-\uffff])/i, t2 = /^([\*\+\/]|[\-]\s)/i, i2 = /^[\),]/;
  return (n2) => {
    const o2 = [];
    for (; n2.length && (n2 = n2.trim(), !i2.test(n2)); )
      if ("(" === n2[0]) {
        const { nodes: e4, remainingInput: t3 } = bp(n2);
        n2 = t3, o2.push({ type: "function", name: { type: "ident", value: "calc" }, arguments: e4 });
      } else if (e3.test(n2)) {
        const e4 = fp(n2), t3 = e4.nodes[0];
        if ("(" === (n2 = e4.remainingInput)[0]) {
          const { nodes: e5, remainingInput: i3 } = bp(n2);
          o2.push({ type: "function", name: t3, arguments: e5 }), n2 = i3;
        } else
          o2.push(t3);
      } else if (t2.test(n2))
        o2.push({ type: "operator", value: n2[0] }), n2 = n2.slice(1);
      else {
        const { nodes: e4, remainingInput: t3 } = "#" === n2[0] ? Ap(n2) : vp(n2);
        if (0 === e4.length)
          break;
        o2.push(e4[0]), n2 = t3;
      }
    return { nodes: [{ type: "expression", terms: o2 }], remainingInput: n2 };
  };
})(), fp = (() => {
  const e3 = /[^a-z0-9_\-\u0240-\uffff]/i;
  return (t2) => {
    const i2 = t2.match(e3);
    return { nodes: [{ type: "ident", value: null == i2 ? t2 : t2.substr(0, i2.index) }], remainingInput: null == i2 ? "" : t2.substr(i2.index) };
  };
})(), vp = (() => {
  const e3 = /[\+\-]?(\d+[\.]\d+|\d+|[\.]\d+)([eE][\+\-]?\d+)?/, t2 = /^[a-z%]+/i, i2 = /^(m|mm|cm|rad|deg|[%])$/;
  return (n2) => {
    const o2 = n2.match(e3), r2 = null == o2 ? "0" : o2[0], s2 = (n2 = null == r2 ? n2 : n2.slice(r2.length)).match(t2);
    let a2 = null != s2 && "" !== s2[0] ? s2[0] : null;
    const l2 = null == s2 ? n2 : n2.slice(a2.length);
    return null == a2 || i2.test(a2) || (a2 = null), { nodes: [{ type: "number", number: parseFloat(r2) || 0, unit: a2 }], remainingInput: l2 };
  };
})(), Ap = (() => {
  const e3 = /^[a-f0-9]*/i;
  return (t2) => {
    const i2 = (t2 = t2.slice(1).trim()).match(e3);
    return { nodes: null == i2 ? [] : [{ type: "hex", value: i2[0] }], remainingInput: null == i2 ? t2 : t2.slice(i2[0].length) };
  };
})(), bp = (e3) => {
  const t2 = [];
  for (e3 = e3.slice(1).trim(); e3.length; ) {
    const i2 = mp(e3);
    if (t2.push(i2.nodes[0]), "," === (e3 = i2.remainingInput.trim())[0])
      e3 = e3.slice(1).trim();
    else if (")" === e3[0]) {
      e3 = e3.slice(1);
      break;
    }
  }
  return { nodes: t2, remainingInput: e3 };
}, yp = Symbol("visitedTypes");
class wp {
  constructor(e3) {
    this[yp] = e3;
  }
  walk(e3, t2) {
    const i2 = e3.slice();
    for (; i2.length; ) {
      const e4 = i2.shift();
      switch (this[yp].indexOf(e4.type) > -1 && t2(e4), e4.type) {
        case "expression":
          i2.unshift(...e4.terms);
          break;
        case "function":
          i2.unshift(e4.name, ...e4.arguments);
      }
    }
  }
}
const xp = Object.freeze({ type: "number", number: 0, unit: null }), Cp = (e3, t2 = 0) => {
  let { number: i2, unit: n2 } = e3;
  if (isFinite(i2)) {
    if ("rad" === e3.unit || null == e3.unit)
      return e3;
  } else
    i2 = t2, n2 = "rad";
  return { type: "number", number: ("deg" === n2 && null != i2 ? i2 : 0) * Math.PI / 180, unit: "rad" };
}, Sp = (e3, t2 = 0) => {
  let i2, { number: n2, unit: o2 } = e3;
  if (isFinite(n2)) {
    if ("m" === e3.unit)
      return e3;
  } else
    n2 = t2, o2 = "m";
  switch (o2) {
    default:
      i2 = 1;
      break;
    case "cm":
      i2 = 0.01;
      break;
    case "mm":
      i2 = 1e-3;
  }
  return { type: "number", number: i2 * n2, unit: "m" };
}, Ep = (() => {
  const e3 = (e4) => e4, t2 = { rad: e3, deg: Cp, m: e3, mm: Sp, cm: Sp };
  return (e4, i2 = xp) => {
    isFinite(e4.number) || (e4.number = i2.number, e4.unit = i2.unit);
    const { unit: n2 } = e4;
    if (null == n2)
      return e4;
    const o2 = t2[n2];
    return null == o2 ? i2 : o2(e4);
  };
})();
var Ip, Tp, Bp;
const Mp = Symbol("evaluate"), kp = Symbol("lastValue");
class Rp {
  constructor() {
    this[Ip] = null;
  }
  static evaluatableFor(e3, t2 = xp) {
    if (e3 instanceof Rp)
      return e3;
    if ("number" === e3.type)
      return "%" === e3.unit ? new Lp(e3, t2) : e3;
    switch (e3.name.value) {
      case "calc":
        return new Up(e3, t2);
      case "env":
        return new Np(e3);
    }
    return xp;
  }
  static evaluate(e3) {
    return e3 instanceof Rp ? e3.evaluate() : e3;
  }
  static isConstant(e3) {
    return !(e3 instanceof Rp) || e3.isConstant;
  }
  static applyIntrinsics(e3, t2) {
    const { basis: i2, keywords: n2 } = t2, { auto: o2 } = n2;
    return i2.map((t3, i3) => {
      const r2 = null == o2[i3] ? t3 : o2[i3];
      let s2 = e3[i3] ? e3[i3] : r2;
      if ("ident" === s2.type) {
        const e4 = s2.value;
        e4 in n2 && (s2 = n2[e4][i3]);
      }
      return null != s2 && "ident" !== s2.type || (s2 = r2), "%" === s2.unit ? _p(s2.number / 100 * t3.number, t3.unit) : (s2 = Ep(s2, t3), s2.unit !== t3.unit ? t3 : s2);
    });
  }
  get isConstant() {
    return false;
  }
  evaluate() {
    return this.isConstant && null != this[kp] || (this[kp] = this[Mp]()), this[kp];
  }
}
Ip = kp;
const Pp = Symbol("percentage"), Dp = Symbol("basis");
class Lp extends Rp {
  constructor(e3, t2) {
    super(), this[Pp] = e3, this[Dp] = t2;
  }
  get isConstant() {
    return true;
  }
  [Mp]() {
    return _p(this[Pp].number / 100 * this[Dp].number, this[Dp].unit);
  }
}
const Fp = Symbol("identNode");
class Np extends Rp {
  constructor(e3) {
    super(), this[Tp] = null;
    const t2 = e3.arguments.length ? e3.arguments[0].terms[0] : null;
    null != t2 && "ident" === t2.type && (this[Fp] = t2);
  }
  get isConstant() {
    return false;
  }
  [(Tp = Fp, Mp)]() {
    if (null != this[Fp] && "window-scroll-y" === this[Fp].value) {
      return { type: "number", number: window.pageYOffset / (Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) - window.innerHeight) || 0, unit: null };
    }
    return xp;
  }
}
const Op = /[\*\/]/, zp = Symbol("evaluator");
class Up extends Rp {
  constructor(e3, t2 = xp) {
    if (super(), this[Bp] = null, 1 !== e3.arguments.length)
      return;
    const i2 = e3.arguments[0].terms.slice(), n2 = [];
    for (; i2.length; ) {
      const e4 = i2.shift();
      if (n2.length > 0) {
        const i3 = n2[n2.length - 1];
        if ("operator" === i3.type && Op.test(i3.value)) {
          const i4 = n2.pop(), o2 = n2.pop();
          if (null == o2)
            return;
          n2.push(new Gp(i4, Rp.evaluatableFor(o2, t2), Rp.evaluatableFor(e4, t2)));
          continue;
        }
      }
      n2.push("operator" === e4.type ? e4 : Rp.evaluatableFor(e4, t2));
    }
    for (; n2.length > 2; ) {
      const [e4, i3, o2] = n2.splice(0, 3);
      if ("operator" !== i3.type)
        return;
      n2.unshift(new Gp(i3, Rp.evaluatableFor(e4, t2), Rp.evaluatableFor(o2, t2)));
    }
    1 === n2.length && (this[zp] = n2[0]);
  }
  get isConstant() {
    return null == this[zp] || Rp.isConstant(this[zp]);
  }
  [(Bp = zp, Mp)]() {
    return null != this[zp] ? Rp.evaluate(this[zp]) : xp;
  }
}
const Hp = Symbol("operator"), Qp = Symbol("left"), Vp = Symbol("right");
class Gp extends Rp {
  constructor(e3, t2, i2) {
    super(), this[Hp] = e3, this[Qp] = t2, this[Vp] = i2;
  }
  get isConstant() {
    return Rp.isConstant(this[Qp]) && Rp.isConstant(this[Vp]);
  }
  [Mp]() {
    const e3 = Ep(Rp.evaluate(this[Qp])), t2 = Ep(Rp.evaluate(this[Vp])), { number: i2, unit: n2 } = e3, { number: o2, unit: r2 } = t2;
    if (null != r2 && null != n2 && r2 != n2)
      return xp;
    const s2 = n2 || r2;
    let a2;
    switch (this[Hp].value) {
      case "+":
        a2 = i2 + o2;
        break;
      case "-":
        a2 = i2 - o2;
        break;
      case "/":
        a2 = i2 / o2;
        break;
      case "*":
        a2 = i2 * o2;
        break;
      default:
        return xp;
    }
    return { type: "number", number: a2, unit: s2 };
  }
}
const $p = Symbol("evaluatables"), Wp = Symbol("intrinsics");
class qp extends Rp {
  constructor(e3, t2) {
    super(), this[Wp] = t2;
    const i2 = e3[0], n2 = null != i2 ? i2.terms : [];
    this[$p] = t2.basis.map((e4, t3) => {
      const i3 = n2[t3];
      return null == i3 ? { type: "ident", value: "auto" } : "ident" === i3.type ? i3 : Rp.evaluatableFor(i3, e4);
    });
  }
  get isConstant() {
    for (const e3 of this[$p])
      if (!Rp.isConstant(e3))
        return false;
    return true;
  }
  [Mp]() {
    const e3 = this[$p].map((e4) => Rp.evaluate(e4));
    return Rp.applyIntrinsics(e3, this[Wp]).map((e4) => e4.number);
  }
}
var jp, Xp, Yp, Kp;
const Zp = Symbol("instances"), Jp = Symbol("activateListener"), e_ = Symbol("deactivateListener"), t_ = Symbol("notifyInstances"), i_ = Symbol("notify"), n_ = Symbol("callback");
class o_ {
  constructor(e3) {
    this[n_] = e3;
  }
  static [t_]() {
    for (const e3 of o_[Zp])
      e3[i_]();
  }
  static [(jp = Zp, Jp)]() {
    window.addEventListener("scroll", this[t_], { passive: true });
  }
  static [e_]() {
    window.removeEventListener("scroll", this[t_]);
  }
  observe() {
    0 === o_[Zp].size && o_[Jp](), o_[Zp].add(this);
  }
  disconnect() {
    o_[Zp].delete(this), 0 === o_[Zp].size && o_[e_]();
  }
  [i_]() {
    this[n_]();
  }
}
o_[jp] = /* @__PURE__ */ new Set();
const r_ = Symbol("computeStyleCallback"), s_ = Symbol("astWalker"), a_ = Symbol("dependencies"), l_ = Symbol("onScroll");
class c_ {
  constructor(e3) {
    this[Xp] = {}, this[Yp] = new wp(["function"]), this[Kp] = () => {
      this[r_]({ relatedState: "window-scroll" });
    }, this[r_] = e3;
  }
  observeEffectsFor(e3) {
    const t2 = {}, i2 = this[a_];
    this[s_].walk(e3, (e4) => {
      const { name: n2 } = e4, o2 = e4.arguments[0].terms[0];
      if ("env" === n2.value && null != o2 && "ident" === o2.type && "window-scroll-y" === o2.value) {
        if (null == t2["window-scroll"]) {
          const e5 = "window-scroll" in i2 ? i2["window-scroll"] : new o_(this[l_]);
          e5.observe(), delete i2["window-scroll"], t2["window-scroll"] = e5;
        }
      }
    });
    for (const e4 in i2) {
      i2[e4].disconnect();
    }
    this[a_] = t2;
  }
  dispose() {
    for (const e3 in this[a_]) {
      this[a_][e3].disconnect();
    }
  }
}
Xp = a_, Yp = s_, Kp = l_;
const h_ = (e3) => {
  const t2 = e3.observeEffects || false, i2 = e3.intrinsics instanceof Function ? e3.intrinsics : () => e3.intrinsics;
  return (n2, o2) => {
    const r2 = n2.updated, s2 = n2.connectedCallback, a2 = n2.disconnectedCallback, l2 = Symbol(`${o2}StyleEffector`), c2 = Symbol(`${o2}StyleEvaluator`), h2 = Symbol(`${o2}UpdateEvaluator`), u2 = Symbol(`${o2}EvaluateAndSync`);
    Object.defineProperties(n2, { [l2]: { value: null, writable: true }, [c2]: { value: null, writable: true }, [h2]: { value: function() {
      const e4 = gp(this[o2]);
      this[c2] = new qp(e4, i2(this)), null == this[l2] && t2 && (this[l2] = new c_(() => this[u2]())), null != this[l2] && this[l2].observeEffectsFor(e4);
    } }, [u2]: { value: function() {
      if (null == this[c2])
        return;
      const t3 = this[c2].evaluate();
      this[e3.updateHandler](t3);
    } }, updated: { value: function(e4) {
      e4.has(o2) && (this[h2](), this[u2]()), r2.call(this, e4);
    } }, connectedCallback: { value: function() {
      s2.call(this), this.requestUpdate(o2, this[o2]);
    } }, disconnectedCallback: { value: function() {
      a2.call(this), null != this[l2] && (this[l2].dispose(), this[l2] = null);
    } } });
  };
}, u_ = (e3) => e3 < 0.5 ? 2 * e3 * e3 : (4 - 2 * e3) * e3 - 1, d_ = (e3, t2, i2 = u_) => (n2) => e3 + (t2 - e3) * i2(n2), p_ = (e3) => {
  const t2 = [], i2 = [];
  let n2 = e3.initialValue;
  for (let o2 = 0; o2 < e3.keyframes.length; ++o2) {
    const r2 = e3.keyframes[o2], { value: s2, frames: a2 } = r2, l2 = r2.ease || u_, c2 = d_(n2, s2, l2);
    t2.push(c2), i2.push(a2), n2 = s2;
  }
  return ((e4, t3) => {
    const i3 = t3.map((n3 = 0, (e5) => n3 += e5));
    var n3;
    return (t4) => {
      t4 = sh(t4, 0, 1), t4 *= i3[i3.length - 1];
      const n4 = i3.findIndex((e5) => e5 >= t4), o2 = n4 < 1 ? 0 : i3[n4 - 1], r2 = i3[n4];
      return e4[n4]((t4 - o2) / (r2 - o2));
    };
  })(t2, i2);
};
var __ = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
const g_ = p_({ initialValue: 0, keyframes: [{ frames: 5, value: -1 }, { frames: 1, value: -1 }, { frames: 8, value: 1 }, { frames: 1, value: 1 }, { frames: 5, value: 0 }, { frames: 18, value: 0 }] }), m_ = p_({ initialValue: 0, keyframes: [{ frames: 1, value: 1 }, { frames: 5, value: 1 }, { frames: 1, value: 0 }, { frames: 6, value: 0 }] }), f_ = "0deg 75deg 105%", v_ = ["front", "right", "back", "left"], A_ = ["upper-", "", "lower-"], b_ = "auto", y_ = "basic", w_ = "wiggle", x_ = "none", C_ = () => ({ basis: [Cp(_p(30, "deg"))], keywords: { auto: [null] } }), S_ = () => ({ basis: [Cp(_p(12, "deg"))], keywords: { auto: [null] } }), E_ = (() => {
  const e3 = gp(f_)[0].terms, t2 = Ep(e3[0]), i2 = Ep(e3[1]);
  return (e4) => {
    const n2 = e4[Dv].idealCameraDistance();
    return { basis: [t2, i2, _p(n2, "m")], keywords: { auto: [null, null, _p(105, "%")] } };
  };
})(), I_ = (e3) => {
  const t2 = 2.2 * e3[Dv].boundingSphere.radius;
  return { basis: [_p(-1 / 0, "rad"), _p(Math.PI / 8, "rad"), _p(t2, "m")], keywords: { auto: [null, null, null] } };
}, T_ = (e3) => {
  const t2 = E_(e3), i2 = new qp([], t2).evaluate()[2];
  return { basis: [_p(1 / 0, "rad"), _p(Math.PI - Math.PI / 8, "rad"), _p(i2, "m")], keywords: { auto: [null, null, null] } };
}, B_ = (e3) => {
  const t2 = e3[Dv].boundingBox.getCenter(new di());
  return { basis: [_p(t2.x, "m"), _p(t2.y, "m"), _p(t2.z, "m")], keywords: { auto: [null, null, null] } };
}, M_ = Math.PI / 2, k_ = Math.PI / 3, R_ = M_ / 2, P_ = 2 * Math.PI, D_ = Symbol("controls"), L_ = Symbol("panElement"), F_ = Symbol("promptElement"), N_ = Symbol("promptAnimatedContainer"), O_ = Symbol("fingerAnimatedContainers"), z_ = Symbol("deferInteractionPrompt"), U_ = Symbol("updateAria"), H_ = Symbol("updateCameraForRadius"), Q_ = Symbol("cancelPrompts"), V_ = Symbol("onChange"), G_ = Symbol("onPointerChange"), $_ = Symbol("waitingToPromptUser"), W_ = Symbol("userHasInteracted"), q_ = Symbol("promptElementVisibleTime"), j_ = Symbol("lastPromptOffset"), X_ = Symbol("cancellationSource"), Y_ = Symbol("lastSpherical"), K_ = Symbol("jumpCamera"), Z_ = Symbol("initialized"), J_ = Symbol("maintainThetaPhi"), eg = Symbol("syncCameraOrbit"), tg = Symbol("syncFieldOfView"), ig = Symbol("syncCameraTarget"), ng = Symbol("syncMinCameraOrbit"), og = Symbol("syncMaxCameraOrbit"), rg = Symbol("syncMinFieldOfView"), sg = Symbol("syncMaxFieldOfView"), ag = new Vt(), lg = new di(), cg = Object.freeze({ minimumRadius: 0, maximumRadius: 1 / 0, minimumPolarAngle: Math.PI / 8, maximumPolarAngle: Math.PI - Math.PI / 8, minimumAzimuthalAngle: -1 / 0, maximumAzimuthalAngle: 1 / 0, minimumFieldOfView: 10, maximumFieldOfView: 45, touchAction: "none" }), hg = Math.PI / 8, ug = 0.04, dg = { USER_INTERACTION: "user-interaction", NONE: "none", AUTOMATIC: "automatic" };
class pg extends Tt {
  constructor(e3, t2, i2) {
    super(), this.camera = e3, this.element = t2, this.scene = i2, this.orbitSensitivity = 1, this.inputSensitivity = 1, this.changeSource = dg.NONE, this._interactionEnabled = false, this._disableZoom = false, this.isUserPointing = false, this.enablePan = true, this.enableTap = true, this.panProjection = new Gt(), this.panPerPixel = 0, this.spherical = new zc(), this.goalSpherical = new zc(), this.thetaDamper = new lp(), this.phiDamper = new lp(), this.radiusDamper = new lp(), this.logFov = Math.log(cg.maximumFieldOfView), this.goalLogFov = this.logFov, this.fovDamper = new lp(), this.touchMode = null, this.pointers = [], this.startTime = 0, this.startPointerPosition = { clientX: 0, clientY: 0 }, this.lastSeparation = 0, this.touchDecided = false, this.onContext = (e4) => {
      if (this.enablePan)
        e4.preventDefault();
      else
        for (const e5 of this.pointers)
          this.onPointerUp(new PointerEvent("pointercancel", Object.assign(Object.assign({}, this.startPointerPosition), { pointerId: e5.id })));
    }, this.touchModeZoom = (e4, t3) => {
      if (!this._disableZoom) {
        const e5 = this.twoTouchDistance(this.pointers[0], this.pointers[1]), t4 = ug * (this.lastSeparation - e5) * 50 / this.scene.height;
        this.lastSeparation = e5, this.userAdjustOrbit(0, 0, t4);
      }
      this.panPerPixel > 0 && this.movePan(e4, t3);
    }, this.disableScroll = (e4) => {
      e4.preventDefault();
    }, this.touchModeRotate = (e4, t3) => {
      const { touchAction: i3 } = this._options;
      if (!this.touchDecided && "none" !== i3) {
        this.touchDecided = true;
        const n2 = Math.abs(e4), o2 = Math.abs(t3);
        if (this.changeSource === dg.USER_INTERACTION && ("pan-y" === i3 && o2 > n2 || "pan-x" === i3 && n2 > o2))
          return void (this.touchMode = null);
        this.element.addEventListener("touchmove", this.disableScroll, { passive: false });
      }
      this.handleSinglePointerMove(e4, t3);
    }, this.onPointerDown = (e4) => {
      if (this.pointers.length > 2)
        return;
      const { element: t3 } = this;
      0 === this.pointers.length && (t3.addEventListener("pointermove", this.onPointerMove), t3.addEventListener("pointerup", this.onPointerUp), this.touchMode = null, this.touchDecided = false, this.startPointerPosition.clientX = e4.clientX, this.startPointerPosition.clientY = e4.clientY, this.startTime = performance.now());
      try {
        t3.setPointerCapture(e4.pointerId);
      } catch (e5) {
      }
      this.pointers.push({ clientX: e4.clientX, clientY: e4.clientY, id: e4.pointerId }), this.isUserPointing = false, "touch" === e4.pointerType ? (this.changeSource = e4.altKey ? dg.AUTOMATIC : dg.USER_INTERACTION, this.onTouchChange(e4)) : (this.changeSource = dg.USER_INTERACTION, this.onMouseDown(e4)), this.changeSource === dg.USER_INTERACTION && this.dispatchEvent({ type: "user-interaction" });
    }, this.onPointerMove = (e4) => {
      const t3 = this.pointers.find((t4) => t4.id === e4.pointerId);
      if (null == t3)
        return;
      if ("mouse" === e4.pointerType && 0 === e4.buttons)
        return void this.onPointerUp(e4);
      const i3 = this.pointers.length, n2 = (e4.clientX - t3.clientX) / i3, o2 = (e4.clientY - t3.clientY) / i3;
      0 === n2 && 0 === o2 || (t3.clientX = e4.clientX, t3.clientY = e4.clientY, "touch" === e4.pointerType ? (this.changeSource = e4.altKey ? dg.AUTOMATIC : dg.USER_INTERACTION, null !== this.touchMode && this.touchMode(n2, o2)) : (this.changeSource = dg.USER_INTERACTION, this.panPerPixel > 0 ? this.movePan(n2, o2) : this.handleSinglePointerMove(n2, o2)));
    }, this.onPointerUp = (e4) => {
      const { element: t3 } = this, i3 = this.pointers.findIndex((t4) => t4.id === e4.pointerId);
      -1 !== i3 && this.pointers.splice(i3, 1), this.panPerPixel > 0 && !e4.altKey && this.resetRadius(), 0 === this.pointers.length ? (t3.removeEventListener("pointermove", this.onPointerMove), t3.removeEventListener("pointerup", this.onPointerUp), t3.removeEventListener("touchmove", this.disableScroll), this.enablePan && this.enableTap && this.recenter(e4)) : null !== this.touchMode && this.onTouchChange(e4), this.scene.element[L_].style.opacity = 0, t3.style.cursor = "grab", this.panPerPixel = 0, this.isUserPointing && this.dispatchEvent({ type: "pointer-change-end" });
    }, this.onWheel = (e4) => {
      this.changeSource = dg.USER_INTERACTION;
      const t3 = e4.deltaY * (1 == e4.deltaMode ? 18 : 1) * ug / 30;
      this.userAdjustOrbit(0, 0, t3), e4.preventDefault(), this.dispatchEvent({ type: "user-interaction" });
    }, this.onKeyDown = (e4) => {
      const { changeSource: t3 } = this;
      this.changeSource = dg.USER_INTERACTION;
      (e4.shiftKey && this.enablePan ? this.panKeyCodeHandler(e4) : this.orbitZoomKeyCodeHandler(e4)) ? (e4.preventDefault(), this.dispatchEvent({ type: "user-interaction" })) : this.changeSource = t3;
    }, this._options = Object.assign({}, cg), this.setOrbit(0, Math.PI / 2, 1), this.setFieldOfView(100), this.jumpToGoal();
  }
  get interactionEnabled() {
    return this._interactionEnabled;
  }
  enableInteraction() {
    if (false === this._interactionEnabled) {
      const { element: e3 } = this;
      e3.addEventListener("pointerdown", this.onPointerDown), e3.addEventListener("pointercancel", this.onPointerUp), this._disableZoom || e3.addEventListener("wheel", this.onWheel), e3.addEventListener("keydown", this.onKeyDown), e3.addEventListener("touchmove", () => {
      }, { passive: false }), e3.addEventListener("contextmenu", this.onContext), this.element.style.cursor = "grab", this._interactionEnabled = true, this.updateTouchActionStyle();
    }
  }
  disableInteraction() {
    if (true === this._interactionEnabled) {
      const { element: e3 } = this;
      e3.removeEventListener("pointerdown", this.onPointerDown), e3.removeEventListener("pointermove", this.onPointerMove), e3.removeEventListener("pointerup", this.onPointerUp), e3.removeEventListener("pointercancel", this.onPointerUp), e3.removeEventListener("wheel", this.onWheel), e3.removeEventListener("keydown", this.onKeyDown), e3.removeEventListener("contextmenu", this.onContext), e3.style.cursor = "", this.touchMode = null, this._interactionEnabled = false, this.updateTouchActionStyle();
    }
  }
  get options() {
    return this._options;
  }
  set disableZoom(e3) {
    this._disableZoom != e3 && (this._disableZoom = e3, true === e3 ? this.element.removeEventListener("wheel", this.onWheel) : this.element.addEventListener("wheel", this.onWheel), this.updateTouchActionStyle());
  }
  getCameraSpherical(e3 = new zc()) {
    return e3.copy(this.spherical);
  }
  getFieldOfView() {
    return this.camera.fov;
  }
  applyOptions(e3) {
    Object.assign(this._options, e3), this.setOrbit(), this.setFieldOfView(Math.exp(this.goalLogFov));
  }
  updateNearFar(e3, t2) {
    this.camera.far = 0 === t2 ? 2 : t2, this.camera.near = Math.max(e3, this.camera.far / 1e3), this.camera.updateProjectionMatrix();
  }
  updateAspect(e3) {
    this.camera.aspect = e3, this.camera.updateProjectionMatrix();
  }
  setOrbit(e3 = this.goalSpherical.theta, t2 = this.goalSpherical.phi, i2 = this.goalSpherical.radius) {
    const { minimumAzimuthalAngle: n2, maximumAzimuthalAngle: o2, minimumPolarAngle: r2, maximumPolarAngle: s2, minimumRadius: a2, maximumRadius: l2 } = this._options, { theta: c2, phi: h2, radius: u2 } = this.goalSpherical, d2 = sh(e3, n2, o2);
    isFinite(n2) || isFinite(o2) || (this.spherical.theta = this.wrapAngle(this.spherical.theta - d2) + d2);
    const p2 = sh(t2, r2, s2), _2 = sh(i2, a2, l2);
    return (d2 !== c2 || p2 !== h2 || _2 !== u2) && (!!(isFinite(d2) && isFinite(p2) && isFinite(_2)) && (this.goalSpherical.theta = d2, this.goalSpherical.phi = p2, this.goalSpherical.radius = _2, this.goalSpherical.makeSafe(), true));
  }
  setRadius(e3) {
    this.goalSpherical.radius = e3, this.setOrbit();
  }
  setFieldOfView(e3) {
    const { minimumFieldOfView: t2, maximumFieldOfView: i2 } = this._options;
    e3 = sh(e3, t2, i2), this.goalLogFov = Math.log(e3);
  }
  setDamperDecayTime(e3) {
    this.thetaDamper.setDecayTime(e3), this.phiDamper.setDecayTime(e3), this.radiusDamper.setDecayTime(e3), this.fovDamper.setDecayTime(e3);
  }
  adjustOrbit(e3, t2, i2) {
    const { theta: n2, phi: o2, radius: r2 } = this.goalSpherical, { minimumRadius: s2, maximumRadius: a2, minimumFieldOfView: l2, maximumFieldOfView: c2 } = this._options, h2 = this.spherical.theta - n2, u2 = Math.PI - 1e-3, d2 = n2 - sh(e3, -u2 - h2, u2 - h2), p2 = o2 - t2, _2 = 0 === i2 ? 0 : ((i2 > 0 ? a2 : s2) - r2) / (Math.log(i2 > 0 ? c2 : l2) - this.goalLogFov), g2 = r2 + i2 * (isFinite(_2) ? _2 : 2 * (a2 - s2));
    if (this.setOrbit(d2, p2, g2), 0 !== i2) {
      const e4 = this.goalLogFov + i2;
      this.setFieldOfView(Math.exp(e4));
    }
  }
  jumpToGoal() {
    this.update(0, 1e4);
  }
  update(e3, t2) {
    if (this.isStationary())
      return false;
    const { maximumPolarAngle: i2, maximumRadius: n2 } = this._options, o2 = this.spherical.theta - this.goalSpherical.theta;
    return Math.abs(o2) > Math.PI && !isFinite(this._options.minimumAzimuthalAngle) && !isFinite(this._options.maximumAzimuthalAngle) && (this.spherical.theta -= 2 * Math.sign(o2) * Math.PI), this.spherical.theta = this.thetaDamper.update(this.spherical.theta, this.goalSpherical.theta, t2, Math.PI), this.spherical.phi = this.phiDamper.update(this.spherical.phi, this.goalSpherical.phi, t2, i2), this.spherical.radius = this.radiusDamper.update(this.spherical.radius, this.goalSpherical.radius, t2, n2), this.logFov = this.fovDamper.update(this.logFov, this.goalLogFov, t2, 1), this.moveCamera(), true;
  }
  updateTouchActionStyle() {
    const { style: e3 } = this.element;
    if (this._interactionEnabled) {
      const { touchAction: t2 } = this._options;
      this._disableZoom && "none" !== t2 ? e3.touchAction = "manipulation" : e3.touchAction = t2;
    } else
      e3.touchAction = "";
  }
  isStationary() {
    return this.goalSpherical.theta === this.spherical.theta && this.goalSpherical.phi === this.spherical.phi && this.goalSpherical.radius === this.spherical.radius && this.goalLogFov === this.logFov;
  }
  moveCamera() {
    this.spherical.makeSafe(), this.camera.position.setFromSpherical(this.spherical), this.camera.setRotationFromEuler(new Zi(this.spherical.phi - Math.PI / 2, this.spherical.theta, 0, "YXZ")), this.camera.fov !== Math.exp(this.logFov) && (this.camera.fov = Math.exp(this.logFov), this.camera.updateProjectionMatrix());
  }
  userAdjustOrbit(e3, t2, i2) {
    this.adjustOrbit(e3 * this.orbitSensitivity * this.inputSensitivity, t2 * this.orbitSensitivity * this.inputSensitivity, i2 * this.inputSensitivity);
  }
  wrapAngle(e3) {
    const t2 = (e3 + Math.PI) / (2 * Math.PI);
    return 2 * (t2 - Math.floor(t2)) * Math.PI - Math.PI;
  }
  pixelLengthToSphericalAngle(e3) {
    return 2 * Math.PI * e3 / this.scene.height;
  }
  twoTouchDistance(e3, t2) {
    const { clientX: i2, clientY: n2 } = e3, { clientX: o2, clientY: r2 } = t2, s2 = o2 - i2, a2 = r2 - n2;
    return Math.sqrt(s2 * s2 + a2 * a2);
  }
  handleSinglePointerMove(e3, t2) {
    const i2 = this.pixelLengthToSphericalAngle(e3), n2 = this.pixelLengthToSphericalAngle(t2);
    false === this.isUserPointing && (this.isUserPointing = true, this.dispatchEvent({ type: "pointer-change-start" })), this.userAdjustOrbit(i2, n2, 0);
  }
  initializePan() {
    const { theta: e3, phi: t2 } = this.spherical, i2 = e3 - this.scene.yaw;
    this.panPerPixel = 0.018 / this.scene.height, this.panProjection.set(-Math.cos(i2), -Math.cos(t2) * Math.sin(i2), 0, 0, Math.sin(t2), 0, Math.sin(i2), -Math.cos(t2) * Math.cos(i2), 0);
  }
  movePan(e3, t2) {
    const { scene: i2 } = this, n2 = lg.set(e3, t2, 0).multiplyScalar(this.inputSensitivity), o2 = this.spherical.radius * Math.exp(this.logFov) * this.panPerPixel;
    n2.multiplyScalar(o2);
    const r2 = i2.getTarget();
    r2.add(n2.applyMatrix3(this.panProjection)), i2.boundingSphere.clampPoint(r2, r2), i2.setTarget(r2.x, r2.y, r2.z);
  }
  recenter(e3) {
    if (performance.now() > this.startTime + 300 || Math.abs(e3.clientX - this.startPointerPosition.clientX) > 2 || Math.abs(e3.clientY - this.startPointerPosition.clientY) > 2)
      return;
    const { scene: t2 } = this, i2 = t2.positionAndNormalFromPoint(t2.getNDC(e3.clientX, e3.clientY));
    if (null == i2) {
      const { cameraTarget: e4 } = t2.element;
      t2.element.cameraTarget = "", t2.element.cameraTarget = e4, this.userAdjustOrbit(0, 0, 1);
    } else
      t2.target.worldToLocal(i2.position), t2.setTarget(i2.position.x, i2.position.y, i2.position.z);
  }
  resetRadius() {
    const { scene: e3 } = this, t2 = e3.positionAndNormalFromPoint(ag.set(0, 0));
    if (null == t2)
      return;
    e3.target.worldToLocal(t2.position);
    const i2 = e3.getTarget(), { theta: n2, phi: o2 } = this.spherical, r2 = n2 - e3.yaw, s2 = lg.set(Math.sin(o2) * Math.sin(r2), Math.cos(o2), Math.sin(o2) * Math.cos(r2)), a2 = s2.dot(t2.position.sub(i2));
    i2.add(s2.multiplyScalar(a2)), e3.setTarget(i2.x, i2.y, i2.z), this.setOrbit(void 0, void 0, this.goalSpherical.radius - a2);
  }
  onTouchChange(e3) {
    if (1 === this.pointers.length)
      this.touchMode = this.touchModeRotate;
    else {
      if (this._disableZoom)
        return this.touchMode = null, void this.element.removeEventListener("touchmove", this.disableScroll);
      this.touchMode = this.touchDecided && null === this.touchMode ? null : this.touchModeZoom, this.touchDecided = true, this.element.addEventListener("touchmove", this.disableScroll, { passive: false }), this.lastSeparation = this.twoTouchDistance(this.pointers[0], this.pointers[1]), this.enablePan && null != this.touchMode && (this.initializePan(), e3.altKey || (this.scene.element[L_].style.opacity = 1));
    }
  }
  onMouseDown(e3) {
    this.panPerPixel = 0, this.enablePan && (2 === e3.button || e3.ctrlKey || e3.metaKey || e3.shiftKey) && (this.initializePan(), this.scene.element[L_].style.opacity = 1), this.element.style.cursor = "grabbing";
  }
  orbitZoomKeyCodeHandler(e3) {
    let t2 = true;
    switch (e3.key) {
      case "PageUp":
        this.userAdjustOrbit(0, 0, ug);
        break;
      case "PageDown":
        this.userAdjustOrbit(0, 0, -0.04);
        break;
      case "ArrowUp":
        this.userAdjustOrbit(0, -hg, 0);
        break;
      case "ArrowDown":
        this.userAdjustOrbit(0, hg, 0);
        break;
      case "ArrowLeft":
        this.userAdjustOrbit(-hg, 0, 0);
        break;
      case "ArrowRight":
        this.userAdjustOrbit(hg, 0, 0);
        break;
      default:
        t2 = false;
    }
    return t2;
  }
  panKeyCodeHandler(e3) {
    this.initializePan();
    let t2 = true;
    switch (e3.key) {
      case "ArrowUp":
        this.movePan(0, -10);
        break;
      case "ArrowDown":
        this.movePan(0, 10);
        break;
      case "ArrowLeft":
        this.movePan(-10, 0);
        break;
      case "ArrowRight":
        this.movePan(10, 0);
        break;
      default:
        t2 = false;
    }
    return t2;
  }
}
const _g = "not-presenting", gg = "session-started", mg = "object-placed", fg = "failed", vg = "tracking", Ag = "not-tracking", bg = new di(), yg = new Qi(), wg = new di(), xg = new Eo(45, 1, 0.1, 100);
class Cg extends Tt {
  constructor(e3) {
    super(), this.renderer = e3, this.currentSession = null, this.placeOnWall = false, this.placementBox = null, this.lastTick = null, this.turntableRotation = null, this.oldShadowIntensity = null, this.frame = null, this.initialHitSource = null, this.transientHitTestSource = null, this.inputSource = null, this._presentedScene = null, this.resolveCleanup = null, this.exitWebXRButtonContainer = null, this.overlay = null, this.xrLight = null, this.tracking = true, this.frames = 0, this.initialized = false, this.oldTarget = new di(), this.placementComplete = false, this.isTranslating = false, this.isRotating = false, this.isTwoFingering = false, this.lastDragPosition = new di(), this.firstRatio = 0, this.lastAngle = 0, this.goalPosition = new di(), this.goalYaw = 0, this.goalScale = 1, this.xDamper = new lp(), this.yDamper = new lp(), this.zDamper = new lp(), this.yawDamper = new lp(), this.scaleDamper = new lp(), this.onExitWebXRButtonContainerClick = () => this.stopPresenting(), this.onUpdateScene = () => {
      null != this.placementBox && this.isPresenting && (this.placementBox.dispose(), this.placementBox = new pp(this.presentedScene, this.placeOnWall ? "back" : "bottom"));
    }, this.onSelectStart = (e4) => {
      const t2 = this.transientHitTestSource;
      if (null == t2)
        return;
      const i2 = this.frame.getHitTestResultsForTransientInput(t2), n2 = this.presentedScene, o2 = this.placementBox;
      if (1 === i2.length) {
        this.inputSource = e4.inputSource;
        const { axes: t3 } = this.inputSource.gamepad, i3 = o2.getHit(this.presentedScene, t3[0], t3[1]);
        o2.show = true, null != i3 ? (this.isTranslating = true, this.lastDragPosition.copy(i3)) : false === this.placeOnWall && (this.isRotating = true, this.lastAngle = 1.5 * t3[0]);
      } else if (2 === i2.length) {
        o2.show = true, this.isTwoFingering = true;
        const { separation: e5 } = this.fingerPolar(i2);
        this.firstRatio = e5 / n2.scale.x;
      }
    }, this.onSelectEnd = () => {
      this.isTranslating = false, this.isRotating = false, this.isTwoFingering = false, this.inputSource = null, this.goalPosition.y += this.placementBox.offsetHeight * this.presentedScene.scale.x, this.placementBox.show = false;
    }, this.threeRenderer = e3.threeRenderer, this.threeRenderer.xr.enabled = true;
  }
  async resolveARSession() {
    nh();
    const e3 = await navigator.xr.requestSession("immersive-ar", { requiredFeatures: ["hit-test"], optionalFeatures: ["dom-overlay", "light-estimation"], domOverlay: this.overlay ? { root: this.overlay } : void 0 });
    return this.threeRenderer.xr.setReferenceSpaceType("local"), await this.threeRenderer.xr.setSession(e3), this.threeRenderer.xr.cameraAutoUpdate = false, e3;
  }
  get presentedScene() {
    return this._presentedScene;
  }
  async supportsPresentation() {
    try {
      return nh(), await navigator.xr.isSessionSupported("immersive-ar");
    } catch (e3) {
      return console.warn("Request to present in WebXR denied:"), console.warn(e3), console.warn("Falling back to next ar-mode"), false;
    }
  }
  async present(e3, t2 = false) {
    this.isPresenting && console.warn("Cannot present while a model is already presenting");
    let i2 = new Promise((e4, t3) => {
      requestAnimationFrame(() => e4());
    });
    e3.setHotspotsVisibility(false), e3.queueRender(), await i2, this._presentedScene = e3, this.overlay = e3.element.shadowRoot.querySelector("div.default"), true === t2 && (this.xrLight = new ap(this.threeRenderer), this.xrLight.addEventListener("estimationstart", () => {
      if (!this.isPresenting || null == this.xrLight)
        return;
      const e4 = this.presentedScene;
      e4.add(this.xrLight), e4.environment = this.xrLight.environment;
    }));
    const n2 = await this.resolveARSession();
    n2.addEventListener("end", () => {
      this.postSessionCleanup();
    }, { once: true });
    const o2 = e3.element.shadowRoot.querySelector(".slot.exit-webxr-ar-button");
    o2.classList.add("enabled"), o2.addEventListener("click", this.onExitWebXRButtonContainerClick), this.exitWebXRButtonContainer = o2;
    const r2 = await n2.requestReferenceSpace("viewer");
    this.tracking = true, this.frames = 0, this.initialized = false, this.turntableRotation = e3.yaw, this.goalYaw = e3.yaw, this.goalScale = 1, e3.background = null, this.oldShadowIntensity = e3.shadowIntensity, e3.setShadowIntensity(0.01), this.oldTarget.copy(e3.getTarget()), e3.element.addEventListener("load", this.onUpdateScene);
    const s2 = 20 * Math.PI / 180, a2 = true === this.placeOnWall ? void 0 : new XRRay(new DOMPoint(0, 0, 0), { x: 0, y: -Math.sin(s2), z: -Math.cos(s2) });
    n2.requestHitTestSource({ space: r2, offsetRay: a2 }).then((e4) => {
      this.initialHitSource = e4;
    }), this.currentSession = n2, this.placementBox = new pp(e3, this.placeOnWall ? "back" : "bottom"), this.placementComplete = false, this.lastTick = performance.now(), this.dispatchEvent({ type: "status", status: gg });
  }
  async stopPresenting() {
    if (!this.isPresenting)
      return;
    const e3 = new Promise((e4) => {
      this.resolveCleanup = e4;
    });
    try {
      await this.currentSession.end(), await e3;
    } catch (e4) {
      console.warn("Error while trying to end WebXR AR session"), console.warn(e4), this.postSessionCleanup();
    }
  }
  get isPresenting() {
    return null != this.presentedScene;
  }
  get target() {
    return this.oldTarget;
  }
  updateTarget() {
    const e3 = this.presentedScene;
    if (null != e3) {
      const t2 = e3.getTarget();
      this.oldTarget.copy(t2), this.placeOnWall ? t2.z = e3.boundingBox.min.z : t2.y = e3.boundingBox.min.y, e3.setTarget(t2.x, t2.y, t2.z);
    }
  }
  postSessionCleanup() {
    const e3 = this.currentSession;
    null != e3 && (e3.removeEventListener("selectstart", this.onSelectStart), e3.removeEventListener("selectend", this.onSelectEnd), this.currentSession = null);
    const t2 = this.presentedScene;
    if (this._presentedScene = null, null != t2) {
      const { element: e4 } = t2;
      null != this.xrLight && (t2.remove(this.xrLight), this.xrLight.dispose(), this.xrLight = null), t2.position.set(0, 0, 0), t2.scale.set(1, 1, 1), t2.setShadowOffset(0);
      const i3 = this.turntableRotation;
      null != i3 && (t2.yaw = i3);
      const n3 = this.oldShadowIntensity;
      null != n3 && t2.setShadowIntensity(n3), t2.setEnvironmentAndSkybox(e4[hh], e4[uh]);
      const o3 = this.oldTarget;
      t2.setTarget(o3.x, o3.y, o3.z), t2.xrCamera = null, t2.element.removeEventListener("load", this.onUpdateScene), t2.orientHotspots(0), e4.requestUpdate("cameraTarget"), e4.requestUpdate("maxCameraOrbit"), e4[Ov](e4.getBoundingClientRect()), requestAnimationFrame(() => {
        t2.element.dispatchEvent(new CustomEvent("camera-change", { detail: { source: dg.NONE } }));
      });
    }
    this.renderer.height = 0;
    const i2 = this.exitWebXRButtonContainer;
    null != i2 && (i2.classList.remove("enabled"), i2.removeEventListener("click", this.onExitWebXRButtonContainerClick), this.exitWebXRButtonContainer = null);
    const n2 = this.transientHitTestSource;
    null != n2 && (n2.cancel(), this.transientHitTestSource = null);
    const o2 = this.initialHitSource;
    null != o2 && (o2.cancel(), this.initialHitSource = null), null != this.placementBox && (this.placementBox.dispose(), this.placementBox = null), this.lastTick = null, this.turntableRotation = null, this.oldShadowIntensity = null, this.frame = null, this.inputSource = null, this.overlay = null, null != this.resolveCleanup && this.resolveCleanup(), this.dispatchEvent({ type: "status", status: _g });
  }
  updateView(e3) {
    const t2 = this.presentedScene, i2 = this.threeRenderer.xr;
    i2.updateCamera(xg), t2.xrCamera = i2.getCamera();
    const { elements: n2 } = t2.getCamera().matrixWorld;
    if (t2.orientHotspots(Math.atan2(n2[1], n2[5])), this.initialized || (this.placeInitially(), this.initialized = true), e3.requestViewportScale && e3.recommendedViewportScale) {
      const t3 = e3.recommendedViewportScale;
      e3.requestViewportScale(Math.max(t3, 0.25));
    }
    const o2 = i2.getBaseLayer();
    if (null != o2) {
      const t3 = o2 instanceof XRWebGLLayer ? o2.getViewport(e3) : i2.getBinding().getViewSubImage(o2, e3).viewport;
      this.threeRenderer.setViewport(t3.x, t3.y, t3.width, t3.height);
    }
  }
  placeInitially() {
    const e3 = this.presentedScene, { position: t2, element: i2 } = e3, n2 = e3.getCamera(), { width: o2, height: r2 } = this.overlay.getBoundingClientRect();
    e3.setSize(o2, r2), n2.projectionMatrixInverse.copy(n2.projectionMatrix).invert();
    const { theta: s2, radius: a2 } = i2.getCameraOrbit(), l2 = n2.getWorldDirection(bg);
    e3.yaw = Math.atan2(-l2.x, -l2.z) - s2, this.goalYaw = e3.yaw, t2.copy(n2.position).add(l2.multiplyScalar(a2)), this.updateTarget();
    const c2 = e3.getTarget();
    t2.add(c2).sub(this.oldTarget), this.goalPosition.copy(t2), e3.setHotspotsVisibility(true);
    const { session: h2 } = this.frame;
    h2.addEventListener("selectstart", this.onSelectStart), h2.addEventListener("selectend", this.onSelectEnd), h2.requestHitTestSourceForTransientInput({ profile: "generic-touchscreen" }).then((e4) => {
      this.transientHitTestSource = e4;
    });
  }
  getTouchLocation() {
    const { axes: e3 } = this.inputSource.gamepad;
    let t2 = this.placementBox.getExpandedHit(this.presentedScene, e3[0], e3[1]);
    return null != t2 && (bg.copy(t2).sub(this.presentedScene.getCamera().position), bg.length() > 10) ? null : t2;
  }
  getHitPoint(e3) {
    const t2 = this.threeRenderer.xr.getReferenceSpace(), i2 = e3.getPose(t2);
    if (null == i2)
      return null;
    const n2 = yg.fromArray(i2.transform.matrix);
    return true === this.placeOnWall && (this.goalYaw = Math.atan2(n2.elements[4], n2.elements[6])), n2.elements[5] > 0.75 !== this.placeOnWall ? wg.setFromMatrixPosition(n2) : null;
  }
  moveToFloor(e3) {
    const t2 = this.initialHitSource;
    if (null == t2)
      return;
    const i2 = e3.getHitTestResults(t2);
    if (0 == i2.length)
      return;
    const n2 = i2[0], o2 = this.getHitPoint(n2);
    null != o2 && (this.placementBox.show = true, this.isTranslating || (this.placeOnWall ? this.goalPosition.copy(o2) : this.goalPosition.y = o2.y), t2.cancel(), this.initialHitSource = null, this.dispatchEvent({ type: "status", status: mg }));
  }
  fingerPolar(e3) {
    const t2 = e3[0].inputSource.gamepad.axes, i2 = e3[1].inputSource.gamepad.axes, n2 = i2[0] - t2[0], o2 = i2[1] - t2[1], r2 = Math.atan2(o2, n2);
    let s2 = this.lastAngle - r2;
    return s2 > Math.PI ? s2 -= 2 * Math.PI : s2 < -Math.PI && (s2 += 2 * Math.PI), this.lastAngle = r2, { separation: Math.sqrt(n2 * n2 + o2 * o2), deltaYaw: s2 };
  }
  processInput(e3) {
    const t2 = this.transientHitTestSource;
    if (null == t2)
      return;
    if (!this.isTranslating && !this.isTwoFingering && !this.isRotating)
      return;
    const i2 = e3.getHitTestResultsForTransientInput(t2), n2 = this.presentedScene, o2 = n2.scale.x;
    if (this.isTwoFingering)
      if (i2.length < 2)
        this.isTwoFingering = false;
      else {
        const { separation: e4, deltaYaw: t3 } = this.fingerPolar(i2);
        if (false === this.placeOnWall && (this.goalYaw += t3), n2.canScale) {
          const t4 = e4 / this.firstRatio;
          this.goalScale = t4 < 1.3 && t4 > 0.7692307692307692 ? 1 : t4;
        }
      }
    else if (2 !== i2.length)
      if (this.isRotating) {
        const e4 = 1.5 * this.inputSource.gamepad.axes[0];
        this.goalYaw += e4 - this.lastAngle, this.lastAngle = e4;
      } else
        this.isTranslating && i2.forEach((e4) => {
          if (e4.inputSource !== this.inputSource)
            return;
          let t3 = null;
          if (e4.results.length > 0 && (t3 = this.getHitPoint(e4.results[0])), null == t3 && (t3 = this.getTouchLocation()), null != t3) {
            if (this.goalPosition.sub(this.lastDragPosition), false === this.placeOnWall) {
              const e5 = t3.y - this.lastDragPosition.y;
              if (e5 < 0) {
                this.placementBox.offsetHeight = e5 / o2, this.presentedScene.setShadowOffset(e5);
                const i3 = bg.copy(n2.getCamera().position), r2 = -e5 / (i3.y - t3.y);
                i3.multiplyScalar(r2), t3.multiplyScalar(1 - r2).add(i3);
              }
            }
            this.goalPosition.add(t3), this.lastDragPosition.copy(t3);
          }
        });
    else {
      this.isTranslating = false, this.isRotating = false, this.isTwoFingering = true;
      const { separation: e4 } = this.fingerPolar(i2);
      this.firstRatio = e4 / o2;
    }
  }
  moveScene(e3) {
    const t2 = this.presentedScene, { position: i2, yaw: n2 } = t2, o2 = t2.boundingSphere.radius, r2 = this.goalPosition, s2 = t2.scale.x, a2 = this.placementBox;
    let l2 = dg.NONE;
    if (!r2.equals(i2) || this.goalScale !== s2) {
      l2 = dg.USER_INTERACTION;
      let { x: n3, y: c2, z: h2 } = i2;
      n3 = this.xDamper.update(n3, r2.x, e3, o2), c2 = this.yDamper.update(c2, r2.y, e3, o2), h2 = this.zDamper.update(h2, r2.z, e3, o2), i2.set(n3, c2, h2);
      const u2 = this.scaleDamper.update(s2, this.goalScale, e3, 1);
      if (t2.scale.set(u2, u2, u2), !this.isTranslating) {
        const e4 = r2.y - c2;
        this.placementComplete && false === this.placeOnWall ? (a2.offsetHeight = e4 / u2, t2.setShadowOffset(e4)) : 0 === e4 && (this.placementComplete = true, a2.show = false, t2.setShadowIntensity(0.8));
      }
    }
    a2.updateOpacity(e3), t2.updateTarget(e3), t2.yaw = this.yawDamper.update(n2, this.goalYaw, e3, Math.PI), t2.element.dispatchEvent(new CustomEvent("camera-change", { detail: { source: l2 } }));
  }
  onWebXRFrame(e3, t2) {
    this.frame = t2, ++this.frames;
    const i2 = this.threeRenderer.xr.getReferenceSpace(), n2 = t2.getViewerPose(i2);
    null == n2 && true === this.tracking && this.frames > 30 && (this.tracking = false, this.dispatchEvent({ type: "tracking", status: Ag }));
    const o2 = this.presentedScene;
    if (null == n2 || null == o2 || !o2.element.loaded)
      return void this.threeRenderer.clear();
    false === this.tracking && (this.tracking = true, this.dispatchEvent({ type: "tracking", status: vg }));
    let r2 = true;
    for (const i3 of n2.views) {
      if (this.updateView(i3), r2) {
        this.moveToFloor(t2), this.processInput(t2);
        const i4 = e3 - this.lastTick;
        this.moveScene(i4), this.renderer.preRender(o2, e3, i4), this.lastTick = e3, o2.renderShadow(this.threeRenderer);
      }
      this.threeRenderer.render(o2, o2.getCamera()), r2 = false;
    }
  }
}
class Sg {
  constructor(e3) {
    e3.threeRenderer.debug = { checkShaderErrors: true }, Promise.resolve().then(() => {
      self.dispatchEvent(new CustomEvent("model-viewer-renderer-debug", { detail: { renderer: e3, THREE: { ShaderMaterial: Co, Texture: si, Mesh: fo, Scene: va, PlaneGeometry: Uo, OrthographicCamera: Ko, WebGLRenderTarget: li } } }));
    });
  }
  addScene(e3) {
    self.dispatchEvent(new CustomEvent("model-viewer-scene-added-debug", { detail: { scene: e3 } }));
  }
  removeScene(e3) {
    self.dispatchEvent(new CustomEvent("model-viewer-scene-removed-debug", { detail: { scene: e3 } }));
  }
}
function Eg(e3) {
  const t2 = /* @__PURE__ */ new Map(), i2 = /* @__PURE__ */ new Map(), n2 = e3.clone();
  return Ig(e3, n2, function(e4, n3) {
    t2.set(n3, e4), i2.set(e4, n3);
  }), n2.traverse(function(e4) {
    if (!e4.isSkinnedMesh)
      return;
    const n3 = e4, o2 = t2.get(e4), r2 = o2.skeleton.bones;
    n3.skeleton = o2.skeleton.clone(), n3.bindMatrix.copy(o2.bindMatrix), n3.skeleton.bones = r2.map(function(e5) {
      return i2.get(e5);
    }), n3.bind(n3.skeleton, n3.bindMatrix);
  }), n2;
}
function Ig(e3, t2, i2) {
  i2(e3, t2);
  for (let n2 = 0; n2 < e3.children.length; n2++)
    Ig(e3.children[n2], t2.children[n2], i2);
}
const Tg = Symbol("prepared"), Bg = Symbol("prepare"), Mg = Symbol("preparedGLTF"), kg = Symbol("clone");
class Rg {
  constructor(e3) {
    this[Mg] = e3;
  }
  static prepare(e3) {
    if (null == e3.scene)
      throw new Error("Model does not have a scene");
    if (e3[Tg])
      return e3;
    const t2 = this[Bg](e3);
    return t2[Tg] = true, t2;
  }
  static [Bg](e3) {
    const { scene: t2 } = e3, i2 = [t2];
    return Object.assign(Object.assign({}, e3), { scene: t2, scenes: i2 });
  }
  get parser() {
    return this[Mg].parser;
  }
  get animations() {
    return this[Mg].animations;
  }
  get scene() {
    return this[Mg].scene;
  }
  get scenes() {
    return this[Mg].scenes;
  }
  get cameras() {
    return this[Mg].cameras;
  }
  get asset() {
    return this[Mg].asset;
  }
  get userData() {
    return this[Mg].userData;
  }
  clone() {
    return new (0, this.constructor)(this[kg]());
  }
  dispose() {
    this.scenes.forEach((e3) => {
      e3.traverse((e4) => {
        const t2 = e4;
        if (!t2.material)
          return;
        (Array.isArray(t2.material) ? t2.material : [t2.material]).forEach((e5) => {
          for (const t3 in e5) {
            const i2 = e5[t3];
            if (i2 instanceof si) {
              const e6 = i2.source.data;
              null != e6.close && e6.close(), i2.dispose();
            }
          }
          e5.dispose();
        }), t2.geometry.dispose();
      });
    });
  }
  [kg]() {
    const e3 = this[Mg], t2 = Eg(this.scene);
    Pg(t2, this.scene);
    const i2 = [t2], n2 = e3.userData ? Object.assign({}, e3.userData) : {};
    return Object.assign(Object.assign({}, e3), { scene: t2, scenes: i2, userData: n2 });
  }
}
const Pg = (e3, t2) => {
  Dg(e3, t2, (e4, t3) => {
    void 0 !== t3.userData.variantMaterials && (e4.userData.variantMaterials = new Map(t3.userData.variantMaterials)), void 0 !== t3.userData.variantData && (e4.userData.variantData = t3.userData.variantData), void 0 !== t3.userData.originalMaterial && (e4.userData.originalMaterial = t3.userData.originalMaterial);
  });
}, Dg = (e3, t2, i2) => {
  i2(e3, t2);
  for (let n2 = 0; n2 < e3.children.length; n2++)
    Dg(e3.children[n2], t2.children[n2], i2);
}, Lg = Symbol("threeGLTF"), Fg = Symbol("gltf"), Ng = Symbol("gltfElementMap"), Og = Symbol("threeObjectMap"), zg = Symbol("parallelTraverseThreeScene"), Ug = Symbol("correlateOriginalThreeGLTF"), Hg = Symbol("correlateCloneThreeGLTF");
class Qg {
  constructor(e3, t2, i2, n2) {
    this[Lg] = e3, this[Fg] = t2, this[Ng] = n2, this[Og] = i2;
  }
  static from(e3, t2) {
    return null != t2 ? this[Hg](e3, t2) : this[Ug](e3);
  }
  static [Ug](e3) {
    const t2 = e3.parser.json, i2 = e3.parser.associations, n2 = /* @__PURE__ */ new Map(), o2 = { name: "Default" }, r2 = { type: "materials", index: -1 };
    for (const e4 of i2.keys())
      e4 instanceof Tn && null == i2.get(e4) && (r2.index < 0 && (null == t2.materials && (t2.materials = []), r2.index = t2.materials.length, t2.materials.push(o2)), e4.name = o2.name, i2.set(e4, { materials: r2.index }));
    for (const [e4, o3] of i2) {
      if (o3) {
        const t3 = e4;
        t3.userData = t3.userData || {}, t3.userData.associations = o3;
      }
      for (const i3 in o3)
        if (null != i3 && "primitives" !== i3) {
          const r3 = i3, s2 = (t2[r3] || [])[o3[r3]];
          if (null == s2)
            continue;
          let a2 = n2.get(s2);
          null == a2 && (a2 = /* @__PURE__ */ new Set(), n2.set(s2, a2)), a2.add(e4);
        }
    }
    return new Qg(e3, t2, i2, n2);
  }
  static [Hg](e3, t2) {
    const i2 = t2.threeGLTF, n2 = t2.gltf, o2 = JSON.parse(JSON.stringify(n2)), r2 = /* @__PURE__ */ new Map(), s2 = /* @__PURE__ */ new Map();
    for (let n3 = 0; n3 < i2.scenes.length; n3++)
      this[zg](i2.scenes[n3], e3.scenes[n3], (e4, i3) => {
        const n4 = t2.threeObjectMap.get(e4);
        if (null != n4) {
          for (const e5 in n4)
            if (null != e5 && "primitives" !== e5) {
              const t3 = e5, a2 = n4[t3], l2 = o2[t3][a2], c2 = r2.get(i3) || {};
              c2[t3] = a2, r2.set(i3, c2);
              const h2 = s2.get(l2) || /* @__PURE__ */ new Set();
              h2.add(i3), s2.set(l2, h2);
            }
        }
      });
    return new Qg(e3, o2, r2, s2);
  }
  static [zg](e3, t2, i2) {
    const n2 = (e4, t3) => {
      if (i2(e4, t3), e4.isObject3D) {
        const o2 = e4, r2 = t3;
        if (o2.material)
          if (Array.isArray(o2.material))
            for (let e5 = 0; e5 < o2.material.length; ++e5)
              i2(o2.material[e5], r2.material[e5]);
          else
            i2(o2.material, r2.material);
        for (let i3 = 0; i3 < e4.children.length; ++i3)
          n2(e4.children[i3], t3.children[i3]);
      }
    };
    n2(e3, t2);
  }
  get threeGLTF() {
    return this[Lg];
  }
  get gltf() {
    return this[Fg];
  }
  get gltfElementMap() {
    return this[Ng];
  }
  get threeObjectMap() {
    return this[Og];
  }
}
const Vg = Symbol("correlatedSceneGraph");
class Gg extends Rg {
  static [Bg](e3) {
    const t2 = super[Bg](e3);
    null == t2[Vg] && (t2[Vg] = Qg.from(t2));
    const { scene: i2 } = t2, n2 = new Pi(void 0, 1 / 0);
    return i2.traverse((e4) => {
      e4.renderOrder = 1e3, e4.frustumCulled = false, e4.name || (e4.name = e4.uuid);
      const i3 = e4;
      if (i3.material) {
        const { geometry: e5 } = i3;
        i3.castShadow = true, i3.isSkinnedMesh && (e5.boundingSphere = n2, e5.boundingBox = null);
        const o2 = i3.material;
        if (true === o2.isMeshBasicMaterial && (o2.toneMapped = false), o2.shadowSide = ve, o2.aoMap) {
          const { gltf: i4, threeObjectMap: n3 } = t2[Vg], r2 = n3.get(o2);
          if (null != i4.materials && null != r2 && null != r2.materials) {
            const t3 = i4.materials[r2.materials];
            t3.occlusionTexture && 0 === t3.occlusionTexture.texCoord && null != e5.attributes.uv && e5.setAttribute("uv2", e5.attributes.uv);
          }
        }
      }
    }), t2;
  }
  get correlatedSceneGraph() {
    return this[Mg][Vg];
  }
  [kg]() {
    const e3 = super[kg](), t2 = /* @__PURE__ */ new Map();
    return e3.scene.traverse((e4) => {
      const i2 = e4;
      if (i2.material) {
        const e5 = i2.material;
        if (null != e5) {
          if (t2.has(e5.uuid))
            return void (i2.material = t2.get(e5.uuid));
          i2.material = e5.clone(), t2.set(e5.uuid, i2.material);
        }
      }
    }), e3[Vg] = Qg.from(e3, this.correlatedSceneGraph), e3;
  }
}
class $g extends rc {
  constructor(e3) {
    super(e3), this.type = qe;
  }
  parse(e3) {
    const t2 = function(e4, t3) {
      switch (e4) {
        case 1:
          console.error("THREE.RGBELoader Read Error: " + (t3 || ""));
          break;
        case 2:
          console.error("THREE.RGBELoader Write Error: " + (t3 || ""));
          break;
        case 3:
          console.error("THREE.RGBELoader Bad File Format: " + (t3 || ""));
          break;
        default:
          console.error("THREE.RGBELoader: Error: " + (t3 || ""));
      }
      return -1;
    }, i2 = function(e4, t3, i3) {
      t3 = t3 || 1024;
      let n3 = e4.pos, o3 = -1, r3 = 0, s3 = "", a2 = String.fromCharCode.apply(null, new Uint16Array(e4.subarray(n3, n3 + 128)));
      for (; 0 > (o3 = a2.indexOf("\n")) && r3 < t3 && n3 < e4.byteLength; )
        s3 += a2, r3 += a2.length, n3 += 128, a2 += String.fromCharCode.apply(null, new Uint16Array(e4.subarray(n3, n3 + 128)));
      return -1 < o3 && (false !== i3 && (e4.pos += r3 + o3 + 1), s3 + a2.slice(0, o3));
    }, n2 = function(e4, t3, i3, n3) {
      const o3 = e4[t3 + 3], r3 = Math.pow(2, o3 - 128) / 255;
      i3[n3 + 0] = e4[t3 + 0] * r3, i3[n3 + 1] = e4[t3 + 1] * r3, i3[n3 + 2] = e4[t3 + 2] * r3, i3[n3 + 3] = 1;
    }, o2 = function(e4, t3, i3, n3) {
      const o3 = e4[t3 + 3], r3 = Math.pow(2, o3 - 128) / 255;
      i3[n3 + 0] = On.toHalfFloat(Math.min(e4[t3 + 0] * r3, 65504)), i3[n3 + 1] = On.toHalfFloat(Math.min(e4[t3 + 1] * r3, 65504)), i3[n3 + 2] = On.toHalfFloat(Math.min(e4[t3 + 2] * r3, 65504)), i3[n3 + 3] = On.toHalfFloat(1);
    }, r2 = new Uint8Array(e3);
    r2.pos = 0;
    const s2 = function(e4) {
      const n3 = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, o3 = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, r3 = /^\s*FORMAT=(\S+)\s*$/, s3 = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, a2 = { valid: 0, string: "", comments: "", programtype: "RGBE", format: "", gamma: 1, exposure: 1, width: 0, height: 0 };
      let l2, c2;
      if (e4.pos >= e4.byteLength || !(l2 = i2(e4)))
        return t2(1, "no header found");
      if (!(c2 = l2.match(/^#\?(\S+)/)))
        return t2(3, "bad initial token");
      for (a2.valid |= 1, a2.programtype = c2[1], a2.string += l2 + "\n"; l2 = i2(e4), false !== l2; )
        if (a2.string += l2 + "\n", "#" !== l2.charAt(0)) {
          if ((c2 = l2.match(n3)) && (a2.gamma = parseFloat(c2[1])), (c2 = l2.match(o3)) && (a2.exposure = parseFloat(c2[1])), (c2 = l2.match(r3)) && (a2.valid |= 2, a2.format = c2[1]), (c2 = l2.match(s3)) && (a2.valid |= 4, a2.height = parseInt(c2[1], 10), a2.width = parseInt(c2[2], 10)), 2 & a2.valid && 4 & a2.valid)
            break;
        } else
          a2.comments += l2 + "\n";
      return 2 & a2.valid ? 4 & a2.valid ? a2 : t2(3, "missing image size specifier") : t2(3, "missing format specifier");
    }(r2);
    if (-1 !== s2) {
      const e4 = s2.width, i3 = s2.height, a2 = function(e5, i4, n3) {
        const o3 = i4;
        if (o3 < 8 || o3 > 32767 || 2 !== e5[0] || 2 !== e5[1] || 128 & e5[2])
          return new Uint8Array(e5);
        if (o3 !== (e5[2] << 8 | e5[3]))
          return t2(3, "wrong scanline width");
        const r3 = new Uint8Array(4 * i4 * n3);
        if (!r3.length)
          return t2(4, "unable to allocate buffer space");
        let s3 = 0, a3 = 0;
        const l2 = 4 * o3, c2 = new Uint8Array(4), h2 = new Uint8Array(l2);
        let u2 = n3;
        for (; u2 > 0 && a3 < e5.byteLength; ) {
          if (a3 + 4 > e5.byteLength)
            return t2(1);
          if (c2[0] = e5[a3++], c2[1] = e5[a3++], c2[2] = e5[a3++], c2[3] = e5[a3++], 2 != c2[0] || 2 != c2[1] || (c2[2] << 8 | c2[3]) != o3)
            return t2(3, "bad rgbe scanline format");
          let i5, n4 = 0;
          for (; n4 < l2 && a3 < e5.byteLength; ) {
            i5 = e5[a3++];
            const o4 = i5 > 128;
            if (o4 && (i5 -= 128), 0 === i5 || n4 + i5 > l2)
              return t2(3, "bad scanline data");
            if (o4) {
              const t3 = e5[a3++];
              for (let e6 = 0; e6 < i5; e6++)
                h2[n4++] = t3;
            } else
              h2.set(e5.subarray(a3, a3 + i5), n4), n4 += i5, a3 += i5;
          }
          const d2 = o3;
          for (let e6 = 0; e6 < d2; e6++) {
            let t3 = 0;
            r3[s3] = h2[e6 + t3], t3 += o3, r3[s3 + 1] = h2[e6 + t3], t3 += o3, r3[s3 + 2] = h2[e6 + t3], t3 += o3, r3[s3 + 3] = h2[e6 + t3], s3 += 4;
          }
          u2--;
        }
        return r3;
      }(r2.subarray(r2.pos), e4, i3);
      if (-1 !== a2) {
        let t3, r3, l2;
        switch (this.type) {
          case We:
            l2 = a2.length / 4;
            const e5 = new Float32Array(4 * l2);
            for (let t4 = 0; t4 < l2; t4++)
              n2(a2, 4 * t4, e5, 4 * t4);
            t3 = e5, r3 = We;
            break;
          case qe:
            l2 = a2.length / 4;
            const i4 = new Uint16Array(4 * l2);
            for (let e6 = 0; e6 < l2; e6++)
              o2(a2, 4 * e6, i4, 4 * e6);
            t3 = i4, r3 = qe;
            break;
          default:
            console.error("THREE.RGBELoader: unsupported type: ", this.type);
        }
        return { width: e4, height: i3, data: t3, header: s2.string, gamma: s2.gamma, exposure: s2.exposure, type: r3 };
      }
    }
    return null;
  }
  setDataType(e3) {
    return this.type = e3, this;
  }
  load(e3, t2, i2, n2) {
    return super.load(e3, function(e4, i3) {
      switch (e4.type) {
        case We:
        case qe:
          e4.encoding = At, e4.minFilter = He, e4.magFilter = He, e4.generateMipmaps = false, e4.flipY = true;
      }
      t2 && t2(e4, i3);
    }, i2, n2);
  }
}
class Wg extends va {
  constructor() {
    super(), this.position.y = -3.5;
    const e3 = new Ao();
    e3.deleteAttribute("uv");
    const t2 = new Tl({ metalness: 0, side: Ae }), i2 = new Tl({ metalness: 0 }), n2 = new vc(16777215, 500, 28, 2);
    n2.position.set(0.418, 16.199, 0.3), this.add(n2);
    const o2 = new fo(e3, t2);
    o2.position.set(-0.757, 13.219, 0.717), o2.scale.set(31.713, 28.305, 28.591), this.add(o2);
    const r2 = new fo(e3, i2);
    r2.position.set(-10.906, 2.009, 1.846), r2.rotation.set(0, -0.195, 0), r2.scale.set(2.328, 7.905, 4.651), this.add(r2);
    const s2 = new fo(e3, i2);
    s2.position.set(-5.607, -0.754, -0.758), s2.rotation.set(0, 0.994, 0), s2.scale.set(1.97, 1.534, 3.955), this.add(s2);
    const a2 = new fo(e3, i2);
    a2.position.set(6.167, 0.857, 7.803), a2.rotation.set(0, 0.561, 0), a2.scale.set(3.927, 6.285, 3.687), this.add(a2);
    const l2 = new fo(e3, i2);
    l2.position.set(-2.017, 0.018, 6.124), l2.rotation.set(0, 0.333, 0), l2.scale.set(2.002, 4.566, 2.064), this.add(l2);
    const c2 = new fo(e3, i2);
    c2.position.set(2.291, -0.756, -2.621), c2.rotation.set(0, -0.286, 0), c2.scale.set(1.546, 1.552, 1.496), this.add(c2);
    const h2 = new fo(e3, i2);
    h2.position.set(-2.193, -0.369, -5.547), h2.rotation.set(0, 0.516, 0), h2.scale.set(3.875, 3.487, 2.986), this.add(h2);
    const u2 = new fo(e3, this.createAreaLightMaterial(50));
    u2.position.set(-16.116, 14.37, 8.208), u2.scale.set(0.1, 2.428, 2.739), this.add(u2);
    const d2 = new fo(e3, this.createAreaLightMaterial(50));
    d2.position.set(-16.109, 18.021, -8.207), d2.scale.set(0.1, 2.425, 2.751), this.add(d2);
    const p2 = new fo(e3, this.createAreaLightMaterial(17));
    p2.position.set(14.904, 12.198, -1.832), p2.scale.set(0.15, 4.265, 6.331), this.add(p2);
    const _2 = new fo(e3, this.createAreaLightMaterial(43));
    _2.position.set(-0.462, 8.89, 14.52), _2.scale.set(4.38, 5.441, 0.088), this.add(_2);
    const g2 = new fo(e3, this.createAreaLightMaterial(20));
    g2.position.set(3.235, 11.486, -12.541), g2.scale.set(2.5, 2, 0.1), this.add(g2);
    const m2 = new fo(e3, this.createAreaLightMaterial(100));
    m2.position.set(0, 20, 0), m2.scale.set(1, 0.1, 1), this.add(m2);
  }
  createAreaLightMaterial(e3) {
    const t2 = new Ln();
    return t2.color.setScalar(e3), t2;
  }
}
class qg extends va {
  constructor() {
    super(), this.position.y = -3.5;
    const e3 = new Ao();
    e3.deleteAttribute("uv");
    const t2 = new Tl({ metalness: 0, side: Ae }), i2 = new Tl({ metalness: 0 }), n2 = new vc(16777215, 400, 28, 2);
    n2.position.set(0.5, 14, 0.5), this.add(n2);
    const o2 = new fo(e3, t2);
    o2.position.set(0, 13.2, 0), o2.scale.set(31.5, 28.5, 31.5), this.add(o2);
    const r2 = new fo(e3, i2);
    r2.position.set(-10.906, -1, 1.846), r2.rotation.set(0, -0.195, 0), r2.scale.set(2.328, 7.905, 4.651), this.add(r2);
    const s2 = new fo(e3, i2);
    s2.position.set(-5.607, -0.754, -0.758), s2.rotation.set(0, 0.994, 0), s2.scale.set(1.97, 1.534, 3.955), this.add(s2);
    const a2 = new fo(e3, i2);
    a2.position.set(6.167, -0.16, 7.803), a2.rotation.set(0, 0.561, 0), a2.scale.set(3.927, 6.285, 3.687), this.add(a2);
    const l2 = new fo(e3, i2);
    l2.position.set(-2.017, 0.018, 6.124), l2.rotation.set(0, 0.333, 0), l2.scale.set(2.002, 4.566, 2.064), this.add(l2);
    const c2 = new fo(e3, i2);
    c2.position.set(2.291, -0.756, -2.621), c2.rotation.set(0, -0.286, 0), c2.scale.set(1.546, 1.552, 1.496), this.add(c2);
    const h2 = new fo(e3, i2);
    h2.position.set(-2.193, -0.369, -5.547), h2.rotation.set(0, 0.516, 0), h2.scale.set(3.875, 3.487, 2.986), this.add(h2);
    const u2 = new fo(e3, this.createAreaLightMaterial(80));
    u2.position.set(-14, 10, 8), u2.scale.set(0.1, 2.5, 2.5), this.add(u2);
    const d2 = new fo(e3, this.createAreaLightMaterial(80));
    d2.position.set(-14, 14, -4), d2.scale.set(0.1, 2.5, 2.5), this.add(d2);
    const p2 = new fo(e3, this.createAreaLightMaterial(23));
    p2.position.set(14, 12, 0), p2.scale.set(0.1, 5, 5), this.add(p2);
    const _2 = new fo(e3, this.createAreaLightMaterial(16));
    _2.position.set(0, 9, 14), _2.scale.set(5, 5, 0.1), this.add(_2);
    const g2 = new fo(e3, this.createAreaLightMaterial(80));
    g2.position.set(7, 8, -14), g2.scale.set(2.5, 2.5, 0.1), this.add(g2);
    const m2 = new fo(e3, this.createAreaLightMaterial(80));
    m2.position.set(-7, 16, -14), m2.scale.set(2.5, 2.5, 0.1), this.add(m2);
    const f2 = new fo(e3, this.createAreaLightMaterial(1));
    f2.position.set(0, 20, 0), f2.scale.set(0.1, 0.1, 0.1), this.add(f2);
  }
  createAreaLightMaterial(e3) {
    const t2 = new Ln();
    return t2.color.setScalar(e3), t2;
  }
}
const jg = 20, Xg = /\.hdr(\.js)?$/;
class Yg extends Tt {
  constructor(e3) {
    super(), this.threeRenderer = e3, this.lottieLoaderUrl = "", this.withCredentials = false, this._ldrLoader = null, this._hdrLoader = null, this._lottieLoader = null, this.generatedEnvironmentMap = null, this.generatedEnvironmentMapAlt = null, this.skyboxCache = /* @__PURE__ */ new Map(), this.blurMaterial = null, this.blurScene = null;
  }
  get ldrLoader() {
    return null == this._ldrLoader && (this._ldrLoader = new sc()), this._ldrLoader.setWithCredentials(this.withCredentials), this._ldrLoader;
  }
  get hdrLoader() {
    return null == this._hdrLoader && (this._hdrLoader = new $g(), this._hdrLoader.setDataType(qe)), this._hdrLoader.setWithCredentials(this.withCredentials), this._hdrLoader;
  }
  async getLottieLoader() {
    if (null == this._lottieLoader) {
      const { LottieLoader: e3 } = await import(this.lottieLoaderUrl);
      this._lottieLoader = new e3();
    }
    return this._lottieLoader.setWithCredentials(this.withCredentials), this._lottieLoader;
  }
  async loadImage(e3) {
    const t2 = await new Promise((t3, i2) => this.ldrLoader.load(e3, t3, () => {
    }, i2));
    return t2.name = e3, t2.flipY = false, t2;
  }
  async loadLottie(e3, t2) {
    const i2 = await this.getLottieLoader();
    i2.setQuality(t2);
    const n2 = await new Promise((t3, n3) => i2.load(e3, t3, () => {
    }, n3));
    return n2.name = e3, n2;
  }
  async loadEquirect(e3, t2 = () => {
  }) {
    try {
      const i2 = Xg.test(e3), n2 = i2 ? this.hdrLoader : this.ldrLoader, o2 = await new Promise((i3, o3) => n2.load(e3, i3, (e4) => {
        t2(e4.loaded / e4.total * 0.9);
      }, o3));
      return t2(1), o2.name = e3, o2.mapping = Pe, i2 || (o2.encoding = bt), o2;
    } finally {
      t2 && t2(1);
    }
  }
  async generateEnvironmentMapAndSkybox(e3 = null, t2 = null, i2 = () => {
  }) {
    const n2 = "legacy" !== t2;
    "legacy" !== t2 && "neutral" !== t2 || (t2 = null), t2 = ih(t2);
    let o2, r2 = Promise.resolve(null);
    e3 && (r2 = this.loadEquirectFromUrl(e3, i2)), o2 = t2 ? this.loadEquirectFromUrl(t2, i2) : e3 ? this.loadEquirectFromUrl(e3, i2) : n2 ? this.loadGeneratedEnvironmentMapAlt() : this.loadGeneratedEnvironmentMap();
    const [s2, a2] = await Promise.all([o2, r2]);
    if (null == s2)
      throw new Error("Failed to load environment map.");
    return { environmentMap: s2, skybox: a2 };
  }
  async loadEquirectFromUrl(e3, t2) {
    if (!this.skyboxCache.has(e3)) {
      const i2 = this.loadEquirect(e3, t2);
      this.skyboxCache.set(e3, i2);
    }
    return this.skyboxCache.get(e3);
  }
  async GenerateEnvironmentMap(e3, t2) {
    await ((e4 = 0) => new Promise((t3) => setTimeout(t3, e4)))();
    const i2 = this.threeRenderer, n2 = new Mo(256, { generateMipmaps: false, type: qe, format: Xe, encoding: At, depthBuffer: true }), o2 = new To(0.1, 100, n2), r2 = o2.renderTarget.texture;
    r2.name = t2;
    const s2 = i2.outputEncoding, a2 = i2.toneMapping;
    return i2.toneMapping = Se, i2.outputEncoding = At, o2.update(i2, e3), this.blurCubemap(n2, 0.04), i2.toneMapping = a2, i2.outputEncoding = s2, r2;
  }
  async loadGeneratedEnvironmentMap() {
    return null == this.generatedEnvironmentMap && (this.generatedEnvironmentMap = this.GenerateEnvironmentMap(new Wg(), "legacy")), this.generatedEnvironmentMap;
  }
  async loadGeneratedEnvironmentMapAlt() {
    return null == this.generatedEnvironmentMapAlt && (this.generatedEnvironmentMapAlt = this.GenerateEnvironmentMap(new qg(), "neutral")), this.generatedEnvironmentMapAlt;
  }
  blurCubemap(e3, t2) {
    if (null == this.blurMaterial) {
      this.blurMaterial = this.getBlurShader(jg);
      const e4 = new Ao(), t3 = new fo(e4, this.blurMaterial);
      this.blurScene = new va(), this.blurScene.add(t3);
    }
    const i2 = e3.clone();
    this.halfblur(e3, i2, t2, "latitudinal"), this.halfblur(i2, e3, t2, "longitudinal");
  }
  halfblur(e3, t2, i2, n2) {
    const o2 = e3.width, r2 = isFinite(i2) ? Math.PI / (2 * o2) : 2 * Math.PI / 39, s2 = i2 / r2, a2 = isFinite(i2) ? 1 + Math.floor(3 * s2) : jg;
    a2 > jg && console.warn(`sigmaRadians, ${i2}, is too large and will clip, as it requested ${a2} samples when the maximum is set to 20`);
    const l2 = [];
    let c2 = 0;
    for (let e4 = 0; e4 < jg; ++e4) {
      const t3 = e4 / s2, i3 = Math.exp(-t3 * t3 / 2);
      l2.push(i3), 0 == e4 ? c2 += i3 : e4 < a2 && (c2 += 2 * i3);
    }
    for (let e4 = 0; e4 < l2.length; e4++)
      l2[e4] = l2[e4] / c2;
    const h2 = this.blurMaterial.uniforms;
    h2.envMap.value = e3.texture, h2.samples.value = a2, h2.weights.value = l2, h2.latitudinal.value = "latitudinal" === n2, h2.dTheta.value = r2;
    new To(0.1, 100, t2).update(this.threeRenderer, this.blurScene);
  }
  getBlurShader(e3) {
    const t2 = new Float32Array(e3), i2 = new di(0, 1, 0);
    return new Co({ name: "SphericalGaussianBlur", defines: { n: e3 }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: t2 }, latitudinal: { value: false }, dTheta: { value: 0 }, poleAxis: { value: i2 } }, vertexShader: "\n      \n      varying vec3 vOutputDirection;\n  \n      void main() {\n  \n        vOutputDirection = vec3( position );\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  \n      }\n    ", fragmentShader: "\n        varying vec3 vOutputDirection;\n  \n        uniform samplerCube envMap;\n        uniform int samples;\n        uniform float weights[ n ];\n        uniform bool latitudinal;\n        uniform float dTheta;\n        uniform vec3 poleAxis;\n  \n        vec3 getSample( float theta, vec3 axis ) {\n  \n          float cosTheta = cos( theta );\n          // Rodrigues' axis-angle rotation\n          vec3 sampleDirection = vOutputDirection * cosTheta\n            + cross( axis, vOutputDirection ) * sin( theta )\n            + axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n  \n          return vec3( textureCube( envMap, sampleDirection ) );\n  \n        }\n  \n        void main() {\n  \n          vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n  \n          if ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n  \n            axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n  \n          }\n  \n          axis = normalize( axis );\n  \n          gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n          gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n  \n          for ( int i = 1; i < n; i++ ) {\n  \n            if ( i >= samples ) {\n  \n              break;\n  \n            }\n  \n            float theta = dTheta * float( i );\n            gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n            gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n  \n          }\n        }\n      ", blending: 0, depthTest: false, depthWrite: false, side: Ae });
  }
  async dispose() {
    for (const [, e3] of this.skyboxCache) {
      (await e3).dispose();
    }
    null != this.generatedEnvironmentMap && ((await this.generatedEnvironmentMap).dispose(), this.generatedEnvironmentMap = null), null != this.generatedEnvironmentMapAlt && ((await this.generatedEnvironmentMapAlt).dispose(), this.generatedEnvironmentMapAlt = null), null != this.blurMaterial && this.blurMaterial.dispose();
  }
}
const Kg = [1, 0.79, 0.62, 0.5, 0.4, 0.31, 0.25], Zg = "high-performance";
class Jg extends Tt {
  constructor(e3) {
    super(), this.loader = new nd(Gg), this.width = 0, this.height = 0, this.dpr = 1, this.debugger = null, this.scenes = /* @__PURE__ */ new Set(), this.multipleScenesVisible = false, this.lastTick = performance.now(), this.renderedLastFrame = false, this.scaleStep = 0, this.lastStep = 3, this.avgFrameDuration = 50, this.onWebGLContextLost = (e4) => {
      this.dispatchEvent({ type: "contextlost", sourceEvent: e4 });
    }, this.onWebGLContextRestored = () => {
      var e4;
      null === (e4 = this.textureUtils) || void 0 === e4 || e4.dispose(), this.textureUtils = new Yg(this.threeRenderer);
      for (const e5 of this.scenes)
        e5.element[dh]();
    }, this.dpr = ah(), this.canvas3D = document.createElement("canvas"), this.canvas3D.id = "webgl-canvas", this.canvas3D.classList.add("show");
    try {
      this.threeRenderer = new fa({ canvas: this.canvas3D, alpha: true, antialias: true, powerPreference: e3.powerPreference, preserveDrawingBuffer: true }), this.threeRenderer.autoClear = true, this.threeRenderer.outputEncoding = bt, this.threeRenderer.useLegacyLights = false, this.threeRenderer.setPixelRatio(1), this.debugger = e3.debug ? new Sg(this) : null, this.threeRenderer.debug = { checkShaderErrors: !!this.debugger }, this.threeRenderer.toneMapping = Be;
    } catch (e4) {
      console.warn(e4);
    }
    this.arRenderer = new Cg(this), this.textureUtils = this.canRender ? new Yg(this.threeRenderer) : null, nd.initializeKTX2Loader(this.threeRenderer), this.canvas3D.addEventListener("webglcontextlost", this.onWebGLContextLost), this.canvas3D.addEventListener("webglcontextrestored", this.onWebGLContextRestored), this.updateRendererSize();
  }
  static get singleton() {
    return this._singleton;
  }
  static resetSingleton() {
    const e3 = this._singleton.dispose();
    for (const t2 of e3)
      t2.disconnectedCallback();
    this._singleton = new Jg({ powerPreference: (self.ModelViewerElement || {}).powerPreference || Zg, debug: lh() });
    for (const t2 of e3)
      t2.connectedCallback();
  }
  get canRender() {
    return null != this.threeRenderer;
  }
  get scaleFactor() {
    return Kg[this.scaleStep];
  }
  set minScale(e3) {
    let t2 = 1;
    for (; t2 < Kg.length && !(Kg[t2] < e3); )
      ++t2;
    this.lastStep = t2 - 1;
  }
  registerScene(e3) {
    this.scenes.add(e3), e3.forceRescale();
    const t2 = new Vt();
    this.threeRenderer.getSize(t2), e3.canvas.width = t2.x, e3.canvas.height = t2.y, this.canRender && this.scenes.size > 0 && this.threeRenderer.setAnimationLoop((e4, t3) => this.render(e4, t3)), null != this.debugger && this.debugger.addScene(e3);
  }
  unregisterScene(e3) {
    this.scenes.delete(e3), this.canvas3D.parentElement === e3.canvas.parentElement && e3.canvas.parentElement.removeChild(this.canvas3D), this.canRender && 0 === this.scenes.size && this.threeRenderer.setAnimationLoop(null), null != this.debugger && this.debugger.removeScene(e3);
  }
  displayCanvas(e3) {
    return this.multipleScenesVisible ? e3.element[Pv] : this.canvas3D;
  }
  countVisibleScenes() {
    const { canvas3D: e3 } = this;
    let t2 = 0, i2 = null;
    for (const n3 of this.scenes) {
      const { element: o2 } = n3;
      o2.modelIsVisible && null == n3.externalRenderer && ++t2, e3.parentElement === n3.canvas.parentElement && (i2 = n3);
    }
    const n2 = t2 > 1;
    if (null != i2) {
      const t3 = n2 && !this.multipleScenesVisible, o2 = !i2.element.modelIsVisible;
      if (t3 || o2) {
        const { width: t4, height: n3 } = this.sceneSize(i2);
        this.copyPixels(i2, t4, n3), e3.parentElement.removeChild(e3);
      }
    }
    this.multipleScenesVisible = n2;
  }
  updateRendererSize() {
    const e3 = ah();
    if (e3 !== this.dpr)
      for (const e4 of this.scenes) {
        const { element: t3 } = e4;
        t3[bv](t3.getBoundingClientRect());
      }
    let t2 = 0, i2 = 0;
    for (const e4 of this.scenes)
      t2 = Math.max(t2, e4.width), i2 = Math.max(i2, e4.height);
    if (t2 !== this.width || i2 !== this.height || e3 !== this.dpr) {
      this.width = t2, this.height = i2, this.dpr = e3, t2 = Math.ceil(t2 * e3), i2 = Math.ceil(i2 * e3), this.canRender && this.threeRenderer.setSize(t2, i2, false);
      for (const e4 of this.scenes) {
        const { canvas: n2 } = e4;
        n2.width = t2, n2.height = i2, e4.forceRescale();
      }
    }
  }
  updateRendererScale(e3) {
    const t2 = this.scaleStep;
    this.avgFrameDuration += sh(0.2 * (e3 - this.avgFrameDuration), -5, 5), this.avgFrameDuration > 60 ? ++this.scaleStep : this.avgFrameDuration < 40 && this.scaleStep > 0 && --this.scaleStep, this.scaleStep = Math.min(this.scaleStep, this.lastStep), t2 !== this.scaleStep && (this.avgFrameDuration = 50);
  }
  shouldRender(e3) {
    if (e3.shouldRender())
      e3.scaleStep != this.scaleStep && (e3.scaleStep = this.scaleStep, this.rescaleCanvas(e3));
    else {
      if (0 == e3.scaleStep)
        return false;
      e3.scaleStep = 0, this.rescaleCanvas(e3);
    }
    return true;
  }
  rescaleCanvas(e3) {
    const t2 = Kg[e3.scaleStep], i2 = Math.ceil(this.width / t2), n2 = Math.ceil(this.height / t2), { style: o2 } = e3.canvas;
    o2.width = `${i2}px`, o2.height = `${n2}px`, this.canvas3D.style.width = `${i2}px`, this.canvas3D.style.height = `${n2}px`;
    const r2 = this.dpr * t2, s2 = t2 < 1 ? "GPU throttling" : this.dpr !== window.devicePixelRatio ? "No meta viewport tag" : "";
    e3.element.dispatchEvent(new CustomEvent("render-scale", { detail: { reportedDpr: window.devicePixelRatio, renderedDpr: r2, minimumDpr: this.dpr * Kg[this.lastStep], pixelWidth: Math.ceil(e3.width * r2), pixelHeight: Math.ceil(e3.height * r2), reason: s2 } }));
  }
  sceneSize(e3) {
    const { dpr: t2 } = this, i2 = Kg[e3.scaleStep];
    return { width: Math.min(Math.ceil(e3.width * i2 * t2), this.canvas3D.width), height: Math.min(Math.ceil(e3.height * i2 * t2), this.canvas3D.height) };
  }
  copyPixels(e3, t2, i2) {
    const n2 = e3.context;
    null != n2 ? (n2.clearRect(0, 0, t2, i2), n2.drawImage(this.canvas3D, 0, 0, t2, i2, 0, 0, t2, i2), e3.canvas.classList.add("show")) : console.log("could not acquire 2d context");
  }
  orderedScenes() {
    const e3 = [];
    for (const t2 of [false, true])
      for (const i2 of this.scenes)
        i2.element.modelIsVisible === t2 && e3.push(i2);
    return e3;
  }
  get isPresenting() {
    return this.arRenderer.isPresenting;
  }
  preRender(e3, t2, i2) {
    const { element: n2, exposure: o2 } = e3;
    n2[Fv](t2, i2);
    const r2 = "number" == typeof o2 && !Number.isNaN(o2);
    this.threeRenderer.toneMappingExposure = r2 ? o2 : 1;
  }
  render(e3, t2) {
    if (null != t2)
      return void this.arRenderer.onWebXRFrame(e3, t2);
    const i2 = e3 - this.lastTick;
    if (this.lastTick = e3, !this.canRender || this.isPresenting)
      return;
    this.countVisibleScenes(), this.updateRendererSize(), this.renderedLastFrame && (this.updateRendererScale(i2), this.renderedLastFrame = false);
    const { canvas3D: n2 } = this;
    for (const t3 of this.orderedScenes()) {
      const { element: o2 } = t3;
      if (!o2.loaded || !o2.modelIsVisible && t3.renderCount > 0)
        continue;
      if (this.preRender(t3, e3, i2), !this.shouldRender(t3))
        continue;
      if (null != t3.externalRenderer) {
        const e4 = t3.getCamera();
        e4.updateMatrix();
        const { matrix: i3, projectionMatrix: n3 } = e4, o3 = i3.elements.slice(), r3 = t3.getTarget();
        o3[12] += r3.x, o3[13] += r3.y, o3[14] += r3.z, t3.externalRenderer.render({ viewMatrix: o3, projectionMatrix: n3.elements });
        continue;
      }
      if (!o2.modelIsVisible && !this.multipleScenesVisible)
        for (const e4 of this.scenes)
          e4.element.modelIsVisible && e4.queueRender();
      const { width: r2, height: s2 } = this.sceneSize(t3);
      t3.renderShadow(this.threeRenderer), this.threeRenderer.setRenderTarget(null), this.threeRenderer.setViewport(0, Math.ceil(this.height * this.dpr) - s2, r2, s2), this.threeRenderer.render(t3, t3.camera), this.multipleScenesVisible || !t3.element.modelIsVisible && 0 === t3.renderCount ? this.copyPixels(t3, r2, s2) : n2.parentElement !== t3.canvas.parentElement && (t3.canvas.parentElement.appendChild(n2), t3.canvas.classList.remove("show")), t3.hasRendered(), ++t3.renderCount, this.renderedLastFrame = true;
    }
  }
  dispose() {
    null != this.textureUtils && this.textureUtils.dispose(), null != this.threeRenderer && this.threeRenderer.dispose(), this.textureUtils = null, this.threeRenderer = null;
    const e3 = [];
    for (const t2 of this.scenes)
      e3.push(t2.element);
    return this.canvas3D.removeEventListener("webglcontextlost", this.onWebGLContextLost), this.canvas3D.removeEventListener("webglcontextrestored", this.onWebGLContextRestored), e3;
  }
}
Jg._singleton = new Jg({ powerPreference: (self.ModelViewerElement || {}).powerPreference || Zg, debug: lh() });
const em = Symbol("correlatedObjects"), tm = Symbol("sourceObject"), im = Symbol("onUpdate");
class nm {
  constructor(e3, t2, i2 = null) {
    this[im] = e3, this[tm] = t2, this[em] = i2;
  }
}
const om = new Ln(), rm = new Uo(2, 2);
let sm = 0;
const am = Symbol("threeTexture");
let lm = class extends nm {
  get [am]() {
    var e3;
    return console.assert(null != this[em] && this[em].size > 0, "Image correlated object is undefined"), null === (e3 = this[em]) || void 0 === e3 ? void 0 : e3.values().next().value;
  }
  constructor(e3, t2, i2) {
    super(e3, i2 = null != i2 ? i2 : { name: t2 && t2.image && t2.image.src ? t2.image.src.split("/").pop() : "adhoc_image", uri: t2 && t2.image && t2.image.src ? t2.image.src : "adhoc_image" + sm++ }, new Set(t2 ? [t2] : []));
  }
  get name() {
    return this[tm].name || "";
  }
  get uri() {
    return this[tm].uri;
  }
  get bufferView() {
    return this[tm].bufferView;
  }
  get element() {
    const e3 = this[am];
    if (e3 && (e3.isCanvasTexture || e3.isVideoTexture))
      return e3.image;
  }
  get animation() {
    const e3 = this[am];
    if (e3 && e3.isCanvasTexture && e3.animation)
      return e3.animation;
  }
  get type() {
    return null != this.uri ? "external" : "embedded";
  }
  set name(e3) {
    this[tm].name = e3;
  }
  update() {
    const e3 = this[am];
    e3 && e3.isCanvasTexture && !e3.animation && (this[am].needsUpdate = true, this[im]());
  }
  async createThumbnail(e3, t2) {
    const i2 = new va();
    om.map = this[am];
    const n2 = new fo(rm, om);
    i2.add(n2);
    const o2 = new Ko(-1, 1, 1, -1, 0, 1), { threeRenderer: r2 } = Jg.singleton, s2 = new li(e3, t2);
    r2.setRenderTarget(s2), r2.render(i2, o2), r2.setRenderTarget(null);
    const a2 = new Uint8Array(e3 * t2 * 4);
    r2.readRenderTargetPixels(s2, 0, 0, e3, t2, a2), hv.width = e3, hv.height = t2;
    const l2 = hv.getContext("2d"), c2 = l2.createImageData(e3, t2);
    return c2.data.set(a2), l2.putImageData(c2, 0, 0), new Promise(async (e4, t3) => {
      hv.toBlob((i3) => {
        if (!i3)
          return t3("Failed to capture thumbnail.");
        e4(URL.createObjectURL(i3));
      }, "image/png");
    });
  }
};
var cm, hm;
!function(e3) {
  e3[e3.Nearest = 9728] = "Nearest", e3[e3.Linear = 9729] = "Linear", e3[e3.NearestMipmapNearest = 9984] = "NearestMipmapNearest", e3[e3.LinearMipmapNearest = 9985] = "LinearMipmapNearest", e3[e3.NearestMipmapLinear = 9986] = "NearestMipmapLinear", e3[e3.LinearMipmapLinear = 9987] = "LinearMipmapLinear";
}(cm || (cm = {})), function(e3) {
  e3[e3.ClampToEdge = 33071] = "ClampToEdge", e3[e3.MirroredRepeat = 33648] = "MirroredRepeat", e3[e3.Repeat = 10497] = "Repeat";
}(hm || (hm = {}));
const um = (() => {
  const e3 = [cm.Nearest, cm.Linear, cm.NearestMipmapNearest, cm.LinearMipmapLinear, cm.NearestMipmapLinear, cm.LinearMipmapLinear];
  return (t2) => e3.indexOf(t2) > -1;
})(), dm = (() => {
  const e3 = [cm.Nearest, cm.Linear];
  return (t2) => e3.indexOf(t2) > -1;
})(), pm = (() => {
  const e3 = [hm.ClampToEdge, hm.MirroredRepeat, hm.Repeat];
  return (t2) => e3.indexOf(t2) > -1;
})(), _m = Symbol("threeTextures"), gm = Symbol("setProperty"), mm = Symbol("sourceSampler");
class fm extends nm {
  get [_m]() {
    return console.assert(null != this[em] && this[em].size > 0, "Sampler correlated object is undefined"), this[em];
  }
  get [mm]() {
    return console.assert(null != this[tm], "Sampler source is undefined"), this[tm];
  }
  constructor(e3, t2, i2) {
    null == (i2 = null != i2 ? i2 : {}).minFilter && (i2.minFilter = t2 ? t2.minFilter : cm.LinearMipmapLinear), null == i2.magFilter && (i2.magFilter = t2 ? t2.magFilter : cm.Linear), null == i2.wrapS && (i2.wrapS = t2 ? t2.wrapS : hm.Repeat), null == i2.wrapT && (i2.wrapT = t2 ? t2.wrapT : hm.Repeat), super(e3, i2, new Set(t2 ? [t2] : []));
  }
  get name() {
    return this[tm].name || "";
  }
  get minFilter() {
    return this[mm].minFilter;
  }
  get magFilter() {
    return this[mm].magFilter;
  }
  get wrapS() {
    return this[mm].wrapS;
  }
  get wrapT() {
    return this[mm].wrapT;
  }
  setMinFilter(e3) {
    this[gm]("minFilter", e3);
  }
  setMagFilter(e3) {
    this[gm]("magFilter", e3);
  }
  setWrapS(e3) {
    this[gm]("wrapS", e3);
  }
  setWrapT(e3) {
    this[gm]("wrapT", e3);
  }
  [gm](e3, t2) {
    const i2 = this[mm];
    if (null != i2) {
      if (((e4, t3) => {
        switch (e4) {
          case "minFilter":
            return um(t3);
          case "magFilter":
            return dm(t3);
          case "wrapS":
          case "wrapT":
            return pm(t3);
          default:
            throw new Error(`Cannot configure property "${e4}" on Sampler`);
        }
      })(e3, t2)) {
        i2[e3] = t2;
        for (const i3 of this[_m])
          i3[e3] = t2, i3.needsUpdate = true;
      }
      this[im]();
    }
  }
}
const vm = Symbol("image"), Am = Symbol("sampler");
class bm extends nm {
  constructor(e3, t2, i2 = null, n2 = null, o2 = null) {
    super(e3, i2 || {}, new Set(t2 ? [t2] : [])), this[Am] = new fm(e3, t2, n2), this[vm] = new lm(e3, t2, o2);
  }
  get name() {
    return this[tm].name || "";
  }
  set name(e3) {
    this[tm].name = e3;
  }
  get sampler() {
    return this[Am];
  }
  get source() {
    return this[vm];
  }
}
var ym, wm, xm;
const Cm = Symbol("texture"), Sm = Symbol("transform"), Em = Symbol("materials"), Im = Symbol("usage"), Tm = Symbol("onUpdate"), Bm = Symbol("activeVideo");
var Mm;
!function(e3) {
  e3[e3.Base = 0] = "Base", e3[e3.MetallicRoughness = 1] = "MetallicRoughness", e3[e3.Normal = 2] = "Normal", e3[e3.Occlusion = 3] = "Occlusion", e3[e3.Emissive = 4] = "Emissive";
}(Mm || (Mm = {}));
class km {
  constructor(e3, t2, i2, n2, o2, r2) {
    if (this[ym] = null, this[wm] = { rotation: 0, scale: new Vt(1, 1), offset: new Vt(0, 0) }, this[xm] = false, r2 && i2) {
      const t3 = o2.textures ? o2.textures[r2.index] : null, n3 = t3 && o2.samplers ? o2.samplers[t3.sampler] : null, s2 = t3 && o2.images ? o2.images[t3.source] : null;
      this[Sm].rotation = i2.rotation, this[Sm].scale.copy(i2.repeat), this[Sm].offset.copy(i2.offset), this[Cm] = new bm(e3, i2, t3, n3, s2);
    }
    this[Tm] = e3, this[Em] = n2, this[Im] = t2;
  }
  get texture() {
    return this[Cm];
  }
  setTexture(e3) {
    var t2, i2;
    const n2 = null != e3 ? e3.source[am] : null, o2 = null === (t2 = this[Cm]) || void 0 === t2 ? void 0 : t2.source[am];
    if (null != o2 && o2.isVideoTexture ? this[Bm] = false : (null === (i2 = this[Cm]) || void 0 === i2 ? void 0 : i2.source.animation) && this[Cm].source.animation.removeEventListener("enterFrame", this[Tm]), this[Cm] = e3, null != n2 && n2.isVideoTexture) {
      const e4 = n2.image;
      if (this[Bm] = true, null != e4.requestVideoFrameCallback) {
        const t3 = () => {
          this[Bm] && (this[Tm](), e4.requestVideoFrameCallback(t3));
        };
        e4.requestVideoFrameCallback(t3);
      } else {
        const e5 = () => {
          this[Bm] && (this[Tm](), requestAnimationFrame(e5));
        };
        requestAnimationFrame(e5);
      }
    } else
      null != (null == e3 ? void 0 : e3.source.animation) && e3.source.animation.addEventListener("enterFrame", this[Tm]);
    let r2 = bt;
    if (this[Em])
      for (const e4 of this[Em]) {
        switch (this[Im]) {
          case Mm.Base:
            e4.map = n2;
            break;
          case Mm.MetallicRoughness:
            r2 = At, e4.metalnessMap = n2, e4.roughnessMap = n2;
            break;
          case Mm.Normal:
            r2 = At, e4.normalMap = n2;
            break;
          case Mm.Occlusion:
            r2 = At, e4.aoMap = n2;
            break;
          case Mm.Emissive:
            e4.emissiveMap = n2;
        }
        e4.needsUpdate = true;
      }
    n2 && (n2.encoding = r2, n2.rotation = this[Sm].rotation, n2.repeat = this[Sm].scale, n2.offset = this[Sm].offset), this[Tm]();
  }
}
ym = Cm, wm = Sm, xm = Bm;
const Rm = Symbol("threeMaterials"), Pm = Symbol("baseColorTexture"), Dm = Symbol("metallicRoughnessTexture");
class Lm extends nm {
  constructor(e3, t2, i2, n2) {
    super(e3, i2, n2), null == i2.baseColorFactor && (i2.baseColorFactor = [1, 1, 1, 1]), null == i2.roughnessFactor && (i2.roughnessFactor = 1), null == i2.metallicFactor && (i2.metallicFactor = 1);
    const { baseColorTexture: o2, metallicRoughnessTexture: r2 } = i2, { map: s2, metalnessMap: a2 } = n2.values().next().value;
    this[Pm] = new km(e3, Mm.Base, s2, n2, t2, o2 || null), this[Dm] = new km(e3, Mm.MetallicRoughness, a2, n2, t2, r2 || null);
  }
  get [Rm]() {
    return this[em];
  }
  get baseColorFactor() {
    return this[tm].baseColorFactor;
  }
  get metallicFactor() {
    return this[tm].metallicFactor;
  }
  get roughnessFactor() {
    return this[tm].roughnessFactor;
  }
  get baseColorTexture() {
    return this[Pm];
  }
  get metallicRoughnessTexture() {
    return this[Dm];
  }
  setBaseColorFactor(e3) {
    const t2 = new Pn();
    e3 instanceof Array ? t2.fromArray(e3) : t2.set(e3).convertSRGBToLinear();
    for (const i2 of this[Rm])
      i2.color.set(t2), e3 instanceof Array ? i2.opacity = e3[3] : (e3 = [0, 0, 0, i2.opacity], t2.toArray(e3));
    this[tm].baseColorFactor = e3, this[im]();
  }
  setMetallicFactor(e3) {
    for (const t2 of this[Rm])
      t2.metalness = e3;
    this[tm].metallicFactor = e3, this[im]();
  }
  setRoughnessFactor(e3) {
    for (const t2 of this[Rm])
      t2.roughness = e3;
    this[tm].roughnessFactor = e3, this[im]();
  }
}
var Fm;
const Nm = Symbol("pbrMetallicRoughness"), Om = Symbol("normalTexture"), zm = Symbol("occlusionTexture"), Um = Symbol("emissiveTexture"), Hm = Symbol("backingThreeMaterial"), Qm = Symbol("applyAlphaCutoff"), Vm = Symbol("lazyLoadGLTFInfo"), Gm = Symbol("initialize"), $m = Symbol("getLoadedMaterial"), Wm = Symbol("ensureMaterialIsLoaded"), qm = Symbol("gltfIndex"), jm = Symbol("setActive"), Xm = Symbol("variantIndices"), Ym = Symbol("isActive"), Km = Symbol("variantSet"), Zm = Symbol("modelVariants");
class Jm extends nm {
  constructor(e3, t2, i2, n2, o2, r2, s2, a2 = void 0) {
    super(e3, i2, s2), this[Fm] = /* @__PURE__ */ new Set(), this[qm] = n2, this[Ym] = o2, this[Zm] = r2, null == a2 ? this[Gm](t2) : this[Vm] = a2;
  }
  get [(Fm = Km, Hm)]() {
    return this[em].values().next().value;
  }
  [Gm](e3) {
    const t2 = this[im], i2 = this[tm], n2 = this[em];
    i2.extensions && i2.extensions.KHR_materials_pbrSpecularGlossiness && console.warn(`Material ${i2.name} uses a deprecated extension
          "KHR_materials_pbrSpecularGlossiness", please use
          "pbrMetallicRoughness" instead. Specular Glossiness materials are
          no longer supported; to convert to metal-rough, see 
          https://www.donmccurdy.com/2022/11/28/converting-gltf-pbr-materials-from-specgloss-to-metalrough/.`), null == i2.pbrMetallicRoughness && (i2.pbrMetallicRoughness = {}), this[Nm] = new Lm(t2, e3, i2.pbrMetallicRoughness, n2), null == i2.emissiveFactor && (i2.emissiveFactor = [0, 0, 0]), null == i2.doubleSided && (i2.doubleSided = false), null == i2.alphaMode && (i2.alphaMode = "OPAQUE"), null == i2.alphaCutoff && (i2.alphaCutoff = 0.5);
    const { normalTexture: o2, occlusionTexture: r2, emissiveTexture: s2 } = i2, { normalMap: a2, aoMap: l2, emissiveMap: c2 } = n2.values().next().value;
    this[Om] = new km(t2, Mm.Normal, a2, n2, e3, o2 || null), this[zm] = new km(t2, Mm.Occlusion, l2, n2, e3, r2 || null), this[Um] = new km(t2, Mm.Emissive, c2, n2, e3, s2 || null);
  }
  async [$m]() {
    if (null != this[Vm]) {
      const { set: e3, material: t2 } = await this[Vm].doLazyLoad();
      return this[em] = e3, this[Gm](this[Vm].gltf), this[Vm] = void 0, this.ensureLoaded = async () => {
      }, t2;
    }
    return this[em].values().next().value;
  }
  [Wm]() {
    if (null != this[Vm])
      throw new Error(`Material "${this.name}" has not been loaded, call 'await
    myMaterial.ensureLoaded()' before using an unloaded material.`);
  }
  async ensureLoaded() {
    await this[$m]();
  }
  get isLoaded() {
    return null == this[Vm];
  }
  get isActive() {
    return this[Ym];
  }
  [jm](e3) {
    this[Ym] = e3;
  }
  get name() {
    return this[tm].name;
  }
  set name(e3) {
    const t2 = this[tm];
    if (null != t2 && (t2.name = e3), null != this[em])
      for (const t3 of this[em])
        t3.name = e3;
  }
  get pbrMetallicRoughness() {
    return this[Wm](), this[Nm];
  }
  get normalTexture() {
    return this[Wm](), this[Om];
  }
  get occlusionTexture() {
    return this[Wm](), this[zm];
  }
  get emissiveTexture() {
    return this[Wm](), this[Um];
  }
  get emissiveFactor() {
    return this[Wm](), this[tm].emissiveFactor;
  }
  get index() {
    return this[qm];
  }
  [Xm]() {
    return this[Km];
  }
  hasVariant(e3) {
    const t2 = this[Zm].get(e3);
    return null != t2 && this[Km].has(t2.index);
  }
  setEmissiveFactor(e3) {
    this[Wm]();
    const t2 = new Pn();
    e3 instanceof Array ? t2.fromArray(e3) : t2.set(e3).convertSRGBToLinear();
    for (const e4 of this[em])
      e4.emissive.set(t2);
    this[tm].emissiveFactor = t2.toArray(), this[im]();
  }
  [Qm]() {
    this[Wm]();
    const e3 = this[tm];
    for (const t2 of this[em])
      "MASK" === this[tm].alphaMode ? t2.alphaTest = e3.alphaCutoff : t2.alphaTest = void 0, t2.needsUpdate = true;
  }
  setAlphaCutoff(e3) {
    this[Wm](), this[tm].alphaCutoff = e3, this[Qm](), this[im]();
  }
  getAlphaCutoff() {
    return this[Wm](), this[tm].alphaCutoff;
  }
  setDoubleSided(e3) {
    this[Wm]();
    for (const t2 of this[em])
      t2.side = e3 ? be : ve, t2.needsUpdate = true;
    this[tm].doubleSided = e3, this[im]();
  }
  getDoubleSided() {
    return this[Wm](), this[tm].doubleSided;
  }
  setAlphaMode(e3) {
    this[Wm]();
    const t2 = (e4, t3) => {
      e4.transparent = t3, e4.depthWrite = !t3;
    };
    this[tm].alphaMode = e3;
    for (const i2 of this[em])
      t2(i2, "BLEND" === e3), this[Qm](), i2.needsUpdate = true;
    this[im]();
  }
  getAlphaMode() {
    return this[Wm](), this[tm].alphaMode;
  }
}
let ef = class {
  constructor(e3) {
    this.name = "", this.children = new Array(), this.name = e3;
  }
};
class tf extends ef {
  constructor(e3, t2, i2, n2) {
    super(e3.name), this.materials = /* @__PURE__ */ new Map(), this.variantToMaterialMap = /* @__PURE__ */ new Map(), this.initialMaterialIdx = 0, this.activeMaterialIdx = 0, this.mesh = e3;
    const { gltf: o2, threeGLTF: r2, threeObjectMap: s2 } = n2;
    this.modelVariants = i2, this.mesh.userData.variantData = i2;
    const a2 = s2.get(e3.material);
    null != a2.materials ? this.initialMaterialIdx = this.activeMaterialIdx = a2.materials : console.error(`Primitive (${e3.name}) missing initial material reference.`);
    const l2 = e3.userData.associations || {};
    if (null == l2.meshes)
      return void console.error("Mesh is missing primitive index association");
    const c2 = ((o2.meshes || [])[l2.meshes].primitives || [])[l2.primitives];
    if (null != c2) {
      if (null != c2.material)
        this.materials.set(c2.material, t2[c2.material]);
      else {
        const e4 = t2.findIndex((e5) => "Default" === e5.name);
        e4 >= 0 ? this.materials.set(e4, t2[e4]) : console.warn("gltfPrimitive has no material!");
      }
      if (c2.extensions && c2.extensions.KHR_materials_variants) {
        const e4 = c2.extensions.KHR_materials_variants, n3 = r2.parser.json.extensions.KHR_materials_variants.variants;
        for (const o3 of e4.mappings) {
          const e5 = t2[o3.material];
          this.materials.set(o3.material, e5);
          for (const t3 of o3.variants) {
            const { name: o4 } = n3[t3];
            this.variantToMaterialMap.set(t3, e5), e5[Xm]().add(t3), i2.has(o4) || i2.set(o4, { name: o4, index: t3 });
          }
        }
      }
    } else
      console.error("Mesh primitive definition is missing.");
  }
  async setActiveMaterial(e3) {
    const t2 = this.materials.get(e3);
    return null != t2 && (this.mesh.material = await t2[$m](), this.activeMaterialIdx = e3), this.mesh.material;
  }
  getActiveMaterial() {
    return this.materials.get(this.activeMaterialIdx);
  }
  getMaterial(e3) {
    return this.materials.get(e3);
  }
  async enableVariant(e3) {
    if (null == e3)
      return this.setActiveMaterial(this.initialMaterialIdx);
    if (null != this.variantToMaterialMap && this.modelVariants.has(e3)) {
      const t2 = this.modelVariants.get(e3);
      return this.enableVariantHelper(t2.index);
    }
    return null;
  }
  async enableVariantHelper(e3) {
    if (null != this.variantToMaterialMap && null != e3) {
      const t2 = this.variantToMaterialMap.get(e3);
      if (null != t2)
        return this.setActiveMaterial(t2.index);
    }
    return null;
  }
  async instantiateVariants() {
    if (null != this.variantToMaterialMap)
      for (const e3 of this.variantToMaterialMap.keys()) {
        const t2 = this.mesh.userData.variantMaterials.get(e3);
        if (null != t2.material)
          continue;
        const i2 = await this.enableVariantHelper(e3);
        null != i2 && (t2.material = i2);
      }
  }
  get variantInfo() {
    return this.variantToMaterialMap;
  }
  addVariant(e3, t2) {
    if (!this.ensureVariantIsUnused(t2))
      return false;
    this.modelVariants.has(t2) || this.modelVariants.set(t2, { name: t2, index: this.modelVariants.size });
    const i2 = this.modelVariants.get(t2).index;
    return e3[Xm]().add(i2), this.variantToMaterialMap.set(i2, e3), this.materials.set(e3.index, e3), this.updateVariantUserData(i2, e3), true;
  }
  deleteVariant(e3) {
    if (this.variantInfo.has(e3)) {
      this.variantInfo.delete(e3);
      const t2 = this.mesh.userData.variantMaterials;
      null != t2 && t2.delete(e3);
    }
  }
  updateVariantUserData(e3, t2) {
    t2[Xm]().add(e3), this.mesh.userData.variantData = this.modelVariants, this.mesh.userData.variantMaterials = this.mesh.userData.variantMaterials || /* @__PURE__ */ new Map();
    this.mesh.userData.variantMaterials.set(e3, { material: t2[em].values().next().value, gltfMaterialIndex: t2.index });
  }
  ensureVariantIsUnused(e3) {
    const t2 = this.modelVariants.get(e3);
    return null == t2 || !this.variantInfo.has(t2.index) || (console.warn(`Primitive cannot add variant '${e3}' for this material, it already exists.`), false);
  }
}
var nf, of, rf, sf, af, lf;
const cf = Symbol("materials"), hf = Symbol("hierarchy"), uf = Symbol("roots"), df = Symbol("primitives"), pf = Symbol("correlatedSceneGraph"), _f = Symbol("prepareVariantsForExport"), gf = Symbol("switchVariant"), mf = Symbol("materialFromPoint"), ff = Symbol("nodeFromPoint"), vf = Symbol("nodeFromIndex"), Af = Symbol("variantData"), bf = Symbol("availableVariants"), yf = Symbol("modelOnUpdate"), wf = Symbol("cloneMaterial");
class xf {
  constructor(e3, t2, i2, n2) {
    this.gltf = e3, this.gltfElementMap = t2, this.mapKey = i2, this.doLazyLoad = n2;
  }
}
class Cf {
  constructor(e3, t2 = () => {
  }) {
    this[nf] = new Array(), this[of] = new Array(), this[rf] = new Array(), this[sf] = new Array(), this[af] = () => {
    }, this[lf] = /* @__PURE__ */ new Map(), this[yf] = t2, this[pf] = e3;
    const { gltf: i2, threeGLTF: n2, gltfElementMap: o2 } = e3;
    for (const [e4, r3] of i2.materials.entries()) {
      const s3 = o2.get(r3);
      if (null != s3)
        this[cf].push(new Jm(t2, i2, r3, e4, true, this[Af], s3));
      else {
        const r4 = (i2.materials || [])[e4], a2 = e4, l2 = async () => {
          const e5 = await n2.parser.getDependency("material", a2), t3 = /* @__PURE__ */ new Set();
          return o2.set(r4, t3), t3.add(e5), { set: t3, material: e5 };
        };
        this[cf].push(new Jm(t2, i2, r4, e4, false, this[Af], s3, new xf(i2, o2, r4, l2)));
      }
    }
    const r2 = /* @__PURE__ */ new Map(), s2 = new Array();
    for (const e4 of n2.scene.children)
      s2.push(e4);
    for (; s2.length > 0; ) {
      const t3 = s2.pop();
      let i3 = null;
      t3 instanceof fo ? (i3 = new tf(t3, this.materials, this[Af], e3), this[df].push(i3)) : i3 = new ef(t3.name);
      const n3 = r2.get(t3);
      null != n3 ? n3.children.push(i3) : this[uf].push(i3), this[hf].push(i3);
      for (const e4 of t3.children)
        s2.push(e4), r2.set(t3, i3);
    }
  }
  get materials() {
    return this[cf];
  }
  [(nf = cf, of = hf, rf = uf, sf = df, af = yf, lf = Af, bf)]() {
    const e3 = Array.from(this[Af].values());
    return e3.sort((e4, t2) => e4.index - t2.index), e3.map((e4) => e4.name);
  }
  getMaterialByName(e3) {
    const t2 = this[cf].filter((t3) => t3.name === e3);
    return t2.length > 0 ? t2[0] : null;
  }
  [vf](e3, t2) {
    const i2 = this[hf].find((i3) => {
      if (i3 instanceof tf) {
        const { meshes: n2, primitives: o2 } = i3.mesh.userData.associations;
        if (n2 == e3 && o2 == t2)
          return true;
      }
      return false;
    });
    return null == i2 ? null : i2;
  }
  [ff](e3) {
    return this[hf].find((t2) => {
      if (t2 instanceof tf) {
        if (t2.mesh === e3.object)
          return true;
      }
      return false;
    });
  }
  [mf](e3) {
    return this[ff](e3).getActiveMaterial();
  }
  async [gf](e3) {
    for (const t2 of this[df])
      await t2.enableVariant(e3);
    for (const e4 of this.materials)
      e4[jm](false);
    for (const e4 of this[df])
      this.materials[e4.getActiveMaterial().index][jm](true);
  }
  async [_f]() {
    const e3 = new Array();
    for (const t2 of this[df])
      e3.push(t2.instantiateVariants());
    await Promise.all(e3);
  }
  [wf](e3, t2) {
    const i2 = this.materials[e3];
    i2.isLoaded || console.error("Cloning an unloaded material,\n           call 'material.ensureLoaded() before cloning the material.");
    const n2 = i2[em], o2 = JSON.parse(JSON.stringify(i2[tm]));
    o2.name = t2;
    this[pf].gltf.materials.push(o2);
    const r2 = /* @__PURE__ */ new Set();
    for (const [e4, i3] of n2.entries()) {
      const o3 = i3.clone();
      o3.name = t2 + (n2.size > 1 ? "_inst" + e4 : ""), r2.add(o3);
    }
    const s2 = new Jm(this[yf], this[pf].gltf, o2, this[cf].length, false, this[Af], r2);
    return this[cf].push(s2), s2;
  }
  createMaterialInstanceForVariant(e3, t2, i2, n2 = true) {
    let o2 = null;
    for (const n3 of this[df]) {
      const r2 = this[Af].get(i2);
      null != r2 && n3.variantInfo.has(r2.index) || null != n3.getMaterial(e3) && (this.hasVariant(i2) || this.createVariant(i2), null == o2 && (o2 = this[wf](e3, t2)), n3.addVariant(o2, i2));
    }
    if (n2 && null != o2) {
      o2[jm](true), this.materials[e3][jm](false);
      for (const e4 of this[df])
        e4.enableVariant(i2);
    }
    return o2;
  }
  createVariant(e3) {
    this[Af].has(e3) ? console.warn(`Variant '${e3}'' already exists`) : this[Af].set(e3, { name: e3, index: this[Af].size });
  }
  hasVariant(e3) {
    return this[Af].has(e3);
  }
  setMaterialToVariant(e3, t2) {
    if (null != this[bf]().find((e4) => e4 === t2))
      if (e3 < 0 || e3 >= this.materials.length)
        console.error("setMaterialToVariant(): materialIndex is out of bounds.");
      else
        for (const i2 of this[df]) {
          const n2 = i2.getMaterial(e3);
          null != n2 && i2.addVariant(n2, t2);
        }
    else
      console.warn(`Can't add material to '${t2}', the variant does not exist.'`);
  }
  updateVariantName(e3, t2) {
    const i2 = this[Af].get(e3);
    null != i2 && (i2.name = t2, this[Af].set(t2, i2), this[Af].delete(e3));
  }
  deleteVariant(e3) {
    const t2 = this[Af].get(e3);
    if (null != t2) {
      for (const i2 of this.materials)
        i2.hasVariant(e3) && i2[Km].delete(t2.index);
      for (const e4 of this[df])
        e4.deleteVariant(t2.index);
      this[Af].delete(e3);
    }
  }
}
var Sf = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
const Ef = Symbol("currentGLTF"), If = Symbol("originalGltfJson"), Tf = Symbol("model"), Bf = Symbol("getOnUpdateMethod"), Mf = Symbol("buildTexture"), kf = new di(), Rf = new di(), Pf = new di(), Df = new Gt(), Lf = new En(), Ff = new ui();
class Nf extends od {
  constructor(e3) {
    super(document.createElement("div")), this.normal = new di(0, 1, 0), this.initialized = false, this.referenceCount = 1, this.pivot = document.createElement("div"), this.slot = document.createElement("slot"), this.element.classList.add("annotation-wrapper"), this.slot.name = e3.name, this.element.appendChild(this.pivot), this.pivot.appendChild(this.slot), this.updatePosition(e3.position), this.updateNormal(e3.normal), this.surface = e3.surface;
  }
  get facingCamera() {
    return !this.element.classList.contains("hide");
  }
  show() {
    this.facingCamera && this.initialized || this.updateVisibility(true);
  }
  hide() {
    !this.facingCamera && this.initialized || this.updateVisibility(false);
  }
  increment() {
    this.referenceCount++;
  }
  decrement() {
    return this.referenceCount > 0 && --this.referenceCount, 0 === this.referenceCount;
  }
  updatePosition(e3) {
    if (null == e3)
      return;
    const t2 = gp(e3)[0].terms;
    for (let e4 = 0; e4 < 3; ++e4)
      this.position.setComponent(e4, Ep(t2[e4]).number);
    this.updateMatrixWorld();
  }
  updateNormal(e3) {
    if (null == e3)
      return;
    const t2 = gp(e3)[0].terms;
    for (let e4 = 0; e4 < 3; ++e4)
      this.normal.setComponent(e4, t2[e4].number);
  }
  updateSurface(e3) {
    if (!e3 && this.initialized)
      return;
    const { mesh: t2, tri: i2, bary: n2 } = this;
    if (null == t2 || null == i2 || null == n2)
      return;
    t2.getVertexPosition(i2.x, kf), t2.getVertexPosition(i2.y, Rf), t2.getVertexPosition(i2.z, Pf), kf.toArray(Df.elements, 0), Rf.toArray(Df.elements, 3), Pf.toArray(Df.elements, 6), this.position.copy(n2).applyMatrix3(Df);
    const o2 = this.parent;
    o2.worldToLocal(t2.localToWorld(this.position)), Lf.set(kf, Rf, Pf), Lf.getNormal(this.normal).transformDirection(t2.matrixWorld);
    const r2 = o2.parent;
    Ff.setFromAxisAngle(kf.set(0, 1, 0), -r2.yaw), this.normal.applyQuaternion(Ff);
  }
  orient(e3) {
    this.pivot.style.transform = `rotate(${e3}rad)`;
  }
  updateVisibility(e3) {
    e3 ? this.element.classList.remove("hide") : this.element.classList.add("hide"), this.slot.assignedNodes().forEach((t2) => {
      if (t2.nodeType !== Node.ELEMENT_NODE)
        return;
      const i2 = t2, n2 = i2.dataset.visibilityAttribute;
      if (null != n2) {
        const t3 = `data-${n2}`;
        e3 ? i2.setAttribute(t3, "") : i2.removeAttribute(t3);
      }
      i2.dispatchEvent(new CustomEvent("hotspot-visibility", { detail: { visible: e3 } }));
    }), this.initialized = true;
  }
}
const Of = { uniforms: { tDiffuse: { value: null }, h: { value: 1 / 512 } }, vertexShader: "\n\n		varying vec2 vUv;\n\n		void main() {\n\n			vUv = uv;\n			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n		}", fragmentShader: "\n\n		uniform sampler2D tDiffuse;\n		uniform float h;\n\n		varying vec2 vUv;\n\n		void main() {\n\n			vec4 sum = vec4( 0.0 );\n\n			sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;\n			sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;\n			sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;\n			sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n			sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;\n			sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;\n			sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;\n			sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;\n\n			gl_FragColor = sum;\n\n		}" }, zf = { uniforms: { tDiffuse: { value: null }, v: { value: 1 / 512 } }, vertexShader: "\n\n		varying vec2 vUv;\n\n		void main() {\n\n			vUv = uv;\n			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n		}", fragmentShader: "\n\n		uniform sampler2D tDiffuse;\n		uniform float v;\n\n		varying vec2 vUv;\n\n		void main() {\n\n			vec4 sum = vec4( 0.0 );\n\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;\n\n			gl_FragColor = sum;\n\n		}" };
function Uf(e3, t2, i2) {
  return (1 - i2) * e3 + i2 * t2;
}
class Hf extends _n {
  constructor(e3, t2, i2) {
    super(), this.camera = new Ko(), this.renderTarget = null, this.renderTargetBlur = null, this.depthMaterial = new ia(), this.horizontalBlurMaterial = new Co(Of), this.verticalBlurMaterial = new Co(zf), this.intensity = 0, this.softness = 1, this.boundingBox = new gi(), this.size = new di(), this.maxDimension = 0, this.isAnimated = false, this.needsUpdate = false;
    const { camera: n2 } = this;
    n2.rotation.x = Math.PI / 2, n2.left = -0.5, n2.right = 0.5, n2.bottom = -0.5, n2.top = 0.5, this.add(n2);
    const o2 = new Uo(), r2 = new Ln({ opacity: 1, transparent: true, side: Ae });
    this.floor = new fo(o2, r2), this.floor.userData.shadow = true, n2.add(this.floor), this.blurPlane = new fo(o2), this.blurPlane.visible = false, n2.add(this.blurPlane), e3.target.add(this), this.depthMaterial.onBeforeCompile = function(e4) {
      e4.fragmentShader = e4.fragmentShader.replace("gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );", "gl_FragColor = vec4( vec3( 0.0 ), ( 1.0 - fragCoordZ ) * opacity );");
    }, this.horizontalBlurMaterial.depthTest = false, this.verticalBlurMaterial.depthTest = false, this.setScene(e3, t2, i2);
  }
  setScene(e3, t2, i2) {
    const { boundingBox: n2, size: o2, rotation: r2, position: s2 } = this;
    if (this.isAnimated = e3.animationNames.length > 0, this.boundingBox.copy(e3.boundingBox), this.size.copy(e3.size), this.maxDimension = Math.max(o2.x, o2.y, o2.z) * (this.isAnimated ? 2 : 1), this.boundingBox.getCenter(s2), "back" === i2) {
      const { min: e4, max: t3 } = n2;
      [e4.y, e4.z] = [e4.z, e4.y], [t3.y, t3.z] = [t3.z, t3.y], [o2.y, o2.z] = [o2.z, o2.y], r2.x = Math.PI / 2, r2.y = Math.PI;
    } else
      r2.x = 0, r2.y = 0;
    if (this.isAnimated) {
      const e4 = n2.min.y, t3 = n2.max.y;
      o2.y = this.maxDimension, n2.expandByVector(o2.subScalar(this.maxDimension).multiplyScalar(-0.5)), n2.min.y = e4, n2.max.y = t3, o2.set(this.maxDimension, t3 - e4, this.maxDimension);
    }
    "bottom" === i2 ? s2.y = n2.min.y : s2.z = n2.min.y, this.setSoftness(t2);
  }
  setSoftness(e3) {
    this.softness = e3;
    const { size: t2, camera: i2 } = this, n2 = this.isAnimated ? 2 : 1, o2 = n2 * Math.pow(2, 9 - 3 * e3);
    this.setMapSize(o2);
    const r2 = t2.y / 2, s2 = t2.y * n2;
    i2.near = 0, i2.far = Uf(s2, r2, e3), this.depthMaterial.opacity = 1 / e3, i2.updateProjectionMatrix(), this.setIntensity(this.intensity), this.setOffset(0);
  }
  setMapSize(e3) {
    const { size: t2 } = this;
    this.isAnimated && (e3 *= 2);
    const i2 = Math.floor(t2.x > t2.z ? e3 : e3 * t2.x / t2.z), n2 = Math.floor(t2.x > t2.z ? e3 * t2.z / t2.x : e3), o2 = 10 + i2, r2 = 10 + n2;
    if (null == this.renderTarget || this.renderTarget.width === o2 && this.renderTarget.height === r2 || (this.renderTarget.dispose(), this.renderTarget = null, this.renderTargetBlur.dispose(), this.renderTargetBlur = null), null == this.renderTarget) {
      const e4 = { format: Xe };
      this.renderTarget = new li(o2, r2, e4), this.renderTargetBlur = new li(o2, r2, e4), this.floor.material.map = this.renderTarget.texture;
    }
    this.camera.scale.set(t2.x * (1 + 10 / i2), t2.z * (1 + 10 / n2), 1), this.needsUpdate = true;
  }
  setIntensity(e3) {
    this.intensity = e3, e3 > 0 ? (this.visible = true, this.floor.visible = true, this.floor.material.opacity = e3 * Uf(0.3, 1, this.softness * this.softness)) : (this.visible = false, this.floor.visible = false);
  }
  getIntensity() {
    return this.intensity;
  }
  setOffset(e3) {
    this.floor.position.z = -e3 + 1e-3 * this.maxDimension;
  }
  render(e3, t2) {
    t2.overrideMaterial = this.depthMaterial;
    const i2 = e3.getClearAlpha();
    e3.setClearAlpha(0), this.floor.visible = false;
    const n2 = e3.xr.enabled;
    e3.xr.enabled = false;
    const o2 = e3.getRenderTarget();
    e3.setRenderTarget(this.renderTarget), e3.render(t2, this.camera), t2.overrideMaterial = null, this.floor.visible = true, this.blurShadow(e3), e3.xr.enabled = n2, e3.setRenderTarget(o2), e3.setClearAlpha(i2);
  }
  blurShadow(e3) {
    const { camera: t2, horizontalBlurMaterial: i2, verticalBlurMaterial: n2, renderTarget: o2, renderTargetBlur: r2, blurPlane: s2 } = this;
    s2.visible = true, s2.material = i2, i2.uniforms.h.value = 1 / this.renderTarget.width, i2.uniforms.tDiffuse.value = this.renderTarget.texture, e3.setRenderTarget(r2), e3.render(s2, t2), s2.material = n2, n2.uniforms.v.value = 1 / this.renderTarget.height, n2.uniforms.tDiffuse.value = this.renderTargetBlur.texture, e3.setRenderTarget(o2), e3.render(s2, t2), s2.visible = false;
  }
  dispose() {
    null != this.renderTarget && this.renderTarget.dispose(), null != this.renderTargetBlur && this.renderTargetBlur.dispose(), this.depthMaterial.dispose(), this.horizontalBlurMaterial.dispose(), this.verticalBlurMaterial.dispose(), this.floor.material.dispose(), this.floor.geometry.dispose(), this.blurPlane.geometry.dispose(), this.removeFromParent();
  }
}
const Qf = new di(), Vf = new di(), Gf = new di(), $f = new Fc(), Wf = new di(), qf = new Vt();
class jf extends va {
  constructor({ canvas: e3, element: t2, width: i2, height: n2 }) {
    super(), this.annotationRenderer = new hd(), this.schemaElement = document.createElement("script"), this.width = 1, this.height = 1, this.aspect = 1, this.scaleStep = 0, this.renderCount = 0, this.externalRenderer = null, this.camera = new Eo(45, 1, 0.1, 100), this.xrCamera = null, this.url = null, this.target = new _n(), this.animationNames = [], this.boundingBox = new gi(), this.boundingSphere = new Pi(), this.size = new di(), this.idealAspect = 0, this.framedFoVDeg = 0, this.shadow = null, this.shadowIntensity = 0, this.shadowSoftness = 1, this.bakedShadows = /* @__PURE__ */ new Set(), this.exposure = 1, this.canScale = true, this.isDirty = false, this.goalTarget = new di(), this.targetDamperX = new lp(), this.targetDamperY = new lp(), this.targetDamperZ = new lp(), this._currentGLTF = null, this._model = null, this.cancelPendingSourceChange = null, this.animationsByName = /* @__PURE__ */ new Map(), this.currentAnimationAction = null, this.name = "ModelScene", this.element = t2, this.canvas = e3, this.camera = new Eo(45, 1, 0.1, 100), this.camera.name = "MainCamera", this.add(this.target), this.setSize(i2, n2), this.target.name = "Target", this.mixer = new Lc(this.target);
    const { domElement: o2 } = this.annotationRenderer, { style: r2 } = o2;
    r2.display = "none", r2.pointerEvents = "none", r2.position = "absolute", r2.top = "0", this.element.shadowRoot.querySelector(".default").appendChild(o2), this.schemaElement.setAttribute("type", "application/ld+json");
  }
  get context() {
    return this.canvas.getContext("2d");
  }
  getCamera() {
    return null != this.xrCamera ? this.xrCamera : this.camera;
  }
  queueRender() {
    this.isDirty = true;
  }
  shouldRender() {
    return this.isDirty;
  }
  hasRendered() {
    this.isDirty = false;
  }
  forceRescale() {
    this.scaleStep = -1, this.queueRender();
  }
  async setObject(e3) {
    this.reset(), this._model = e3, this.target.add(e3), await this.setupScene();
  }
  async setSource(e3, t2 = () => {
  }) {
    if (!e3 || e3 === this.url)
      return void t2(1);
    if (this.reset(), this.url = e3, null != this.externalRenderer) {
      const e4 = await this.externalRenderer.load(t2);
      return this.boundingSphere.radius = e4.framedRadius, void (this.idealAspect = e4.fieldOfViewAspect);
    }
    let i2;
    null != this.cancelPendingSourceChange && (this.cancelPendingSourceChange(), this.cancelPendingSourceChange = null);
    try {
      i2 = await new Promise(async (i3, n3) => {
        this.cancelPendingSourceChange = () => n3();
        try {
          i3(await this.element[zv].loader.load(e3, this.element, t2));
        } catch (e4) {
          n3(e4);
        }
      });
    } catch (e4) {
      if (null == e4)
        return;
      throw e4;
    }
    this.cancelPendingSourceChange = null, this.reset(), this.url = e3, this._currentGLTF = i2, null != i2 && (this._model = i2.scene, this.target.add(i2.scene));
    const { animations: n2 } = i2, o2 = /* @__PURE__ */ new Map(), r2 = [];
    for (const e4 of n2)
      o2.set(e4.name, e4), r2.push(e4.name);
    this.animations = n2, this.animationsByName = o2, this.animationNames = r2, await this.setupScene();
  }
  async setupScene() {
    this.applyTransform(), this.updateBoundingBox(), await this.updateFraming(), this.updateShadow(), this.setShadowIntensity(this.shadowIntensity);
  }
  reset() {
    this.url = null, this.renderCount = 0, this.queueRender(), null != this.shadow && this.shadow.setIntensity(0), this.bakedShadows.clear();
    const { _model: e3 } = this;
    null != e3 && (e3.removeFromParent(), this._model = null);
    const t2 = this._currentGLTF;
    null != t2 && (t2.dispose(), this._currentGLTF = null), null != this.currentAnimationAction && (this.currentAnimationAction.stop(), this.currentAnimationAction = null), this.mixer.stopAllAction(), this.mixer.uncacheRoot(this);
  }
  dispose() {
    this.reset(), null != this.shadow && (this.shadow.dispose(), this.shadow = null), this.element[Ef] = null, this.element[If] = null, this.element[Tf] = null;
  }
  get currentGLTF() {
    return this._currentGLTF;
  }
  setSize(e3, t2) {
    if (this.width !== e3 || this.height !== t2) {
      if (this.width = Math.max(e3, 1), this.height = Math.max(t2, 1), this.annotationRenderer.setSize(e3, t2), this.aspect = this.width / this.height, null != this.externalRenderer) {
        const i2 = ah();
        this.externalRenderer.resize(e3 * i2, t2 * i2);
      }
      this.queueRender();
    }
  }
  markBakedShadow(e3) {
    e3.userData.shadow = true, this.bakedShadows.add(e3);
  }
  unmarkBakedShadow(e3) {
    e3.userData.shadow = false, e3.visible = true, this.bakedShadows.delete(e3), this.boundingBox.expandByObject(e3);
  }
  findBakedShadows(e3) {
    const t2 = new gi();
    e3.traverse((e4) => {
      const i2 = e4;
      if (!i2.material)
        return;
      if (!i2.material.transparent)
        return;
      t2.setFromObject(i2);
      const n2 = t2.getSize(Wf), o2 = Math.min(n2.x, n2.y, n2.z);
      Math.max(n2.x, n2.y, n2.z) < 100 * o2 || this.markBakedShadow(i2);
    });
  }
  checkBakedShadows() {
    const { min: e3, max: t2 } = this.boundingBox, i2 = new gi();
    this.boundingBox.getSize(this.size);
    for (const n2 of this.bakedShadows)
      i2.setFromObject(n2), i2.min.y < e3.y + this.size.y / 100 && i2.min.x <= e3.x && i2.max.x >= t2.x && i2.min.z <= e3.z && i2.max.z >= t2.z || i2.min.z < e3.z + this.size.z / 100 && i2.min.x <= e3.x && i2.max.x >= t2.x && i2.min.y <= e3.y && i2.max.y >= t2.y || this.unmarkBakedShadow(n2);
  }
  applyTransform() {
    const { model: e3 } = this;
    if (null == e3)
      return;
    const t2 = gp(this.element.orientation)[0].terms, i2 = Ep(t2[0]).number, n2 = Ep(t2[1]).number, o2 = Ep(t2[2]).number;
    e3.quaternion.setFromEuler(new Zi(n2, o2, i2, "YXZ"));
    const r2 = gp(this.element.scale)[0].terms;
    e3.scale.set(r2[0].number, r2[1].number, r2[2].number);
  }
  updateBoundingBox() {
    const { model: e3 } = this;
    if (null == e3)
      return;
    this.target.remove(e3), this.findBakedShadows(e3);
    const t2 = (e4, t3) => e4.expandByPoint(t3);
    this.setBakedShadowVisibility(false), this.boundingBox = ud(e3, t2, new gi()), this.boundingBox.isEmpty() && (this.setBakedShadowVisibility(true), this.bakedShadows.forEach((e4) => this.unmarkBakedShadow(e4)), this.boundingBox = ud(e3, t2, new gi())), this.checkBakedShadows(), this.setBakedShadowVisibility(), this.boundingBox.getSize(this.size), this.target.add(e3);
  }
  async updateFraming() {
    const { model: e3 } = this;
    if (null == e3)
      return;
    this.target.remove(e3), this.setBakedShadowVisibility(false);
    const { center: t2 } = this.boundingSphere;
    this.element.requestUpdate("cameraTarget"), await this.element.updateComplete, t2.copy(this.getTarget());
    this.boundingSphere.radius = Math.sqrt(ud(e3, (e4, i2) => Math.max(e4, t2.distanceToSquared(i2)), 0));
    this.idealAspect = ud(e3, (e4, i2) => {
      i2.sub(t2);
      const n2 = Math.sqrt(i2.x * i2.x + i2.z * i2.z);
      return Math.max(e4, n2 / (this.idealCameraDistance() - Math.abs(i2.y)));
    }, 0) / Math.tan(this.framedFoVDeg / 2 * Math.PI / 180), this.setBakedShadowVisibility(), this.target.add(e3);
  }
  setBakedShadowVisibility(e3 = this.shadowIntensity <= 0) {
    for (const t2 of this.bakedShadows)
      t2.visible = e3;
  }
  idealCameraDistance() {
    const e3 = this.framedFoVDeg / 2 * Math.PI / 180;
    return this.boundingSphere.radius / Math.sin(e3);
  }
  adjustedFoV(e3) {
    const t2 = Math.tan(e3 / 2 * Math.PI / 180) * Math.max(1, this.idealAspect / this.aspect);
    return 2 * Math.atan(t2) * 180 / Math.PI;
  }
  getNDC(e3, t2) {
    if (null != this.xrCamera)
      qf.set(e3 / window.screen.width, t2 / window.screen.height);
    else {
      const i2 = this.element.getBoundingClientRect();
      qf.set((e3 - i2.x) / this.width, (t2 - i2.y) / this.height);
    }
    return qf.multiplyScalar(2).subScalar(1), qf.y *= -1, qf;
  }
  getSize() {
    return { width: this.width, height: this.height };
  }
  setEnvironmentAndSkybox(e3, t2) {
    this.element[zv].arRenderer.presentedScene !== this && (this.environment = e3, this.background = t2, this.queueRender());
  }
  setTarget(e3, t2, i2) {
    this.goalTarget.set(-e3, -t2, -i2);
  }
  setTargetDamperDecayTime(e3) {
    this.targetDamperX.setDecayTime(e3), this.targetDamperY.setDecayTime(e3), this.targetDamperZ.setDecayTime(e3);
  }
  getTarget() {
    return this.goalTarget.clone().multiplyScalar(-1);
  }
  jumpToGoal() {
    this.updateTarget(1e4);
  }
  updateTarget(e3) {
    const t2 = this.goalTarget, i2 = this.target.position;
    if (t2.equals(i2))
      return false;
    {
      const n2 = this.boundingSphere.radius / 10;
      let { x: o2, y: r2, z: s2 } = i2;
      return o2 = this.targetDamperX.update(o2, t2.x, e3, n2), r2 = this.targetDamperY.update(r2, t2.y, e3, n2), s2 = this.targetDamperZ.update(s2, t2.z, e3, n2), this.target.position.set(o2, r2, s2), this.target.updateMatrixWorld(), this.queueRender(), true;
    }
  }
  pointTowards(e3, t2) {
    const { x: i2, z: n2 } = this.position;
    this.yaw = Math.atan2(e3 - i2, t2 - n2);
  }
  get model() {
    return this._model;
  }
  set yaw(e3) {
    this.rotation.y = e3, this.queueRender();
  }
  get yaw() {
    return this.rotation.y;
  }
  set animationTime(e3) {
    this.mixer.setTime(e3), this.queueShadowRender();
  }
  get animationTime() {
    if (null != this.currentAnimationAction) {
      const e3 = Math.max(this.currentAnimationAction._loopCount, 0);
      return this.currentAnimationAction.loop === ut && 1 == (1 & e3) ? this.duration - this.currentAnimationAction.time : this.currentAnimationAction.time;
    }
    return 0;
  }
  set animationTimeScale(e3) {
    this.mixer.timeScale = e3;
  }
  get animationTimeScale() {
    return this.mixer.timeScale;
  }
  get duration() {
    return null != this.currentAnimationAction && this.currentAnimationAction.getClip() ? this.currentAnimationAction.getClip().duration : 0;
  }
  get hasActiveAnimation() {
    return null != this.currentAnimationAction;
  }
  playAnimation(e3 = null, t2 = 0, i2 = 2201, n2 = 1 / 0) {
    if (null == this._currentGLTF)
      return;
    const { animations: o2 } = this;
    if (null == o2 || 0 === o2.length)
      return;
    let r2 = null;
    if (null != e3 && (r2 = this.animationsByName.get(e3), null == r2)) {
      const t3 = parseInt(e3);
      !isNaN(t3) && t3 >= 0 && t3 < o2.length && (r2 = o2[t3]);
    }
    null == r2 && (r2 = o2[0]);
    try {
      const { currentAnimationAction: e4 } = this, o3 = this.mixer.clipAction(r2, this);
      this.currentAnimationAction = o3, this.element.paused ? this.mixer.stopAllAction() : (o3.paused = false, null != e4 && o3 !== e4 ? o3.crossFadeFrom(e4, t2, false) : this.animationTimeScale > 0 && this.animationTime == this.duration && (this.animationTime = 0)), o3.setLoop(i2, n2), o3.enabled = true, o3.clampWhenFinished = true, o3.play();
    } catch (e4) {
      console.error(e4);
    }
  }
  stopAnimation() {
    this.currentAnimationAction = null, this.mixer.stopAllAction();
  }
  updateAnimation(e3) {
    this.mixer.update(e3), this.queueShadowRender();
  }
  subscribeMixerEvent(e3, t2) {
    this.mixer.addEventListener(e3, t2);
  }
  updateShadow() {
    const e3 = this.shadow;
    if (null != e3) {
      const t2 = "wall" === this.element.arPlacement ? "back" : "bottom";
      e3.setScene(this, this.shadowSoftness, t2), e3.needsUpdate = true;
    }
  }
  renderShadow(e3) {
    const t2 = this.shadow;
    null != t2 && 1 == t2.needsUpdate && (t2.render(e3, this), t2.needsUpdate = false);
  }
  queueShadowRender() {
    null != this.shadow && (this.shadow.needsUpdate = true);
  }
  setShadowIntensity(e3) {
    if (this.shadowIntensity = e3, null != this._currentGLTF && (this.setBakedShadowVisibility(), !(e3 <= 0 && null == this.shadow))) {
      if (null == this.shadow) {
        const e4 = "wall" === this.element.arPlacement ? "back" : "bottom";
        this.shadow = new Hf(this, this.shadowSoftness, e4);
      }
      this.shadow.setIntensity(e3);
    }
  }
  setShadowSoftness(e3) {
    this.shadowSoftness = e3;
    const t2 = this.shadow;
    null != t2 && t2.setSoftness(e3);
  }
  setShadowOffset(e3) {
    const t2 = this.shadow;
    null != t2 && t2.setOffset(e3);
  }
  hitFromPoint(e3, t2 = this) {
    $f.setFromCamera(e3, this.getCamera());
    return $f.intersectObject(t2, true).find((e4) => e4.object.visible && !e4.object.userData.shadow);
  }
  positionAndNormalFromPoint(e3, t2 = this) {
    var i2;
    const n2 = this.hitFromPoint(e3, t2);
    if (null == n2)
      return null;
    return { position: n2.point, normal: null != n2.face ? n2.face.normal.clone().applyNormalMatrix(new Gt().getNormalMatrix(n2.object.matrixWorld)) : $f.ray.direction.clone().multiplyScalar(-1), uv: null !== (i2 = n2.uv) && void 0 !== i2 ? i2 : null };
  }
  surfaceFromPoint(e3, t2 = this) {
    const i2 = this.element.model;
    if (null == i2)
      return null;
    const n2 = this.hitFromPoint(e3, t2);
    if (null == n2 || null == n2.face)
      return null;
    const o2 = i2[ff](n2), { meshes: r2, primitives: s2 } = o2.mesh.userData.associations, a2 = new di(), l2 = new di(), c2 = new di(), { a: h2, b: u2, c: d2 } = n2.face, p2 = n2.object;
    p2.getVertexPosition(h2, a2), p2.getVertexPosition(u2, l2), p2.getVertexPosition(d2, c2);
    const _2 = new En(a2, l2, c2), g2 = new di();
    return _2.getBarycoord(p2.worldToLocal(n2.point), g2), `${r2} ${s2} ${h2} ${u2} ${d2} ${g2.x.toFixed(3)} ${g2.y.toFixed(3)} ${g2.z.toFixed(3)}`;
  }
  addHotspot(e3) {
    this.target.add(e3), this.annotationRenderer.domElement.appendChild(e3.element);
  }
  removeHotspot(e3) {
    this.target.remove(e3);
  }
  forHotspots(e3) {
    const { children: t2 } = this.target;
    for (let i2 = 0, n2 = t2.length; i2 < n2; i2++) {
      const n3 = t2[i2];
      n3 instanceof Nf && e3(n3);
    }
  }
  initializeSurface(e3) {
    if (null != e3.surface && null == e3.mesh) {
      const t2 = gp(e3.surface)[0].terms;
      if (8 != t2.length)
        return void console.warn(e3.surface + " does not have exactly 8 numbers.");
      const i2 = this.element.model[vf](t2[0].number, t2[1].number), n2 = new di(t2[2].number, t2[3].number, t2[4].number);
      if (null == i2)
        return void console.warn(e3.surface + " does not match a node/primitive in this glTF! Skipping this hotspot.");
      const o2 = i2.mesh.geometry.attributes.position.count;
      if (n2.x >= o2 || n2.y >= o2 || n2.z >= o2)
        return void console.warn(e3.surface + " vertex indices out of range in this glTF! Skipping this hotspot.");
      const r2 = new di(t2[5].number, t2[6].number, t2[7].number);
      e3.mesh = i2.mesh, e3.tri = n2, e3.bary = r2;
    }
  }
  updateSurfaceHotspots() {
    const e3 = !this.element.paused;
    this.forHotspots((t2) => {
      this.initializeSurface(t2), t2.updateSurface(e3);
    });
  }
  updateHotspotsVisibility(e3) {
    this.forHotspots((t2) => {
      Qf.copy(e3), Vf.setFromMatrixPosition(t2.matrixWorld), Qf.sub(Vf), Gf.copy(t2.normal).transformDirection(this.target.matrixWorld), Qf.dot(Gf) < 0 ? t2.hide() : t2.show();
    });
  }
  orientHotspots(e3) {
    this.forHotspots((t2) => {
      t2.orient(e3);
    });
  }
  setHotspotsVisibility(e3) {
    this.forHotspots((t2) => {
      t2.visible = e3;
    });
  }
  updateSchema(e3) {
    var t2;
    const { schemaElement: i2, element: n2 } = this, { alt: o2, poster: r2, iosSrc: s2 } = n2;
    if (null != e3) {
      const n3 = [{ "@type": "MediaObject", contentUrl: e3, encodingFormat: "gltf" === (null === (t2 = e3.split(".").pop()) || void 0 === t2 ? void 0 : t2.toLowerCase()) ? "model/gltf+json" : "model/gltf-binary" }];
      s2 && n3.push({ "@type": "MediaObject", contentUrl: s2, encodingFormat: "model/vnd.usdz+zip" });
      const a2 = { "@context": "http://schema.org/", "@type": "3DModel", image: null != r2 ? r2 : void 0, name: null != o2 ? o2 : void 0, encoding: n3 };
      i2.textContent = JSON.stringify(a2), document.head.appendChild(i2);
    } else
      null != i2.parentElement && i2.parentElement.removeChild(i2);
  }
}
class Xf extends EventTarget {
  constructor() {
    super(...arguments), this.ongoingActivities = /* @__PURE__ */ new Set(), this.totalProgress = 0;
  }
  get ongoingActivityCount() {
    return this.ongoingActivities.size;
  }
  beginActivity() {
    const e3 = { progress: 0, completed: false };
    return this.ongoingActivities.add(e3), 1 === this.ongoingActivityCount && this.announceTotalProgress(e3, 0), (t2) => {
      let i2;
      return i2 = Math.max(sh(t2, 0, 1), e3.progress), i2 !== e3.progress && this.announceTotalProgress(e3, i2), e3.progress;
    };
  }
  announceTotalProgress(e3, t2) {
    let i2 = 0, n2 = 0;
    1 == t2 && (e3.completed = true);
    for (const e4 of this.ongoingActivities) {
      const { progress: t3 } = e4;
      i2 += 1 - t3, true === e4.completed && n2++;
    }
    const o2 = e3.progress;
    e3.progress = t2, this.totalProgress += (t2 - o2) * (1 - this.totalProgress) / i2;
    const r2 = n2 === this.ongoingActivityCount ? 1 : this.totalProgress;
    this.dispatchEvent(new CustomEvent("progress", { detail: { totalProgress: r2 } })), n2 === this.ongoingActivityCount && (this.totalProgress = 0, this.ongoingActivities.clear());
  }
}
var Yf, Kf, Zf, Jf, ev, tv, iv, nv, ov, rv, sv, av, lv, cv = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
const hv = document.createElement("canvas"), uv = Symbol("fallbackResizeHandler"), dv = Symbol("defaultAriaLabel"), pv = Symbol("resizeObserver"), _v = Symbol("clearModelTimeout"), gv = Symbol("onContextLost"), mv = Symbol("loaded"), fv = Symbol("status"), vv = Symbol("onFocus"), Av = Symbol("onBlur"), bv = Symbol("updateSize"), yv = Symbol("intersectionObserver"), wv = Symbol("isElementInViewport"), xv = Symbol("announceModelVisibility"), Cv = Symbol("ariaLabel"), Sv = Symbol("altDefaulted"), Ev = Symbol("statusElement"), Iv = Symbol("updateStatus"), Tv = Symbol("loadedTime"), Bv = Symbol("updateSource"), Mv = Symbol("markLoaded"), kv = Symbol("container"), Rv = Symbol("input"), Pv = Symbol("canvas"), Dv = Symbol("scene"), Lv = Symbol("needsRender"), Fv = Symbol("tick"), Nv = Symbol("onModelLoad"), Ov = Symbol("onResize"), zv = Symbol("renderer"), Uv = Symbol("progressTracker"), Hv = Symbol("getLoaded"), Qv = Symbol("getModelIsVisible"), Vv = Symbol("shouldAttemptPreload"), Gv = (e3) => ({ x: e3.x, y: e3.y, z: e3.z, toString() {
  return `${this.x}m ${this.y}m ${this.z}m`;
} }), $v = (e3) => ({ u: e3.x, v: e3.y, toString() {
  return `${this.u} ${this.v}`;
} });
class Wv extends m {
  constructor() {
    super(), this.alt = null, this.src = null, this.withCredentials = false, this.generateSchema = false, this[Yf] = false, this[Kf] = false, this[Zf] = 0, this[Jf] = "", this[ev] = null, this[tv] = rh(() => {
      const e4 = this.getBoundingClientRect();
      this[bv](e4);
    }, 50), this[iv] = rh((e4) => {
      const t3 = this.modelIsVisible;
      t3 !== e4 && this.dispatchEvent(new CustomEvent("model-visibility", { detail: { visible: t3 } }));
    }, 0), this[nv] = null, this[ov] = null, this[rv] = new Xf(), this[sv] = () => {
      this[Ev].textContent = this[fv];
    }, this[av] = () => {
      this[Ev].textContent = "";
    }, this[lv] = (e4) => {
      this.dispatchEvent(new CustomEvent("error", { detail: { type: "webglcontextlost", sourceError: e4.sourceEvent } }));
    }, this.attachShadow({ mode: "open" });
    const e3 = this.shadowRoot;
    let t2, i2;
    if (((e4) => {
      oe(fh, e4);
    })(e3), this[kv] = e3.querySelector(".container"), this[Rv] = e3.querySelector(".userInput"), this[Pv] = e3.querySelector("canvas"), this[Ev] = e3.querySelector("#status"), this[dv] = this[Rv].getAttribute("aria-label"), this.isConnected) {
      const e4 = this.getBoundingClientRect();
      t2 = e4.width, i2 = e4.height;
    } else
      t2 = 300, i2 = 150;
    this[Dv] = new jf({ canvas: this[Pv], element: this, width: t2, height: i2 }), Promise.resolve().then(() => {
      this[bv](this.getBoundingClientRect());
    }), Wc && (this[pv] = new ResizeObserver((e4) => {
      if (!this[zv].isPresenting)
        for (let t3 of e4)
          t3.target === this && this[bv](t3.contentRect);
    })), qc ? this[yv] = new IntersectionObserver((e4) => {
      for (let t3 of e4)
        if (t3.target === this) {
          const e5 = this.modelIsVisible;
          this[wv] = t3.isIntersecting, this[xv](e5), this[wv] && !this.loaded && this[Bv]();
        }
    }, { root: null, rootMargin: "0px", threshold: 1e-5 }) : this[wv] = true;
  }
  static get is() {
    return "model-viewer";
  }
  static set modelCacheSize(e3) {
    nd[td].evictionThreshold = e3;
  }
  static get modelCacheSize() {
    return nd[td].evictionThreshold;
  }
  static set minimumRenderScale(e3) {
    e3 > 1 && console.warn("<model-viewer> minimumRenderScale has been clamped to a maximum value of 1."), e3 <= 0 && console.warn("<model-viewer> minimumRenderScale has been clamped to a minimum value of 0.25."), Jg.singleton.minScale = e3;
  }
  static get minimumRenderScale() {
    return Jg.singleton.minScale;
  }
  get loaded() {
    return this[Hv]();
  }
  get [(Yf = wv, Kf = mv, Zf = Tv, Jf = fv, ev = _v, tv = uv, iv = xv, nv = pv, ov = yv, rv = Uv, zv)]() {
    return Jg.singleton;
  }
  get modelIsVisible() {
    return this[Qv]();
  }
  connectedCallback() {
    super.connectedCallback && super.connectedCallback(), Wc ? this[pv].observe(this) : self.addEventListener("resize", this[uv]), qc && this[yv].observe(this), this.addEventListener("focus", this[vv]), this.addEventListener("blur", this[Av]);
    const e3 = this[zv];
    e3.addEventListener("contextlost", this[gv]), e3.registerScene(this[Dv]), null != this[_v] && (self.clearTimeout(this[_v]), this[_v] = null, this.requestUpdate("src", null));
  }
  disconnectedCallback() {
    super.disconnectedCallback && super.disconnectedCallback(), Wc ? this[pv].unobserve(this) : self.removeEventListener("resize", this[uv]), qc && this[yv].unobserve(this), this.removeEventListener("focus", this[vv]), this.removeEventListener("blur", this[Av]);
    const e3 = this[zv];
    e3.removeEventListener("contextlost", this[gv]), e3.unregisterScene(this[Dv]), this[_v] = self.setTimeout(() => {
      this[Dv].dispose(), this[_v] = null;
    }, 10);
  }
  updated(e3) {
    super.updated(e3), e3.has("src") && (null == this.src ? (this[mv] = false, this[Tv] = 0, this[Dv].reset()) : this.src !== this[Dv].url && (this[mv] = false, this[Tv] = 0, this[Bv]())), e3.has("alt") && this[Rv].setAttribute("aria-label", this[Cv]), e3.has("withCredentials") && (nd.withCredentials = this.withCredentials, this[zv].textureUtils.withCredentials = this.withCredentials), e3.has("generateSchema") && (this.generateSchema ? this[Dv].updateSchema(this.src) : this[Dv].updateSchema(null));
  }
  toDataURL(e3, t2) {
    return this[zv].displayCanvas(this[Dv]).toDataURL(e3, t2);
  }
  async toBlob(e3) {
    const t2 = e3 ? e3.mimeType : void 0, i2 = e3 ? e3.qualityArgument : void 0, n2 = e3 ? e3.idealAspect : void 0, { width: o2, height: r2, idealAspect: s2, aspect: a2 } = this[Dv], { dpr: l2, scaleFactor: c2 } = this[zv];
    let h2 = o2 * c2 * l2, u2 = r2 * c2 * l2, d2 = 0, p2 = 0;
    if (true === n2)
      if (s2 > a2) {
        const e4 = u2;
        u2 = Math.round(h2 / s2), p2 = (e4 - u2) / 2;
      } else {
        const e4 = h2;
        h2 = Math.round(u2 * s2), d2 = (e4 - h2) / 2;
      }
    hv.width = h2, hv.height = u2;
    try {
      return new Promise(async (e4, n3) => (hv.getContext("2d").drawImage(this[zv].displayCanvas(this[Dv]), d2, p2, h2, u2, 0, 0, h2, u2), !hv.msToBlob || t2 && "image/png" !== t2 ? hv.toBlob ? void hv.toBlob((t3) => {
        if (!t3)
          return n3(new Error("Unable to retrieve canvas blob"));
        e4(t3);
      }, t2, i2) : e4(await (async (e5) => new Promise((t3, i3) => {
        const n4 = e5.match(/data:(.*);/);
        if (!n4)
          return i3(new Error(`${e5} is not a valid data Url`));
        const o3 = n4[1], r3 = e5.replace(/data:image\/\w+;base64,/, ""), s3 = atob(r3), a3 = [];
        for (let e6 = 0; e6 < s3.length; e6 += 512) {
          const t4 = s3.slice(e6, e6 + 512), i4 = new Array(t4.length);
          for (let e7 = 0; e7 < t4.length; e7++)
            i4[e7] = t4.charCodeAt(e7);
          const n5 = new Uint8Array(i4);
          a3.push(n5);
        }
        t3(new Blob(a3, { type: o3 }));
      }))(hv.toDataURL(t2, i2))) : e4(hv.msToBlob())));
    } finally {
      this[bv]({ width: o2, height: r2 });
    }
  }
  registerRenderer(e3) {
    this[Dv].externalRenderer = e3;
  }
  unregisterRenderer() {
    this[Dv].externalRenderer = null;
  }
  get [Cv]() {
    return this[Sv];
  }
  get [Sv]() {
    return null == this.alt || "null" === this.alt ? this[dv] : this.alt;
  }
  [Hv]() {
    return this[mv];
  }
  [Qv]() {
    return this.loaded && this[wv];
  }
  [Vv]() {
    return !!this.src && this[wv];
  }
  [bv]({ width: e3, height: t2 }) {
    0 !== e3 && 0 !== t2 && (this[kv].style.width = `${e3}px`, this[kv].style.height = `${t2}px`, this[Ov]({ width: e3, height: t2 }));
  }
  [Fv](e3, t2) {
  }
  [Mv]() {
    this[mv] || (this[mv] = true, this[Tv] = performance.now());
  }
  [Lv]() {
    this[Dv].queueRender();
  }
  [Nv]() {
  }
  [Iv](e3) {
    this[fv] = e3;
    const t2 = this.getRootNode();
    null != t2 && t2.activeElement === this && this[Ev].textContent != e3 && (this[Ev].textContent = e3);
  }
  [(sv = vv, av = Av, Ov)](e3) {
    this[Dv].setSize(e3.width, e3.height);
  }
  async [(lv = gv, Bv)]() {
    const e3 = this[Dv];
    if (this.loaded || !this[Vv]() || this.src === e3.url)
      return;
    this.generateSchema && e3.updateSchema(this.src), this[Iv]("Loading"), e3.stopAnimation();
    const t2 = this[Uv].beginActivity(), i2 = this.src;
    try {
      const n2 = e3.setSource(i2, (e4) => t2(0.95 * sh(e4, 0, 1))), o2 = this[dh]();
      await Promise.all([n2, o2]), this[Mv](), this[Nv](), await new Promise((e4) => {
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            this.dispatchEvent(new CustomEvent("load", { detail: { url: i2 } })), e4();
          });
        });
      });
    } catch (e4) {
      this.dispatchEvent(new CustomEvent("error", { detail: { type: "loadfailure", sourceError: e4 } }));
    } finally {
      t2(1);
    }
  }
}
cv([ue({ type: String })], Wv.prototype, "alt", void 0), cv([ue({ type: String })], Wv.prototype, "src", void 0), cv([ue({ type: Boolean, attribute: "with-credentials" })], Wv.prototype, "withCredentials", void 0), cv([ue({ type: Boolean, attribute: "generate-schema" })], Wv.prototype, "generateSchema", void 0);
var qv = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
const jv = Symbol("changeAnimation"), Xv = Symbol("paused"), Yv = { repetitions: 1 / 0, pingpong: false }, Kv = Symbol("hotspotMap"), Zv = Symbol("mutationCallback"), Jv = Symbol("observer"), eA = Symbol("addHotspot"), tA = Symbol("removeHotspot"), iA = new Qi();
var nA = function(e3) {
  return URL.createObjectURL(new Blob([e3], { type: "text/javascript" }));
};
try {
  URL.revokeObjectURL(nA(""));
} catch (Ry2) {
  nA = function(e3) {
    return "data:application/javascript;charset=UTF-8," + encodeURI(e3);
  };
}
var oA = Uint8Array, rA = Uint16Array, sA = Uint32Array, aA = new oA([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), lA = new oA([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), cA = new oA([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), hA = function(e3, t2) {
  for (var i2 = new rA(31), n2 = 0; n2 < 31; ++n2)
    i2[n2] = t2 += 1 << e3[n2 - 1];
  var o2 = new sA(i2[30]);
  for (n2 = 1; n2 < 30; ++n2)
    for (var r2 = i2[n2]; r2 < i2[n2 + 1]; ++r2)
      o2[r2] = r2 - i2[n2] << 5 | n2;
  return [i2, o2];
}, uA = hA(aA, 2), dA = uA[0], pA = uA[1];
dA[28] = 258, pA[258] = 28;
for (var _A = hA(lA, 0)[1], gA = new rA(32768), mA = 0; mA < 32768; ++mA) {
  var fA = (43690 & mA) >>> 1 | (21845 & mA) << 1;
  fA = (61680 & (fA = (52428 & fA) >>> 2 | (13107 & fA) << 2)) >>> 4 | (3855 & fA) << 4, gA[mA] = ((65280 & fA) >>> 8 | (255 & fA) << 8) >>> 1;
}
var vA = function(e3, t2, i2) {
  for (var n2 = e3.length, o2 = 0, r2 = new rA(t2); o2 < n2; ++o2)
    ++r2[e3[o2] - 1];
  var s2, a2 = new rA(t2);
  for (o2 = 0; o2 < t2; ++o2)
    a2[o2] = a2[o2 - 1] + r2[o2 - 1] << 1;
  if (i2) {
    s2 = new rA(1 << t2);
    var l2 = 15 - t2;
    for (o2 = 0; o2 < n2; ++o2)
      if (e3[o2])
        for (var c2 = o2 << 4 | e3[o2], h2 = t2 - e3[o2], u2 = a2[e3[o2] - 1]++ << h2, d2 = u2 | (1 << h2) - 1; u2 <= d2; ++u2)
          s2[gA[u2] >>> l2] = c2;
  } else
    for (s2 = new rA(n2), o2 = 0; o2 < n2; ++o2)
      e3[o2] && (s2[o2] = gA[a2[e3[o2] - 1]++] >>> 15 - e3[o2]);
  return s2;
}, AA = new oA(288);
for (mA = 0; mA < 144; ++mA)
  AA[mA] = 8;
for (mA = 144; mA < 256; ++mA)
  AA[mA] = 9;
for (mA = 256; mA < 280; ++mA)
  AA[mA] = 7;
for (mA = 280; mA < 288; ++mA)
  AA[mA] = 8;
var bA = new oA(32);
for (mA = 0; mA < 32; ++mA)
  bA[mA] = 5;
var yA = vA(AA, 9, 0), wA = vA(bA, 5, 0), xA = function(e3) {
  return (e3 / 8 | 0) + (7 & e3 && 1);
}, CA = function(e3, t2, i2) {
  (null == t2 || t2 < 0) && (t2 = 0), (null == i2 || i2 > e3.length) && (i2 = e3.length);
  var n2 = new (e3 instanceof rA ? rA : e3 instanceof sA ? sA : oA)(i2 - t2);
  return n2.set(e3.subarray(t2, i2)), n2;
}, SA = function(e3, t2, i2) {
  i2 <<= 7 & t2;
  var n2 = t2 / 8 | 0;
  e3[n2] |= i2, e3[n2 + 1] |= i2 >>> 8;
}, EA = function(e3, t2, i2) {
  i2 <<= 7 & t2;
  var n2 = t2 / 8 | 0;
  e3[n2] |= i2, e3[n2 + 1] |= i2 >>> 8, e3[n2 + 2] |= i2 >>> 16;
}, IA = function(e3, t2) {
  for (var i2 = [], n2 = 0; n2 < e3.length; ++n2)
    e3[n2] && i2.push({ s: n2, f: e3[n2] });
  var o2 = i2.length, r2 = i2.slice();
  if (!o2)
    return [DA, 0];
  if (1 == o2) {
    var s2 = new oA(i2[0].s + 1);
    return s2[i2[0].s] = 1, [s2, 1];
  }
  i2.sort(function(e4, t3) {
    return e4.f - t3.f;
  }), i2.push({ s: -1, f: 25001 });
  var a2 = i2[0], l2 = i2[1], c2 = 0, h2 = 1, u2 = 2;
  for (i2[0] = { s: -1, f: a2.f + l2.f, l: a2, r: l2 }; h2 != o2 - 1; )
    a2 = i2[i2[c2].f < i2[u2].f ? c2++ : u2++], l2 = i2[c2 != h2 && i2[c2].f < i2[u2].f ? c2++ : u2++], i2[h2++] = { s: -1, f: a2.f + l2.f, l: a2, r: l2 };
  var d2 = r2[0].s;
  for (n2 = 1; n2 < o2; ++n2)
    r2[n2].s > d2 && (d2 = r2[n2].s);
  var p2 = new rA(d2 + 1), _2 = TA(i2[h2 - 1], p2, 0);
  if (_2 > t2) {
    n2 = 0;
    var g2 = 0, m2 = _2 - t2, f2 = 1 << m2;
    for (r2.sort(function(e4, t3) {
      return p2[t3.s] - p2[e4.s] || e4.f - t3.f;
    }); n2 < o2; ++n2) {
      var v2 = r2[n2].s;
      if (!(p2[v2] > t2))
        break;
      g2 += f2 - (1 << _2 - p2[v2]), p2[v2] = t2;
    }
    for (g2 >>>= m2; g2 > 0; ) {
      var A2 = r2[n2].s;
      p2[A2] < t2 ? g2 -= 1 << t2 - p2[A2]++ - 1 : ++n2;
    }
    for (; n2 >= 0 && g2; --n2) {
      var b2 = r2[n2].s;
      p2[b2] == t2 && (--p2[b2], ++g2);
    }
    _2 = t2;
  }
  return [new oA(p2), _2];
}, TA = function(e3, t2, i2) {
  return -1 == e3.s ? Math.max(TA(e3.l, t2, i2 + 1), TA(e3.r, t2, i2 + 1)) : t2[e3.s] = i2;
}, BA = function(e3) {
  for (var t2 = e3.length; t2 && !e3[--t2]; )
    ;
  for (var i2 = new rA(++t2), n2 = 0, o2 = e3[0], r2 = 1, s2 = function(e4) {
    i2[n2++] = e4;
  }, a2 = 1; a2 <= t2; ++a2)
    if (e3[a2] == o2 && a2 != t2)
      ++r2;
    else {
      if (!o2 && r2 > 2) {
        for (; r2 > 138; r2 -= 138)
          s2(32754);
        r2 > 2 && (s2(r2 > 10 ? r2 - 11 << 5 | 28690 : r2 - 3 << 5 | 12305), r2 = 0);
      } else if (r2 > 3) {
        for (s2(o2), --r2; r2 > 6; r2 -= 6)
          s2(8304);
        r2 > 2 && (s2(r2 - 3 << 5 | 8208), r2 = 0);
      }
      for (; r2--; )
        s2(o2);
      r2 = 1, o2 = e3[a2];
    }
  return [i2.subarray(0, n2), t2];
}, MA = function(e3, t2) {
  for (var i2 = 0, n2 = 0; n2 < t2.length; ++n2)
    i2 += e3[n2] * t2[n2];
  return i2;
}, kA = function(e3, t2, i2) {
  var n2 = i2.length, o2 = xA(t2 + 2);
  e3[o2] = 255 & n2, e3[o2 + 1] = n2 >>> 8, e3[o2 + 2] = 255 ^ e3[o2], e3[o2 + 3] = 255 ^ e3[o2 + 1];
  for (var r2 = 0; r2 < n2; ++r2)
    e3[o2 + r2 + 4] = i2[r2];
  return 8 * (o2 + 4 + n2);
}, RA = function(e3, t2, i2, n2, o2, r2, s2, a2, l2, c2, h2) {
  SA(t2, h2++, i2), ++o2[256];
  for (var u2 = IA(o2, 15), d2 = u2[0], p2 = u2[1], _2 = IA(r2, 15), g2 = _2[0], m2 = _2[1], f2 = BA(d2), v2 = f2[0], A2 = f2[1], b2 = BA(g2), y2 = b2[0], w2 = b2[1], x2 = new rA(19), C2 = 0; C2 < v2.length; ++C2)
    x2[31 & v2[C2]]++;
  for (C2 = 0; C2 < y2.length; ++C2)
    x2[31 & y2[C2]]++;
  for (var S2 = IA(x2, 7), E2 = S2[0], I2 = S2[1], T2 = 19; T2 > 4 && !E2[cA[T2 - 1]]; --T2)
    ;
  var B2, M2, k2, R2, P2 = c2 + 5 << 3, D2 = MA(o2, AA) + MA(r2, bA) + s2, L2 = MA(o2, d2) + MA(r2, g2) + s2 + 14 + 3 * T2 + MA(x2, E2) + (2 * x2[16] + 3 * x2[17] + 7 * x2[18]);
  if (P2 <= D2 && P2 <= L2)
    return kA(t2, h2, e3.subarray(l2, l2 + c2));
  if (SA(t2, h2, 1 + (L2 < D2)), h2 += 2, L2 < D2) {
    B2 = vA(d2, p2, 0), M2 = d2, k2 = vA(g2, m2, 0), R2 = g2;
    var F2 = vA(E2, I2, 0);
    SA(t2, h2, A2 - 257), SA(t2, h2 + 5, w2 - 1), SA(t2, h2 + 10, T2 - 4), h2 += 14;
    for (C2 = 0; C2 < T2; ++C2)
      SA(t2, h2 + 3 * C2, E2[cA[C2]]);
    h2 += 3 * T2;
    for (var N2 = [v2, y2], O2 = 0; O2 < 2; ++O2) {
      var z2 = N2[O2];
      for (C2 = 0; C2 < z2.length; ++C2) {
        var U2 = 31 & z2[C2];
        SA(t2, h2, F2[U2]), h2 += E2[U2], U2 > 15 && (SA(t2, h2, z2[C2] >>> 5 & 127), h2 += z2[C2] >>> 12);
      }
    }
  } else
    B2 = yA, M2 = AA, k2 = wA, R2 = bA;
  for (C2 = 0; C2 < a2; ++C2)
    if (n2[C2] > 255) {
      U2 = n2[C2] >>> 18 & 31;
      EA(t2, h2, B2[U2 + 257]), h2 += M2[U2 + 257], U2 > 7 && (SA(t2, h2, n2[C2] >>> 23 & 31), h2 += aA[U2]);
      var H2 = 31 & n2[C2];
      EA(t2, h2, k2[H2]), h2 += R2[H2], H2 > 3 && (EA(t2, h2, n2[C2] >>> 5 & 8191), h2 += lA[H2]);
    } else
      EA(t2, h2, B2[n2[C2]]), h2 += M2[n2[C2]];
  return EA(t2, h2, B2[256]), h2 + M2[256];
}, PA = new sA([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), DA = new oA(0), LA = function() {
  for (var e3 = new sA(256), t2 = 0; t2 < 256; ++t2) {
    for (var i2 = t2, n2 = 9; --n2; )
      i2 = (1 & i2 && 3988292384) ^ i2 >>> 1;
    e3[t2] = i2;
  }
  return e3;
}(), FA = function() {
  var e3 = -1;
  return { p: function(t2) {
    for (var i2 = e3, n2 = 0; n2 < t2.length; ++n2)
      i2 = LA[255 & i2 ^ t2[n2]] ^ i2 >>> 8;
    e3 = i2;
  }, d: function() {
    return ~e3;
  } };
}, NA = function(e3, t2, i2, n2, o2) {
  return function(e4, t3, i3, n3, o3, r2) {
    var s2 = e4.length, a2 = new oA(n3 + s2 + 5 * (1 + Math.ceil(s2 / 7e3)) + o3), l2 = a2.subarray(n3, a2.length - o3), c2 = 0;
    if (!t3 || s2 < 8)
      for (var h2 = 0; h2 <= s2; h2 += 65535) {
        var u2 = h2 + 65535;
        u2 < s2 ? c2 = kA(l2, c2, e4.subarray(h2, u2)) : (l2[h2] = r2, c2 = kA(l2, c2, e4.subarray(h2, s2)));
      }
    else {
      for (var d2 = PA[t3 - 1], p2 = d2 >>> 13, _2 = 8191 & d2, g2 = (1 << i3) - 1, m2 = new rA(32768), f2 = new rA(g2 + 1), v2 = Math.ceil(i3 / 3), A2 = 2 * v2, b2 = function(t4) {
        return (e4[t4] ^ e4[t4 + 1] << v2 ^ e4[t4 + 2] << A2) & g2;
      }, y2 = new sA(25e3), w2 = new rA(288), x2 = new rA(32), C2 = 0, S2 = 0, E2 = (h2 = 0, 0), I2 = 0, T2 = 0; h2 < s2; ++h2) {
        var B2 = b2(h2), M2 = 32767 & h2, k2 = f2[B2];
        if (m2[M2] = k2, f2[B2] = M2, I2 <= h2) {
          var R2 = s2 - h2;
          if ((C2 > 7e3 || E2 > 24576) && R2 > 423) {
            c2 = RA(e4, l2, 0, y2, w2, x2, S2, E2, T2, h2 - T2, c2), E2 = C2 = S2 = 0, T2 = h2;
            for (var P2 = 0; P2 < 286; ++P2)
              w2[P2] = 0;
            for (P2 = 0; P2 < 30; ++P2)
              x2[P2] = 0;
          }
          var D2 = 2, L2 = 0, F2 = _2, N2 = M2 - k2 & 32767;
          if (R2 > 2 && B2 == b2(h2 - N2))
            for (var O2 = Math.min(p2, R2) - 1, z2 = Math.min(32767, h2), U2 = Math.min(258, R2); N2 <= z2 && --F2 && M2 != k2; ) {
              if (e4[h2 + D2] == e4[h2 + D2 - N2]) {
                for (var H2 = 0; H2 < U2 && e4[h2 + H2] == e4[h2 + H2 - N2]; ++H2)
                  ;
                if (H2 > D2) {
                  if (D2 = H2, L2 = N2, H2 > O2)
                    break;
                  var Q2 = Math.min(N2, H2 - 2), V2 = 0;
                  for (P2 = 0; P2 < Q2; ++P2) {
                    var G2 = h2 - N2 + P2 + 32768 & 32767, $2 = G2 - m2[G2] + 32768 & 32767;
                    $2 > V2 && (V2 = $2, k2 = G2);
                  }
                }
              }
              N2 += (M2 = k2) - (k2 = m2[M2]) + 32768 & 32767;
            }
          if (L2) {
            y2[E2++] = 268435456 | pA[D2] << 18 | _A[L2];
            var W2 = 31 & pA[D2], q2 = 31 & _A[L2];
            S2 += aA[W2] + lA[q2], ++w2[257 + W2], ++x2[q2], I2 = h2 + D2, ++C2;
          } else
            y2[E2++] = e4[h2], ++w2[e4[h2]];
        }
      }
      c2 = RA(e4, l2, r2, y2, w2, x2, S2, E2, T2, h2 - T2, c2), !r2 && 7 & c2 && (c2 = kA(l2, c2 + 1, DA));
    }
    return CA(a2, 0, n3 + xA(c2) + o3);
  }(e3, null == t2.level ? 6 : t2.level, null == t2.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(e3.length)))) : 12 + t2.mem, i2, n2, !o2);
}, OA = function(e3, t2) {
  var i2 = {};
  for (var n2 in e3)
    i2[n2] = e3[n2];
  for (var n2 in t2)
    i2[n2] = t2[n2];
  return i2;
}, zA = function(e3, t2, i2) {
  for (; i2; ++t2)
    e3[t2] = i2, i2 >>>= 8;
};
function UA(e3, t2) {
  return NA(e3, t2 || {}, 0, 0);
}
var HA = function(e3, t2, i2, n2) {
  for (var o2 in e3) {
    var r2 = e3[o2], s2 = t2 + o2;
    r2 instanceof oA ? i2[s2] = [r2, n2] : Array.isArray(r2) ? i2[s2] = [r2[0], OA(n2, r2[1])] : HA(r2, s2 + "/", i2, n2);
  }
}, QA = "undefined" != typeof TextEncoder && new TextEncoder(), VA = "undefined" != typeof TextDecoder && new TextDecoder();
try {
  VA.decode(DA, { stream: true }), 1;
} catch (Ry2) {
}
function GA(e3, t2) {
  if (t2) {
    for (var i2 = new oA(e3.length), n2 = 0; n2 < e3.length; ++n2)
      i2[n2] = e3.charCodeAt(n2);
    return i2;
  }
  if (QA)
    return QA.encode(e3);
  var o2 = e3.length, r2 = new oA(e3.length + (e3.length >> 1)), s2 = 0, a2 = function(e4) {
    r2[s2++] = e4;
  };
  for (n2 = 0; n2 < o2; ++n2) {
    if (s2 + 5 > r2.length) {
      var l2 = new oA(s2 + 8 + (o2 - n2 << 1));
      l2.set(r2), r2 = l2;
    }
    var c2 = e3.charCodeAt(n2);
    c2 < 128 || t2 ? a2(c2) : c2 < 2048 ? (a2(192 | c2 >> 6), a2(128 | 63 & c2)) : c2 > 55295 && c2 < 57344 ? (a2(240 | (c2 = 65536 + (1047552 & c2) | 1023 & e3.charCodeAt(++n2)) >> 18), a2(128 | c2 >> 12 & 63), a2(128 | c2 >> 6 & 63), a2(128 | 63 & c2)) : (a2(224 | c2 >> 12), a2(128 | c2 >> 6 & 63), a2(128 | 63 & c2));
  }
  return CA(r2, 0, s2);
}
var $A = function(e3) {
  var t2 = 0;
  if (e3)
    for (var i2 in e3) {
      var n2 = e3[i2].length;
      if (n2 > 65535)
        throw "extra field too long";
      t2 += n2 + 4;
    }
  return t2;
}, WA = function(e3, t2, i2, n2, o2, r2, s2, a2) {
  var l2 = n2.length, c2 = i2.extra, h2 = a2 && a2.length, u2 = $A(c2);
  zA(e3, t2, null != s2 ? 33639248 : 67324752), t2 += 4, null != s2 && (e3[t2++] = 20, e3[t2++] = i2.os), e3[t2] = 20, t2 += 2, e3[t2++] = i2.flag << 1 | (null == r2 && 8), e3[t2++] = o2 && 8, e3[t2++] = 255 & i2.compression, e3[t2++] = i2.compression >> 8;
  var d2 = new Date(null == i2.mtime ? Date.now() : i2.mtime), p2 = d2.getFullYear() - 1980;
  if (p2 < 0 || p2 > 119)
    throw "date not in range 1980-2099";
  if (zA(e3, t2, p2 << 25 | d2.getMonth() + 1 << 21 | d2.getDate() << 16 | d2.getHours() << 11 | d2.getMinutes() << 5 | d2.getSeconds() >>> 1), t2 += 4, null != r2 && (zA(e3, t2, i2.crc), zA(e3, t2 + 4, r2), zA(e3, t2 + 8, i2.size)), zA(e3, t2 + 12, l2), zA(e3, t2 + 14, u2), t2 += 16, null != s2 && (zA(e3, t2, h2), zA(e3, t2 + 6, i2.attrs), zA(e3, t2 + 10, s2), t2 += 14), e3.set(n2, t2), t2 += l2, u2)
    for (var _2 in c2) {
      var g2 = c2[_2], m2 = g2.length;
      zA(e3, t2, +_2), zA(e3, t2 + 2, m2), e3.set(g2, t2 + 4), t2 += 4 + m2;
    }
  return h2 && (e3.set(a2, t2), t2 += h2), t2;
};
function qA(e3, t2) {
  t2 || (t2 = {});
  var i2 = {}, n2 = [];
  HA(e3, "", i2, t2);
  var o2 = 0, r2 = 0;
  for (var s2 in i2) {
    var a2 = i2[s2], l2 = a2[0], c2 = a2[1], h2 = 0 == c2.level ? 0 : 8, u2 = (x2 = GA(s2)).length, d2 = c2.comment, p2 = d2 && GA(d2), _2 = p2 && p2.length, g2 = $A(c2.extra);
    if (u2 > 65535)
      throw "filename too long";
    var m2 = h2 ? UA(l2, c2) : l2, f2 = m2.length, v2 = FA();
    v2.p(l2), n2.push(OA(c2, { size: l2.length, crc: v2.d(), c: m2, f: x2, m: p2, u: u2 != s2.length || p2 && d2.length != _2, o: o2, compression: h2 })), o2 += 30 + u2 + g2 + f2, r2 += 76 + 2 * (u2 + g2) + (_2 || 0) + f2;
  }
  for (var A2 = new oA(r2 + 22), b2 = o2, y2 = r2 - o2, w2 = 0; w2 < n2.length; ++w2) {
    var x2 = n2[w2];
    WA(A2, x2.o, x2, x2.f, x2.u, x2.c.length);
    var C2 = 30 + x2.f.length + $A(x2.extra);
    A2.set(x2.c, x2.o + C2), WA(A2, o2, x2, x2.f, x2.u, x2.c.length, x2.o, x2.m), o2 += 16 + C2 + (x2.m ? x2.m.length : 0);
  }
  return function(e4, t3, i3, n3, o3) {
    zA(e4, t3, 101010256), zA(e4, t3 + 8, i3), zA(e4, t3 + 10, i3), zA(e4, t3 + 12, n3), zA(e4, t3 + 16, o3);
  }(A2, o2, n2.length, y2, b2), A2;
}
class jA {
  async parse(e3, t2 = {}) {
    t2 = Object.assign({ ar: { anchoring: { type: "plane" }, planeAnchoring: { alignment: "horizontal" } } }, t2);
    const i2 = {}, n2 = "model.usda";
    i2[n2] = null;
    let o2 = KA();
    o2 += function(e4) {
      return `def Xform "Root"
{
    def Scope "Scenes" (
        kind = "sceneLibrary"
    )
    {
        def Xform "Scene" (
            customData = {
                bool preliminary_collidesWithEnvironment = 0
                string sceneName = "Scene"
            }
            sceneName = "Scene"
        )
        {
        token preliminary:anchoring:type = "${e4.ar.anchoring.type}"
        token preliminary:planeAnchoring:alignment = "${e4.ar.planeAnchoring.alignment}"

`;
    }(t2);
    const r2 = {}, s2 = {};
    e3.traverseVisible((e4) => {
      if (e4.isMesh) {
        const t3 = e4.geometry, n3 = e4.material;
        if (n3.isMeshStandardMaterial) {
          const s3 = "geometries/Geometry_" + t3.id + ".usd";
          if (!(s3 in i2)) {
            const e5 = function(e6) {
              const t4 = function(e7) {
                const t5 = "Geometry", i3 = e7.attributes, n4 = i3.position.count;
                return `
    def Mesh "${t5}"
    {
        int[] faceVertexCounts = [${function(e8) {
                  const t6 = null !== e8.index ? e8.index.count : e8.attributes.position.count;
                  return Array(t6 / 3).fill(3).join(", ");
                }(e7)}]
        int[] faceVertexIndices = [${function(e8) {
                  const t6 = e8.index, i4 = [];
                  if (null !== t6)
                    for (let e9 = 0; e9 < t6.count; e9++)
                      i4.push(t6.getX(e9));
                  else {
                    const t7 = e8.attributes.position.count;
                    for (let e9 = 0; e9 < t7; e9++)
                      i4.push(e9);
                  }
                  return i4.join(", ");
                }(e7)}]
        normal3f[] normals = [${eb(i3.normal, n4)}] (
            interpolation = "vertex"
        )
        point3f[] points = [${eb(i3.position, n4)}]
        float2[] primvars:st = [${function(e8, t6) {
                  if (void 0 === e8)
                    return console.warn("USDZExporter: UVs missing."), Array(t6).fill("(0, 0)").join(", ");
                  const i4 = [];
                  for (let t7 = 0; t7 < e8.count; t7++) {
                    const n5 = e8.getX(t7), o3 = e8.getY(t7);
                    i4.push(`(${n5.toPrecision(YA)}, ${1 - o3.toPrecision(YA)})`);
                  }
                  return i4.join(", ");
                }(i3.uv, n4)}] (
            interpolation = "vertex"
        )
        uniform token subdivisionScheme = "none"
    }
`;
              }(e6);
              return `
def "Geometry"
{
  ${t4}
}
`;
            }(t3);
            i2[s3] = function(e6) {
              let t4 = KA();
              return t4 += e6, GA(t4);
            }(e5);
          }
          n3.uuid in r2 || (r2[n3.uuid] = n3), o2 += function(e5, t4, i3) {
            const n4 = "Object_" + e5.id, o3 = ZA(e5.matrixWorld);
            e5.matrixWorld.determinant() < 0 && console.warn("THREE.USDZExporter: USDZ does not support negative scales", e5);
            return `def Xform "${n4}" (
    prepend references = @./geometries/Geometry_${t4.id}.usd@</Geometry>
)
{
    matrix4d xformOp:transform = ${o3}
    uniform token[] xformOpOrder = ["xformOp:transform"]

    rel material:binding = </Materials/Material_${i3.id}>
}

`;
          }(e4, t3, n3);
        } else
          console.warn("THREE.USDZExporter: Unsupported material type (USDZ only supports MeshStandardMaterial)", e4);
      } else
        e4.isCamera && (o2 += function(e5) {
          const t3 = e5.name ? e5.name : "Camera_" + e5.id, i3 = ZA(e5.matrixWorld);
          e5.matrixWorld.determinant() < 0 && console.warn("THREE.USDZExporter: USDZ does not support negative scales", e5);
          return e5.isOrthographicCamera ? `def Camera "${t3}"
		{
			matrix4d xformOp:transform = ${i3}
			uniform token[] xformOpOrder = ["xformOp:transform"]
	
			float2 clippingRange = (${e5.near.toPrecision(YA)}, ${e5.far.toPrecision(YA)})
			float horizontalAperture = ${(10 * (Math.abs(e5.left) + Math.abs(e5.right))).toPrecision(YA)}
			float verticalAperture = ${(10 * (Math.abs(e5.top) + Math.abs(e5.bottom))).toPrecision(YA)}
			token projection = "orthographic"
		}
	
	` : `def Camera "${t3}"
		{
			matrix4d xformOp:transform = ${i3}
			uniform token[] xformOpOrder = ["xformOp:transform"]
	
			float2 clippingRange = (${e5.near.toPrecision(YA)}, ${e5.far.toPrecision(YA)})
			float focalLength = ${e5.getFocalLength().toPrecision(YA)}
			float focusDistance = ${e5.focus.toPrecision(YA)}
			float horizontalAperture = ${e5.getFilmWidth().toPrecision(YA)}
			token projection = "perspective"
			float verticalAperture = ${e5.getFilmHeight().toPrecision(YA)}
		}
	
	`;
        }(e4));
    }), o2 += "\n        }\n    }\n}\n\n", o2 += function(e4, t3) {
      const i3 = [];
      for (const n3 in e4) {
        const o3 = e4[n3];
        i3.push(tb(o3, t3));
      }
      return `def "Materials"
{
${i3.join("")}
}

`;
    }(r2, s2), i2[n2] = GA(o2), o2 = null;
    for (const e4 in s2) {
      const t3 = s2[e4], n3 = e4.split("_")[1], o3 = 1023 === t3.format, r3 = XA(t3.image, n3, t3.flipY), a3 = await new Promise((e5) => r3.toBlob(e5, o3 ? "image/png" : "image/jpeg", 1));
      i2[`textures/Texture_${e4}.${o3 ? "png" : "jpg"}`] = new Uint8Array(await a3.arrayBuffer());
    }
    let a2 = 0;
    for (const e4 in i2) {
      const t3 = i2[e4];
      a2 += 34 + e4.length;
      const n3 = 63 & a2;
      if (4 !== n3) {
        const o3 = new Uint8Array(64 - n3);
        i2[e4] = [t3, { extra: { 12345: o3 } }];
      }
      a2 = t3.length;
    }
    return qA(i2, { level: 0 });
  }
}
function XA(e3, t2, i2) {
  if ("undefined" != typeof HTMLImageElement && e3 instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e3 instanceof HTMLCanvasElement || "undefined" != typeof OffscreenCanvas && e3 instanceof OffscreenCanvas || "undefined" != typeof ImageBitmap && e3 instanceof ImageBitmap) {
    const n2 = 1024 / Math.max(e3.width, e3.height), o2 = document.createElement("canvas");
    o2.width = e3.width * Math.min(1, n2), o2.height = e3.height * Math.min(1, n2);
    const r2 = o2.getContext("2d");
    if (true === i2 && (r2.translate(0, o2.height), r2.scale(1, -1)), r2.drawImage(e3, 0, 0, o2.width, o2.height), void 0 !== t2) {
      const e4 = parseInt(t2, 16), i3 = (e4 >> 16 & 255) / 255, n3 = (e4 >> 8 & 255) / 255, s2 = (255 & e4) / 255, a2 = r2.getImageData(0, 0, o2.width, o2.height), l2 = a2.data;
      for (let e5 = 0; e5 < l2.length; e5 += 4)
        l2[e5 + 0] = l2[e5 + 0] * i3, l2[e5 + 1] = l2[e5 + 1] * n3, l2[e5 + 2] = l2[e5 + 2] * s2;
      r2.putImageData(a2, 0, 0);
    }
    return o2;
  }
  throw new Error("THREE.USDZExporter: No valid image data found. Unable to process texture.");
}
const YA = 7;
function KA() {
  return '#usda 1.0\n(\n    customLayerData = {\n        string creator = "Three.js USDZExporter"\n    }\n    metersPerUnit = 1\n    upAxis = "Y"\n)\n\n';
}
function ZA(e3) {
  const t2 = e3.elements;
  return `( ${JA(t2, 0)}, ${JA(t2, 4)}, ${JA(t2, 8)}, ${JA(t2, 12)} )`;
}
function JA(e3, t2) {
  return `(${e3[t2 + 0]}, ${e3[t2 + 1]}, ${e3[t2 + 2]}, ${e3[t2 + 3]})`;
}
function eb(e3, t2) {
  if (void 0 === e3)
    return console.warn("USDZExporter: Normals missing."), Array(t2).fill("(0, 0, 0)").join(", ");
  const i2 = [];
  for (let t3 = 0; t3 < e3.count; t3++) {
    const n2 = e3.getX(t3), o2 = e3.getY(t3), r2 = e3.getZ(t3);
    i2.push(`(${n2.toPrecision(YA)}, ${o2.toPrecision(YA)}, ${r2.toPrecision(YA)})`);
  }
  return i2.join(", ");
}
function tb(e3, t2) {
  const i2 = "            ", n2 = [], o2 = [];
  function r2(i3, n3, o3) {
    const r3 = i3.id + (o3 ? "_" + o3.getHexString() : ""), s2 = 1023 === i3.format;
    return t2[r3] = i3, `
        def Shader "Transform2d_${n3}" (
            sdrMetadata = {
                string role = "math"
            }
        )
        {
            uniform token info:id = "UsdTransform2d"
            float2 inputs:in.connect = </Materials/Material_${e3.id}/uvReader_st.outputs:result>
            float2 inputs:scale = ${nb(i3.repeat)}
            float2 inputs:translation = ${nb(i3.offset)}
            float2 outputs:result
        }

        def Shader "Texture_${i3.id}_${n3}"
        {
            uniform token info:id = "UsdUVTexture"
            asset inputs:file = @textures/Texture_${r3}.${s2 ? "png" : "jpg"}@
            float2 inputs:st.connect = </Materials/Material_${e3.id}/Transform2d_${n3}.outputs:result>
            token inputs:wrapS = "repeat"
            token inputs:wrapT = "repeat"
            float outputs:r
            float outputs:g
            float outputs:b
            float3 outputs:rgb
            ${e3.transparent || e3.alphaTest > 0 ? "float outputs:a" : ""}
        }`;
  }
  return e3.side === be && console.warn("THREE.USDZExporter: USDZ does not support double sided materials", e3), null !== e3.map ? (n2.push(`${i2}color3f inputs:diffuseColor.connect = </Materials/Material_${e3.id}/Texture_${e3.map.id}_diffuse.outputs:rgb>`), e3.transparent ? n2.push(`${i2}float inputs:opacity.connect = </Materials/Material_${e3.id}/Texture_${e3.map.id}_diffuse.outputs:a>`) : e3.alphaTest > 0 && (n2.push(`${i2}float inputs:opacity.connect = </Materials/Material_${e3.id}/Texture_${e3.map.id}_diffuse.outputs:a>`), n2.push(`${i2}float inputs:opacityThreshold = ${e3.alphaTest}`)), o2.push(r2(e3.map, "diffuse", e3.color))) : n2.push(`${i2}color3f inputs:diffuseColor = ${ib(e3.color)}`), null !== e3.emissiveMap ? (n2.push(`${i2}color3f inputs:emissiveColor.connect = </Materials/Material_${e3.id}/Texture_${e3.emissiveMap.id}_emissive.outputs:rgb>`), o2.push(r2(e3.emissiveMap, "emissive"))) : e3.emissive.getHex() > 0 && n2.push(`${i2}color3f inputs:emissiveColor = ${ib(e3.emissive)}`), null !== e3.normalMap && (n2.push(`${i2}normal3f inputs:normal.connect = </Materials/Material_${e3.id}/Texture_${e3.normalMap.id}_normal.outputs:rgb>`), o2.push(r2(e3.normalMap, "normal"))), null !== e3.aoMap && (n2.push(`${i2}float inputs:occlusion.connect = </Materials/Material_${e3.id}/Texture_${e3.aoMap.id}_occlusion.outputs:r>`), o2.push(r2(e3.aoMap, "occlusion"))), null !== e3.roughnessMap && 1 === e3.roughness ? (n2.push(`${i2}float inputs:roughness.connect = </Materials/Material_${e3.id}/Texture_${e3.roughnessMap.id}_roughness.outputs:g>`), o2.push(r2(e3.roughnessMap, "roughness"))) : n2.push(`${i2}float inputs:roughness = ${e3.roughness}`), null !== e3.metalnessMap && 1 === e3.metalness ? (n2.push(`${i2}float inputs:metallic.connect = </Materials/Material_${e3.id}/Texture_${e3.metalnessMap.id}_metallic.outputs:b>`), o2.push(r2(e3.metalnessMap, "metallic"))) : n2.push(`${i2}float inputs:metallic = ${e3.metalness}`), null !== e3.alphaMap ? (n2.push(`${i2}float inputs:opacity.connect = </Materials/Material_${e3.id}/Texture_${e3.alphaMap.id}_opacity.outputs:r>`), n2.push(`${i2}float inputs:opacityThreshold = 0.0001`), o2.push(r2(e3.alphaMap, "opacity"))) : n2.push(`${i2}float inputs:opacity = ${e3.opacity}`), e3.isMeshPhysicalMaterial && (n2.push(`${i2}float inputs:clearcoat = ${e3.clearcoat}`), n2.push(`${i2}float inputs:clearcoatRoughness = ${e3.clearcoatRoughness}`), n2.push(`${i2}float inputs:ior = ${e3.ior}`)), `
    def Material "Material_${e3.id}"
    {
        def Shader "PreviewSurface"
        {
            uniform token info:id = "UsdPreviewSurface"
${n2.join("\n")}
            int inputs:useSpecularWorkflow = 0
            token outputs:surface
        }

        token outputs:surface.connect = </Materials/Material_${e3.id}/PreviewSurface.outputs:surface>
        token inputs:frame:stPrimvarName = "st"

        def Shader "uvReader_st"
        {
            uniform token info:id = "UsdPrimvarReader_float2"
            token inputs:varname.connect = </Materials/Material_${e3.id}.inputs:frame:stPrimvarName>
            float2 inputs:fallback = (0.0, 0.0)
            float2 outputs:result
        }

${o2.join("\n")}

    }
`;
}
function ib(e3) {
  return `(${e3.r}, ${e3.g}, ${e3.b})`;
}
function nb(e3) {
  return `(${e3.x}, ${e3.y})`;
}
var ob = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
let rb = false, sb = false;
const ab = "#model-viewer-no-ar-fallback", lb = (cb = ["quick-look", "scene-viewer", "webxr", "none"], (e3) => {
  try {
    const t2 = gp(e3), i2 = (t2.length ? t2[0].terms : []).filter((e4) => e4 && "ident" === e4.type).map((e4) => e4.value).filter((e4) => cb.indexOf(e4) > -1), n2 = /* @__PURE__ */ new Set();
    for (const e4 of i2)
      n2.add(e4);
    return n2;
  } catch (e4) {
  }
  return /* @__PURE__ */ new Set();
});
var cb;
const hb = "quick-look", ub = "scene-viewer", db = "webxr", pb = "none", _b = Symbol("arButtonContainer"), gb = Symbol("enterARWithWebXR"), mb = Symbol("openSceneViewer"), fb = Symbol("openIOSARQuickLook"), vb = Symbol("canActivateAR"), Ab = Symbol("arMode"), bb = Symbol("arModes"), yb = Symbol("arAnchor"), wb = Symbol("preload"), xb = Symbol("onARButtonContainerClick"), Cb = Symbol("onARStatus"), Sb = Symbol("onARTracking"), Eb = Symbol("onARTap"), Ib = Symbol("selectARMode"), Tb = Symbol("triggerLoad");
var Bb = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
const Mb = "auto", kb = "auto", Rb = "eager", Pb = Symbol("defaultProgressBarElement"), Db = Symbol("posterContainerElement"), Lb = Symbol("defaultPosterElement"), Fb = Symbol("shouldDismissPoster"), Nb = Symbol("hidePoster"), Ob = Symbol("modelIsRevealed"), zb = Symbol("updateProgressBar"), Ub = Symbol("ariaLabelCallToAction"), Hb = Symbol("onProgress");
var Qb = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
const Vb = Math.PI / 32, Gb = { basis: [Cp(_p(Vb, "rad"))], keywords: { auto: [null] } }, $b = Symbol("autoRotateStartTime"), Wb = Symbol("radiansPerSecond"), qb = Symbol("syncRotationRate"), jb = Symbol("onCameraChange"), Xb = ((e3) => {
  var t2, i2, n2;
  class o2 extends e3 {
    constructor() {
      super(...arguments), this[t2] = /* @__PURE__ */ new Map(), this[i2] = (e4) => {
        e4.forEach((e5) => {
          e5 instanceof MutationRecord && "childList" !== e5.type || (e5.addedNodes.forEach((e6) => {
            this[eA](e6);
          }), e5.removedNodes.forEach((e6) => {
            this[tA](e6);
          }), this[Lv]());
        });
      }, this[n2] = new MutationObserver(this[Zv]);
    }
    connectedCallback() {
      super.connectedCallback();
      for (let e5 = 0; e5 < this.children.length; ++e5)
        this[eA](this.children[e5]);
      const { ShadyDOM: e4 } = self;
      null == e4 ? this[Jv].observe(this, { childList: true }) : this[Jv] = e4.observeChildren(this, this[Zv]);
    }
    disconnectedCallback() {
      super.disconnectedCallback();
      const { ShadyDOM: e4 } = self;
      null == e4 ? this[Jv].disconnect() : e4.unobserveChildren(this[Jv]);
    }
    [(t2 = Kv, i2 = Zv, n2 = Jv, Fv)](e4, t3) {
      super[Fv](e4, t3);
      const i3 = this[Dv], { annotationRenderer: n3 } = i3, o3 = i3.getCamera();
      i3.shouldRender() && (i3.updateSurfaceHotspots(), i3.updateHotspotsVisibility(o3.position), n3.domElement.style.display = "", n3.render(i3, o3));
    }
    updateHotspot(e4) {
      const t3 = this[Kv].get(e4.name);
      null != t3 && (t3.updatePosition(e4.position), t3.updateNormal(e4.normal), t3.surface = e4.surface, this[Lv]());
    }
    queryHotspot(e4) {
      const t3 = this[Kv].get(e4);
      if (null == t3)
        return null;
      const i3 = Gv(t3.position), n3 = Gv(t3.normal), o3 = t3.facingCamera, r2 = this[Dv], s2 = r2.getCamera(), a2 = new di();
      a2.setFromMatrixPosition(t3.matrixWorld), a2.project(s2);
      const l2 = r2.width / 2, c2 = r2.height / 2;
      a2.x = a2.x * l2 + l2, a2.y = -a2.y * c2 + c2;
      const h2 = Gv(new di(a2.x, a2.y, a2.z));
      return Number.isFinite(h2.x) && Number.isFinite(h2.y) ? { position: i3, normal: n3, canvasPosition: h2, facingCamera: o3 } : null;
    }
    positionAndNormalFromPoint(e4, t3) {
      const i3 = this[Dv], n3 = i3.getNDC(e4, t3), o3 = i3.positionAndNormalFromPoint(n3);
      if (null == o3)
        return null;
      iA.copy(i3.target.matrixWorld).invert();
      const r2 = Gv(o3.position.applyMatrix4(iA)), s2 = Gv(o3.normal.transformDirection(iA));
      let a2 = null;
      return null != o3.uv && (a2 = $v(o3.uv)), { position: r2, normal: s2, uv: a2 };
    }
    surfaceFromPoint(e4, t3) {
      const i3 = this[Dv], n3 = i3.getNDC(e4, t3);
      return i3.surfaceFromPoint(n3);
    }
    [eA](e4) {
      if (!(e4 instanceof HTMLElement && 0 === e4.slot.indexOf("hotspot")))
        return;
      let t3 = this[Kv].get(e4.slot);
      null != t3 ? t3.increment() : (t3 = new Nf({ name: e4.slot, position: e4.dataset.position, normal: e4.dataset.normal, surface: e4.dataset.surface }), this[Kv].set(e4.slot, t3), this[Dv].addHotspot(t3)), this[Dv].queueRender();
    }
    [tA](e4) {
      if (!(e4 instanceof HTMLElement))
        return;
      const t3 = this[Kv].get(e4.slot);
      t3 && (t3.decrement() && (this[Dv].removeHotspot(t3), this[Kv].delete(e4.slot)), this[Dv].queueRender());
    }
  }
  return o2;
})(((e3) => {
  var t2, i2, n2;
  class o2 extends e3 {
    constructor() {
      super(...arguments), this[t2] = void 0, this[i2] = null, this[n2] = null, this.variantName = null, this.orientation = "0 0 0", this.scale = "1 1 1";
    }
    get model() {
      return this[Tf];
    }
    get availableVariants() {
      return this.model ? this.model[bf]() : [];
    }
    get originalGltfJson() {
      return this[If];
    }
    [(t2 = Tf, i2 = Ef, n2 = If, Bf)]() {
      return () => {
        this[Lv]();
      };
    }
    [Mf](e4) {
      return e4.encoding = bt, e4.wrapS = Le, e4.wrapT = Le, new bm(this[Bf](), e4);
    }
    async createTexture(e4, t3 = "image/png") {
      const { textureUtils: i3 } = this[zv], n3 = await i3.loadImage(e4);
      return n3.userData.mimeType = t3, this[Mf](n3);
    }
    async createLottieTexture(e4, t3 = 1) {
      const { textureUtils: i3 } = this[zv], n3 = await i3.loadLottie(e4, t3);
      return this[Mf](n3);
    }
    createVideoTexture(e4) {
      const t3 = document.createElement("video");
      t3.src = e4, t3.muted = true, t3.playsInline = true, t3.loop = true, t3.play();
      const i3 = new xl(t3);
      return this[Mf](i3);
    }
    createCanvasTexture() {
      const e4 = document.createElement("canvas"), t3 = new El(e4);
      return this[Mf](t3);
    }
    async updated(e4) {
      if (super.updated(e4), e4.has("variantName")) {
        const e5 = this[Uv].beginActivity();
        e5(0.1);
        const t3 = this[Tf], { variantName: i3 } = this;
        null != t3 && (await t3[gf](i3), this[Lv](), this.dispatchEvent(new CustomEvent("variant-applied"))), e5(1);
      }
      if (e4.has("orientation") || e4.has("scale")) {
        if (!this.loaded)
          return;
        const e5 = this[Dv];
        e5.applyTransform(), e5.updateBoundingBox(), e5.updateShadow(), this[zv].arRenderer.onUpdateScene(), this[Lv]();
      }
    }
    [Nv]() {
      super[Nv]();
      const { currentGLTF: e4 } = this[Dv];
      if (null != e4) {
        const { correlatedSceneGraph: t3 } = e4;
        null != t3 && e4 !== this[Ef] && (this[Tf] = new Cf(t3, this[Bf]()), this[If] = JSON.parse(JSON.stringify(t3.gltf))), "variants" in e4.userData && this.requestUpdate("variantName");
      }
      this[Ef] = e4;
    }
    async exportScene(e4) {
      const t3 = this[Dv];
      return new Promise(async (i3, n3) => {
        const o3 = { binary: true, onlyVisible: true, maxTextureSize: 1 / 0, includeCustomExtensions: false, forceIndices: false };
        Object.assign(o3, e4), o3.animations = t3.animations, o3.truncateDrawRange = true;
        const r2 = t3.shadow;
        let s2 = false;
        null != r2 && (s2 = r2.visible, r2.visible = false), await this[Tf][_f]();
        new pd().register((e5) => new rp(e5)).parse(t3.model, (e5) => i3(new Blob([o3.binary ? e5 : JSON.stringify(e5)], { type: o3.binary ? "application/octet-stream" : "application/json" })), () => n3("glTF export failed"), o3), null != r2 && (r2.visible = s2);
      });
    }
    materialFromPoint(e4, t3) {
      const i3 = this[Tf];
      if (null == i3)
        return null;
      const n3 = this[Dv], o3 = n3.getNDC(e4, t3), r2 = n3.hitFromPoint(o3);
      return null == r2 || null == r2.face ? null : i3[mf](r2);
    }
  }
  return Sf([ue({ type: String, attribute: "variant-name" })], o2.prototype, "variantName", void 0), Sf([ue({ type: String, attribute: "orientation" })], o2.prototype, "orientation", void 0), Sf([ue({ type: String, attribute: "scale" })], o2.prototype, "scale", void 0), o2;
})(((e3) => {
  var t2, i2, n2;
  class o2 extends e3 {
    constructor() {
      super(...arguments), this.autoRotate = false, this.autoRotateDelay = 3e3, this.rotationPerSecond = "auto", this[t2] = performance.now(), this[i2] = 0, this[n2] = (e4) => {
        this.autoRotate && "user-interaction" === e4.detail.source && (this[$b] = performance.now());
      };
    }
    connectedCallback() {
      super.connectedCallback(), this.addEventListener("camera-change", this[jb]), this[$b] = performance.now();
    }
    disconnectedCallback() {
      super.disconnectedCallback(), this.removeEventListener("camera-change", this[jb]), this[$b] = performance.now();
    }
    updated(e4) {
      super.updated(e4), e4.has("autoRotate") && (this[$b] = performance.now());
    }
    [(t2 = $b, i2 = Wb, qb)](e4) {
      this[Wb] = e4[0];
    }
    [Fv](e4, t3) {
      if (super[Fv](e4, t3), !this.autoRotate || !this[Qv]() || this[zv].isPresenting)
        return;
      const i3 = Math.min(t3, e4 - this[$b] - this.autoRotateDelay);
      i3 > 0 && (this[Dv].yaw = this.turntableRotation + this[Wb] * i3 * 1e-3);
    }
    get turntableRotation() {
      return this[Dv].yaw;
    }
    resetTurntableRotation(e4 = 0) {
      this[Dv].yaw = e4;
    }
  }
  return n2 = jb, Qb([ue({ type: Boolean, attribute: "auto-rotate" })], o2.prototype, "autoRotate", void 0), Qb([ue({ type: Number, attribute: "auto-rotate-delay" })], o2.prototype, "autoRotateDelay", void 0), Qb([h_({ intrinsics: Gb, updateHandler: qb }), ue({ type: String, attribute: "rotation-per-second" })], o2.prototype, "rotationPerSecond", void 0), o2;
})(((e3) => {
  var t2, i2, n2;
  class o2 extends e3 {
    constructor() {
      super(...arguments), this.environmentImage = null, this.skyboxImage = null, this.shadowIntensity = 0, this.shadowSoftness = 1, this.exposure = 1, this[t2] = null, this[i2] = null, this[n2] = null;
    }
    updated(e4) {
      super.updated(e4), e4.has("shadowIntensity") && (this[Dv].setShadowIntensity(0.5 * this.shadowIntensity), this[Lv]()), e4.has("shadowSoftness") && (this[Dv].setShadowSoftness(this.shadowSoftness), this[Lv]()), e4.has("exposure") && (this[Dv].exposure = this.exposure, this[Lv]()), (e4.has("environmentImage") || e4.has("skyboxImage")) && this[Vv]() && this[dh]();
    }
    hasBakedShadow() {
      return this[Dv].bakedShadows.size > 0;
    }
    async [(t2 = hh, i2 = uh, n2 = ph, dh)]() {
      const { skyboxImage: e4, environmentImage: t3 } = this;
      null != this[ph] && (this[ph](), this[ph] = null);
      const { textureUtils: i3 } = this[zv];
      if (null == i3)
        return;
      const n3 = this[Uv].beginActivity();
      try {
        const { environmentMap: o3, skybox: r2 } = await i3.generateEnvironmentMapAndSkybox(ih(e4), t3, (e5) => n3(sh(e5, 0, 1)));
        this[hh] !== o3 && (this[hh] = o3, this.dispatchEvent(new CustomEvent("environment-change"))), this[uh] = null != r2 ? r2.name === o3.name ? o3 : r2 : null, this[Dv].setEnvironmentAndSkybox(this[hh], this[uh]), this[Dv].dispatchEvent({ type: "envmap-update" });
      } catch (e5) {
        if (e5 instanceof Error)
          throw this[Dv].setEnvironmentAndSkybox(null, null), e5;
      } finally {
        n3(1);
      }
    }
  }
  return ch([ue({ type: String, attribute: "environment-image" })], o2.prototype, "environmentImage", void 0), ch([ue({ type: String, attribute: "skybox-image" })], o2.prototype, "skyboxImage", void 0), ch([ue({ type: Number, attribute: "shadow-intensity" })], o2.prototype, "shadowIntensity", void 0), ch([ue({ type: Number, attribute: "shadow-softness" })], o2.prototype, "shadowSoftness", void 0), ch([ue({ type: Number })], o2.prototype, "exposure", void 0), o2;
})(((e3) => {
  var t2, i2, n2, o2, r2, s2, a2, l2, c2, h2, u2, d2, p2, _2, g2, m2, f2;
  class v2 extends e3 {
    constructor() {
      super(...arguments), this.cameraControls = false, this.cameraOrbit = f_, this.cameraTarget = "auto auto auto", this.fieldOfView = "auto", this.minCameraOrbit = "auto", this.maxCameraOrbit = "auto", this.minFieldOfView = "auto", this.maxFieldOfView = "auto", this.interactionPromptThreshold = 3e3, this.interactionPrompt = b_, this.interactionPromptStyle = w_, this.orbitSensitivity = 1, this.touchAction = x_, this.disableZoom = false, this.disablePan = false, this.disableTap = false, this.interpolationDecay = 50, this[t2] = this.shadowRoot.querySelector(".interaction-prompt"), this[i2] = this.shadowRoot.querySelector("#prompt"), this[n2] = [this.shadowRoot.querySelector("#finger0"), this.shadowRoot.querySelector("#finger1")], this[o2] = this.shadowRoot.querySelector(".pan-target"), this[r2] = 0, this[s2] = 1 / 0, this[a2] = false, this[l2] = false, this[c2] = dg.AUTOMATIC, this[h2] = new pg(this[Dv].camera, this[Rv], this[Dv]), this[u2] = new zc(), this[d2] = false, this[p2] = false, this[_2] = false, this[g2] = () => {
        const e4 = this[D_].changeSource;
        this[X_] = e4, e4 === dg.USER_INTERACTION && (this[W_] = true, this[z_]());
      }, this[m2] = () => {
        this[U_](), this[Lv]();
        const e4 = this[D_].changeSource;
        this.dispatchEvent(new CustomEvent("camera-change", { detail: { source: e4 } }));
      }, this[f2] = (e4) => {
        "pointer-change-start" === e4.type ? this[kv].classList.add("pointer-tumbling") : this[kv].classList.remove("pointer-tumbling");
      };
    }
    get inputSensitivity() {
      return this[D_].inputSensitivity;
    }
    set inputSensitivity(e4) {
      this[D_].inputSensitivity = e4;
    }
    getCameraOrbit() {
      const { theta: e4, phi: t3, radius: i3 } = this[Y_];
      return { theta: e4, phi: t3, radius: i3, toString() {
        return `${this.theta}rad ${this.phi}rad ${this.radius}m`;
      } };
    }
    getCameraTarget() {
      return Gv(this[zv].isPresenting ? this[zv].arRenderer.target : this[Dv].getTarget());
    }
    getFieldOfView() {
      return this[D_].getFieldOfView();
    }
    getMinimumFieldOfView() {
      return this[D_].options.minimumFieldOfView;
    }
    getMaximumFieldOfView() {
      return this[D_].options.maximumFieldOfView;
    }
    getIdealAspect() {
      return this[Dv].idealAspect;
    }
    jumpCameraToGoal() {
      this[K_] = true, this.requestUpdate(K_, false);
    }
    resetInteractionPrompt() {
      this[j_] = 0, this[q_] = 1 / 0, this[W_] = false, this[$_] = this.interactionPrompt === b_ && this.cameraControls;
    }
    zoom(e4) {
      const t3 = new WheelEvent("wheel", { deltaY: -30 * e4 });
      this[Rv].dispatchEvent(t3);
    }
    connectedCallback() {
      super.connectedCallback(), this[D_].addEventListener("user-interaction", this[Q_]), this[D_].addEventListener("pointer-change-start", this[G_]), this[D_].addEventListener("pointer-change-end", this[G_]);
    }
    disconnectedCallback() {
      super.disconnectedCallback(), this[D_].removeEventListener("user-interaction", this[Q_]), this[D_].removeEventListener("pointer-change-start", this[G_]), this[D_].removeEventListener("pointer-change-end", this[G_]);
    }
    updated(e4) {
      super.updated(e4);
      const t3 = this[D_], i3 = this[Dv];
      if (e4.has("cameraControls") && (this.cameraControls ? (t3.enableInteraction(), this.interactionPrompt === b_ && (this[$_] = true)) : (t3.disableInteraction(), this[z_]()), this[Rv].setAttribute("aria-label", this[Cv])), e4.has("disableZoom") && (t3.disableZoom = this.disableZoom), e4.has("disablePan") && (t3.enablePan = !this.disablePan), e4.has("disableTap") && (t3.enableTap = !this.disableTap), (e4.has("interactionPrompt") || e4.has("cameraControls") || e4.has("src")) && (this.interactionPrompt === b_ && this.cameraControls && !this[W_] ? this[$_] = true : this[z_]()), e4.has("interactionPromptStyle") && (this[N_].style.opacity = this.interactionPromptStyle == y_ ? "1" : "0"), e4.has("touchAction")) {
        const e5 = this.touchAction;
        t3.applyOptions({ touchAction: e5 }), t3.updateTouchActionStyle();
      }
      e4.has("orbitSensitivity") && (t3.orbitSensitivity = this.orbitSensitivity), e4.has("interpolationDecay") && (t3.setDamperDecayTime(this.interpolationDecay), i3.setTargetDamperDecayTime(this.interpolationDecay)), true === this[K_] && Promise.resolve().then(() => {
        t3.jumpToGoal(), i3.jumpToGoal(), this[V_](), this[K_] = false;
      });
    }
    async updateFraming() {
      const e4 = this[Dv], t3 = e4.adjustedFoV(e4.framedFoVDeg);
      await e4.updateFraming();
      const i3 = e4.adjustedFoV(e4.framedFoVDeg), n3 = this[D_].getFieldOfView() / t3;
      this[D_].setFieldOfView(i3 * n3), this[J_] = true, this.requestUpdate("maxFieldOfView"), this.requestUpdate("fieldOfView"), this.requestUpdate("minCameraOrbit"), this.requestUpdate("maxCameraOrbit"), this.requestUpdate("cameraOrbit"), await this.updateComplete;
    }
    interact(e4, t3, i3) {
      const n3 = this[Rv], o3 = this[O_];
      if ("1" === o3[0].style.opacity)
        return void console.warn("interact() failed because an existing interaction is running.");
      const r3 = new Array();
      r3.push({ x: p_(t3.x), y: p_(t3.y) });
      const s3 = [{ x: r3[0].x(0), y: r3[0].y(0) }];
      null != i3 && (r3.push({ x: p_(i3.x), y: p_(i3.y) }), s3.push({ x: r3[1].x(0), y: r3[1].y(0) }));
      let a3 = performance.now();
      const { width: l3, height: c3 } = this[Dv], h3 = (e5) => {
        for (const [t4, i4] of s3.entries()) {
          const { style: r4 } = o3[t4];
          r4.transform = `translateX(${l3 * i4.x}px) translateY(${c3 * i4.y}px)`, "pointerdown" === e5 ? r4.opacity = "1" : "pointerup" === e5 && (r4.opacity = "0");
          const s4 = { pointerId: t4 - 5678, pointerType: "touch", target: n3, clientX: l3 * i4.x, clientY: c3 * i4.y, altKey: true };
          n3.dispatchEvent(new PointerEvent(e5, s4));
        }
      }, u3 = () => {
        const t4 = this[X_];
        if (t4 !== dg.AUTOMATIC || !n3.isConnected) {
          for (const e5 of this[O_])
            e5.style.opacity = "0";
          return h3("pointercancel"), this.dispatchEvent(new CustomEvent("interact-stopped", { detail: { source: t4 } })), void document.removeEventListener("visibilitychange", d3);
        }
        const i4 = Math.min(1, (performance.now() - a3) / e4);
        for (const [e5, t5] of s3.entries())
          t5.x = r3[e5].x(i4), t5.y = r3[e5].y(i4);
        h3("pointermove"), i4 < 1 ? requestAnimationFrame(u3) : (h3("pointerup"), this.dispatchEvent(new CustomEvent("interact-stopped", { detail: { source: dg.AUTOMATIC } })), document.removeEventListener("visibilitychange", d3));
      }, d3 = () => {
        let e5 = 0;
        "hidden" === document.visibilityState ? e5 = performance.now() - a3 : a3 = performance.now() - e5;
      };
      document.addEventListener("visibilitychange", d3), h3("pointerdown"), this[X_] = dg.AUTOMATIC, requestAnimationFrame(u3);
    }
    [(t2 = F_, i2 = N_, n2 = O_, o2 = L_, r2 = j_, s2 = q_, a2 = W_, l2 = $_, c2 = X_, h2 = D_, u2 = Y_, d2 = K_, p2 = Z_, _2 = J_, tg)](e4) {
      const t3 = this[D_], i3 = this[Dv];
      i3.framedFoVDeg = 180 * e4[0] / Math.PI, t3.changeSource = dg.NONE, t3.setFieldOfView(i3.adjustedFoV(i3.framedFoVDeg)), this[Q_]();
    }
    [eg](e4) {
      const t3 = this[D_];
      if (this[J_]) {
        const { theta: t4, phi: i3 } = this.getCameraOrbit();
        e4[0] = t4, e4[1] = i3, this[J_] = false;
      }
      t3.changeSource = dg.NONE, t3.setOrbit(e4[0], e4[1], e4[2]), this[Q_]();
    }
    [ng](e4) {
      this[D_].applyOptions({ minimumAzimuthalAngle: e4[0], minimumPolarAngle: e4[1], minimumRadius: e4[2] }), this.jumpCameraToGoal();
    }
    [og](e4) {
      this[D_].applyOptions({ maximumAzimuthalAngle: e4[0], maximumPolarAngle: e4[1], maximumRadius: e4[2] }), this[H_](e4[2]), this.jumpCameraToGoal();
    }
    [rg](e4) {
      this[D_].applyOptions({ minimumFieldOfView: 180 * e4[0] / Math.PI }), this.jumpCameraToGoal();
    }
    [sg](e4) {
      const t3 = this[Dv].adjustedFoV(180 * e4[0] / Math.PI);
      this[D_].applyOptions({ maximumFieldOfView: t3 }), this.jumpCameraToGoal();
    }
    [ig](e4) {
      const [t3, i3, n3] = e4;
      this[zv].arRenderer.isPresenting || this[Dv].setTarget(t3, i3, n3), this[D_].changeSource = dg.NONE, this[zv].arRenderer.updateTarget(), this[Q_]();
    }
    [Fv](e4, t3) {
      if (super[Fv](e4, t3), this[zv].isPresenting || !this[Qv]())
        return;
      const i3 = this[D_], n3 = this[Dv], o3 = performance.now();
      if (this[$_] && this.loaded && o3 > this[Tv] + this.interactionPromptThreshold && (this[$_] = false, this[q_] = o3, this[F_].classList.add("visible")), isFinite(this[q_]) && this.interactionPromptStyle === w_) {
        const e5 = (o3 - this[q_]) / 5e3 % 1, t4 = g_(e5), r4 = m_(e5);
        if (this[N_].style.opacity = `${r4}`, t4 !== this[j_]) {
          const e6 = t4 * n3.width * 0.05, o4 = (t4 - this[j_]) * Math.PI / 16;
          this[N_].style.transform = `translateX(${e6}px)`, i3.changeSource = dg.AUTOMATIC, i3.adjustOrbit(o4, 0, 0), this[j_] = t4;
        }
      }
      const r3 = i3.update(e4, t3), s3 = n3.updateTarget(t3);
      (r3 || s3) && this[V_]();
    }
    [z_]() {
      this[$_] = false, this[F_].classList.remove("visible"), this[q_] = 1 / 0;
    }
    [H_](e4) {
      const t3 = 2 * Math.max(this[Dv].boundingSphere.radius, e4);
      this[D_].updateNearFar(0, t3);
    }
    [U_]() {
      const { theta: e4, phi: t3 } = this[D_].getCameraSpherical(this[Y_]), i3 = (4 + Math.floor((e4 % P_ + R_) / M_)) % 4, n3 = Math.floor(t3 / k_), o3 = v_[i3], r3 = A_[n3];
      this[Iv](`View from stage ${r3}${o3}`);
    }
    get [Cv]() {
      return super[Cv].replace(/\.$/, "") + (this.cameraControls ? ". Use mouse, touch or arrow keys to move." : "");
    }
    async [Ov](e4) {
      const t3 = this[D_], i3 = this[Dv], n3 = i3.adjustedFoV(i3.framedFoVDeg);
      super[Ov](e4);
      const o3 = i3.adjustedFoV(i3.framedFoVDeg) / n3, r3 = t3.getFieldOfView() * (isFinite(o3) ? o3 : 1);
      t3.updateAspect(this[Dv].aspect), this.requestUpdate("maxFieldOfView", this.maxFieldOfView), await this.updateComplete, this[D_].setFieldOfView(r3), this.jumpCameraToGoal();
    }
    [Nv]() {
      super[Nv](), this[Z_] ? this[J_] = true : this[Z_] = true, this.requestUpdate("maxFieldOfView", this.maxFieldOfView), this.requestUpdate("fieldOfView", this.fieldOfView), this.requestUpdate("minCameraOrbit", this.minCameraOrbit), this.requestUpdate("maxCameraOrbit", this.maxCameraOrbit), this.requestUpdate("cameraOrbit", this.cameraOrbit), this.requestUpdate("cameraTarget", this.cameraTarget), this.jumpCameraToGoal();
    }
  }
  return g2 = Q_, m2 = V_, f2 = G_, __([ue({ type: Boolean, attribute: "camera-controls" })], v2.prototype, "cameraControls", void 0), __([h_({ intrinsics: E_, observeEffects: true, updateHandler: eg }), ue({ type: String, attribute: "camera-orbit", hasChanged: () => true })], v2.prototype, "cameraOrbit", void 0), __([h_({ intrinsics: B_, observeEffects: true, updateHandler: ig }), ue({ type: String, attribute: "camera-target", hasChanged: () => true })], v2.prototype, "cameraTarget", void 0), __([h_({ intrinsics: C_, observeEffects: true, updateHandler: tg }), ue({ type: String, attribute: "field-of-view", hasChanged: () => true })], v2.prototype, "fieldOfView", void 0), __([h_({ intrinsics: I_, updateHandler: ng }), ue({ type: String, attribute: "min-camera-orbit", hasChanged: () => true })], v2.prototype, "minCameraOrbit", void 0), __([h_({ intrinsics: T_, updateHandler: og }), ue({ type: String, attribute: "max-camera-orbit", hasChanged: () => true })], v2.prototype, "maxCameraOrbit", void 0), __([h_({ intrinsics: S_, updateHandler: rg }), ue({ type: String, attribute: "min-field-of-view", hasChanged: () => true })], v2.prototype, "minFieldOfView", void 0), __([h_({ intrinsics: C_, updateHandler: sg }), ue({ type: String, attribute: "max-field-of-view", hasChanged: () => true })], v2.prototype, "maxFieldOfView", void 0), __([ue({ type: Number, attribute: "interaction-prompt-threshold" })], v2.prototype, "interactionPromptThreshold", void 0), __([ue({ type: String, attribute: "interaction-prompt" })], v2.prototype, "interactionPrompt", void 0), __([ue({ type: String, attribute: "interaction-prompt-style" })], v2.prototype, "interactionPromptStyle", void 0), __([ue({ type: Number, attribute: "orbit-sensitivity" })], v2.prototype, "orbitSensitivity", void 0), __([ue({ type: String, attribute: "touch-action" })], v2.prototype, "touchAction", void 0), __([ue({ type: Boolean, attribute: "disable-zoom" })], v2.prototype, "disableZoom", void 0), __([ue({ type: Boolean, attribute: "disable-pan" })], v2.prototype, "disablePan", void 0), __([ue({ type: Boolean, attribute: "disable-tap" })], v2.prototype, "disableTap", void 0), __([ue({ type: Number, attribute: "interpolation-decay" })], v2.prototype, "interpolationDecay", void 0), v2;
})(((e3) => {
  var t2, i2, n2, o2, r2, s2, a2, l2, c2, h2;
  class u2 extends e3 {
    constructor() {
      super(...arguments), this.ar = false, this.arScale = "auto", this.arPlacement = "floor", this.arModes = "webxr scene-viewer quick-look", this.iosSrc = null, this.xrEnvironment = false, this[t2] = false, this[i2] = this.shadowRoot.querySelector(".ar-button"), this[n2] = document.createElement("a"), this[o2] = /* @__PURE__ */ new Set(), this[r2] = pb, this[s2] = false, this[a2] = (e4) => {
        e4.preventDefault(), this.activateAR();
      }, this[l2] = ({ status: e4 }) => {
        e4 !== _g && this[zv].arRenderer.presentedScene !== this[Dv] || (this.setAttribute("ar-status", e4), this.dispatchEvent(new CustomEvent("ar-status", { detail: { status: e4 } })), e4 === _g ? this.removeAttribute("ar-tracking") : e4 === gg && this.setAttribute("ar-tracking", vg));
      }, this[c2] = ({ status: e4 }) => {
        this.setAttribute("ar-tracking", e4), this.dispatchEvent(new CustomEvent("ar-tracking", { detail: { status: e4 } }));
      }, this[h2] = (e4) => {
        "_apple_ar_quicklook_button_tapped" == e4.data && this.dispatchEvent(new CustomEvent("quick-look-button-tapped"));
      };
    }
    get canActivateAR() {
      return this[Ab] !== pb;
    }
    connectedCallback() {
      super.connectedCallback(), this[zv].arRenderer.addEventListener("status", this[Cb]), this.setAttribute("ar-status", _g), this[zv].arRenderer.addEventListener("tracking", this[Sb]), this[yb].addEventListener("message", this[Eb]);
    }
    disconnectedCallback() {
      super.disconnectedCallback(), this[zv].arRenderer.removeEventListener("status", this[Cb]), this[zv].arRenderer.removeEventListener("tracking", this[Sb]), this[yb].removeEventListener("message", this[Eb]);
    }
    update(e4) {
      super.update(e4), e4.has("arScale") && (this[Dv].canScale = "fixed" !== this.arScale), e4.has("arPlacement") && (this[Dv].updateShadow(), this[Lv]()), e4.has("arModes") && (this[bb] = lb(this.arModes)), (e4.has("ar") || e4.has("arModes") || e4.has("src") || e4.has("iosSrc")) && this[Ib]();
    }
    async activateAR() {
      switch (this[Ab]) {
        case hb:
          this[fb]();
          break;
        case db:
          await this[gb]();
          break;
        case ub:
          this[mb]();
          break;
        default:
          console.warn("No AR Mode can be activated. This is probably due to missing configuration or device capabilities");
      }
    }
    async [(t2 = vb, i2 = _b, n2 = yb, o2 = bb, r2 = Ab, s2 = wb, a2 = xb, l2 = Cb, c2 = Sb, h2 = Eb, Ib)]() {
      let e4 = pb;
      if (this.ar) {
        if (null != this.src)
          for (const t3 of this[bb]) {
            if ("webxr" === t3 && jc && !rb && await this[zv].arRenderer.supportsPresentation()) {
              e4 = db;
              break;
            }
            if ("scene-viewer" === t3 && Jc && !sb) {
              e4 = ub;
              break;
            }
            if ("quick-look" === t3 && th) {
              e4 = hb;
              break;
            }
          }
        e4 === pb && null != this.iosSrc && th && (e4 = hb);
      }
      if (e4 !== pb)
        this[_b].classList.add("enabled"), this[_b].addEventListener("click", this[xb]);
      else if (this[_b].classList.contains("enabled")) {
        this[_b].removeEventListener("click", this[xb]), this[_b].classList.remove("enabled");
        const e5 = fg;
        this.setAttribute("ar-status", e5), this.dispatchEvent(new CustomEvent("ar-status", { detail: { status: e5 } }));
      }
      this[Ab] = e4;
    }
    async [gb]() {
      console.log("Attempting to present in AR with WebXR..."), await this[Tb]();
      try {
        this[_b].removeEventListener("click", this[xb]);
        const { arRenderer: e4 } = this[zv];
        e4.placeOnWall = "wall" === this.arPlacement, await e4.present(this[Dv], this.xrEnvironment);
      } catch (e4) {
        console.warn("Error while trying to present in AR with WebXR"), console.error(e4), await this[zv].arRenderer.stopPresenting(), rb = true, console.warn("Falling back to next ar-mode"), await this[Ib](), this.activateAR();
      } finally {
        this[Ib]();
      }
    }
    async [Tb]() {
      this.loaded || (this[wb] = true, this[Bv](), await ((e4, t3, i3 = null) => new Promise((n3) => {
        e4.addEventListener(t3, function o3(r3) {
          i3 && !i3(r3) || (n3(r3), e4.removeEventListener(t3, o3));
        });
      }))(this, "load"), this[wb] = false);
    }
    [Vv]() {
      return super[Vv]() || this[wb];
    }
    [mb]() {
      const e4 = self.location.toString(), t3 = new URL(e4), i3 = new URL(this.src, e4);
      i3.hash && (i3.hash = "");
      const n3 = new URLSearchParams(i3.search);
      if (t3.hash = ab, n3.set("mode", "ar_preferred"), n3.has("disable_occlusion") || n3.set("disable_occlusion", "true"), "fixed" === this.arScale && n3.set("resizable", "false"), "wall" === this.arPlacement && n3.set("enable_vertical_placement", "true"), n3.has("sound")) {
        const t4 = new URL(n3.get("sound"), e4);
        n3.set("sound", t4.toString());
      }
      if (n3.has("link")) {
        const t4 = new URL(n3.get("link"), e4);
        n3.set("link", t4.toString());
      }
      const o3 = `intent://arvr.google.com/scene-viewer/1.0?${n3.toString() + "&file=" + encodeURIComponent(i3.toString())}#Intent;scheme=https;package=com.google.ar.core;action=android.intent.action.VIEW;S.browser_fallback_url=${encodeURIComponent(t3.toString())};end;`;
      self.addEventListener("hashchange", () => {
        self.location.hash === ab && (sb = true, self.history.back(), console.warn("Error while trying to present in AR with Scene Viewer"), console.warn("Falling back to next ar-mode"), this[Ib]());
      }, { once: true }), this[yb].setAttribute("href", o3), console.log("Attempting to present in AR with Scene Viewer..."), this[yb].click();
    }
    async [fb]() {
      const e4 = !this.iosSrc;
      this[_b].classList.remove("enabled");
      const t3 = e4 ? await this.prepareUSDZ() : this.iosSrc, i3 = new URL(t3, self.location.toString());
      if (e4) {
        const e5 = self.location.toString(), t4 = new URL(e5), n4 = new URL(this.src, t4);
        n4.hash && (i3.hash = n4.hash);
      }
      "fixed" === this.arScale && (i3.hash && (i3.hash += "&"), i3.hash += "allowsContentScaling=0");
      const n3 = this[yb];
      n3.setAttribute("rel", "ar");
      const o3 = document.createElement("img");
      n3.appendChild(o3), n3.setAttribute("href", i3.toString()), e4 && n3.setAttribute("download", "model.usdz"), n3.style.display = "none", n3.isConnected || this.shadowRoot.appendChild(n3), console.log("Attempting to present in AR with Quick Look..."), n3.click(), n3.removeChild(o3), e4 && URL.revokeObjectURL(t3), this[_b].classList.add("enabled");
    }
    async prepareUSDZ() {
      const e4 = this[Uv].beginActivity();
      await this[Tb]();
      const { model: t3, shadow: i3 } = this[Dv];
      if (null == t3)
        return "";
      let n3 = false;
      null != i3 && (n3 = i3.visible, i3.visible = false), e4(0.2);
      const o3 = new jA(), r3 = await o3.parse(t3), s3 = new Blob([r3], { type: "model/vnd.usdz+zip" }), a3 = URL.createObjectURL(s3);
      return e4(1), null != i3 && (i3.visible = n3), a3;
    }
  }
  return ob([ue({ type: Boolean, attribute: "ar" })], u2.prototype, "ar", void 0), ob([ue({ type: String, attribute: "ar-scale" })], u2.prototype, "arScale", void 0), ob([ue({ type: String, attribute: "ar-placement" })], u2.prototype, "arPlacement", void 0), ob([ue({ type: String, attribute: "ar-modes" })], u2.prototype, "arModes", void 0), ob([ue({ type: String, attribute: "ios-src" })], u2.prototype, "iosSrc", void 0), ob([ue({ type: Boolean, attribute: "xr-environment" })], u2.prototype, "xrEnvironment", void 0), u2;
})(((e3) => {
  var t2, i2, n2, o2, r2, s2, a2, l2;
  class c2 extends e3 {
    constructor(...e4) {
      super(...e4), this.poster = null, this.reveal = Mb, this.loading = kb, this[t2] = false, this[i2] = false, this[n2] = this.shadowRoot.querySelector(".slot.poster"), this[o2] = this.shadowRoot.querySelector("#default-poster"), this[r2] = this.shadowRoot.querySelector("#default-progress-bar > .bar"), this[s2] = this[Lb].getAttribute("aria-label"), this[a2] = ((e5, t3) => {
        let i3 = null;
        const n3 = (...n4) => {
          null == i3 && (e5(...n4), i3 = self.setTimeout(() => i3 = null, t3));
        };
        return n3.flush = () => {
          null != i3 && (self.clearTimeout(i3), i3 = null);
        }, n3;
      })((e5) => {
        const t3 = this[Pb].parentNode;
        requestAnimationFrame(() => {
          this[Pb].style.transform = `scaleX(${e5})`, 0 === e5 && (t3.removeChild(this[Pb]), t3.appendChild(this[Pb])), 1 === e5 ? this[Pb].classList.add("hide") : this[Pb].classList.remove("hide");
        });
      }, 100), this[l2] = (e5) => {
        const t3 = e5.detail.totalProgress;
        1 === t3 && (this[zb].flush(), this.loaded && (this[Fb] || this.reveal === Mb) && this[Nb]()), this[zb](t3), this.dispatchEvent(new CustomEvent("progress", { detail: { totalProgress: t3 } }));
      };
      const c3 = self.ModelViewerElement || {}, h2 = c3.dracoDecoderLocation || "https://www.gstatic.com/draco/versioned/decoders/1.5.6/";
      nd.setDRACODecoderLocation(h2);
      const u2 = c3.ktx2TranscoderLocation || "https://www.gstatic.com/basis-universal/versioned/2021-04-15-ba1c3e4/";
      nd.setKTX2TranscoderLocation(u2), c3.meshoptDecoderLocation && nd.setMeshoptDecoderLocation(c3.meshoptDecoderLocation);
      const d2 = c3.lottieLoaderLocation || "https://cdn.jsdelivr.net/npm/three@0.149.0/examples/jsm/loaders/LottieLoader.js";
      Jg.singleton.textureUtils.lottieLoaderUrl = d2;
    }
    static set dracoDecoderLocation(e4) {
      nd.setDRACODecoderLocation(e4);
    }
    static get dracoDecoderLocation() {
      return nd.getDRACODecoderLocation();
    }
    static set ktx2TranscoderLocation(e4) {
      nd.setKTX2TranscoderLocation(e4);
    }
    static get ktx2TranscoderLocation() {
      return nd.getKTX2TranscoderLocation();
    }
    static set meshoptDecoderLocation(e4) {
      nd.setMeshoptDecoderLocation(e4);
    }
    static get meshoptDecoderLocation() {
      return nd.getMeshoptDecoderLocation();
    }
    static set lottieLoaderLocation(e4) {
      Jg.singleton.textureUtils.lottieLoaderUrl = e4;
    }
    static get lottieLoaderLocation() {
      return Jg.singleton.textureUtils.lottieLoaderUrl;
    }
    static mapURLs(e4) {
      Jg.singleton.loader[ed].manager.setURLModifier(e4);
    }
    dismissPoster() {
      this.loaded ? this[Nb]() : (this[Fb] = true, this[Bv]());
    }
    showPoster() {
      const e4 = this[Db];
      if (e4.classList.contains("show"))
        return;
      e4.classList.add("show"), this[Rv].classList.remove("show");
      const t3 = this[Lb];
      t3.removeAttribute("tabindex"), t3.removeAttribute("aria-hidden");
      const i3 = this.modelIsVisible;
      this[Ob] = false, this[xv](i3);
    }
    getDimensions() {
      return Gv(this[Dv].size);
    }
    getBoundingBoxCenter() {
      return Gv(this[Dv].boundingBox.getCenter(new di()));
    }
    connectedCallback() {
      super.connectedCallback(), this.loaded || this.showPoster(), this[Uv].addEventListener("progress", this[Hb]);
    }
    disconnectedCallback() {
      super.disconnectedCallback(), this[Uv].removeEventListener("progress", this[Hb]);
    }
    async updated(e4) {
      super.updated(e4), e4.has("poster") && null != this.poster && (this[Lb].style.backgroundImage = `url(${this.poster})`), e4.has("alt") && this[Lb].setAttribute("aria-label", this[Sv]), (e4.has("reveal") || e4.has("loading")) && this[Bv]();
    }
    [(t2 = Ob, i2 = Fb, n2 = Db, o2 = Lb, r2 = Pb, s2 = Ub, a2 = zb, l2 = Hb, Vv)]() {
      return !!this.src && (this[Fb] || this.loading === Rb || this.reveal === Mb && this[wv]);
    }
    [Nb]() {
      this[Fb] = false;
      const e4 = this[Db];
      if (!e4.classList.contains("show"))
        return;
      e4.classList.remove("show"), this[Rv].classList.add("show");
      const t3 = this.modelIsVisible;
      this[Ob] = true, this[xv](t3);
      const i3 = this.getRootNode();
      i3 && i3.activeElement === this && this[Rv].focus();
      const n3 = this[Lb];
      n3.setAttribute("aria-hidden", "true"), n3.tabIndex = -1, this.dispatchEvent(new CustomEvent("poster-dismissed"));
    }
    [Qv]() {
      return super[Qv]() && this[Ob];
    }
  }
  return Bb([ue({ type: String })], c2.prototype, "poster", void 0), Bb([ue({ type: String })], c2.prototype, "reveal", void 0), Bb([ue({ type: String })], c2.prototype, "loading", void 0), c2;
})(((e3) => {
  var t2;
  class i2 extends e3 {
    constructor(...e4) {
      super(e4), this.autoplay = false, this.animationName = void 0, this.animationCrossfadeDuration = 300, this[t2] = true, this[Dv].subscribeMixerEvent("loop", (e5) => {
        const t3 = e5.action._loopCount;
        this.dispatchEvent(new CustomEvent("loop", { detail: { count: t3 } }));
      }), this[Dv].subscribeMixerEvent("finished", () => {
        this[Xv] = true, this.dispatchEvent(new CustomEvent("finished"));
      });
    }
    get availableAnimations() {
      return this.loaded ? this[Dv].animationNames : [];
    }
    get duration() {
      return this[Dv].duration;
    }
    get paused() {
      return this[Xv];
    }
    get currentTime() {
      return this[Dv].animationTime;
    }
    set currentTime(e4) {
      this[Dv].animationTime = e4, this[Lv]();
    }
    get timeScale() {
      return this[Dv].animationTimeScale;
    }
    set timeScale(e4) {
      this[Dv].animationTimeScale = e4;
    }
    pause() {
      this[Xv] || (this[Xv] = true, this.dispatchEvent(new CustomEvent("pause")));
    }
    play(e4) {
      this.availableAnimations.length > 0 && (this[Xv] = false, this[jv](e4), this.dispatchEvent(new CustomEvent("play")));
    }
    [(t2 = Xv, Nv)]() {
      super[Nv](), this[Xv] = true, null != this.animationName && this[jv](), this.autoplay && this.play();
    }
    [Fv](e4, t3) {
      super[Fv](e4, t3), this[Xv] || !this[Qv]() && !this[zv].isPresenting || (this[Dv].updateAnimation(t3 / 1e3), this[Lv]());
    }
    updated(e4) {
      super.updated(e4), e4.has("autoplay") && this.autoplay && this.play(), e4.has("animationName") && this[jv]();
    }
    [jv](e4 = Yv) {
      var t3;
      const i3 = null !== (t3 = e4.repetitions) && void 0 !== t3 ? t3 : 1 / 0, n2 = e4.pingpong ? ut : 1 === i3 ? 2200 : ht;
      this[Dv].playAnimation(this.animationName, this.animationCrossfadeDuration / 1e3, n2, i3), this[Xv] && (this[Dv].updateAnimation(0), this[Lv]());
    }
  }
  return qv([ue({ type: Boolean })], i2.prototype, "autoplay", void 0), qv([ue({ type: String, attribute: "animation-name" })], i2.prototype, "animationName", void 0), qv([ue({ type: Number, attribute: "animation-crossfade-duration" })], i2.prototype, "animationCrossfadeDuration", void 0), i2;
})(Wv))))))));
customElements.define("model-viewer", Xb);
var Yb = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function Kb(e3) {
  return e3 && e3.__esModule && Object.prototype.hasOwnProperty.call(e3, "default") ? e3.default : e3;
}
var Zb, Jb = { exports: {} }, ey = "object" == typeof Reflect ? Reflect : null, ty = ey && "function" == typeof ey.apply ? ey.apply : function(e3, t2, i2) {
  return Function.prototype.apply.call(e3, t2, i2);
};
Zb = ey && "function" == typeof ey.ownKeys ? ey.ownKeys : Object.getOwnPropertySymbols ? function(e3) {
  return Object.getOwnPropertyNames(e3).concat(Object.getOwnPropertySymbols(e3));
} : function(e3) {
  return Object.getOwnPropertyNames(e3);
};
var iy = Number.isNaN || function(e3) {
  return e3 != e3;
};
function ny() {
  ny.init.call(this);
}
Jb.exports = ny, Jb.exports.once = function(e3, t2) {
  return new Promise(function(i2, n2) {
    function o2(i3) {
      e3.removeListener(t2, r2), n2(i3);
    }
    function r2() {
      "function" == typeof e3.removeListener && e3.removeListener("error", o2), i2([].slice.call(arguments));
    }
    py(e3, t2, r2, { once: true }), "error" !== t2 && function(e4, t3, i3) {
      "function" == typeof e4.on && py(e4, "error", t3, i3);
    }(e3, o2, { once: true });
  });
}, ny.EventEmitter = ny, ny.prototype._events = void 0, ny.prototype._eventsCount = 0, ny.prototype._maxListeners = void 0;
var oy = 10;
function ry(e3) {
  if ("function" != typeof e3)
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e3);
}
function sy(e3) {
  return void 0 === e3._maxListeners ? ny.defaultMaxListeners : e3._maxListeners;
}
function ay(e3, t2, i2, n2) {
  var o2, r2, s2, a2;
  if (ry(i2), void 0 === (r2 = e3._events) ? (r2 = e3._events = /* @__PURE__ */ Object.create(null), e3._eventsCount = 0) : (void 0 !== r2.newListener && (e3.emit("newListener", t2, i2.listener ? i2.listener : i2), r2 = e3._events), s2 = r2[t2]), void 0 === s2)
    s2 = r2[t2] = i2, ++e3._eventsCount;
  else if ("function" == typeof s2 ? s2 = r2[t2] = n2 ? [i2, s2] : [s2, i2] : n2 ? s2.unshift(i2) : s2.push(i2), (o2 = sy(e3)) > 0 && s2.length > o2 && !s2.warned) {
    s2.warned = true;
    var l2 = new Error("Possible EventEmitter memory leak detected. " + s2.length + " " + String(t2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    l2.name = "MaxListenersExceededWarning", l2.emitter = e3, l2.type = t2, l2.count = s2.length, a2 = l2, console && console.warn && console.warn(a2);
  }
  return e3;
}
function ly() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function cy(e3, t2, i2) {
  var n2 = { fired: false, wrapFn: void 0, target: e3, type: t2, listener: i2 }, o2 = ly.bind(n2);
  return o2.listener = i2, n2.wrapFn = o2, o2;
}
function hy(e3, t2, i2) {
  var n2 = e3._events;
  if (void 0 === n2)
    return [];
  var o2 = n2[t2];
  return void 0 === o2 ? [] : "function" == typeof o2 ? i2 ? [o2.listener || o2] : [o2] : i2 ? function(e4) {
    for (var t3 = new Array(e4.length), i3 = 0; i3 < t3.length; ++i3)
      t3[i3] = e4[i3].listener || e4[i3];
    return t3;
  }(o2) : dy(o2, o2.length);
}
function uy(e3) {
  var t2 = this._events;
  if (void 0 !== t2) {
    var i2 = t2[e3];
    if ("function" == typeof i2)
      return 1;
    if (void 0 !== i2)
      return i2.length;
  }
  return 0;
}
function dy(e3, t2) {
  for (var i2 = new Array(t2), n2 = 0; n2 < t2; ++n2)
    i2[n2] = e3[n2];
  return i2;
}
function py(e3, t2, i2, n2) {
  if ("function" == typeof e3.on)
    n2.once ? e3.once(t2, i2) : e3.on(t2, i2);
  else {
    if ("function" != typeof e3.addEventListener)
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e3);
    e3.addEventListener(t2, function o2(r2) {
      n2.once && e3.removeEventListener(t2, o2), i2(r2);
    });
  }
}
Object.defineProperty(ny, "defaultMaxListeners", { enumerable: true, get: function() {
  return oy;
}, set: function(e3) {
  if ("number" != typeof e3 || e3 < 0 || iy(e3))
    throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e3 + ".");
  oy = e3;
} }), ny.init = function() {
  void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, ny.prototype.setMaxListeners = function(e3) {
  if ("number" != typeof e3 || e3 < 0 || iy(e3))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e3 + ".");
  return this._maxListeners = e3, this;
}, ny.prototype.getMaxListeners = function() {
  return sy(this);
}, ny.prototype.emit = function(e3) {
  for (var t2 = [], i2 = 1; i2 < arguments.length; i2++)
    t2.push(arguments[i2]);
  var n2 = "error" === e3, o2 = this._events;
  if (void 0 !== o2)
    n2 = n2 && void 0 === o2.error;
  else if (!n2)
    return false;
  if (n2) {
    var r2;
    if (t2.length > 0 && (r2 = t2[0]), r2 instanceof Error)
      throw r2;
    var s2 = new Error("Unhandled error." + (r2 ? " (" + r2.message + ")" : ""));
    throw s2.context = r2, s2;
  }
  var a2 = o2[e3];
  if (void 0 === a2)
    return false;
  if ("function" == typeof a2)
    ty(a2, this, t2);
  else {
    var l2 = a2.length, c2 = dy(a2, l2);
    for (i2 = 0; i2 < l2; ++i2)
      ty(c2[i2], this, t2);
  }
  return true;
}, ny.prototype.addListener = function(e3, t2) {
  return ay(this, e3, t2, false);
}, ny.prototype.on = ny.prototype.addListener, ny.prototype.prependListener = function(e3, t2) {
  return ay(this, e3, t2, true);
}, ny.prototype.once = function(e3, t2) {
  return ry(t2), this.on(e3, cy(this, e3, t2)), this;
}, ny.prototype.prependOnceListener = function(e3, t2) {
  return ry(t2), this.prependListener(e3, cy(this, e3, t2)), this;
}, ny.prototype.removeListener = function(e3, t2) {
  var i2, n2, o2, r2, s2;
  if (ry(t2), void 0 === (n2 = this._events))
    return this;
  if (void 0 === (i2 = n2[e3]))
    return this;
  if (i2 === t2 || i2.listener === t2)
    0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete n2[e3], n2.removeListener && this.emit("removeListener", e3, i2.listener || t2));
  else if ("function" != typeof i2) {
    for (o2 = -1, r2 = i2.length - 1; r2 >= 0; r2--)
      if (i2[r2] === t2 || i2[r2].listener === t2) {
        s2 = i2[r2].listener, o2 = r2;
        break;
      }
    if (o2 < 0)
      return this;
    0 === o2 ? i2.shift() : function(e4, t3) {
      for (; t3 + 1 < e4.length; t3++)
        e4[t3] = e4[t3 + 1];
      e4.pop();
    }(i2, o2), 1 === i2.length && (n2[e3] = i2[0]), void 0 !== n2.removeListener && this.emit("removeListener", e3, s2 || t2);
  }
  return this;
}, ny.prototype.off = ny.prototype.removeListener, ny.prototype.removeAllListeners = function(e3) {
  var t2, i2, n2;
  if (void 0 === (i2 = this._events))
    return this;
  if (void 0 === i2.removeListener)
    return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== i2[e3] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete i2[e3]), this;
  if (0 === arguments.length) {
    var o2, r2 = Object.keys(i2);
    for (n2 = 0; n2 < r2.length; ++n2)
      "removeListener" !== (o2 = r2[n2]) && this.removeAllListeners(o2);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if ("function" == typeof (t2 = i2[e3]))
    this.removeListener(e3, t2);
  else if (void 0 !== t2)
    for (n2 = t2.length - 1; n2 >= 0; n2--)
      this.removeListener(e3, t2[n2]);
  return this;
}, ny.prototype.listeners = function(e3) {
  return hy(this, e3, true);
}, ny.prototype.rawListeners = function(e3) {
  return hy(this, e3, false);
}, ny.listenerCount = function(e3, t2) {
  return "function" == typeof e3.listenerCount ? e3.listenerCount(t2) : uy.call(e3, t2);
}, ny.prototype.listenerCount = uy, ny.prototype.eventNames = function() {
  return this._eventsCount > 0 ? Zb(this._events) : [];
};
var _y = Jb.exports;
const gy = (e3, t2 = 250) => {
  let i2;
  return function(...n2) {
    clearTimeout(i2), i2 = setTimeout(() => e3.apply(this, n2), t2);
  };
};
class my extends _y.EventEmitter {
  constructor(e3, t2 = "mousedown", i2 = "click", n2 = 200) {
    super(), this._isHoldEvent = false, this._holdTimeoutId = -1, this._doubleClickTimeoutId = -1, this._numClick = 0, e3.addEventListener(t2, this._handleMouseDown.bind(this)), e3.addEventListener(i2, this._handleMouseClick.bind(this)), this._delay = n2;
  }
  _handleMouseDown() {
    this._isHoldEvent = false, window.clearTimeout(this._doubleClickTimeoutId), this._holdTimeoutId = window.setTimeout(() => {
      this._isHoldEvent = true, this.emit("pointerevent-is-hold-event");
    }, this._delay);
  }
  _handleMouseClick(e3) {
    if (this._isHoldEvent)
      return this._numClick = 0, void (this._isHoldEvent = false);
    window.clearTimeout(this._holdTimeoutId), this._numClick++, 1 === this._numClick ? this._doubleClickTimeoutId = window.setTimeout(() => {
      this._numClick = 0, this.emit("single-click", e3);
    }, this._delay) : (this._numClick = 0, this.emit("double-click", e3));
  }
}
var fy = Object.defineProperty, vy = Object.getOwnPropertyDescriptor, Ay = (e3, t2, i2, n2) => {
  for (var o2, r2 = n2 > 1 ? void 0 : n2 ? vy(t2, i2) : t2, s2 = e3.length - 1; s2 >= 0; s2--)
    (o2 = e3[s2]) && (r2 = (n2 ? o2(t2, i2, r2) : o2(r2)) || r2);
  return n2 && r2 && fy(t2, i2, r2), r2;
};
function by(e3, t2 = null) {
  const i2 = document.createElement("canvas");
  i2.width = 64, i2.height = 64;
  const n2 = i2.getContext("2d");
  if (null == n2)
    return;
  if (n2.beginPath(), n2.arc(32, 32, 16, 0, 2 * Math.PI), n2.closePath(), n2.fillStyle = e3.getStyle(), n2.fill(), null !== t2) {
    const e4 = 20;
    n2.font = e4 + "px Arial";
    const o3 = n2.measureText(t2), r2 = o3.width, s2 = o3.actualBoundingBoxAscent - o3.actualBoundingBoxDescent, a2 = (i2.width - r2) / 2, l2 = (i2.height + s2) / 2;
    n2.fillStyle = "#ffffff", n2.fillText(t2, a2, l2);
  }
  const o2 = new El(i2);
  return new wa({ map: o2, toneMapped: false });
}
let yy = class extends Xb {
  constructor() {
    super(), this._coordinateAxes = [], this._coordinateLabel = [], this._lastSphericalPosition = { theta: -1, phi: -1, radius: -1 }, this._lastFieldOfViewInDeg = -1, this._referenceFieldOfViewInRad = -1, this._referenceMaxRadius = -1, this._isRadiusConst = false, this._maxZoomLevel = 100, this._minZoomLevel = 0.5, this._currentZoomLevel = 1, this._minPhiInDeg = 0, this._maxPhiInDeg = 1800, this._deltaX = 0, this._deltaY = 0, this._emitCamOrbitAngleChanged = gy(() => {
      console.log("Cam Phi Theta", 180 * this._lastSphericalPosition.phi / Math.PI, 180 * this._lastSphericalPosition.theta / Math.PI), this.dispatchEvent(new Event("cam-orbit-angle-changed"));
    }, 250), this.addEventListener("load", this._handleModelLoaded), this.addEventListener("camera-change", this._handleCameraChanged);
    const e3 = new my(this);
    e3.on("single-click", this._handleSceneClicked.bind(this)), this.addEventListener("pointerup", () => this[Rv].style.cursor = "default"), this.addEventListener("pointerdown", () => this[Rv].style.cursor = "pointer"), e3.on("pointerevent-is-hold-event", () => {
      console.log("Single click over"), this[Rv].style.cursor = "grabbing";
    });
  }
  firstUpdated() {
    this[Dv].add(this.measurementTool.sceneElementGroup), this.measurementTool.on("scene-update-requested", () => this.updateRendering()), this.measurementTool.on("calculate-hotspot-requested", this._intersectObject.bind(this)), this.measurementTool.on("hotspot-added", this._handleHotspotAdded.bind(this));
  }
  connectWithSettings(e3) {
    e3.modelOrientation.on("model-orientation-changed", (e4) => {
      this.orientation = e4.angleInRadAsString(), this.measurementTool.eulerOrientation = e4;
    }), e3.environment3D.on("change-axes-visibility-requested", this._changeAxesVisibility.bind(this)), e3.environment3D.on("change-viewer-background-color-requested", this._changeBackgroundColor.bind(this)), e3.environment3D.on("change-exposure-requested", (e4) => this.exposure = e4);
    const [t2, i2] = e3.environment3D.backgroundColor;
    this._changeBackgroundColor(t2, i2);
  }
  resize(e3, t2) {
    this.style.height = e3 + "px", this.style.width = t2 + "px", this[Dv].idealAspect = this[Dv].aspect;
  }
  getCamera() {
    return this[Dv].camera;
  }
  setReferenceFieldOfView(e3, t2 = false) {
    if (e3 == this._referenceFieldOfViewInRad)
      return void (t2 && (this.fieldOfView = e3 + "rad"));
    this._referenceFieldOfViewInRad = e3, this[Dv].idealAspect = this[Dv].aspect, this.minFieldOfView = e3 / this._maxZoomLevel + "rad", this.maxFieldOfView = e3 / this._minZoomLevel + "rad", t2 && (this.fieldOfView = e3 + "rad");
    const i2 = this.getDimensions(), n2 = Math.sqrt(i2.x * i2.x + i2.y * i2.y + i2.z * i2.z);
    this.clientWidth > this.clientHeight ? this._referenceMaxRadius = n2 / e3 : this._referenceMaxRadius = n2 / e3 * this.clientHeight / this.clientWidth, this._isRadiusConst || (this.maxCameraOrbit = "Infinity " + this._maxPhiInDeg + "deg " + this._referenceMaxRadius + "m");
  }
  rotateModel(e3, t2) {
    const i2 = 2 * Math.PI / this[Dv].height, n2 = i2 * e3, o2 = i2 * t2;
    let r2 = this[D_];
    r2.changeSource = dg.USER_INTERACTION, r2.adjustOrbit(n2, o2, 0);
  }
  zoomTo(e3) {
    -1 != this._referenceFieldOfViewInRad ? (this._currentZoomLevel = e3, this[Dv].idealAspect = this[Dv].aspect, this.fieldOfView = this._referenceFieldOfViewInRad / e3 + "rad") : console.log("Return 3d  zoom, ", this._currentZoomLevel);
  }
  setViewerOffset(e3, t2) {
    this._deltaX == e3 && this._deltaY == t2 || (this._deltaX = e3, this._deltaY = t2, this[Dv].camera.setViewOffset(this.clientWidth, this.clientHeight, e3, t2, this.clientWidth, this.clientHeight), this.updateRendering());
  }
  updateRendering() {
    this[Dv].queueRender();
  }
  setMinZoomLevel(e3) {
    if (this._minZoomLevel != e3 && -1 != this._referenceFieldOfViewInRad) {
      const t2 = this._referenceFieldOfViewInRad / e3, i2 = this.getFieldOfView() / 180 * Math.PI;
      if (t2 < i2)
        if (0 == this._isRadiusConst) {
          const e4 = this.getCameraOrbit(), n2 = this.getCameraOrbit().radius;
          e4.radius = n2 * i2 / t2, this.cameraOrbit = e4.toString();
        } else
          this.fieldOfView = t2 + "rad";
      this.maxFieldOfView = t2 + "rad", this._minZoomLevel = e3;
    }
  }
  setCameraOrbitPos(e3) {
    this._isRadiusConst && (this.minCameraOrbit = "-Infinity " + this._minPhiInDeg + "deg " + e3.radius + "m", this.maxCameraOrbit = "Infinity " + this._maxPhiInDeg + "deg " + e3.radius + "m"), this.cameraOrbit = e3.toString();
  }
  updateRadiusMode(e3) {
    if (e3 != this._isRadiusConst)
      if (this._isRadiusConst = e3, e3) {
        const e4 = this.getCameraOrbit().radius;
        this.minCameraOrbit = "-Infinity " + this._minPhiInDeg + "deg " + e4 + "m", this.maxCameraOrbit = "Infinity " + this._maxPhiInDeg + "deg " + e4 + "m";
      } else {
        this.minCameraOrbit = "-Infinity " + this._minPhiInDeg + "deg  auto";
        const e4 = this._referenceMaxRadius > 0 ? this._referenceMaxRadius + "m" : "auto";
        this.maxCameraOrbit = "Infinity " + this._maxPhiInDeg + "deg " + e4;
      }
  }
  _changeAxesVisibility(e3) {
    this._changeCoordinateVisibility(e3), this.updateRendering();
  }
  _changeBackgroundColor(e3, t2) {
    console.log("Change background color", e3, t2), this.style.background = t2 ? "radial-gradient(circle at center, " + t2 + ", " + e3 + ")" : e3;
  }
  _handleHotspotAdded(e3) {
    e3.addEventListener("hotspot-position-changed", () => {
      this.updateHotspot({ name: e3.slot, position: e3.dataset.position, normal: e3.dataset.normal });
    }), this.appendChild(e3);
  }
  _intersectObject(e3, t2) {
    let i2 = this.getCameraTarget();
    console.log("Current translation 2", i2), e3.x -= i2.x, e3.y -= i2.y, e3.z -= i2.z, this[Dv].remove(this.measurementTool.sceneElementGroup), this._removeCoordinateElements();
    const n2 = new Fc(e3, t2).intersectObject(this[Dv], true);
    this[Dv].add(this.measurementTool.sceneElementGroup), this._addCoordinateElements();
    var o2 = n2.find((e4) => e4.object.visible && !e4.object.userData.shadow);
    if (null == o2 || null == o2.face)
      return;
    let r2, s2;
    null == o2.uv ? (r2 = o2.point, s2 = o2.face.normal) : (o2.face.normal.applyNormalMatrix(new Gt().getNormalMatrix(o2.object.matrixWorld)), r2 = o2.point, s2 = o2.face.normal), r2.x += i2.x, r2.y += i2.y, r2.z += i2.z, this.measurementTool.addPointFrom3DScene(r2, s2, false);
  }
  _coordinateLabelIsClicked(e3) {
    if (!this._coordinateAxes[0].visible)
      return false;
    const t2 = this[Dv].getNDC(e3.clientX, e3.clientY), i2 = new Fc();
    i2.setFromCamera(t2, this.getCamera());
    const n2 = i2.intersectObjects(this._coordinateLabel, true);
    if (console.log("Label hit?", n2.length), 0 == n2.length)
      return false;
    const o2 = n2[0].object;
    let r2 = this.getCameraOrbit();
    switch (o2.userData.type) {
      case "posX":
        r2.phi = 0.5 * Math.PI, r2.theta = 0.5 * Math.PI;
        break;
      case "posY":
        r2.phi = 0, r2.theta = 0;
        break;
      case "posZ":
        r2.phi = 0.5 * Math.PI, r2.theta = 0;
        break;
      case "negX":
        r2.phi = 0.5 * Math.PI, r2.theta = 1.5 * Math.PI;
        break;
      case "negY":
        r2.phi = Math.PI, r2.theta = 0;
        break;
      case "negZ":
        r2.phi = 0.5 * Math.PI, r2.theta = Math.PI;
        break;
      default:
        console.log("default");
    }
    return this.cameraOrbit = r2.toString(), this._emitCamOrbitAngleChanged(), true;
  }
  _handleSceneClicked(e3) {
    if (console.log("Single Click"), this._coordinateLabelIsClicked(e3))
      return;
    if (!this.measurementTool.isEditModeActive)
      return;
    const t2 = e3.clientX, i2 = e3.clientY;
    this[Dv].remove(this.measurementTool.sceneElementGroup), this._removeCoordinateElements();
    const n2 = this.positionAndNormalFromPoint(t2, i2);
    if (this[Dv].add(this.measurementTool.sceneElementGroup), this._addCoordinateElements(), null == n2)
      return void console.log("no hit result: mouse = ", t2, ", ", i2);
    const { position: o2, normal: r2 } = n2;
    this.measurementTool.addPointFrom3DScene(o2, r2);
  }
  _addCoordinateElements() {
    this._coordinateAxes.forEach((e3) => {
      this[Dv].add(e3);
    }), this._coordinateLabel.forEach((e3) => {
      this[Dv].add(e3);
    });
  }
  _removeCoordinateElements() {
    this._coordinateAxes.forEach((e3) => {
      this[Dv].remove(e3);
    }), this._coordinateLabel.forEach((e3) => {
      this[Dv].remove(e3);
    });
  }
  _changeCoordinateVisibility(e3) {
    this._coordinateAxes.forEach((t2) => {
      t2.visible = e3;
    }), this._coordinateLabel.forEach((t2) => {
      t2.visible = e3;
    });
  }
  _handleModelLoaded() {
    const e3 = this.getDimensions(), t2 = 0.5 * Math.max(Math.max(e3.x, e3.y), e3.z);
    this._coordinateAxes.push(new Vc(new di(t2, 0, 0), new di(-t2, 0, 0), 2 * t2, "red", 0.5, 0.25)), this._coordinateAxes.push(new Vc(new di(0, t2, 0), new di(0, -t2, 0), 2 * t2, "green", 0.5, 0.25)), this._coordinateAxes.push(new Vc(new di(0, 0, t2), new di(0, 0, -t2), 2 * t2, "blue", 0.5, 0.25));
    const i2 = new di(0.5, 0.5, 0.5);
    let n2 = new Qi();
    n2.scale(i2);
    let o2 = new Fa(by(new Pn("red"), "X"));
    o2.userData.type = "posX", o2.applyMatrix4(n2), o2.position.x = t2, this._coordinateLabel.push(o2);
    let r2 = new Fa(by(new Pn(1, 0.2, 0.2), "-x"));
    r2.userData.type = "negX", r2.applyMatrix4(n2), r2.position.x = -t2, this._coordinateLabel.push(r2);
    let s2 = new Fa(by(new Pn("green"), "y"));
    s2.userData.type = "posY", s2.applyMatrix4(n2), s2.position.y = t2, this._coordinateLabel.push(s2);
    let a2 = new Fa(by(new Pn(0.2, 1, 0.2), "-y"));
    a2.userData.type = "negY", a2.applyMatrix4(n2), a2.position.y = -t2, this._coordinateLabel.push(a2);
    let l2 = new Fa(by(new Pn("blue"), "z"));
    l2.userData.type = "posZ", l2.applyMatrix4(n2), l2.position.z = t2, this._coordinateLabel.push(l2);
    let c2 = new Fa(by(new Pn(0.2, 0.2, 1), "-z"));
    c2.userData.type = "negZ", c2.applyMatrix4(n2), c2.position.z = -t2, this._coordinateLabel.push(c2), this._addCoordinateElements(), this._lastSphericalPosition = this.getCameraOrbit(), this[Dv].idealAspect = this[Dv].aspect, this[Dv].queueRender(), this._emitCamOrbitAngleChanged(), this[Rv].style.cursor = "default", this.minCameraOrbit = "-Infinity " + this._minPhiInDeg + "deg  auto", this.maxCameraOrbit = "Infinity " + this._maxPhiInDeg + "deg auto";
  }
  _handleCameraChanged(e3) {
    this.measurementTool.translation = new di().setFromMatrixPosition(this[Dv].target.matrixWorld);
    const t2 = this.getCameraOrbit(), i2 = this.getFieldOfView();
    if ("user-interaction" != e3.detail.source)
      return this._lastSphericalPosition = t2, void (this._lastFieldOfViewInDeg = i2);
    this._lastSphericalPosition.phi == t2.phi && this._lastSphericalPosition.theta == t2.theta || (console.log("CamChanged", this.getCameraOrbit(), this._lastSphericalPosition), t2.radius > 0 && this._emitCamOrbitAngleChanged()), this._lastSphericalPosition.radius == t2.radius && this._lastFieldOfViewInDeg != i2 && (this._currentZoomLevel = 180 * this._referenceFieldOfViewInRad / Math.PI / i2, console.log("FOV change", this._currentZoomLevel, 180 * this._referenceFieldOfViewInRad / Math.PI, i2), this.dispatchEvent(new CustomEvent("fov-based-zoom-changed", { detail: { zoomLevel: this._currentZoomLevel } }))), this._lastSphericalPosition = t2, this._lastFieldOfViewInDeg = i2;
  }
};
yy.styles = r`
 `, Ay([ue({ type: Object })], yy.prototype, "measurementTool", 2), yy = Ay([ce("viewer-3d")], yy);
var wy = { exports: {} };
!function(e3) {
  function t2(e4) {
    return new t2.Viewer(e4);
  }
  var i2, n2;
  !function(e4) {
    e4.version = { versionStr: "4.1.0", major: parseInt("4", 10), minor: parseInt("1", 10), revision: parseInt("0", 10) };
    var i3, n3 = { "[object Boolean]": "boolean", "[object Number]": "number", "[object String]": "string", "[object Function]": "function", "[object AsyncFunction]": "function", "[object Promise]": "promise", "[object Array]": "array", "[object Date]": "date", "[object RegExp]": "regexp", "[object Object]": "object" }, o2 = Object.prototype.toString, r2 = Object.prototype.hasOwnProperty;
    e4.isFunction = function(t3) {
      return "function" === e4.type(t3);
    }, e4.isArray = Array.isArray || function(t3) {
      return "array" === e4.type(t3);
    }, e4.isWindow = function(e5) {
      return e5 && "object" == typeof e5 && "setInterval" in e5;
    }, e4.type = function(e5) {
      return null == e5 ? String(e5) : n3[o2.call(e5)] || "object";
    }, e4.isPlainObject = function(i4) {
      if (!i4 || "object" !== t2.type(i4) || i4.nodeType || e4.isWindow(i4))
        return false;
      if (i4.constructor && !r2.call(i4, "constructor") && !r2.call(i4.constructor.prototype, "isPrototypeOf"))
        return false;
      var n4;
      for (var o3 in i4)
        n4 = o3;
      return void 0 === n4 || r2.call(i4, n4);
    }, e4.isEmptyObject = function(e5) {
      for (var t3 in e5)
        return false;
      return true;
    }, e4.freezeObject = function(t3) {
      return Object.freeze ? e4.freezeObject = Object.freeze : e4.freezeObject = function(e5) {
        return e5;
      }, e4.freezeObject(t3);
    }, e4.supportsCanvas = (i3 = document.createElement("canvas"), !(!e4.isFunction(i3.getContext) || !i3.getContext("2d"))), e4.isCanvasTainted = function(e5) {
      var t3 = false;
      try {
        e5.getContext("2d").getImageData(0, 0, 1, 1);
      } catch (e6) {
        t3 = true;
      }
      return t3;
    }, e4.supportsAddEventListener = !(!document.documentElement.addEventListener || !document.addEventListener), e4.supportsRemoveEventListener = !(!document.documentElement.removeEventListener || !document.removeEventListener), e4.supportsEventListenerOptions = function() {
      var t3 = 0;
      if (e4.supportsAddEventListener)
        try {
          var i4 = { get capture() {
            return t3++, false;
          }, get once() {
            return t3++, false;
          }, get passive() {
            return t3++, false;
          } };
          window.addEventListener("test", null, i4), window.removeEventListener("test", null, i4);
        } catch (e5) {
          t3 = 0;
        }
      return t3 >= 3;
    }(), e4.getCurrentPixelDensityRatio = function() {
      if (e4.supportsCanvas) {
        var t3 = document.createElement("canvas").getContext("2d"), i4 = window.devicePixelRatio || 1, n4 = t3.webkitBackingStorePixelRatio || t3.mozBackingStorePixelRatio || t3.msBackingStorePixelRatio || t3.oBackingStorePixelRatio || t3.backingStorePixelRatio || 1;
        return Math.max(i4, 1) / n4;
      }
      return 1;
    }, e4.pixelDensityRatio = e4.getCurrentPixelDensityRatio();
  }(t2), function(e4) {
    e4.extend = function() {
      var i4, n4, o3, r3, s2, a2, l2 = arguments[0] || {}, c2 = arguments.length, h2 = false, u2 = 1;
      for ("boolean" == typeof l2 && (h2 = l2, l2 = arguments[1] || {}, u2 = 2), "object" == typeof l2 || t2.isFunction(l2) || (l2 = {}), c2 === u2 && (l2 = this, --u2); u2 < c2; u2++)
        if (null !== (i4 = arguments[u2]) || void 0 !== i4)
          for (n4 in i4) {
            var d2 = Object.getOwnPropertyDescriptor(i4, n4);
            void 0 !== d2 ? d2.get || d2.set ? Object.defineProperty(l2, n4, d2) : l2 !== (r3 = d2.value) && (h2 && r3 && (t2.isPlainObject(r3) || (s2 = t2.isArray(r3))) ? (o3 = l2[n4], s2 ? (s2 = false, a2 = o3 && t2.isArray(o3) ? o3 : []) : a2 = o3 && t2.isPlainObject(o3) ? o3 : {}, l2[n4] = t2.extend(h2, a2, r3)) : void 0 !== r3 && (l2[n4] = r3)) : e4.console.warn('Could not copy inherited property "' + n4 + '".');
          }
      return l2;
    };
    e4.extend(e4, { DEFAULT_SETTINGS: { xmlPath: null, tileSources: null, tileHost: null, initialPage: 0, crossOriginPolicy: false, ajaxWithCredentials: false, loadTilesWithAjax: false, ajaxHeaders: {}, splitHashDataForPost: false, panHorizontal: true, panVertical: true, constrainDuringPan: false, wrapHorizontal: false, wrapVertical: false, visibilityRatio: 0.5, minPixelRatio: 0.5, defaultZoomLevel: 0, minZoomLevel: null, maxZoomLevel: null, homeFillsViewer: false, clickTimeThreshold: 300, clickDistThreshold: 5, dblClickTimeThreshold: 300, dblClickDistThreshold: 20, springStiffness: 6.5, animationTime: 1.2, gestureSettingsMouse: { dragToPan: true, scrollToZoom: true, clickToZoom: true, dblClickToZoom: false, dblClickDragToZoom: false, pinchToZoom: false, zoomToRefPoint: true, flickEnabled: false, flickMinSpeed: 120, flickMomentum: 0.25, pinchRotate: false }, gestureSettingsTouch: { dragToPan: true, scrollToZoom: false, clickToZoom: false, dblClickToZoom: true, dblClickDragToZoom: true, pinchToZoom: true, zoomToRefPoint: true, flickEnabled: true, flickMinSpeed: 120, flickMomentum: 0.25, pinchRotate: false }, gestureSettingsPen: { dragToPan: true, scrollToZoom: false, clickToZoom: true, dblClickToZoom: false, dblClickDragToZoom: false, pinchToZoom: false, zoomToRefPoint: true, flickEnabled: false, flickMinSpeed: 120, flickMomentum: 0.25, pinchRotate: false }, gestureSettingsUnknown: { dragToPan: true, scrollToZoom: false, clickToZoom: false, dblClickToZoom: true, dblClickDragToZoom: false, pinchToZoom: true, zoomToRefPoint: true, flickEnabled: true, flickMinSpeed: 120, flickMomentum: 0.25, pinchRotate: false }, zoomPerClick: 2, zoomPerScroll: 1.2, zoomPerDblClickDrag: 1.2, zoomPerSecond: 1, blendTime: 0, alwaysBlend: false, autoHideControls: true, immediateRender: false, minZoomImageRatio: 0.9, maxZoomPixelRatio: 1.1, smoothTileEdgesMinZoom: 1.1, iOSDevice: function() {
      if ("object" != typeof navigator)
        return false;
      var e5 = navigator.userAgent;
      return "string" == typeof e5 && (-1 !== e5.indexOf("iPhone") || -1 !== e5.indexOf("iPad") || -1 !== e5.indexOf("iPod"));
    }(), pixelsPerWheelLine: 40, pixelsPerArrowPress: 40, autoResize: true, preserveImageSizeOnResize: false, minScrollDeltaTime: 50, rotationIncrement: 90, showSequenceControl: true, sequenceControlAnchor: null, preserveViewport: false, preserveOverlays: false, navPrevNextWrap: false, showNavigationControl: true, navigationControlAnchor: null, showZoomControl: true, showHomeControl: true, showFullPageControl: true, showRotationControl: false, showFlipControl: false, controlsFadeDelay: 2e3, controlsFadeLength: 1500, mouseNavEnabled: true, showNavigator: false, navigatorElement: null, navigatorId: null, navigatorPosition: null, navigatorSizeRatio: 0.2, navigatorMaintainSizeRatio: false, navigatorTop: null, navigatorLeft: null, navigatorHeight: null, navigatorWidth: null, navigatorAutoResize: true, navigatorAutoFade: true, navigatorRotate: true, navigatorBackground: "#000", navigatorOpacity: 0.8, navigatorBorderColor: "#555", navigatorDisplayRegionColor: "#900", degrees: 0, flipped: false, opacity: 1, preload: false, compositeOperation: null, imageSmoothingEnabled: true, placeholderFillStyle: null, subPixelRoundingForTransparency: null, showReferenceStrip: false, referenceStripScroll: "horizontal", referenceStripElement: null, referenceStripHeight: null, referenceStripWidth: null, referenceStripPosition: "BOTTOM_LEFT", referenceStripSizeRatio: 0.2, collectionRows: 3, collectionColumns: 0, collectionLayout: "horizontal", collectionMode: false, collectionTileSize: 800, collectionTileMargin: 80, imageLoaderLimit: 0, maxImageCacheCount: 200, timeout: 3e4, useCanvas: true, tileRetryMax: 0, tileRetryDelay: 2500, prefixUrl: "/images/", navImages: { zoomIn: { REST: "zoomin_rest.png", GROUP: "zoomin_grouphover.png", HOVER: "zoomin_hover.png", DOWN: "zoomin_pressed.png" }, zoomOut: { REST: "zoomout_rest.png", GROUP: "zoomout_grouphover.png", HOVER: "zoomout_hover.png", DOWN: "zoomout_pressed.png" }, home: { REST: "home_rest.png", GROUP: "home_grouphover.png", HOVER: "home_hover.png", DOWN: "home_pressed.png" }, fullpage: { REST: "fullpage_rest.png", GROUP: "fullpage_grouphover.png", HOVER: "fullpage_hover.png", DOWN: "fullpage_pressed.png" }, rotateleft: { REST: "rotateleft_rest.png", GROUP: "rotateleft_grouphover.png", HOVER: "rotateleft_hover.png", DOWN: "rotateleft_pressed.png" }, rotateright: { REST: "rotateright_rest.png", GROUP: "rotateright_grouphover.png", HOVER: "rotateright_hover.png", DOWN: "rotateright_pressed.png" }, flip: { REST: "flip_rest.png", GROUP: "flip_grouphover.png", HOVER: "flip_hover.png", DOWN: "flip_pressed.png" }, previous: { REST: "previous_rest.png", GROUP: "previous_grouphover.png", HOVER: "previous_hover.png", DOWN: "previous_pressed.png" }, next: { REST: "next_rest.png", GROUP: "next_grouphover.png", HOVER: "next_hover.png", DOWN: "next_pressed.png" } }, debugMode: false, debugGridColor: ["#437AB2", "#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666"], silenceMultiImageWarnings: false }, SIGNAL: "----seadragon----", delegate: function(e5, t3) {
      return function() {
        var i4 = arguments;
        return void 0 === i4 && (i4 = []), t3.apply(e5, i4);
      };
    }, BROWSERS: { UNKNOWN: 0, IE: 1, FIREFOX: 2, SAFARI: 3, CHROME: 4, OPERA: 5, EDGE: 6, CHROMEEDGE: 7 }, SUBPIXEL_ROUNDING_OCCURRENCES: { NEVER: 0, ONLY_AT_REST: 1, ALWAYS: 2 }, _viewers: /* @__PURE__ */ new Map(), getViewer: function(t3) {
      return e4._viewers.get(this.getElement(t3));
    }, getElement: function(e5) {
      return "string" == typeof e5 && (e5 = document.getElementById(e5)), e5;
    }, getElementPosition: function(t3) {
      var i4, n4, o3 = new e4.Point();
      for (n4 = r2(t3 = e4.getElement(t3), i4 = "fixed" === e4.getElementStyle(t3).position); n4; )
        o3.x += t3.offsetLeft, o3.y += t3.offsetTop, i4 && (o3 = o3.plus(e4.getPageScroll())), n4 = r2(t3 = n4, i4 = "fixed" === e4.getElementStyle(t3).position);
      return o3;
    }, getElementOffset: function(t3) {
      var i4, n4, o3 = (t3 = e4.getElement(t3)) && t3.ownerDocument, r3 = { top: 0, left: 0 };
      return o3 ? (i4 = o3.documentElement, void 0 !== t3.getBoundingClientRect && (r3 = t3.getBoundingClientRect()), n4 = o3 === o3.window ? o3 : 9 === o3.nodeType && (o3.defaultView || o3.parentWindow), new e4.Point(r3.left + (n4.pageXOffset || i4.scrollLeft) - (i4.clientLeft || 0), r3.top + (n4.pageYOffset || i4.scrollTop) - (i4.clientTop || 0))) : new e4.Point();
    }, getElementSize: function(t3) {
      return t3 = e4.getElement(t3), new e4.Point(t3.clientWidth, t3.clientHeight);
    }, getElementStyle: document.documentElement.currentStyle ? function(t3) {
      return (t3 = e4.getElement(t3)).currentStyle;
    } : function(t3) {
      return t3 = e4.getElement(t3), window.getComputedStyle(t3, "");
    }, getCssPropertyWithVendorPrefix: function(t3) {
      var i4 = {};
      return e4.getCssPropertyWithVendorPrefix = function(t4) {
        if (void 0 !== i4[t4])
          return i4[t4];
        var n4 = document.createElement("div").style, o3 = null;
        if (void 0 !== n4[t4])
          o3 = t4;
        else
          for (var r3 = ["Webkit", "Moz", "MS", "O", "webkit", "moz", "ms", "o"], s2 = e4.capitalizeFirstLetter(t4), a2 = 0; a2 < r3.length; a2++) {
            var l2 = r3[a2] + s2;
            if (void 0 !== n4[l2]) {
              o3 = l2;
              break;
            }
          }
        return i4[t4] = o3, o3;
      }, e4.getCssPropertyWithVendorPrefix(t3);
    }, capitalizeFirstLetter: function(e5) {
      return e5.charAt(0).toUpperCase() + e5.slice(1);
    }, positiveModulo: function(e5, t3) {
      var i4 = e5 % t3;
      return i4 < 0 && (i4 += t3), i4;
    }, pointInElement: function(t3, i4) {
      t3 = e4.getElement(t3);
      var n4 = e4.getElementOffset(t3), o3 = e4.getElementSize(t3);
      return i4.x >= n4.x && i4.x < n4.x + o3.x && i4.y < n4.y + o3.y && i4.y >= n4.y;
    }, getMousePosition: function(t3) {
      if ("number" == typeof t3.pageX)
        e4.getMousePosition = function(t4) {
          var i4 = new e4.Point();
          return i4.x = t4.pageX, i4.y = t4.pageY, i4;
        };
      else {
        if ("number" != typeof t3.clientX)
          throw new Error("Unknown event mouse position, no known technique.");
        e4.getMousePosition = function(t4) {
          var i4 = new e4.Point();
          return i4.x = t4.clientX + document.body.scrollLeft + document.documentElement.scrollLeft, i4.y = t4.clientY + document.body.scrollTop + document.documentElement.scrollTop, i4;
        };
      }
      return e4.getMousePosition(t3);
    }, getPageScroll: function() {
      var t3 = document.documentElement || {}, i4 = document.body || {};
      if ("number" == typeof window.pageXOffset)
        e4.getPageScroll = function() {
          return new e4.Point(window.pageXOffset, window.pageYOffset);
        };
      else if (i4.scrollLeft || i4.scrollTop)
        e4.getPageScroll = function() {
          return new e4.Point(document.body.scrollLeft, document.body.scrollTop);
        };
      else {
        if (!t3.scrollLeft && !t3.scrollTop)
          return new e4.Point(0, 0);
        e4.getPageScroll = function() {
          return new e4.Point(document.documentElement.scrollLeft, document.documentElement.scrollTop);
        };
      }
      return e4.getPageScroll();
    }, setPageScroll: function(t3) {
      if (void 0 !== window.scrollTo)
        e4.setPageScroll = function(e5) {
          window.scrollTo(e5.x, e5.y);
        };
      else {
        var i4 = e4.getPageScroll();
        if (i4.x === t3.x && i4.y === t3.y)
          return;
        document.body.scrollLeft = t3.x, document.body.scrollTop = t3.y;
        var n4 = e4.getPageScroll();
        if (n4.x !== i4.x && n4.y !== i4.y)
          return void (e4.setPageScroll = function(e5) {
            document.body.scrollLeft = e5.x, document.body.scrollTop = e5.y;
          });
        if (document.documentElement.scrollLeft = t3.x, document.documentElement.scrollTop = t3.y, (n4 = e4.getPageScroll()).x !== i4.x && n4.y !== i4.y)
          return void (e4.setPageScroll = function(e5) {
            document.documentElement.scrollLeft = e5.x, document.documentElement.scrollTop = e5.y;
          });
        e4.setPageScroll = function(e5) {
        };
      }
      e4.setPageScroll(t3);
    }, getWindowSize: function() {
      var t3 = document.documentElement || {}, i4 = document.body || {};
      if ("number" == typeof window.innerWidth)
        e4.getWindowSize = function() {
          return new e4.Point(window.innerWidth, window.innerHeight);
        };
      else if (t3.clientWidth || t3.clientHeight)
        e4.getWindowSize = function() {
          return new e4.Point(document.documentElement.clientWidth, document.documentElement.clientHeight);
        };
      else {
        if (!i4.clientWidth && !i4.clientHeight)
          throw new Error("Unknown window size, no known technique.");
        e4.getWindowSize = function() {
          return new e4.Point(document.body.clientWidth, document.body.clientHeight);
        };
      }
      return e4.getWindowSize();
    }, makeCenteredNode: function(t3) {
      t3 = e4.getElement(t3);
      var i4 = [e4.makeNeutralElement("div"), e4.makeNeutralElement("div"), e4.makeNeutralElement("div")];
      return e4.extend(i4[0].style, { display: "table", height: "100%", width: "100%" }), e4.extend(i4[1].style, { display: "table-row" }), e4.extend(i4[2].style, { display: "table-cell", verticalAlign: "middle", textAlign: "center" }), i4[0].appendChild(i4[1]), i4[1].appendChild(i4[2]), i4[2].appendChild(t3), i4[0];
    }, makeNeutralElement: function(e5) {
      var t3 = document.createElement(e5), i4 = t3.style;
      return i4.background = "transparent none", i4.border = "none", i4.margin = "0px", i4.padding = "0px", i4.position = "static", t3;
    }, now: function() {
      return Date.now ? e4.now = Date.now : e4.now = function() {
        return (/* @__PURE__ */ new Date()).getTime();
      }, e4.now();
    }, makeTransparentImage: function(t3) {
      var i4 = e4.makeNeutralElement("img");
      return i4.src = t3, i4;
    }, setElementOpacity: function(t3, i4, n4) {
      var o3;
      t3 = e4.getElement(t3), n4 && !e4.Browser.alpha && (i4 = Math.round(i4)), e4.Browser.opacity ? t3.style.opacity = i4 < 1 ? i4 : "" : i4 < 1 ? (o3 = "alpha(opacity=" + Math.round(100 * i4) + ")", t3.style.filter = o3) : t3.style.filter = "";
    }, setElementTouchActionNone: function(t3) {
      void 0 !== (t3 = e4.getElement(t3)).style.touchAction ? t3.style.touchAction = "none" : void 0 !== t3.style.msTouchAction && (t3.style.msTouchAction = "none");
    }, setElementPointerEvents: function(t3, i4) {
      void 0 !== (t3 = e4.getElement(t3)).style && void 0 !== t3.style.pointerEvents && (t3.style.pointerEvents = i4);
    }, setElementPointerEventsNone: function(t3) {
      e4.setElementPointerEvents(t3, "none");
    }, addClass: function(t3, i4) {
      (t3 = e4.getElement(t3)).className ? -1 === (" " + t3.className + " ").indexOf(" " + i4 + " ") && (t3.className += " " + i4) : t3.className = i4;
    }, indexOf: function(e5, t3, i4) {
      return Array.prototype.indexOf ? this.indexOf = function(e6, t4, i5) {
        return e6.indexOf(t4, i5);
      } : this.indexOf = function(e6, t4, i5) {
        var n4, o3, r3 = i5 || 0;
        if (!e6)
          throw new TypeError();
        if (0 === (o3 = e6.length) || r3 >= o3)
          return -1;
        for (r3 < 0 && (r3 = o3 - Math.abs(r3)), n4 = r3; n4 < o3; n4++)
          if (e6[n4] === t4)
            return n4;
        return -1;
      }, this.indexOf(e5, t3, i4);
    }, removeClass: function(t3, i4) {
      var n4, o3, r3 = [];
      for (n4 = (t3 = e4.getElement(t3)).className.split(/\s+/), o3 = 0; o3 < n4.length; o3++)
        n4[o3] && n4[o3] !== i4 && r3.push(n4[o3]);
      t3.className = r3.join(" ");
    }, normalizeEventListenerOptions: function(t3) {
      return void 0 !== t3 ? "boolean" == typeof t3 ? e4.supportsEventListenerOptions ? { capture: t3 } : t3 : e4.supportsEventListenerOptions ? t3 : void 0 !== t3.capture && t3.capture : !!e4.supportsEventListenerOptions && { capture: false };
    }, addEvent: function() {
      if (e4.supportsAddEventListener)
        return function(t3, i4, n4, o3) {
          o3 = e4.normalizeEventListenerOptions(o3), (t3 = e4.getElement(t3)).addEventListener(i4, n4, o3);
        };
      if (document.documentElement.attachEvent && document.attachEvent)
        return function(t3, i4, n4) {
          (t3 = e4.getElement(t3)).attachEvent("on" + i4, n4);
        };
      throw new Error("No known event model.");
    }(), removeEvent: function() {
      if (e4.supportsRemoveEventListener)
        return function(t3, i4, n4, o3) {
          o3 = e4.normalizeEventListenerOptions(o3), (t3 = e4.getElement(t3)).removeEventListener(i4, n4, o3);
        };
      if (document.documentElement.detachEvent && document.detachEvent)
        return function(t3, i4, n4) {
          (t3 = e4.getElement(t3)).detachEvent("on" + i4, n4);
        };
      throw new Error("No known event model.");
    }(), cancelEvent: function(e5) {
      e5.preventDefault();
    }, eventIsCanceled: function(e5) {
      return e5.defaultPrevented;
    }, stopEvent: function(e5) {
      e5.stopPropagation();
    }, createCallback: function(e5, t3) {
      var i4, n4 = [];
      for (i4 = 2; i4 < arguments.length; i4++)
        n4.push(arguments[i4]);
      return function() {
        var i5, o3 = n4.concat([]);
        for (i5 = 0; i5 < arguments.length; i5++)
          o3.push(arguments[i5]);
        return t3.apply(e5, o3);
      };
    }, getUrlParameter: function(e5) {
      var t3 = o2[e5];
      return t3 || null;
    }, getUrlProtocol: function(e5) {
      var t3 = e5.match(/^([a-z]+:)\/\//i);
      return null === t3 ? window.location.protocol : t3[1].toLowerCase();
    }, createAjaxRequest: function(t3) {
      var i4;
      try {
        i4 = !!new ActiveXObject("Microsoft.XMLHTTP");
      } catch (e5) {
        i4 = false;
      }
      if (i4)
        window.XMLHttpRequest ? e4.createAjaxRequest = function(e5) {
          return e5 ? new ActiveXObject("Microsoft.XMLHTTP") : new XMLHttpRequest();
        } : e4.createAjaxRequest = function() {
          return new ActiveXObject("Microsoft.XMLHTTP");
        };
      else {
        if (!window.XMLHttpRequest)
          throw new Error("Browser doesn't support XMLHttpRequest.");
        e4.createAjaxRequest = function() {
          return new XMLHttpRequest();
        };
      }
      return e4.createAjaxRequest(t3);
    }, makeAjaxRequest: function(t3, i4, n4) {
      var o3, r3, s2, a2;
      e4.isPlainObject(t3) && (i4 = t3.success, n4 = t3.error, o3 = t3.withCredentials, r3 = t3.headers, s2 = t3.responseType || null, a2 = t3.postData || null, t3 = t3.url);
      var l2 = e4.getUrlProtocol(t3), c2 = e4.createAjaxRequest("file:" === l2);
      if (!e4.isFunction(i4))
        throw new Error("makeAjaxRequest requires a success callback");
      c2.onreadystatechange = function() {
        4 === c2.readyState && (c2.onreadystatechange = function() {
        }, c2.status >= 200 && c2.status < 300 || 0 === c2.status && "http:" !== l2 && "https:" !== l2 ? i4(c2) : e4.isFunction(n4) ? n4(c2) : e4.console.error("AJAX request returned %d: %s", c2.status, t3));
      };
      var h2 = a2 ? "POST" : "GET";
      try {
        if (c2.open(h2, t3, true), s2 && (c2.responseType = s2), r3)
          for (var u2 in r3)
            Object.prototype.hasOwnProperty.call(r3, u2) && r3[u2] && c2.setRequestHeader(u2, r3[u2]);
        o3 && (c2.withCredentials = true), c2.send(a2);
      } catch (t4) {
        e4.console.error("%s while making AJAX request: %s", t4.name, t4.message), c2.onreadystatechange = function() {
        }, e4.isFunction(n4) && n4(c2, t4);
      }
      return c2;
    }, jsonp: function(t3) {
      var i4, n4 = t3.url, o3 = document.head || document.getElementsByTagName("head")[0] || document.documentElement, r3 = t3.callbackName || "openseadragon" + e4.now(), s2 = window[r3], a2 = "$1" + r3 + "$2", l2 = t3.param || "callback", c2 = t3.callback;
      n4 = n4.replace(/(=)\?(&|$)|\?\?/i, a2), n4 += (/\?/.test(n4) ? "&" : "?") + l2 + "=" + r3, window[r3] = function(t4) {
        if (s2)
          window[r3] = s2;
        else
          try {
            delete window[r3];
          } catch (e5) {
          }
        c2 && e4.isFunction(c2) && c2(t4);
      }, i4 = document.createElement("script"), void 0 === t3.async && false === t3.async || (i4.async = "async"), t3.scriptCharset && (i4.charset = t3.scriptCharset), i4.src = n4, i4.onload = i4.onreadystatechange = function(e5, t4) {
        (t4 || !i4.readyState || /loaded|complete/.test(i4.readyState)) && (i4.onload = i4.onreadystatechange = null, o3 && i4.parentNode && o3.removeChild(i4), i4 = void 0);
      }, o3.insertBefore(i4, o3.firstChild);
    }, createFromDZI: function() {
      throw "OpenSeadragon.createFromDZI is deprecated, use Viewer.open.";
    }, parseXml: function(t3) {
      if (window.DOMParser)
        e4.parseXml = function(e5) {
          return new DOMParser().parseFromString(e5, "text/xml");
        };
      else {
        if (!window.ActiveXObject)
          throw new Error("Browser doesn't support XML DOM.");
        e4.parseXml = function(e5) {
          var t4 = null;
          return (t4 = new ActiveXObject("Microsoft.XMLDOM")).async = false, t4.loadXML(e5), t4;
        };
      }
      return e4.parseXml(t3);
    }, parseJSON: function(t3) {
      return e4.parseJSON = window.JSON.parse, e4.parseJSON(t3);
    }, imageFormatSupported: function(e5) {
      return !!n3[(e5 = e5 || "").toLowerCase()];
    }, setImageFormatsSupported: function(t3) {
      e4.extend(n3, t3);
    } });
    var i3 = function(e5) {
    };
    e4.console = window.console || { log: i3, debug: i3, info: i3, warn: i3, error: i3, assert: i3 }, e4.Browser = { vendor: e4.BROWSERS.UNKNOWN, version: 0, alpha: true };
    var n3 = { bmp: false, jpeg: true, jpg: true, png: true, tif: false, wdp: false }, o2 = {};
    function r2(e5, t3) {
      return t3 && e5 !== document.body ? document.body : e5.offsetParent;
    }
    !function() {
      var t3 = navigator.appVersion, i4 = navigator.userAgent;
      switch (navigator.appName) {
        case "Microsoft Internet Explorer":
          window.attachEvent && window.ActiveXObject && (e4.Browser.vendor = e4.BROWSERS.IE, e4.Browser.version = parseFloat(i4.substring(i4.indexOf("MSIE") + 5, i4.indexOf(";", i4.indexOf("MSIE")))));
          break;
        case "Netscape":
          window.addEventListener && (i4.indexOf("Edge") >= 0 ? (e4.Browser.vendor = e4.BROWSERS.EDGE, e4.Browser.version = parseFloat(i4.substring(i4.indexOf("Edge") + 5))) : i4.indexOf("Edg") >= 0 ? (e4.Browser.vendor = e4.BROWSERS.CHROMEEDGE, e4.Browser.version = parseFloat(i4.substring(i4.indexOf("Edg") + 4))) : i4.indexOf("Firefox") >= 0 ? (e4.Browser.vendor = e4.BROWSERS.FIREFOX, e4.Browser.version = parseFloat(i4.substring(i4.indexOf("Firefox") + 8))) : i4.indexOf("Safari") >= 0 ? (e4.Browser.vendor = i4.indexOf("Chrome") >= 0 ? e4.BROWSERS.CHROME : e4.BROWSERS.SAFARI, e4.Browser.version = parseFloat(i4.substring(i4.substring(0, i4.indexOf("Safari")).lastIndexOf("/") + 1, i4.indexOf("Safari")))) : null !== new RegExp("Trident/.*rv:([0-9]{1,}[.0-9]{0,})").exec(i4) && (e4.Browser.vendor = e4.BROWSERS.IE, e4.Browser.version = parseFloat(RegExp.$1)));
          break;
        case "Opera":
          e4.Browser.vendor = e4.BROWSERS.OPERA, e4.Browser.version = parseFloat(t3);
      }
      var n4, r3, s2, a2 = window.location.search.substring(1).split("&");
      for (s2 = 0; s2 < a2.length; s2++)
        if ((r3 = (n4 = a2[s2]).indexOf("=")) > 0) {
          var l2 = n4.substring(0, r3), c2 = n4.substring(r3 + 1);
          try {
            o2[l2] = decodeURIComponent(c2);
          } catch (t4) {
            e4.console.error("Ignoring malformed URL parameter: %s=%s", l2, c2);
          }
        }
      e4.Browser.alpha = !(e4.Browser.vendor === e4.BROWSERS.CHROME && e4.Browser.version < 2), e4.Browser.opacity = true, e4.Browser.vendor === e4.BROWSERS.IE && e4.Browser.version < 11 && e4.console.error("Internet Explorer versions < 11 are not supported by OpenSeadragon");
    }(), function(t3) {
      var i4 = t3.requestAnimationFrame || t3.mozRequestAnimationFrame || t3.webkitRequestAnimationFrame || t3.msRequestAnimationFrame, n4 = t3.cancelAnimationFrame || t3.mozCancelAnimationFrame || t3.webkitCancelAnimationFrame || t3.msCancelAnimationFrame;
      if (i4 && n4)
        e4.requestAnimationFrame = function() {
          return i4.apply(t3, arguments);
        }, e4.cancelAnimationFrame = function() {
          return n4.apply(t3, arguments);
        };
      else {
        var o3, r3 = [], s2 = [], a2 = 0;
        e4.requestAnimationFrame = function(t4) {
          return r3.push([++a2, t4]), o3 || (o3 = setInterval(function() {
            if (r3.length) {
              var t5 = e4.now(), i5 = s2;
              for (s2 = r3, r3 = i5; s2.length; )
                s2.shift()[1](t5);
            } else
              clearInterval(o3), o3 = void 0;
          }, 20)), a2;
        }, e4.cancelAnimationFrame = function(e5) {
          var t4, i5;
          for (t4 = 0, i5 = r3.length; t4 < i5; t4 += 1)
            if (r3[t4][0] === e5)
              return void r3.splice(t4, 1);
          for (t4 = 0, i5 = s2.length; t4 < i5; t4 += 1)
            if (s2[t4][0] === e5)
              return void s2.splice(t4, 1);
        };
      }
    }(window);
  }(t2), i2 = Yb, n2 = function() {
    return t2;
  }, e3.exports ? e3.exports = n2() : i2.OpenSeadragon = n2(), function(e4) {
    var t3 = { supportsFullScreen: false, isFullScreen: function() {
      return false;
    }, getFullScreenElement: function() {
      return null;
    }, requestFullScreen: function() {
    }, exitFullScreen: function() {
    }, cancelFullScreen: function() {
    }, fullScreenEventName: "", fullScreenErrorEventName: "" };
    document.exitFullscreen ? (t3.supportsFullScreen = true, t3.getFullScreenElement = function() {
      return document.fullscreenElement;
    }, t3.requestFullScreen = function(e5) {
      return e5.requestFullscreen();
    }, t3.exitFullScreen = function() {
      document.exitFullscreen();
    }, t3.fullScreenEventName = "fullscreenchange", t3.fullScreenErrorEventName = "fullscreenerror") : document.msExitFullscreen ? (t3.supportsFullScreen = true, t3.getFullScreenElement = function() {
      return document.msFullscreenElement;
    }, t3.requestFullScreen = function(e5) {
      return e5.msRequestFullscreen();
    }, t3.exitFullScreen = function() {
      document.msExitFullscreen();
    }, t3.fullScreenEventName = "MSFullscreenChange", t3.fullScreenErrorEventName = "MSFullscreenError") : document.webkitExitFullscreen ? (t3.supportsFullScreen = true, t3.getFullScreenElement = function() {
      return document.webkitFullscreenElement;
    }, t3.requestFullScreen = function(e5) {
      return e5.webkitRequestFullscreen();
    }, t3.exitFullScreen = function() {
      document.webkitExitFullscreen();
    }, t3.fullScreenEventName = "webkitfullscreenchange", t3.fullScreenErrorEventName = "webkitfullscreenerror") : document.webkitCancelFullScreen ? (t3.supportsFullScreen = true, t3.getFullScreenElement = function() {
      return document.webkitCurrentFullScreenElement;
    }, t3.requestFullScreen = function(e5) {
      return e5.webkitRequestFullScreen();
    }, t3.exitFullScreen = function() {
      document.webkitCancelFullScreen();
    }, t3.fullScreenEventName = "webkitfullscreenchange", t3.fullScreenErrorEventName = "webkitfullscreenerror") : document.mozCancelFullScreen && (t3.supportsFullScreen = true, t3.getFullScreenElement = function() {
      return document.mozFullScreenElement;
    }, t3.requestFullScreen = function(e5) {
      return e5.mozRequestFullScreen();
    }, t3.exitFullScreen = function() {
      document.mozCancelFullScreen();
    }, t3.fullScreenEventName = "mozfullscreenchange", t3.fullScreenErrorEventName = "mozfullscreenerror"), t3.isFullScreen = function() {
      return null !== t3.getFullScreenElement();
    }, t3.cancelFullScreen = function() {
      e4.console.error("cancelFullScreen is deprecated. Use exitFullScreen instead."), t3.exitFullScreen();
    }, e4.extend(e4, t3);
  }(t2), function(e4) {
    e4.EventSource = function() {
      this.events = {};
    }, e4.EventSource.prototype = { addOnceHandler: function(e5, t3, i3, n3, o2) {
      var r2 = this;
      n3 = n3 || 1;
      var s2 = 0, a2 = function(i4) {
        return ++s2 === n3 && r2.removeHandler(e5, a2), t3(i4);
      };
      this.addHandler(e5, a2, i3, o2);
    }, addHandler: function(t3, i3, n3, o2) {
      var r2 = this.events[t3];
      if (r2 || (this.events[t3] = r2 = []), i3 && e4.isFunction(i3)) {
        var s2 = r2.length, a2 = { handler: i3, userData: n3 || null, priority: o2 || 0 };
        for (r2[s2] = a2; s2 > 0 && r2[s2 - 1].priority < r2[s2].priority; )
          r2[s2] = r2[s2 - 1], r2[s2 - 1] = a2, s2--;
      }
    }, removeHandler: function(t3, i3) {
      var n3, o2 = this.events[t3], r2 = [];
      if (o2 && e4.isArray(o2)) {
        for (n3 = 0; n3 < o2.length; n3++)
          o2[n3].handler !== i3 && r2.push(o2[n3]);
        this.events[t3] = r2;
      }
    }, numberOfHandlers: function(e5) {
      var t3 = this.events[e5];
      return t3 ? t3.length : 0;
    }, removeAllHandlers: function(e5) {
      if (e5)
        this.events[e5] = [];
      else
        for (var t3 in this.events)
          this.events[t3] = [];
    }, getHandler: function(e5) {
      var t3 = this.events[e5];
      return t3 && t3.length ? (t3 = 1 === t3.length ? [t3[0]] : Array.apply(null, t3), function(e6, i3) {
        var n3, o2 = t3.length;
        for (n3 = 0; n3 < o2; n3++)
          t3[n3] && (i3.eventSource = e6, i3.userData = t3[n3].userData, t3[n3].handler(i3));
      }) : null;
    }, raiseEvent: function(e5, t3) {
      var i3 = this.getHandler(e5);
      if (i3)
        return i3(this, t3 || {});
    } };
  }(t2), function(e4) {
    var t3 = {};
    e4.MouseTracker = function(i4) {
      var n4 = arguments;
      e4.isPlainObject(i4) || (i4 = { element: n4[0], clickTimeThreshold: n4[1], clickDistThreshold: n4[2] }), this.hash = Math.random(), this.element = e4.getElement(i4.element), this.clickTimeThreshold = i4.clickTimeThreshold || e4.DEFAULT_SETTINGS.clickTimeThreshold, this.clickDistThreshold = i4.clickDistThreshold || e4.DEFAULT_SETTINGS.clickDistThreshold, this.dblClickTimeThreshold = i4.dblClickTimeThreshold || e4.DEFAULT_SETTINGS.dblClickTimeThreshold, this.dblClickDistThreshold = i4.dblClickDistThreshold || e4.DEFAULT_SETTINGS.dblClickDistThreshold, this.userData = i4.userData || null, this.stopDelay = i4.stopDelay || 50, this.preProcessEventHandler = i4.preProcessEventHandler || null, this.contextMenuHandler = i4.contextMenuHandler || null, this.enterHandler = i4.enterHandler || null, this.leaveHandler = i4.leaveHandler || null, this.exitHandler = i4.exitHandler || null, this.overHandler = i4.overHandler || null, this.outHandler = i4.outHandler || null, this.pressHandler = i4.pressHandler || null, this.nonPrimaryPressHandler = i4.nonPrimaryPressHandler || null, this.releaseHandler = i4.releaseHandler || null, this.nonPrimaryReleaseHandler = i4.nonPrimaryReleaseHandler || null, this.moveHandler = i4.moveHandler || null, this.scrollHandler = i4.scrollHandler || null, this.clickHandler = i4.clickHandler || null, this.dblClickHandler = i4.dblClickHandler || null, this.dragHandler = i4.dragHandler || null, this.dragEndHandler = i4.dragEndHandler || null, this.pinchHandler = i4.pinchHandler || null, this.stopHandler = i4.stopHandler || null, this.keyDownHandler = i4.keyDownHandler || null, this.keyUpHandler = i4.keyUpHandler || null, this.keyHandler = i4.keyHandler || null, this.focusHandler = i4.focusHandler || null, this.blurHandler = i4.blurHandler || null;
      var o3 = this;
      t3[this.hash] = { click: function(t4) {
        !function(t5, i5) {
          var n5 = { originalEvent: i5, eventType: "click", pointerType: "mouse", isEmulated: false };
          D2(t5, n5), n5.preventDefault && !n5.defaultPrevented && e4.cancelEvent(i5);
          n5.stopPropagation && e4.stopEvent(i5);
        }(o3, t4);
      }, dblclick: function(t4) {
        !function(t5, i5) {
          var n5 = { originalEvent: i5, eventType: "dblclick", pointerType: "mouse", isEmulated: false };
          D2(t5, n5), n5.preventDefault && !n5.defaultPrevented && e4.cancelEvent(i5);
          n5.stopPropagation && e4.stopEvent(i5);
        }(o3, t4);
      }, keydown: function(t4) {
        !function(t5, i5) {
          var n5 = null, o4 = { originalEvent: i5, eventType: "keydown", pointerType: "", isEmulated: false };
          D2(t5, o4), !t5.keyDownHandler || o4.preventGesture || o4.defaultPrevented || (n5 = { eventSource: t5, keyCode: i5.keyCode ? i5.keyCode : i5.charCode, ctrl: i5.ctrlKey, shift: i5.shiftKey, alt: i5.altKey, meta: i5.metaKey, originalEvent: i5, preventDefault: o4.preventDefault || o4.defaultPrevented, userData: t5.userData }, t5.keyDownHandler(n5));
          (n5 && n5.preventDefault || o4.preventDefault && !o4.defaultPrevented) && e4.cancelEvent(i5);
          o4.stopPropagation && e4.stopEvent(i5);
        }(o3, t4);
      }, keyup: function(t4) {
        !function(t5, i5) {
          var n5 = null, o4 = { originalEvent: i5, eventType: "keyup", pointerType: "", isEmulated: false };
          D2(t5, o4), !t5.keyUpHandler || o4.preventGesture || o4.defaultPrevented || (n5 = { eventSource: t5, keyCode: i5.keyCode ? i5.keyCode : i5.charCode, ctrl: i5.ctrlKey, shift: i5.shiftKey, alt: i5.altKey, meta: i5.metaKey, originalEvent: i5, preventDefault: o4.preventDefault || o4.defaultPrevented, userData: t5.userData }, t5.keyUpHandler(n5));
          (n5 && n5.preventDefault || o4.preventDefault && !o4.defaultPrevented) && e4.cancelEvent(i5);
          o4.stopPropagation && e4.stopEvent(i5);
        }(o3, t4);
      }, keypress: function(t4) {
        !function(t5, i5) {
          var n5 = null, o4 = { originalEvent: i5, eventType: "keypress", pointerType: "", isEmulated: false };
          D2(t5, o4), !t5.keyHandler || o4.preventGesture || o4.defaultPrevented || (n5 = { eventSource: t5, keyCode: i5.keyCode ? i5.keyCode : i5.charCode, ctrl: i5.ctrlKey, shift: i5.shiftKey, alt: i5.altKey, meta: i5.metaKey, originalEvent: i5, preventDefault: o4.preventDefault || o4.defaultPrevented, userData: t5.userData }, t5.keyHandler(n5));
          (n5 && n5.preventDefault || o4.preventDefault && !o4.defaultPrevented) && e4.cancelEvent(i5);
          o4.stopPropagation && e4.stopEvent(i5);
        }(o3, t4);
      }, focus: function(e5) {
        !function(e6, t4) {
          var i5 = { originalEvent: t4, eventType: "focus", pointerType: "", isEmulated: false };
          D2(e6, i5), e6.focusHandler && !i5.preventGesture && e6.focusHandler({ eventSource: e6, originalEvent: t4, userData: e6.userData });
        }(o3, e5);
      }, blur: function(e5) {
        !function(e6, t4) {
          var i5 = { originalEvent: t4, eventType: "blur", pointerType: "", isEmulated: false };
          D2(e6, i5), e6.blurHandler && !i5.preventGesture && e6.blurHandler({ eventSource: e6, originalEvent: t4, userData: e6.userData });
        }(o3, e5);
      }, contextmenu: function(t4) {
        !function(t5, i5) {
          var n5 = null, o4 = { originalEvent: i5, eventType: "contextmenu", pointerType: "mouse", isEmulated: false };
          D2(t5, o4), !t5.contextMenuHandler || o4.preventGesture || o4.defaultPrevented || (n5 = { eventSource: t5, position: A2(f2(i5), t5.element), originalEvent: o4.originalEvent, preventDefault: o4.preventDefault || o4.defaultPrevented, userData: t5.userData }, t5.contextMenuHandler(n5));
          (n5 && n5.preventDefault || o4.preventDefault && !o4.defaultPrevented) && e4.cancelEvent(i5);
          o4.stopPropagation && e4.stopEvent(i5);
        }(o3, t4);
      }, wheel: function(e5) {
        !function(e6, t4) {
          w2(e6, t4, t4);
        }(o3, e5);
      }, mousewheel: function(e5) {
        y2(o3, e5);
      }, DOMMouseScroll: function(e5) {
        y2(o3, e5);
      }, MozMousePixelScroll: function(e5) {
        y2(o3, e5);
      }, losecapture: function(t4) {
        !function(t5, i5) {
          var n5 = { id: e4.MouseTracker.mousePointerId, type: "mouse" }, o4 = { originalEvent: i5, eventType: "lostpointercapture", pointerType: "mouse", isEmulated: false };
          D2(t5, o4), i5.target === t5.element && L2(t5, n5, false);
          o4.stopPropagation && e4.stopEvent(i5);
        }(o3, t4);
      }, mouseenter: function(e5) {
        x2(o3, e5);
      }, mouseleave: function(e5) {
        C2(o3, e5);
      }, mouseover: function(e5) {
        S2(o3, e5);
      }, mouseout: function(e5) {
        E2(o3, e5);
      }, mousedown: function(e5) {
        I2(o3, e5);
      }, mouseup: function(e5) {
        T2(o3, e5);
      }, mousemove: function(e5) {
        M2(o3, e5);
      }, touchstart: function(t4) {
        !function(t5, i5) {
          var n5, o4, r3, s3 = i5.changedTouches.length, a3 = t5.getActivePointersListByType("touch");
          n5 = e4.now(), a3.getLength() > i5.touches.length - s3 && e4.console.warn("Tracked touch contact count doesn't match event.touches.length");
          var l3 = { originalEvent: i5, eventType: "pointerdown", pointerType: "touch", isEmulated: false };
          for (D2(t5, l3), o4 = 0; o4 < s3; o4++)
            F2(t5, l3, r3 = { id: i5.changedTouches[o4].identifier, type: "touch", isPrimary: 0 === a3.getLength(), currentPos: f2(i5.changedTouches[o4]), currentTime: n5 }), O2(t5, l3, r3, 0), L2(t5, r3, true);
          l3.preventDefault && !l3.defaultPrevented && e4.cancelEvent(i5);
          l3.stopPropagation && e4.stopEvent(i5);
        }(o3, t4);
      }, touchend: function(t4) {
        !function(t5, i5) {
          var n5, o4, r3, s3 = i5.changedTouches.length;
          n5 = e4.now();
          var a3 = { originalEvent: i5, eventType: "pointerup", pointerType: "touch", isEmulated: false };
          for (D2(t5, a3), o4 = 0; o4 < s3; o4++)
            z2(t5, a3, r3 = { id: i5.changedTouches[o4].identifier, type: "touch", currentPos: f2(i5.changedTouches[o4]), currentTime: n5 }, 0), L2(t5, r3, false), N2(t5, a3, r3);
          a3.preventDefault && !a3.defaultPrevented && e4.cancelEvent(i5);
          a3.stopPropagation && e4.stopEvent(i5);
        }(o3, t4);
      }, touchmove: function(t4) {
        !function(t5, i5) {
          var n5, o4, r3 = i5.changedTouches.length;
          n5 = e4.now();
          var s3 = { originalEvent: i5, eventType: "pointermove", pointerType: "touch", isEmulated: false };
          for (D2(t5, s3), o4 = 0; o4 < r3; o4++)
            U2(t5, s3, { id: i5.changedTouches[o4].identifier, type: "touch", currentPos: f2(i5.changedTouches[o4]), currentTime: n5 });
          s3.preventDefault && !s3.defaultPrevented && e4.cancelEvent(i5);
          s3.stopPropagation && e4.stopEvent(i5);
        }(o3, t4);
      }, touchcancel: function(t4) {
        !function(t5, i5) {
          var n5, o4 = i5.changedTouches.length, r3 = { originalEvent: i5, eventType: "pointercancel", pointerType: "touch", isEmulated: false };
          for (D2(t5, r3), n5 = 0; n5 < o4; n5++)
            H2(t5, r3, { id: i5.changedTouches[n5].identifier, type: "touch" });
          r3.stopPropagation && e4.stopEvent(i5);
        }(o3, t4);
      }, gesturestart: function(t4) {
        !function(t5, i5) {
          e4.eventIsCanceled(i5) || i5.preventDefault();
        }(0, t4);
      }, gesturechange: function(t4) {
        !function(t5, i5) {
          e4.eventIsCanceled(i5) || i5.preventDefault();
        }(0, t4);
      }, gotpointercapture: function(t4) {
        !function(t5, i5) {
          var n5 = { originalEvent: i5, eventType: "gotpointercapture", pointerType: g2(i5), isEmulated: false };
          D2(t5, n5), i5.target === t5.element && L2(t5, { id: i5.pointerId, type: g2(i5) }, true);
          n5.stopPropagation && e4.stopEvent(i5);
        }(o3, t4);
      }, lostpointercapture: function(t4) {
        !function(t5, i5) {
          var n5 = { originalEvent: i5, eventType: "lostpointercapture", pointerType: g2(i5), isEmulated: false };
          D2(t5, n5), i5.target === t5.element && L2(t5, { id: i5.pointerId, type: g2(i5) }, false);
          n5.stopPropagation && e4.stopEvent(i5);
        }(o3, t4);
      }, pointerenter: function(e5) {
        x2(o3, e5);
      }, pointerleave: function(e5) {
        C2(o3, e5);
      }, pointerover: function(e5) {
        S2(o3, e5);
      }, pointerout: function(e5) {
        E2(o3, e5);
      }, pointerdown: function(e5) {
        I2(o3, e5);
      }, pointerup: function(e5) {
        T2(o3, e5);
      }, pointermove: function(e5) {
        M2(o3, e5);
      }, pointercancel: function(t4) {
        !function(t5, i5) {
          var n5 = { id: i5.pointerId, type: g2(i5) }, o4 = { originalEvent: i5, eventType: "pointercancel", pointerType: n5.type, isEmulated: false };
          D2(t5, o4), H2(t5, o4, n5), o4.stopPropagation && e4.stopEvent(i5);
        }(o3, t4);
      }, pointerupcaptured: function(t4) {
        !function(t5, i5) {
          var n5 = t5.getActivePointersListByType(g2(i5));
          n5.getById(i5.pointerId) && B2(t5, i5);
          e4.stopEvent(i5);
        }(o3, t4);
      }, pointermovecaptured: function(t4) {
        !function(t5, i5) {
          var n5 = t5.getActivePointersListByType(g2(i5));
          n5.getById(i5.pointerId) && k2(t5, i5);
          e4.stopEvent(i5);
        }(o3, t4);
      }, tracking: false, activePointersLists: [], lastClickPos: null, dblClickTimeOut: null, pinchGPoints: [], lastPinchDist: 0, currentPinchDist: 0, lastPinchCenter: null, currentPinchCenter: null, sentDragEvent: false }, this.hasGestureHandlers = !!(this.pressHandler || this.nonPrimaryPressHandler || this.releaseHandler || this.nonPrimaryReleaseHandler || this.clickHandler || this.dblClickHandler || this.dragHandler || this.dragEndHandler || this.pinchHandler), this.hasScrollHandler = !!this.scrollHandler, e4.MouseTracker.havePointerEvents && e4.setElementPointerEvents(this.element, "auto"), this.exitHandler && e4.console.error("MouseTracker.exitHandler is deprecated. Use MouseTracker.leaveHandler instead."), i4.startDisabled || this.setTracking(true);
    }, e4.MouseTracker.prototype = { destroy: function() {
      u2(this), this.element = null, t3[this.hash] = null, delete t3[this.hash];
    }, isTracking: function() {
      return t3[this.hash].tracking;
    }, setTracking: function(i4) {
      return i4 ? function(i5) {
        var n4, o3, r3 = t3[i5.hash];
        if (!r3.tracking) {
          for (o3 = 0; o3 < e4.MouseTracker.subscribeEvents.length; o3++)
            n4 = e4.MouseTracker.subscribeEvents[o3], e4.addEvent(i5.element, n4, r3[n4], n4 === e4.MouseTracker.wheelEventName && { passive: false, capture: false });
          h2(i5), r3.tracking = true;
        }
      }(this) : u2(this), this;
    }, getActivePointersListByType: function(i4) {
      var n4, o3, r3 = t3[this.hash], s3 = r3.activePointersLists.length;
      for (n4 = 0; n4 < s3; n4++)
        if (r3.activePointersLists[n4].type === i4)
          return r3.activePointersLists[n4];
      return o3 = new e4.MouseTracker.GesturePointList(i4), r3.activePointersLists.push(o3), o3;
    }, getActivePointerCount: function() {
      var e5, i4 = t3[this.hash], n4 = i4.activePointersLists.length, o3 = 0;
      for (e5 = 0; e5 < n4; e5++)
        o3 += i4.activePointersLists[e5].getLength();
      return o3;
    }, preProcessEventHandler: function() {
    }, contextMenuHandler: function() {
    }, enterHandler: function() {
    }, leaveHandler: function() {
    }, exitHandler: function() {
    }, overHandler: function() {
    }, outHandler: function() {
    }, pressHandler: function() {
    }, nonPrimaryPressHandler: function() {
    }, releaseHandler: function() {
    }, nonPrimaryReleaseHandler: function() {
    }, moveHandler: function() {
    }, scrollHandler: function() {
    }, clickHandler: function() {
    }, dblClickHandler: function() {
    }, dragHandler: function() {
    }, dragEndHandler: function() {
    }, pinchHandler: function() {
    }, stopHandler: function() {
    }, keyDownHandler: function() {
    }, keyUpHandler: function() {
    }, keyHandler: function() {
    }, focusHandler: function() {
    }, blurHandler: function() {
    } };
    var i3, n3, o2, r2, s2, a2, l2 = function() {
      try {
        return window.self !== window.top;
      } catch (e5) {
        return true;
      }
    }();
    function c2(e5) {
      try {
        return e5.addEventListener && e5.removeEventListener;
      } catch (e6) {
        return false;
      }
    }
    function h2(e5) {
      var i4, n4, o3, r3, s3, a3 = t3[e5.hash], l3 = a3.activePointersLists.length;
      for (i4 = 0; i4 < l3; i4++)
        if ((o3 = a3.activePointersLists[i4]).getLength() > 0) {
          for (s3 = [], r3 = o3.asArray(), n4 = 0; n4 < r3.length; n4++)
            s3.push(r3[n4]);
          for (n4 = 0; n4 < s3.length; n4++)
            P2(e5, o3, s3[n4]);
        }
      for (i4 = 0; i4 < l3; i4++)
        a3.activePointersLists.pop();
      a3.sentDragEvent = false;
    }
    function u2(i4) {
      var n4, o3, r3 = t3[i4.hash];
      if (r3.tracking) {
        for (o3 = 0; o3 < e4.MouseTracker.subscribeEvents.length; o3++)
          n4 = e4.MouseTracker.subscribeEvents[o3], e4.removeEvent(i4.element, n4, r3[n4], false);
        h2(i4), r3.tracking = false;
      }
    }
    function d2(e5, i4) {
      var n4 = t3[e5.hash];
      if ("pointerevent" === i4)
        return { upName: "pointerup", upHandler: n4.pointerupcaptured, moveName: "pointermove", moveHandler: n4.pointermovecaptured };
      if ("mouse" === i4)
        return { upName: "pointerup", upHandler: n4.pointerupcaptured, moveName: "pointermove", moveHandler: n4.pointermovecaptured };
      if ("touch" === i4)
        return { upName: "touchend", upHandler: n4.touchendcaptured, moveName: "touchmove", moveHandler: n4.touchmovecaptured };
      throw new Error("MouseTracker.getCaptureEventParams: Unknown pointer type.");
    }
    function p2(t4, i4) {
      var n4, o3;
      if (e4.MouseTracker.havePointerCapture)
        if (e4.MouseTracker.havePointerEvents) {
          if (!(o3 = t4.getActivePointersListByType(i4.type).getById(i4.id)) || !o3.captured)
            return;
          try {
            t4.element.releasePointerCapture(i4.id);
          } catch (e5) {
          }
        } else
          t4.element.releaseCapture();
      else
        n4 = d2(t4, e4.MouseTracker.havePointerEvents ? "pointerevent" : i4.type), l2 && c2(window.top) && e4.removeEvent(window.top, n4.upName, n4.upHandler, true), e4.removeEvent(e4.MouseTracker.captureElement, n4.moveName, n4.moveHandler, true), e4.removeEvent(e4.MouseTracker.captureElement, n4.upName, n4.upHandler, true);
      L2(t4, i4, false);
    }
    function _2(t4) {
      return e4.MouseTracker.havePointerEvents ? t4.pointerId : e4.MouseTracker.mousePointerId;
    }
    function g2(t4) {
      return e4.MouseTracker.havePointerEvents ? t4.pointerType || (e4.Browser.vendor === e4.BROWSERS.IE ? "mouse" : "") : "mouse";
    }
    function m2(t4) {
      return !e4.MouseTracker.havePointerEvents || t4.isPrimary;
    }
    function f2(t4) {
      return e4.getMousePosition(t4);
    }
    function v2(e5, t4) {
      return A2(f2(e5), t4);
    }
    function A2(t4, i4) {
      var n4 = e4.getElementOffset(i4);
      return t4.minus(n4);
    }
    function b2(t4, i4) {
      return new e4.Point((t4.x + i4.x) / 2, (t4.y + i4.y) / 2);
    }
    function y2(t4, i4) {
      var n4 = { target: i4.target || i4.srcElement, type: "wheel", shiftKey: i4.shiftKey || false, clientX: i4.clientX, clientY: i4.clientY, pageX: i4.pageX ? i4.pageX : i4.clientX, pageY: i4.pageY ? i4.pageY : i4.clientY, deltaMode: "MozMousePixelScroll" === i4.type ? 0 : 1, deltaX: 0, deltaZ: 0 };
      "mousewheel" === e4.MouseTracker.wheelEventName ? n4.deltaY = -i4.wheelDelta / e4.DEFAULT_SETTINGS.pixelsPerWheelLine : n4.deltaY = i4.detail, w2(t4, n4, i4);
    }
    function w2(t4, i4, n4) {
      var o3, r3, s3 = null;
      o3 = i4.deltaY < 0 ? 1 : -1, D2(t4, r3 = { originalEvent: i4, eventType: "wheel", pointerType: "mouse", isEmulated: i4 !== n4 }), !t4.scrollHandler || r3.preventGesture || r3.defaultPrevented || (s3 = { eventSource: t4, pointerType: "mouse", position: v2(i4, t4.element), scroll: o3, shift: i4.shiftKey, isTouchEvent: false, originalEvent: n4, preventDefault: r3.preventDefault || r3.defaultPrevented, userData: t4.userData }, t4.scrollHandler(s3)), r3.stopPropagation && e4.stopEvent(n4), (s3 && s3.preventDefault || r3.preventDefault && !r3.defaultPrevented) && e4.cancelEvent(n4);
    }
    function x2(t4, i4) {
      var n4 = { id: _2(i4), type: g2(i4), isPrimary: m2(i4), currentPos: f2(i4), currentTime: e4.now() }, o3 = { originalEvent: i4, eventType: "pointerenter", pointerType: n4.type, isEmulated: false };
      D2(t4, o3), F2(t4, o3, n4);
    }
    function C2(t4, i4) {
      var n4 = { id: _2(i4), type: g2(i4), isPrimary: m2(i4), currentPos: f2(i4), currentTime: e4.now() }, o3 = { originalEvent: i4, eventType: "pointerleave", pointerType: n4.type, isEmulated: false };
      D2(t4, o3), N2(t4, o3, n4);
    }
    function S2(t4, i4) {
      var n4 = { id: _2(i4), type: g2(i4), isPrimary: m2(i4), currentPos: f2(i4), currentTime: e4.now() }, o3 = { originalEvent: i4, eventType: "pointerover", pointerType: n4.type, isEmulated: false };
      D2(t4, o3), function(e5, t5, i5) {
        var n5, o4;
        n5 = e5.getActivePointersListByType(i5.type), o4 = n5.getById(i5.id), o4 ? i5 = o4 : (i5.captured = false, i5.insideElementPressed = false);
        e5.overHandler && e5.overHandler({ eventSource: e5, pointerType: i5.type, position: A2(i5.currentPos, e5.element), buttons: n5.buttons, pointers: e5.getActivePointerCount(), insideElementPressed: i5.insideElementPressed, buttonDownAny: 0 !== n5.buttons, isTouchEvent: "touch" === i5.type, originalEvent: t5.originalEvent, userData: e5.userData });
      }(t4, o3, n4), o3.preventDefault && !o3.defaultPrevented && e4.cancelEvent(i4), o3.stopPropagation && e4.stopEvent(i4);
    }
    function E2(t4, i4) {
      var n4 = { id: _2(i4), type: g2(i4), isPrimary: m2(i4), currentPos: f2(i4), currentTime: e4.now() }, o3 = { originalEvent: i4, eventType: "pointerout", pointerType: n4.type, isEmulated: false };
      D2(t4, o3), function(e5, t5, i5) {
        var n5, o4;
        n5 = e5.getActivePointersListByType(i5.type), o4 = n5.getById(i5.id), o4 ? i5 = o4 : (i5.captured = false, i5.insideElementPressed = false);
        e5.outHandler && e5.outHandler({ eventSource: e5, pointerType: i5.type, position: i5.currentPos && A2(i5.currentPos, e5.element), buttons: n5.buttons, pointers: e5.getActivePointerCount(), insideElementPressed: i5.insideElementPressed, buttonDownAny: 0 !== n5.buttons, isTouchEvent: "touch" === i5.type, originalEvent: t5.originalEvent, userData: e5.userData });
      }(t4, o3, n4), o3.preventDefault && !o3.defaultPrevented && e4.cancelEvent(i4), o3.stopPropagation && e4.stopEvent(i4);
    }
    function I2(t4, i4) {
      var n4 = { id: _2(i4), type: g2(i4), isPrimary: m2(i4), currentPos: f2(i4), currentTime: e4.now() }, o3 = e4.MouseTracker.havePointerEvents && "touch" === n4.type && e4.Browser.vendor !== e4.BROWSERS.IE, r3 = { originalEvent: i4, eventType: "pointerdown", pointerType: n4.type, isEmulated: false };
      D2(t4, r3), O2(t4, r3, n4, i4.button), r3.preventDefault && !r3.defaultPrevented && e4.cancelEvent(i4), r3.stopPropagation && e4.stopEvent(i4), r3.shouldCapture && (o3 ? L2(t4, n4, true) : function(t5, i5) {
        var n5;
        if (e4.MouseTracker.havePointerCapture)
          if (e4.MouseTracker.havePointerEvents)
            try {
              t5.element.setPointerCapture(i5.id);
            } catch (t6) {
              return void e4.console.warn("setPointerCapture() called on invalid pointer ID");
            }
          else
            t5.element.setCapture(true);
        else
          n5 = d2(t5, e4.MouseTracker.havePointerEvents ? "pointerevent" : i5.type), l2 && c2(window.top) && e4.addEvent(window.top, n5.upName, n5.upHandler, true), e4.addEvent(e4.MouseTracker.captureElement, n5.upName, n5.upHandler, true), e4.addEvent(e4.MouseTracker.captureElement, n5.moveName, n5.moveHandler, true);
        L2(t5, i5, true);
      }(t4, n4));
    }
    function T2(e5, t4) {
      B2(e5, t4);
    }
    function B2(t4, i4) {
      var n4, o3 = { originalEvent: i4, eventType: "pointerup", pointerType: (n4 = { id: _2(i4), type: g2(i4), isPrimary: m2(i4), currentPos: f2(i4), currentTime: e4.now() }).type, isEmulated: false };
      D2(t4, o3), z2(t4, o3, n4, i4.button), o3.preventDefault && !o3.defaultPrevented && e4.cancelEvent(i4), o3.stopPropagation && e4.stopEvent(i4), o3.shouldReleaseCapture && (i4.target === t4.element ? p2(t4, n4) : L2(t4, n4, false));
    }
    function M2(e5, t4) {
      k2(e5, t4);
    }
    function k2(t4, i4) {
      var n4 = { id: _2(i4), type: g2(i4), isPrimary: m2(i4), currentPos: f2(i4), currentTime: e4.now() }, o3 = { originalEvent: i4, eventType: "pointermove", pointerType: n4.type, isEmulated: false };
      D2(t4, o3), U2(t4, o3, n4), o3.preventDefault && !o3.defaultPrevented && e4.cancelEvent(i4), o3.stopPropagation && e4.stopEvent(i4);
    }
    function R2(e5, t4) {
      return t4.speed = 0, t4.direction = 0, t4.contactPos = t4.currentPos, t4.contactTime = t4.currentTime, t4.lastPos = t4.currentPos, t4.lastTime = t4.currentTime, e5.add(t4);
    }
    function P2(t4, i4, n4) {
      var o3, r3 = i4.getById(n4.id);
      return r3 ? (r3.captured && (e4.console.warn("stopTrackingPointer() called on captured pointer"), p2(t4, r3)), i4.removeContact(), o3 = i4.removeById(n4.id)) : o3 = i4.getLength(), o3;
    }
    function D2(t4, i4) {
      i4.eventSource = t4, i4.eventPhase = i4.originalEvent && void 0 !== i4.originalEvent.eventPhase ? i4.originalEvent.eventPhase : 0, i4.defaultPrevented = e4.eventIsCanceled(i4.originalEvent), i4.shouldCapture = false, i4.shouldReleaseCapture = false, i4.userData = t4.userData, function(e5, t5) {
        switch (t5.eventType) {
          case "pointermove":
          case "pointerdown":
          case "pointerup":
            t5.isStoppable = true, t5.isCancelable = true, t5.preventDefault = false, t5.preventGesture = !e5.hasGestureHandlers, t5.stopPropagation = false;
            break;
          case "pointerover":
          case "pointerout":
          case "contextmenu":
          case "keydown":
          case "keyup":
          case "keypress":
            t5.isStoppable = true, t5.isCancelable = true, t5.preventDefault = false, t5.preventGesture = false, t5.stopPropagation = false;
            break;
          case "wheel":
            t5.isStoppable = true, t5.isCancelable = true, t5.preventDefault = false, t5.preventGesture = !e5.hasScrollHandler, t5.stopPropagation = false;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
            t5.isStoppable = true, t5.isCancelable = false, t5.preventDefault = false, t5.preventGesture = false, t5.stopPropagation = false;
            break;
          case "click":
            t5.isStoppable = true, t5.isCancelable = true, t5.preventDefault = !!e5.clickHandler, t5.preventGesture = false, t5.stopPropagation = false;
            break;
          case "dblclick":
            t5.isStoppable = true, t5.isCancelable = true, t5.preventDefault = !!e5.dblClickHandler, t5.preventGesture = false, t5.stopPropagation = false;
            break;
          default:
            t5.isStoppable = false, t5.isCancelable = false, t5.preventDefault = false, t5.preventGesture = false, t5.stopPropagation = false;
        }
      }(t4, i4), t4.preProcessEventHandler && t4.preProcessEventHandler(i4);
    }
    function L2(t4, i4, n4) {
      var o3 = t4.getActivePointersListByType(i4.type), r3 = o3.getById(i4.id);
      r3 ? n4 && !r3.captured ? (r3.captured = true, o3.captureCount++) : !n4 && r3.captured && (r3.captured = false, o3.captureCount--, o3.captureCount < 0 && (o3.captureCount = 0, e4.console.warn("updatePointerCaptured() - pointsList.captureCount went negative"))) : e4.console.warn("updatePointerCaptured() called on untracked pointer");
    }
    function F2(e5, t4, i4) {
      var n4, o3 = e5.getActivePointersListByType(i4.type);
      (n4 = o3.getById(i4.id)) ? (n4.insideElement = true, n4.lastPos = n4.currentPos, n4.lastTime = n4.currentTime, n4.currentPos = i4.currentPos, n4.currentTime = i4.currentTime, i4 = n4) : (i4.captured = false, i4.insideElementPressed = false, i4.insideElement = true, R2(o3, i4)), e5.enterHandler && e5.enterHandler({ eventSource: e5, pointerType: i4.type, position: A2(i4.currentPos, e5.element), buttons: o3.buttons, pointers: e5.getActivePointerCount(), insideElementPressed: i4.insideElementPressed, buttonDownAny: 0 !== o3.buttons, isTouchEvent: "touch" === i4.type, originalEvent: t4.originalEvent, userData: e5.userData });
    }
    function N2(e5, t4, i4) {
      var n4, o3, r3 = e5.getActivePointersListByType(i4.type);
      (n4 = r3.getById(i4.id)) ? (n4.captured ? (n4.insideElement = false, n4.lastPos = n4.currentPos, n4.lastTime = n4.currentTime, n4.currentPos = i4.currentPos, n4.currentTime = i4.currentTime) : P2(e5, r3, n4), i4 = n4) : (i4.captured = false, i4.insideElementPressed = false), (e5.leaveHandler || e5.exitHandler) && (o3 = { eventSource: e5, pointerType: i4.type, position: i4.currentPos && A2(i4.currentPos, e5.element), buttons: r3.buttons, pointers: e5.getActivePointerCount(), insideElementPressed: i4.insideElementPressed, buttonDownAny: 0 !== r3.buttons, isTouchEvent: "touch" === i4.type, originalEvent: t4.originalEvent, userData: e5.userData }, e5.leaveHandler && e5.leaveHandler(o3), e5.exitHandler && e5.exitHandler(o3));
    }
    function O2(i4, n4, o3, r3) {
      var s3, a3 = t3[i4.hash], l3 = i4.getActivePointersListByType(o3.type);
      if (void 0 !== n4.originalEvent.buttons ? l3.buttons = n4.originalEvent.buttons : 0 === r3 ? l3.buttons |= 1 : 1 === r3 ? l3.buttons |= 4 : 2 === r3 ? l3.buttons |= 2 : 3 === r3 ? l3.buttons |= 8 : 4 === r3 ? l3.buttons |= 16 : 5 === r3 && (l3.buttons |= 32), 0 !== r3)
        return n4.shouldCapture = false, n4.shouldReleaseCapture = false, void (!i4.nonPrimaryPressHandler || n4.preventGesture || n4.defaultPrevented || (n4.preventDefault = true, i4.nonPrimaryPressHandler({ eventSource: i4, pointerType: o3.type, position: A2(o3.currentPos, i4.element), button: r3, buttons: l3.buttons, isTouchEvent: "touch" === o3.type, originalEvent: n4.originalEvent, userData: i4.userData })));
      (s3 = l3.getById(o3.id)) ? (s3.insideElementPressed = true, s3.insideElement = true, s3.originalTarget = n4.originalEvent.target, s3.contactPos = o3.currentPos, s3.contactTime = o3.currentTime, s3.lastPos = s3.currentPos, s3.lastTime = s3.currentTime, s3.currentPos = o3.currentPos, s3.currentTime = o3.currentTime, o3 = s3) : (o3.captured = false, o3.insideElementPressed = true, o3.insideElement = true, o3.originalTarget = n4.originalEvent.target, R2(l3, o3)), l3.addContact(), n4.preventGesture || n4.defaultPrevented ? (n4.shouldCapture = false, n4.shouldReleaseCapture = false) : (n4.shouldCapture = true, n4.shouldReleaseCapture = false, n4.preventDefault = true, (i4.dragHandler || i4.dragEndHandler || i4.pinchHandler) && e4.MouseTracker.gesturePointVelocityTracker.addPoint(i4, o3), 1 === l3.contacts ? i4.pressHandler && !n4.preventGesture && i4.pressHandler({ eventSource: i4, pointerType: o3.type, position: A2(o3.contactPos, i4.element), buttons: l3.buttons, isTouchEvent: "touch" === o3.type, originalEvent: n4.originalEvent, userData: i4.userData }) : 2 === l3.contacts && i4.pinchHandler && "touch" === o3.type && (a3.pinchGPoints = l3.asArray(), a3.lastPinchDist = a3.currentPinchDist = a3.pinchGPoints[0].currentPos.distanceTo(a3.pinchGPoints[1].currentPos), a3.lastPinchCenter = a3.currentPinchCenter = b2(a3.pinchGPoints[0].currentPos, a3.pinchGPoints[1].currentPos)));
    }
    function z2(i4, n4, o3, r3) {
      var s3, a3, l3, c3, h3 = t3[i4.hash], u3 = i4.getActivePointersListByType(o3.type), d3 = false;
      if (void 0 !== n4.originalEvent.buttons ? u3.buttons = n4.originalEvent.buttons : 0 === r3 ? u3.buttons ^= -2 : 1 === r3 ? u3.buttons ^= -5 : 2 === r3 ? u3.buttons ^= -3 : 3 === r3 ? u3.buttons ^= -9 : 4 === r3 ? u3.buttons ^= -17 : 5 === r3 && (u3.buttons ^= -33), n4.shouldCapture = false, 0 !== r3)
        return n4.shouldReleaseCapture = false, void (!i4.nonPrimaryReleaseHandler || n4.preventGesture || n4.defaultPrevented || (n4.preventDefault = true, i4.nonPrimaryReleaseHandler({ eventSource: i4, pointerType: o3.type, position: A2(o3.currentPos, i4.element), button: r3, buttons: u3.buttons, isTouchEvent: "touch" === o3.type, originalEvent: n4.originalEvent, userData: i4.userData })));
      (l3 = u3.getById(o3.id)) ? (u3.removeContact(), l3.captured && (d3 = true), l3.lastPos = l3.currentPos, l3.lastTime = l3.currentTime, l3.currentPos = o3.currentPos, l3.currentTime = o3.currentTime, l3.insideElement || P2(i4, u3, l3), s3 = l3.currentPos, a3 = l3.currentTime) : (o3.captured = false, o3.insideElementPressed = false, o3.insideElement = true, R2(u3, o3), l3 = o3), n4.preventGesture || n4.defaultPrevented || (d3 ? (n4.shouldReleaseCapture = true, n4.preventDefault = true, (i4.dragHandler || i4.dragEndHandler || i4.pinchHandler) && e4.MouseTracker.gesturePointVelocityTracker.removePoint(i4, l3), 0 === u3.contacts ? (i4.releaseHandler && s3 && i4.releaseHandler({ eventSource: i4, pointerType: l3.type, position: A2(s3, i4.element), buttons: u3.buttons, insideElementPressed: l3.insideElementPressed, insideElementReleased: l3.insideElement, isTouchEvent: "touch" === l3.type, originalEvent: n4.originalEvent, userData: i4.userData }), i4.dragEndHandler && h3.sentDragEvent && i4.dragEndHandler({ eventSource: i4, pointerType: l3.type, position: A2(l3.currentPos, i4.element), speed: l3.speed, direction: l3.direction, shift: n4.originalEvent.shiftKey, isTouchEvent: "touch" === l3.type, originalEvent: n4.originalEvent, userData: i4.userData }), h3.sentDragEvent = false, (i4.clickHandler || i4.dblClickHandler) && l3.insideElement && (c3 = a3 - l3.contactTime <= i4.clickTimeThreshold && l3.contactPos.distanceTo(s3) <= i4.clickDistThreshold, i4.clickHandler && i4.clickHandler({ eventSource: i4, pointerType: l3.type, position: A2(l3.currentPos, i4.element), quick: c3, shift: n4.originalEvent.shiftKey, isTouchEvent: "touch" === l3.type, originalEvent: n4.originalEvent, originalTarget: l3.originalTarget, userData: i4.userData }), i4.dblClickHandler && c3 && (u3.clicks++, 1 === u3.clicks ? (h3.lastClickPos = s3, h3.dblClickTimeOut = setTimeout(function() {
        u3.clicks = 0;
      }, i4.dblClickTimeThreshold)) : 2 === u3.clicks && (clearTimeout(h3.dblClickTimeOut), u3.clicks = 0, h3.lastClickPos.distanceTo(s3) <= i4.dblClickDistThreshold && i4.dblClickHandler({ eventSource: i4, pointerType: l3.type, position: A2(l3.currentPos, i4.element), shift: n4.originalEvent.shiftKey, isTouchEvent: "touch" === l3.type, originalEvent: n4.originalEvent, userData: i4.userData }), h3.lastClickPos = null)))) : 2 === u3.contacts && i4.pinchHandler && "touch" === l3.type && (h3.pinchGPoints = u3.asArray(), h3.lastPinchDist = h3.currentPinchDist = h3.pinchGPoints[0].currentPos.distanceTo(h3.pinchGPoints[1].currentPos), h3.lastPinchCenter = h3.currentPinchCenter = b2(h3.pinchGPoints[0].currentPos, h3.pinchGPoints[1].currentPos))) : (n4.shouldReleaseCapture = false, i4.releaseHandler && s3 && (i4.releaseHandler({ eventSource: i4, pointerType: l3.type, position: A2(s3, i4.element), buttons: u3.buttons, insideElementPressed: l3.insideElementPressed, insideElementReleased: l3.insideElement, isTouchEvent: "touch" === l3.type, originalEvent: n4.originalEvent, userData: i4.userData }), n4.preventDefault = true)));
    }
    function U2(e5, i4, n4) {
      var o3, r3, s3, a3 = t3[e5.hash], l3 = e5.getActivePointersListByType(n4.type);
      void 0 !== i4.originalEvent.buttons && (l3.buttons = i4.originalEvent.buttons), (o3 = l3.getById(n4.id)) && (o3.lastPos = o3.currentPos, o3.lastTime = o3.currentTime, o3.currentPos = n4.currentPos, o3.currentTime = n4.currentTime, i4.shouldCapture = false, i4.shouldReleaseCapture = false, e5.stopHandler && "mouse" === n4.type && (clearTimeout(e5.stopTimeOut), e5.stopTimeOut = setTimeout(function() {
        !function(e6, t4, i5) {
          e6.stopHandler && e6.stopHandler({ eventSource: e6, pointerType: i5, position: v2(t4, e6.element), buttons: e6.getActivePointersListByType(i5).buttons, isTouchEvent: "touch" === i5, originalEvent: t4, userData: e6.userData });
        }(e5, i4.originalEvent, n4.type);
      }, e5.stopDelay)), 0 === l3.contacts ? e5.moveHandler && e5.moveHandler({ eventSource: e5, pointerType: n4.type, position: A2(n4.currentPos, e5.element), buttons: l3.buttons, isTouchEvent: "touch" === n4.type, originalEvent: i4.originalEvent, userData: e5.userData }) : 1 === l3.contacts ? (e5.moveHandler && (o3 = l3.asArray()[0], e5.moveHandler({ eventSource: e5, pointerType: o3.type, position: A2(o3.currentPos, e5.element), buttons: l3.buttons, isTouchEvent: "touch" === o3.type, originalEvent: i4.originalEvent, userData: e5.userData })), !e5.dragHandler || i4.preventGesture || i4.defaultPrevented || (s3 = (o3 = l3.asArray()[0]).currentPos.minus(o3.lastPos), e5.dragHandler({ eventSource: e5, pointerType: o3.type, position: A2(o3.currentPos, e5.element), buttons: l3.buttons, delta: s3, speed: o3.speed, direction: o3.direction, shift: i4.originalEvent.shiftKey, isTouchEvent: "touch" === o3.type, originalEvent: i4.originalEvent, userData: e5.userData }), i4.preventDefault = true, a3.sentDragEvent = true)) : 2 === l3.contacts && (e5.moveHandler && (r3 = l3.asArray(), e5.moveHandler({ eventSource: e5, pointerType: r3[0].type, position: A2(b2(r3[0].currentPos, r3[1].currentPos), e5.element), buttons: l3.buttons, isTouchEvent: "touch" === r3[0].type, originalEvent: i4.originalEvent, userData: e5.userData })), !e5.pinchHandler || "touch" !== n4.type || i4.preventGesture || i4.defaultPrevented || (s3 = a3.pinchGPoints[0].currentPos.distanceTo(a3.pinchGPoints[1].currentPos)) !== a3.currentPinchDist && (a3.lastPinchDist = a3.currentPinchDist, a3.currentPinchDist = s3, a3.lastPinchCenter = a3.currentPinchCenter, a3.currentPinchCenter = b2(a3.pinchGPoints[0].currentPos, a3.pinchGPoints[1].currentPos), e5.pinchHandler({ eventSource: e5, pointerType: "touch", gesturePoints: a3.pinchGPoints, lastCenter: A2(a3.lastPinchCenter, e5.element), center: A2(a3.currentPinchCenter, e5.element), lastDistance: a3.lastPinchDist, distance: a3.currentPinchDist, shift: i4.originalEvent.shiftKey, originalEvent: i4.originalEvent, userData: e5.userData }), i4.preventDefault = true)));
    }
    function H2(e5, t4, i4) {
      var n4, o3 = e5.getActivePointersListByType(i4.type);
      (n4 = o3.getById(i4.id)) && P2(e5, o3, n4);
    }
    e4.MouseTracker.gesturePointVelocityTracker = (i3 = [], n3 = 0, o2 = 0, r2 = function(e5, t4) {
      return e5.hash.toString() + t4.type + t4.id.toString();
    }, s2 = function() {
      var t4, n4, r3, s3, a3, l3, c3 = i3.length, h3 = e4.now();
      for (s3 = h3 - o2, o2 = h3, t4 = 0; t4 < c3; t4++)
        (r3 = (n4 = i3[t4]).gPoint).direction = Math.atan2(r3.currentPos.y - n4.lastPos.y, r3.currentPos.x - n4.lastPos.x), a3 = n4.lastPos.distanceTo(r3.currentPos), n4.lastPos = r3.currentPos, l3 = 1e3 * a3 / (s3 + 1), r3.speed = 0.75 * l3 + 0.25 * r3.speed;
    }, { addPoint: function(t4, a3) {
      var l3 = r2(t4, a3);
      i3.push({ guid: l3, gPoint: a3, lastPos: a3.currentPos }), 1 === i3.length && (o2 = e4.now(), n3 = window.setInterval(s2, 50));
    }, removePoint: function(e5, t4) {
      var o3, s3 = r2(e5, t4), a3 = i3.length;
      for (o3 = 0; o3 < a3; o3++)
        if (i3[o3].guid === s3) {
          i3.splice(o3, 1), 0 == --a3 && window.clearInterval(n3);
          break;
        }
    } }), e4.MouseTracker.captureElement = document, e4.MouseTracker.wheelEventName = e4.Browser.vendor === e4.BROWSERS.IE && e4.Browser.version > 8 || "onwheel" in document.createElement("div") ? "wheel" : void 0 !== document.onmousewheel ? "mousewheel" : "DOMMouseScroll", e4.MouseTracker.subscribeEvents = ["click", "dblclick", "keydown", "keyup", "keypress", "focus", "blur", "contextmenu", e4.MouseTracker.wheelEventName], "DOMMouseScroll" === e4.MouseTracker.wheelEventName && e4.MouseTracker.subscribeEvents.push("MozMousePixelScroll"), window.PointerEvent ? (e4.MouseTracker.havePointerEvents = true, e4.MouseTracker.subscribeEvents.push("pointerenter", "pointerleave", "pointerover", "pointerout", "pointerdown", "pointerup", "pointermove", "pointercancel"), e4.MouseTracker.havePointerCapture = (a2 = document.createElement("div"), e4.isFunction(a2.setPointerCapture) && e4.isFunction(a2.releasePointerCapture)), e4.MouseTracker.havePointerCapture && e4.MouseTracker.subscribeEvents.push("gotpointercapture", "lostpointercapture")) : (e4.MouseTracker.havePointerEvents = false, e4.MouseTracker.subscribeEvents.push("mouseenter", "mouseleave", "mouseover", "mouseout", "mousedown", "mouseup", "mousemove"), e4.MouseTracker.mousePointerId = "legacy-mouse", e4.MouseTracker.havePointerCapture = function() {
      var t4 = document.createElement("div");
      return e4.isFunction(t4.setCapture) && e4.isFunction(t4.releaseCapture);
    }(), e4.MouseTracker.havePointerCapture && e4.MouseTracker.subscribeEvents.push("losecapture"), "ontouchstart" in window && e4.MouseTracker.subscribeEvents.push("touchstart", "touchend", "touchmove", "touchcancel"), "ongesturestart" in window && e4.MouseTracker.subscribeEvents.push("gesturestart", "gesturechange")), e4.MouseTracker.GesturePointList = function(e5) {
      this._gPoints = [], this.type = e5, this.buttons = 0, this.contacts = 0, this.clicks = 0, this.captureCount = 0;
    }, e4.MouseTracker.GesturePointList.prototype = { getLength: function() {
      return this._gPoints.length;
    }, asArray: function() {
      return this._gPoints;
    }, add: function(e5) {
      return this._gPoints.push(e5);
    }, removeById: function(e5) {
      var t4, i4 = this._gPoints.length;
      for (t4 = 0; t4 < i4; t4++)
        if (this._gPoints[t4].id === e5) {
          this._gPoints.splice(t4, 1);
          break;
        }
      return this._gPoints.length;
    }, getByIndex: function(e5) {
      return e5 < this._gPoints.length ? this._gPoints[e5] : null;
    }, getById: function(e5) {
      var t4, i4 = this._gPoints.length;
      for (t4 = 0; t4 < i4; t4++)
        if (this._gPoints[t4].id === e5)
          return this._gPoints[t4];
      return null;
    }, getPrimary: function(e5) {
      var t4, i4 = this._gPoints.length;
      for (t4 = 0; t4 < i4; t4++)
        if (this._gPoints[t4].isPrimary)
          return this._gPoints[t4];
      return null;
    }, addContact: function() {
      ++this.contacts, this.contacts > 1 && ("mouse" === this.type || "pen" === this.type) && (e4.console.warn("GesturePointList.addContact() Implausible contacts value"), this.contacts = 1);
    }, removeContact: function() {
      --this.contacts, this.contacts < 0 && (this.contacts = 0);
    } };
  }(t2), function(e4) {
    e4.ControlAnchor = { NONE: 0, TOP_LEFT: 1, TOP_RIGHT: 2, BOTTOM_RIGHT: 3, BOTTOM_LEFT: 4, ABSOLUTE: 5 }, e4.Control = function(t3, i3, n3) {
      var o2 = t3.parentNode;
      "number" == typeof i3 && (e4.console.error("Passing an anchor directly into the OpenSeadragon.Control constructor is deprecated; please use an options object instead.  Support for this deprecated variant is scheduled for removal in December 2013"), i3 = { anchor: i3 }), i3.attachToViewer = void 0 === i3.attachToViewer || i3.attachToViewer, this.autoFade = void 0 === i3.autoFade || i3.autoFade, this.element = t3, this.anchor = i3.anchor, this.container = n3, this.anchor === e4.ControlAnchor.ABSOLUTE ? (this.wrapper = e4.makeNeutralElement("div"), this.wrapper.style.position = "absolute", this.wrapper.style.top = "number" == typeof i3.top ? i3.top + "px" : i3.top, this.wrapper.style.left = "number" == typeof i3.left ? i3.left + "px" : i3.left, this.wrapper.style.height = "number" == typeof i3.height ? i3.height + "px" : i3.height, this.wrapper.style.width = "number" == typeof i3.width ? i3.width + "px" : i3.width, this.wrapper.style.margin = "0px", this.wrapper.style.padding = "0px", this.element.style.position = "relative", this.element.style.top = "0px", this.element.style.left = "0px", this.element.style.height = "100%", this.element.style.width = "100%") : (this.wrapper = e4.makeNeutralElement("div"), this.wrapper.style.display = "inline-block", this.anchor === e4.ControlAnchor.NONE && (this.wrapper.style.width = this.wrapper.style.height = "100%")), this.wrapper.appendChild(this.element), i3.attachToViewer ? this.anchor === e4.ControlAnchor.TOP_RIGHT || this.anchor === e4.ControlAnchor.BOTTOM_RIGHT ? this.container.insertBefore(this.wrapper, this.container.firstChild) : this.container.appendChild(this.wrapper) : o2.appendChild(this.wrapper);
    }, e4.Control.prototype = { destroy: function() {
      this.wrapper.removeChild(this.element), this.anchor !== e4.ControlAnchor.NONE && this.container.removeChild(this.wrapper);
    }, isVisible: function() {
      return "none" !== this.wrapper.style.display;
    }, setVisible: function(t3) {
      this.wrapper.style.display = t3 ? this.anchor === e4.ControlAnchor.ABSOLUTE ? "block" : "inline-block" : "none";
    }, setOpacity: function(t3) {
      this.element[e4.SIGNAL] && e4.Browser.vendor === e4.BROWSERS.IE ? e4.setElementOpacity(this.element, t3, true) : e4.setElementOpacity(this.wrapper, t3, true);
    } };
  }(t2), function(e4) {
    function t3(e5, t4) {
      var i3, n3 = e5.controls;
      for (i3 = n3.length - 1; i3 >= 0; i3--)
        if (n3[i3].element === t4)
          return i3;
      return -1;
    }
    e4.ControlDock = function(t4) {
      var i3, n3, o2 = ["topleft", "topright", "bottomright", "bottomleft"];
      for (e4.extend(true, this, { id: "controldock-" + e4.now() + "-" + Math.floor(1e6 * Math.random()), container: e4.makeNeutralElement("div"), controls: [] }, t4), this.container.onsubmit = function() {
        return false;
      }, this.element && (this.element = e4.getElement(this.element), this.element.appendChild(this.container), this.element.style.position = "relative", this.container.style.width = "100%", this.container.style.height = "100%"), n3 = 0; n3 < o2.length; n3++)
        i3 = o2[n3], this.controls[i3] = e4.makeNeutralElement("div"), this.controls[i3].style.position = "absolute", i3.match("left") && (this.controls[i3].style.left = "0px"), i3.match("right") && (this.controls[i3].style.right = "0px"), i3.match("top") && (this.controls[i3].style.top = "0px"), i3.match("bottom") && (this.controls[i3].style.bottom = "0px");
      this.container.appendChild(this.controls.topleft), this.container.appendChild(this.controls.topright), this.container.appendChild(this.controls.bottomright), this.container.appendChild(this.controls.bottomleft);
    }, e4.ControlDock.prototype = { addControl: function(i3, n3) {
      var o2 = null;
      if (!(t3(this, i3 = e4.getElement(i3)) >= 0)) {
        switch (n3.anchor) {
          case e4.ControlAnchor.TOP_RIGHT:
            o2 = this.controls.topright, i3.style.position = "relative", i3.style.paddingRight = "0px", i3.style.paddingTop = "0px";
            break;
          case e4.ControlAnchor.BOTTOM_RIGHT:
            o2 = this.controls.bottomright, i3.style.position = "relative", i3.style.paddingRight = "0px", i3.style.paddingBottom = "0px";
            break;
          case e4.ControlAnchor.BOTTOM_LEFT:
            o2 = this.controls.bottomleft, i3.style.position = "relative", i3.style.paddingLeft = "0px", i3.style.paddingBottom = "0px";
            break;
          case e4.ControlAnchor.TOP_LEFT:
            o2 = this.controls.topleft, i3.style.position = "relative", i3.style.paddingLeft = "0px", i3.style.paddingTop = "0px";
            break;
          case e4.ControlAnchor.ABSOLUTE:
          default:
          case e4.ControlAnchor.NONE:
            o2 = this.container, i3.style.margin = "0px", i3.style.padding = "0px";
        }
        this.controls.push(new e4.Control(i3, n3, o2)), i3.style.display = "inline-block";
      }
    }, removeControl: function(i3) {
      var n3 = t3(this, i3 = e4.getElement(i3));
      return n3 >= 0 && (this.controls[n3].destroy(), this.controls.splice(n3, 1)), this;
    }, clearControls: function() {
      for (; this.controls.length > 0; )
        this.controls.pop().destroy();
      return this;
    }, areControlsEnabled: function() {
      var e5;
      for (e5 = this.controls.length - 1; e5 >= 0; e5--)
        if (this.controls[e5].isVisible())
          return true;
      return false;
    }, setControlsEnabled: function(e5) {
      var t4;
      for (t4 = this.controls.length - 1; t4 >= 0; t4--)
        this.controls[t4].setVisible(e5);
      return this;
    } };
  }(t2), function(e4) {
    e4.Placement = e4.freezeObject({ CENTER: 0, TOP_LEFT: 1, TOP: 2, TOP_RIGHT: 3, RIGHT: 4, BOTTOM_RIGHT: 5, BOTTOM: 6, BOTTOM_LEFT: 7, LEFT: 8, properties: { 0: { isLeft: false, isHorizontallyCentered: true, isRight: false, isTop: false, isVerticallyCentered: true, isBottom: false }, 1: { isLeft: true, isHorizontallyCentered: false, isRight: false, isTop: true, isVerticallyCentered: false, isBottom: false }, 2: { isLeft: false, isHorizontallyCentered: true, isRight: false, isTop: true, isVerticallyCentered: false, isBottom: false }, 3: { isLeft: false, isHorizontallyCentered: false, isRight: true, isTop: true, isVerticallyCentered: false, isBottom: false }, 4: { isLeft: false, isHorizontallyCentered: false, isRight: true, isTop: false, isVerticallyCentered: true, isBottom: false }, 5: { isLeft: false, isHorizontallyCentered: false, isRight: true, isTop: false, isVerticallyCentered: false, isBottom: true }, 6: { isLeft: false, isHorizontallyCentered: true, isRight: false, isTop: false, isVerticallyCentered: false, isBottom: true }, 7: { isLeft: true, isHorizontallyCentered: false, isRight: false, isTop: false, isVerticallyCentered: false, isBottom: true }, 8: { isLeft: true, isHorizontallyCentered: false, isRight: false, isTop: false, isVerticallyCentered: true, isBottom: false } } });
  }(t2), function(e4) {
    var t3 = {}, i3 = 1;
    function n3(t4) {
      return t4 = e4.getElement(t4), new e4.Point(0 === t4.clientWidth ? 1 : t4.clientWidth, 0 === t4.clientHeight ? 1 : t4.clientHeight);
    }
    function o2(t4, i4) {
      if (i4 instanceof e4.Overlay)
        return i4;
      var n4 = null;
      if (i4.element)
        n4 = e4.getElement(i4.element);
      else {
        var o3 = i4.id ? i4.id : "openseadragon-overlay-" + Math.floor(1e7 * Math.random());
        (n4 = e4.getElement(i4.id)) || ((n4 = document.createElement("a")).href = "#/overlay/" + o3), n4.id = o3, e4.addClass(n4, i4.className ? i4.className : "openseadragon-overlay");
      }
      var r3 = i4.location, s3 = i4.width, a3 = i4.height;
      if (!r3) {
        var l3 = i4.x, c3 = i4.y;
        if (void 0 !== i4.px) {
          var h3 = t4.viewport.imageToViewportRectangle(new e4.Rect(i4.px, i4.py, s3 || 0, a3 || 0));
          l3 = h3.x, c3 = h3.y, s3 = void 0 !== s3 ? h3.width : void 0, a3 = void 0 !== a3 ? h3.height : void 0;
        }
        r3 = new e4.Point(l3, c3);
      }
      var u3 = i4.placement;
      return u3 && "string" === e4.type(u3) && (u3 = e4.Placement[i4.placement.toUpperCase()]), new e4.Overlay({ element: n4, location: r3, placement: u3, onDraw: i4.onDraw, checkResize: i4.checkResize, width: s3, height: a3, rotationMode: i4.rotationMode });
    }
    function r2(e5, t4) {
      var i4;
      for (i4 = e5.length - 1; i4 >= 0; i4--)
        if (e5[i4].element === t4)
          return i4;
      return -1;
    }
    function s2(t4, i4) {
      return e4.requestAnimationFrame(function() {
        i4(t4);
      });
    }
    function a2(t4) {
      e4.requestAnimationFrame(function() {
        !function(t5) {
          var i4, n4;
          if (t5.controlsShouldFade) {
            for (i4 = 1 - (e4.now() - t5.controlsFadeBeginTime) / t5.controlsFadeLength, i4 = Math.min(1, i4), i4 = Math.max(0, i4), n4 = t5.controls.length - 1; n4 >= 0; n4--)
              t5.controls[n4].autoFade && t5.controls[n4].setOpacity(i4);
            i4 > 0 && a2(t5);
          }
        }(t4);
      });
    }
    function l2(t4) {
      t4.autoHideControls && (t4.controlsShouldFade = true, t4.controlsFadeBeginTime = e4.now() + t4.controlsFadeDelay, window.setTimeout(function() {
        a2(t4);
      }, t4.controlsFadeDelay));
    }
    function c2(e5) {
      var t4;
      for (e5.controlsShouldFade = false, t4 = e5.controls.length - 1; t4 >= 0; t4--)
        e5.controls[t4].setOpacity(1);
    }
    function h2() {
      c2(this);
    }
    function u2() {
      l2(this);
    }
    function d2(e5) {
      var t4 = { tracker: e5.eventSource, position: e5.position, originalEvent: e5.originalEvent, preventDefault: e5.preventDefault };
      this.raiseEvent("canvas-contextmenu", t4), e5.preventDefault = t4.preventDefault;
    }
    function p2(t4) {
      var i4 = { originalEvent: t4.originalEvent, preventDefaultAction: false, preventVerticalPan: t4.preventVerticalPan || !this.panVertical, preventHorizontalPan: t4.preventHorizontalPan || !this.panHorizontal };
      if (this.raiseEvent("canvas-key", i4), i4.preventDefaultAction || t4.ctrl || t4.alt || t4.meta)
        t4.preventDefault = false;
      else
        switch (t4.keyCode) {
          case 38:
            i4.preventVerticalPan || (t4.shift ? this.viewport.zoomBy(1.1) : this.viewport.panBy(this.viewport.deltaPointsFromPixels(new e4.Point(0, -this.pixelsPerArrowPress))), this.viewport.applyConstraints()), t4.preventDefault = true;
            break;
          case 40:
            i4.preventVerticalPan || (t4.shift ? this.viewport.zoomBy(0.9) : this.viewport.panBy(this.viewport.deltaPointsFromPixels(new e4.Point(0, this.pixelsPerArrowPress))), this.viewport.applyConstraints()), t4.preventDefault = true;
            break;
          case 37:
            i4.preventHorizontalPan || (this.viewport.panBy(this.viewport.deltaPointsFromPixels(new e4.Point(-this.pixelsPerArrowPress, 0))), this.viewport.applyConstraints()), t4.preventDefault = true;
            break;
          case 39:
            i4.preventHorizontalPan || (this.viewport.panBy(this.viewport.deltaPointsFromPixels(new e4.Point(this.pixelsPerArrowPress, 0))), this.viewport.applyConstraints()), t4.preventDefault = true;
            break;
          case 187:
            this.viewport.zoomBy(1.1), this.viewport.applyConstraints(), t4.preventDefault = true;
            break;
          case 189:
            this.viewport.zoomBy(0.9), this.viewport.applyConstraints(), t4.preventDefault = true;
            break;
          case 48:
            this.viewport.goHome(), this.viewport.applyConstraints(), t4.preventDefault = true;
            break;
          case 87:
            i4.preventVerticalPan || (t4.shift ? this.viewport.zoomBy(1.1) : this.viewport.panBy(this.viewport.deltaPointsFromPixels(new e4.Point(0, -40))), this.viewport.applyConstraints()), t4.preventDefault = true;
            break;
          case 83:
            i4.preventVerticalPan || (t4.shift ? this.viewport.zoomBy(0.9) : this.viewport.panBy(this.viewport.deltaPointsFromPixels(new e4.Point(0, 40))), this.viewport.applyConstraints()), t4.preventDefault = true;
            break;
          case 65:
            i4.preventHorizontalPan || (this.viewport.panBy(this.viewport.deltaPointsFromPixels(new e4.Point(-40, 0))), this.viewport.applyConstraints()), t4.preventDefault = true;
            break;
          case 68:
            i4.preventHorizontalPan || (this.viewport.panBy(this.viewport.deltaPointsFromPixels(new e4.Point(40, 0))), this.viewport.applyConstraints()), t4.preventDefault = true;
            break;
          case 82:
            t4.shift ? this.viewport.flipped ? this.viewport.setRotation(this.viewport.getRotation() + this.rotationIncrement) : this.viewport.setRotation(this.viewport.getRotation() - this.rotationIncrement) : this.viewport.flipped ? this.viewport.setRotation(this.viewport.getRotation() - this.rotationIncrement) : this.viewport.setRotation(this.viewport.getRotation() + this.rotationIncrement), this.viewport.applyConstraints(), t4.preventDefault = true;
            break;
          case 70:
            this.viewport.toggleFlip(), t4.preventDefault = true;
            break;
          case 74:
            this.goToPreviousPage();
            break;
          case 75:
            this.goToNextPage();
            break;
          default:
            t4.preventDefault = false;
        }
    }
    function _2(e5) {
      var t4 = { originalEvent: e5.originalEvent };
      this.raiseEvent("canvas-key-press", t4);
    }
    function g2(i4) {
      var n4;
      document.activeElement === this.canvas || this.canvas.focus(), this.viewport.flipped && (i4.position.x = this.viewport.getContainerSize().x - i4.position.x);
      var o3 = { tracker: i4.eventSource, position: i4.position, quick: i4.quick, shift: i4.shift, originalEvent: i4.originalEvent, originalTarget: i4.originalTarget, preventDefaultAction: false };
      this.raiseEvent("canvas-click", o3), !o3.preventDefaultAction && this.viewport && i4.quick && (true === (n4 = this.gestureSettingsByDeviceType(i4.pointerType)).clickToZoom && (this.viewport.zoomBy(i4.shift ? 1 / this.zoomPerClick : this.zoomPerClick, n4.zoomToRefPoint ? this.viewport.pointFromPixel(i4.position, true) : null), this.viewport.applyConstraints()), n4.dblClickDragToZoom && (true === t3[this.hash].draggingToZoom ? (t3[this.hash].lastClickTime = null, t3[this.hash].draggingToZoom = false) : t3[this.hash].lastClickTime = e4.now()));
    }
    function m2(e5) {
      var t4, i4 = { tracker: e5.eventSource, position: e5.position, shift: e5.shift, originalEvent: e5.originalEvent, preventDefaultAction: false };
      this.raiseEvent("canvas-double-click", i4), !i4.preventDefaultAction && this.viewport && (t4 = this.gestureSettingsByDeviceType(e5.pointerType)).dblClickToZoom && (this.viewport.zoomBy(e5.shift ? 1 / this.zoomPerClick : this.zoomPerClick, t4.zoomToRefPoint ? this.viewport.pointFromPixel(e5.position, true) : null), this.viewport.applyConstraints());
    }
    function f2(e5) {
      var i4, n4 = { tracker: e5.eventSource, pointerType: e5.pointerType, position: e5.position, delta: e5.delta, speed: e5.speed, direction: e5.direction, shift: e5.shift, originalEvent: e5.originalEvent, preventDefaultAction: false };
      if (this.raiseEvent("canvas-drag", n4), i4 = this.gestureSettingsByDeviceType(e5.pointerType), !n4.preventDefaultAction && this.viewport) {
        if (i4.dblClickDragToZoom && t3[this.hash].draggingToZoom) {
          var o3 = Math.pow(this.zoomPerDblClickDrag, e5.delta.y / 50);
          this.viewport.zoomBy(o3);
        } else if (i4.dragToPan && !t3[this.hash].draggingToZoom) {
          if (this.panHorizontal || (e5.delta.x = 0), this.panVertical || (e5.delta.y = 0), this.viewport.flipped && (e5.delta.x = -e5.delta.x), this.constrainDuringPan) {
            var r3 = this.viewport.deltaPointsFromPixels(e5.delta.negate());
            this.viewport.centerSpringX.target.value += r3.x, this.viewport.centerSpringY.target.value += r3.y;
            var s3 = this.viewport.getConstrainedBounds();
            this.viewport.centerSpringX.target.value -= r3.x, this.viewport.centerSpringY.target.value -= r3.y, s3.xConstrained && (e5.delta.x = 0), s3.yConstrained && (e5.delta.y = 0);
          }
          this.viewport.panBy(this.viewport.deltaPointsFromPixels(e5.delta.negate()), i4.flickEnabled && !this.constrainDuringPan);
        }
      }
    }
    function v2(i4) {
      var n4, o3 = { tracker: i4.eventSource, pointerType: i4.pointerType, position: i4.position, speed: i4.speed, direction: i4.direction, shift: i4.shift, originalEvent: i4.originalEvent, preventDefaultAction: false };
      if (this.raiseEvent("canvas-drag-end", o3), n4 = this.gestureSettingsByDeviceType(i4.pointerType), !o3.preventDefaultAction && this.viewport) {
        if (!t3[this.hash].draggingToZoom && n4.flickEnabled && i4.speed >= n4.flickMinSpeed) {
          var r3 = 0;
          this.panHorizontal && (r3 = n4.flickMomentum * i4.speed * Math.cos(i4.direction));
          var s3 = 0;
          this.panVertical && (s3 = n4.flickMomentum * i4.speed * Math.sin(i4.direction));
          var a3 = this.viewport.pixelFromPoint(this.viewport.getCenter(true)), l3 = this.viewport.pointFromPixel(new e4.Point(a3.x - r3, a3.y - s3));
          this.viewport.panTo(l3, false);
        }
        this.viewport.applyConstraints();
      }
      n4.dblClickDragToZoom && true === t3[this.hash].draggingToZoom && (t3[this.hash].draggingToZoom = false);
    }
    function A2(e5) {
      this.raiseEvent("canvas-enter", { tracker: e5.eventSource, pointerType: e5.pointerType, position: e5.position, buttons: e5.buttons, pointers: e5.pointers, insideElementPressed: e5.insideElementPressed, buttonDownAny: e5.buttonDownAny, originalEvent: e5.originalEvent });
    }
    function b2(e5) {
      this.raiseEvent("canvas-exit", { tracker: e5.eventSource, pointerType: e5.pointerType, position: e5.position, buttons: e5.buttons, pointers: e5.pointers, insideElementPressed: e5.insideElementPressed, buttonDownAny: e5.buttonDownAny, originalEvent: e5.originalEvent });
    }
    function y2(i4) {
      if (this.raiseEvent("canvas-press", { tracker: i4.eventSource, pointerType: i4.pointerType, position: i4.position, insideElementPressed: i4.insideElementPressed, insideElementReleased: i4.insideElementReleased, originalEvent: i4.originalEvent }), this.gestureSettingsByDeviceType(i4.pointerType).dblClickDragToZoom) {
        var n4 = t3[this.hash].lastClickTime, o3 = e4.now();
        if (null === n4)
          return;
        o3 - n4 < this.dblClickTimeThreshold && (t3[this.hash].draggingToZoom = true), t3[this.hash].lastClickTime = null;
      }
    }
    function w2(e5) {
      this.raiseEvent("canvas-release", { tracker: e5.eventSource, pointerType: e5.pointerType, position: e5.position, insideElementPressed: e5.insideElementPressed, insideElementReleased: e5.insideElementReleased, originalEvent: e5.originalEvent });
    }
    function x2(e5) {
      this.raiseEvent("canvas-nonprimary-press", { tracker: e5.eventSource, position: e5.position, pointerType: e5.pointerType, button: e5.button, buttons: e5.buttons, originalEvent: e5.originalEvent });
    }
    function C2(e5) {
      this.raiseEvent("canvas-nonprimary-release", { tracker: e5.eventSource, position: e5.position, pointerType: e5.pointerType, button: e5.button, buttons: e5.buttons, originalEvent: e5.originalEvent });
    }
    function S2(e5) {
      var t4, i4, n4, o3 = { tracker: e5.eventSource, pointerType: e5.pointerType, gesturePoints: e5.gesturePoints, lastCenter: e5.lastCenter, center: e5.center, lastDistance: e5.lastDistance, distance: e5.distance, shift: e5.shift, originalEvent: e5.originalEvent, preventDefaultPanAction: false, preventDefaultZoomAction: false, preventDefaultRotateAction: false };
      if (this.raiseEvent("canvas-pinch", o3), this.viewport && (!(t4 = this.gestureSettingsByDeviceType(e5.pointerType)).pinchToZoom || o3.preventDefaultPanAction && o3.preventDefaultZoomAction || (i4 = this.viewport.pointFromPixel(e5.center, true), t4.zoomToRefPoint && !o3.preventDefaultPanAction && (n4 = this.viewport.pointFromPixel(e5.lastCenter, true).minus(i4), this.panHorizontal || (n4.x = 0), this.panVertical || (n4.y = 0), this.viewport.panBy(n4, true)), o3.preventDefaultZoomAction || this.viewport.zoomBy(e5.distance / e5.lastDistance, i4, true), this.viewport.applyConstraints()), t4.pinchRotate && !o3.preventDefaultRotateAction)) {
        var r3 = Math.atan2(e5.gesturePoints[0].currentPos.y - e5.gesturePoints[1].currentPos.y, e5.gesturePoints[0].currentPos.x - e5.gesturePoints[1].currentPos.x), s3 = Math.atan2(e5.gesturePoints[0].lastPos.y - e5.gesturePoints[1].lastPos.y, e5.gesturePoints[0].lastPos.x - e5.gesturePoints[1].lastPos.x);
        i4 = this.viewport.pointFromPixel(e5.center, true), this.viewport.rotateTo(this.viewport.getRotation(true) + (r3 - s3) * (180 / Math.PI), i4, true);
      }
    }
    function E2(e5) {
      this.raiseEvent("canvas-focus", { tracker: e5.eventSource, originalEvent: e5.originalEvent });
    }
    function I2(e5) {
      this.raiseEvent("canvas-blur", { tracker: e5.eventSource, originalEvent: e5.originalEvent });
    }
    function T2(t4) {
      var i4, n4, o3, r3;
      (r3 = e4.now()) - this._lastScrollTime > this.minScrollDeltaTime ? (this._lastScrollTime = r3, i4 = { tracker: t4.eventSource, position: t4.position, scroll: t4.scroll, shift: t4.shift, originalEvent: t4.originalEvent, preventDefaultAction: false, preventDefault: true }, this.raiseEvent("canvas-scroll", i4), !i4.preventDefaultAction && this.viewport && (this.viewport.flipped && (t4.position.x = this.viewport.getContainerSize().x - t4.position.x), (n4 = this.gestureSettingsByDeviceType(t4.pointerType)).scrollToZoom && (o3 = Math.pow(this.zoomPerScroll, t4.scroll), this.viewport.zoomBy(o3, n4.zoomToRefPoint ? this.viewport.pointFromPixel(t4.position, true) : null), this.viewport.applyConstraints())), t4.preventDefault = i4.preventDefault) : t4.preventDefault = true;
    }
    function B2(e5) {
      t3[this.hash].mouseInside = true, c2(this), this.raiseEvent("container-enter", { tracker: e5.eventSource, pointerType: e5.pointerType, position: e5.position, buttons: e5.buttons, pointers: e5.pointers, insideElementPressed: e5.insideElementPressed, buttonDownAny: e5.buttonDownAny, originalEvent: e5.originalEvent });
    }
    function M2(e5) {
      e5.pointers < 1 && (t3[this.hash].mouseInside = false, t3[this.hash].animating || l2(this)), this.raiseEvent("container-exit", { tracker: e5.eventSource, pointerType: e5.pointerType, position: e5.position, buttons: e5.buttons, pointers: e5.pointers, insideElementPressed: e5.insideElementPressed, buttonDownAny: e5.buttonDownAny, originalEvent: e5.originalEvent });
    }
    function k2(i4) {
      !function(i5) {
        if (i5._opening || !t3[i5.hash])
          return;
        if (i5.autoResize || t3[i5.hash].forceResize) {
          var o3;
          if (i5._autoResizePolling) {
            o3 = n3(i5.container);
            var r3 = t3[i5.hash].prevContainerSize;
            o3.equals(r3) || (t3[i5.hash].needsResize = true);
          }
          t3[i5.hash].needsResize && function(i6, n4) {
            var o4, r4 = i6.viewport, s4 = r4.getZoom(), a4 = r4.getCenter();
            if (r4.resize(n4, i6.preserveImageSizeOnResize), r4.panTo(a4, true), i6.preserveImageSizeOnResize)
              o4 = t3[i6.hash].prevContainerSize.x / n4.x;
            else {
              var l3 = new e4.Point(0, 0), c3 = new e4.Point(t3[i6.hash].prevContainerSize.x, t3[i6.hash].prevContainerSize.y).distanceTo(l3);
              o4 = new e4.Point(n4.x, n4.y).distanceTo(l3) / c3 * t3[i6.hash].prevContainerSize.x / n4.x;
            }
            r4.zoomTo(s4 * o4, null, true), t3[i6.hash].prevContainerSize = n4, t3[i6.hash].forceRedraw = true, t3[i6.hash].needsResize = false, t3[i6.hash].forceResize = false;
          }(i5, o3 || n3(i5.container));
        }
        var s3 = i5.viewport.update(), a3 = i5.world.update() || s3;
        s3 && i5.raiseEvent("viewport-change");
        i5.referenceStrip && (a3 = i5.referenceStrip.update(i5.viewport) || a3);
        var h3 = t3[i5.hash].animating;
        !h3 && a3 && (i5.raiseEvent("animation-start"), c2(i5));
        var u3 = h3 && !a3;
        u3 && (t3[i5.hash].animating = false);
        (a3 || u3 || t3[i5.hash].forceRedraw || i5.world.needsDraw()) && (!function(e5) {
          e5.imageLoader.clear(), e5.drawer.clear(), e5.world.draw(), e5.raiseEvent("update-viewport", {});
        }(i5), i5._drawOverlays(), i5.navigator && i5.navigator.update(i5.viewport), t3[i5.hash].forceRedraw = false, a3 && i5.raiseEvent("animation"));
        u3 && (i5.raiseEvent("animation-finish"), t3[i5.hash].mouseInside || l2(i5));
        t3[i5.hash].animating = a3;
      }(i4), i4.isOpen() ? i4._updateRequestId = s2(i4, k2) : i4._updateRequestId = false;
    }
    function R2(e5, t4) {
      return e5 ? e5 + t4 : t4;
    }
    function P2() {
      t3[this.hash].lastZoomTime = e4.now(), t3[this.hash].zoomFactor = this.zoomPerSecond, t3[this.hash].zooming = true, F2(this);
    }
    function D2() {
      t3[this.hash].lastZoomTime = e4.now(), t3[this.hash].zoomFactor = 1 / this.zoomPerSecond, t3[this.hash].zooming = true, F2(this);
    }
    function L2() {
      t3[this.hash].zooming = false;
    }
    function F2(t4) {
      e4.requestAnimationFrame(e4.delegate(t4, N2));
    }
    function N2() {
      var i4, n4, o3;
      t3[this.hash].zooming && this.viewport && (n4 = (i4 = e4.now()) - t3[this.hash].lastZoomTime, o3 = Math.pow(t3[this.hash].zoomFactor, n4 / 1e3), this.viewport.zoomBy(o3), this.viewport.applyConstraints(), t3[this.hash].lastZoomTime = i4, F2(this));
    }
    function O2() {
      this.viewport && (t3[this.hash].zooming = false, this.viewport.zoomBy(this.zoomPerClick / 1), this.viewport.applyConstraints());
    }
    function z2() {
      this.viewport && (t3[this.hash].zooming = false, this.viewport.zoomBy(1 / this.zoomPerClick), this.viewport.applyConstraints());
    }
    function U2() {
      this.buttonGroup && (this.buttonGroup.emulateEnter(), this.buttonGroup.emulateLeave());
    }
    function H2() {
      this.viewport && this.viewport.goHome();
    }
    function Q2() {
      this.isFullPage() && !e4.isFullScreen() ? this.setFullPage(false) : this.setFullScreen(!this.isFullPage()), this.buttonGroup && this.buttonGroup.emulateLeave(), this.fullPageButton.element.focus(), this.viewport && this.viewport.applyConstraints();
    }
    function V2() {
      if (this.viewport) {
        var e5 = this.viewport.getRotation();
        this.viewport.flipped ? e5 += this.rotationIncrement : e5 -= this.rotationIncrement, this.viewport.setRotation(e5);
      }
    }
    function G2() {
      if (this.viewport) {
        var e5 = this.viewport.getRotation();
        this.viewport.flipped ? e5 -= this.rotationIncrement : e5 += this.rotationIncrement, this.viewport.setRotation(e5);
      }
    }
    function $2() {
      this.viewport.toggleFlip();
    }
    e4.Viewer = function(o3) {
      var r3, a3 = arguments, c3 = this;
      if (e4.isPlainObject(o3) || (o3 = { id: a3[0], xmlPath: a3.length > 1 ? a3[1] : void 0, prefixUrl: a3.length > 2 ? a3[2] : void 0, controls: a3.length > 3 ? a3[3] : void 0, overlays: a3.length > 4 ? a3[4] : void 0 }), o3.config && (e4.extend(true, o3, o3.config), delete o3.config), e4.extend(true, this, { id: o3.id, hash: o3.hash || i3++, initialPage: 0, element: null, container: null, canvas: null, overlays: [], overlaysContainer: null, previousBody: [], customControls: [], source: null, drawer: null, world: null, viewport: null, navigator: null, collectionViewport: null, collectionDrawer: null, navImages: null, buttonGroup: null, profiler: null }, e4.DEFAULT_SETTINGS, o3), void 0 === this.hash)
        throw new Error("A hash must be defined, either by specifying options.id or options.hash.");
      for (void 0 !== t3[this.hash] && e4.console.warn("Hash " + this.hash + " has already been used."), t3[this.hash] = { fsBoundsDelta: new e4.Point(1, 1), prevContainerSize: null, animating: false, forceRedraw: false, needsResize: false, forceResize: false, mouseInside: false, group: null, zooming: false, zoomFactor: null, lastZoomTime: null, fullPage: false, onfullscreenchange: null, lastClickTime: null, draggingToZoom: false }, this._sequenceIndex = 0, this._firstOpen = true, this._updateRequestId = null, this._loadQueue = [], this.currentOverlays = [], this._updatePixelDensityRatioBind = null, this._lastScrollTime = e4.now(), e4.EventSource.call(this), this.addHandler("open-failed", function(t4) {
        var i4 = e4.getString("Errors.OpenFailed", t4.eventSource, t4.message);
        c3._showMessage(i4);
      }), e4.ControlDock.call(this, o3), this.xmlPath && (this.tileSources = [this.xmlPath]), this.element = this.element || document.getElementById(this.id), this.canvas = e4.makeNeutralElement("div"), this.canvas.className = "openseadragon-canvas", function(e5) {
        e5.width = "100%", e5.height = "100%", e5.overflow = "hidden", e5.position = "absolute", e5.top = "0px", e5.left = "0px";
      }(this.canvas.style), e4.setElementTouchActionNone(this.canvas), "" !== o3.tabIndex && (this.canvas.tabIndex = void 0 === o3.tabIndex ? 0 : o3.tabIndex), this.container.className = "openseadragon-container", function(e5) {
        e5.width = "100%", e5.height = "100%", e5.position = "relative", e5.overflow = "hidden", e5.left = "0px", e5.top = "0px", e5.textAlign = "left";
      }(this.container.style), e4.setElementTouchActionNone(this.container), this.container.insertBefore(this.canvas, this.container.firstChild), this.element.appendChild(this.container), this.bodyWidth = document.body.style.width, this.bodyHeight = document.body.style.height, this.bodyOverflow = document.body.style.overflow, this.docOverflow = document.documentElement.style.overflow, this.innerTracker = new e4.MouseTracker({ userData: "Viewer.innerTracker", element: this.canvas, startDisabled: !this.mouseNavEnabled, clickTimeThreshold: this.clickTimeThreshold, clickDistThreshold: this.clickDistThreshold, dblClickTimeThreshold: this.dblClickTimeThreshold, dblClickDistThreshold: this.dblClickDistThreshold, contextMenuHandler: e4.delegate(this, d2), keyDownHandler: e4.delegate(this, p2), keyHandler: e4.delegate(this, _2), clickHandler: e4.delegate(this, g2), dblClickHandler: e4.delegate(this, m2), dragHandler: e4.delegate(this, f2), dragEndHandler: e4.delegate(this, v2), enterHandler: e4.delegate(this, A2), leaveHandler: e4.delegate(this, b2), pressHandler: e4.delegate(this, y2), releaseHandler: e4.delegate(this, w2), nonPrimaryPressHandler: e4.delegate(this, x2), nonPrimaryReleaseHandler: e4.delegate(this, C2), scrollHandler: e4.delegate(this, T2), pinchHandler: e4.delegate(this, S2), focusHandler: e4.delegate(this, E2), blurHandler: e4.delegate(this, I2) }), this.outerTracker = new e4.MouseTracker({ userData: "Viewer.outerTracker", element: this.container, startDisabled: !this.mouseNavEnabled, clickTimeThreshold: this.clickTimeThreshold, clickDistThreshold: this.clickDistThreshold, dblClickTimeThreshold: this.dblClickTimeThreshold, dblClickDistThreshold: this.dblClickDistThreshold, enterHandler: e4.delegate(this, B2), leaveHandler: e4.delegate(this, M2) }), this.toolbar && (this.toolbar = new e4.ControlDock({ element: this.toolbar })), this.bindStandardControls(), t3[this.hash].prevContainerSize = n3(this.container), window.ResizeObserver ? (this._autoResizePolling = false, this._resizeObserver = new ResizeObserver(function() {
        t3[c3.hash].needsResize = true;
      }), this._resizeObserver.observe(this.container, {})) : this._autoResizePolling = true, this.world = new e4.World({ viewer: this }), this.world.addHandler("add-item", function(e5) {
        c3.source = c3.world.getItemAt(0).source, t3[c3.hash].forceRedraw = true, c3._updateRequestId || (c3._updateRequestId = s2(c3, k2));
      }), this.world.addHandler("remove-item", function(e5) {
        c3.world.getItemCount() ? c3.source = c3.world.getItemAt(0).source : c3.source = null, t3[c3.hash].forceRedraw = true;
      }), this.world.addHandler("metrics-change", function(e5) {
        c3.viewport && c3.viewport._setContentBounds(c3.world.getHomeBounds(), c3.world.getContentFactor());
      }), this.world.addHandler("item-index-change", function(e5) {
        c3.source = c3.world.getItemAt(0).source;
      }), this.viewport = new e4.Viewport({ containerSize: t3[this.hash].prevContainerSize, springStiffness: this.springStiffness, animationTime: this.animationTime, minZoomImageRatio: this.minZoomImageRatio, maxZoomPixelRatio: this.maxZoomPixelRatio, visibilityRatio: this.visibilityRatio, wrapHorizontal: this.wrapHorizontal, wrapVertical: this.wrapVertical, defaultZoomLevel: this.defaultZoomLevel, minZoomLevel: this.minZoomLevel, maxZoomLevel: this.maxZoomLevel, viewer: this, degrees: this.degrees, flipped: this.flipped, navigatorRotate: this.navigatorRotate, homeFillsViewer: this.homeFillsViewer, margins: this.viewportMargins, silenceMultiImageWarnings: this.silenceMultiImageWarnings }), this.viewport._setContentBounds(this.world.getHomeBounds(), this.world.getContentFactor()), this.imageLoader = new e4.ImageLoader({ jobLimit: this.imageLoaderLimit, timeout: o3.timeout, tileRetryMax: this.tileRetryMax, tileRetryDelay: this.tileRetryDelay }), this.tileCache = new e4.TileCache({ maxImageCacheCount: this.maxImageCacheCount }), this.drawer = new e4.Drawer({ viewer: this, viewport: this.viewport, element: this.canvas, debugGridColor: this.debugGridColor }), this.overlaysContainer = e4.makeNeutralElement("div"), this.canvas.appendChild(this.overlaysContainer), this.drawer.canRotate() || (this.rotateLeft && (r3 = this.buttonGroup.buttons.indexOf(this.rotateLeft), this.buttonGroup.buttons.splice(r3, 1), this.buttonGroup.element.removeChild(this.rotateLeft.element)), this.rotateRight && (r3 = this.buttonGroup.buttons.indexOf(this.rotateRight), this.buttonGroup.buttons.splice(r3, 1), this.buttonGroup.element.removeChild(this.rotateRight.element))), this._addUpdatePixelDensityRatioEvent(), this.showNavigator && (this.navigator = new e4.Navigator({ element: this.navigatorElement, id: this.navigatorId, position: this.navigatorPosition, sizeRatio: this.navigatorSizeRatio, maintainSizeRatio: this.navigatorMaintainSizeRatio, top: this.navigatorTop, left: this.navigatorLeft, width: this.navigatorWidth, height: this.navigatorHeight, autoResize: this.navigatorAutoResize, autoFade: this.navigatorAutoFade, prefixUrl: this.prefixUrl, viewer: this, navigatorRotate: this.navigatorRotate, background: this.navigatorBackground, opacity: this.navigatorOpacity, borderColor: this.navigatorBorderColor, displayRegionColor: this.navigatorDisplayRegionColor, crossOriginPolicy: this.crossOriginPolicy, animationTime: this.animationTime })), this.sequenceMode && this.bindSequenceControls(), this.tileSources && this.open(this.tileSources), r3 = 0; r3 < this.customControls.length; r3++)
        this.addControl(this.customControls[r3].id, { anchor: this.customControls[r3].anchor });
      e4.requestAnimationFrame(function() {
        l2(c3);
      }), void 0 === this.imageSmoothingEnabled || this.imageSmoothingEnabled || this.drawer.setImageSmoothingEnabled(this.imageSmoothingEnabled), e4._viewers.set(this.element, this);
    }, e4.extend(e4.Viewer.prototype, e4.EventSource.prototype, e4.ControlDock.prototype, { isOpen: function() {
      return !!this.world.getItemCount();
    }, openDzi: function(t4) {
      return e4.console.error("[Viewer.openDzi] this function is deprecated; use Viewer.open() instead."), this.open(t4);
    }, openTileSource: function(t4) {
      return e4.console.error("[Viewer.openTileSource] this function is deprecated; use Viewer.open() instead."), this.open(t4);
    }, get buttons() {
      return e4.console.warn("Viewer.buttons is deprecated; Please use Viewer.buttonGroup"), this.buttonGroup;
    }, open: function(t4, i4) {
      var n4 = this;
      if (this.close(), !t4)
        return this;
      if (this.sequenceMode && e4.isArray(t4))
        return this.referenceStrip && (this.referenceStrip.destroy(), this.referenceStrip = null), void 0 === i4 || isNaN(i4) || (this.initialPage = i4), this.tileSources = t4, this._sequenceIndex = Math.max(0, Math.min(this.tileSources.length - 1, this.initialPage)), this.tileSources.length && (this.open(this.tileSources[this._sequenceIndex]), this.showReferenceStrip && this.addReferenceStrip()), this._updateSequenceButtons(this._sequenceIndex), this;
      if (e4.isArray(t4) || (t4 = [t4]), !t4.length)
        return this;
      this._opening = true;
      for (var r3, s3 = t4.length, a3 = 0, l3 = 0, c3 = function() {
        if (a3 + l3 === s3)
          if (a3) {
            !n4._firstOpen && n4.preserveViewport || (n4.viewport.goHome(true), n4.viewport.update()), n4._firstOpen = false;
            var e5 = t4[0];
            if (e5.tileSource && (e5 = e5.tileSource), n4.overlays && !n4.preserveOverlays)
              for (var i5 = 0; i5 < n4.overlays.length; i5++)
                n4.currentOverlays[i5] = o2(n4, n4.overlays[i5]);
            n4._drawOverlays(), n4._opening = false, n4.raiseEvent("open", { source: e5 });
          } else
            n4._opening = false, n4.raiseEvent("open-failed", r3);
      }, h3 = function(t5) {
        e4.isPlainObject(t5) && t5.tileSource || (t5 = { tileSource: t5 }), void 0 !== t5.index && (e4.console.error("[Viewer.open] setting indexes here is not supported; use addTiledImage instead"), delete t5.index), void 0 === t5.collectionImmediately && (t5.collectionImmediately = true);
        var i5 = t5.success;
        t5.success = function(e5) {
          if (a3++, t5.tileSource.overlays)
            for (var o4 = 0; o4 < t5.tileSource.overlays.length; o4++)
              n4.addOverlay(t5.tileSource.overlays[o4]);
          i5 && i5(e5), c3();
        };
        var o3 = t5.error;
        t5.error = function(e5) {
          l3++, r3 || (r3 = e5), o3 && o3(e5), c3();
        }, n4.addTiledImage(t5);
      }, u3 = 0; u3 < t4.length; u3++)
        h3(t4[u3]);
      return this;
    }, close: function() {
      return t3[this.hash] ? (this._opening = false, this.navigator && this.navigator.close(), this.preserveOverlays || (this.clearOverlays(), this.overlaysContainer.innerHTML = ""), t3[this.hash].animating = false, this.world.removeAll(), this.imageLoader.clear(), this.raiseEvent("close"), this) : this;
    }, destroy: function() {
      if (t3[this.hash]) {
        if (this.raiseEvent("before-destroy"), this._removeUpdatePixelDensityRatioEvent(), this.close(), this.clearOverlays(), this.overlaysContainer.innerHTML = "", this._resizeObserver && this._resizeObserver.disconnect(), this.referenceStrip && (this.referenceStrip.destroy(), this.referenceStrip = null), null !== this._updateRequestId && (e4.cancelAnimationFrame(this._updateRequestId), this._updateRequestId = null), this.drawer && this.drawer.destroy(), this.navigator && (this.navigator.destroy(), t3[this.navigator.hash] = null, delete t3[this.navigator.hash], this.navigator = null), this.buttonGroup)
          this.buttonGroup.destroy();
        else if (this.customButtons)
          for (; this.customButtons.length; )
            this.customButtons.pop().destroy();
        if (this.paging && this.paging.destroy(), this.element)
          for (; this.element.firstChild; )
            this.element.removeChild(this.element.firstChild);
        this.container.onsubmit = null, this.clearControls(), this.innerTracker && this.innerTracker.destroy(), this.outerTracker && this.outerTracker.destroy(), t3[this.hash] = null, delete t3[this.hash], this.canvas = null, this.container = null, e4._viewers.delete(this.element), this.element = null, this.raiseEvent("destroy"), this.removeAllHandlers();
      }
    }, isMouseNavEnabled: function() {
      return this.innerTracker.isTracking();
    }, setMouseNavEnabled: function(e5) {
      return this.innerTracker.setTracking(e5), this.outerTracker.setTracking(e5), this.raiseEvent("mouse-enabled", { enabled: e5 }), this;
    }, areControlsEnabled: function() {
      var e5, t4 = this.controls.length;
      for (e5 = 0; e5 < this.controls.length; e5++)
        t4 = t4 && this.controls[e5].isVisible();
      return t4;
    }, setControlsEnabled: function(e5) {
      return e5 ? c2(this) : l2(this), this.raiseEvent("controls-enabled", { enabled: e5 }), this;
    }, setDebugMode: function(e5) {
      for (var t4 = 0; t4 < this.world.getItemCount(); t4++)
        this.world.getItemAt(t4).debugMode = e5;
      this.debugMode = e5, this.forceRedraw();
    }, setAjaxHeaders: function(t4, i4) {
      if (null === t4 && (t4 = {}), e4.isPlainObject(t4)) {
        if (void 0 === i4 && (i4 = true), this.ajaxHeaders = t4, i4) {
          for (var n4 = 0; n4 < this.world.getItemCount(); n4++)
            this.world.getItemAt(n4)._updateAjaxHeaders(true);
          if (this.navigator && this.navigator.setAjaxHeaders(this.ajaxHeaders, true), this.referenceStrip && this.referenceStrip.miniViewers)
            for (var o3 in this.referenceStrip.miniViewers)
              this.referenceStrip.miniViewers[o3].setAjaxHeaders(this.ajaxHeaders, true);
        }
      } else
        console.error("[Viewer.setAjaxHeaders] Ignoring invalid headers, must be a plain object");
    }, addButton: function(e5) {
      this.buttonGroup.addButton(e5);
    }, isFullPage: function() {
      return t3[this.hash].fullPage;
    }, setFullPage: function(i4) {
      var n4, o3, r3 = document.body, s3 = r3.style, a3 = document.documentElement.style, l3 = this;
      if (i4 === this.isFullPage())
        return this;
      var c3 = { fullPage: i4, preventDefaultAction: false };
      if (this.raiseEvent("pre-full-page", c3), c3.preventDefaultAction)
        return this;
      if (i4) {
        for (this.elementSize = e4.getElementSize(this.element), this.pageScroll = e4.getPageScroll(), this.elementMargin = this.element.style.margin, this.element.style.margin = "0", this.elementPadding = this.element.style.padding, this.element.style.padding = "0", this.bodyMargin = s3.margin, this.docMargin = a3.margin, s3.margin = "0", a3.margin = "0", this.bodyPadding = s3.padding, this.docPadding = a3.padding, s3.padding = "0", a3.padding = "0", this.bodyWidth = s3.width, this.docWidth = a3.width, s3.width = "100%", a3.width = "100%", this.bodyHeight = s3.height, this.docHeight = a3.height, s3.height = "100%", a3.height = "100%", this.bodyDisplay = s3.display, s3.display = "block", this.previousBody = [], t3[this.hash].prevElementParent = this.element.parentNode, t3[this.hash].prevNextSibling = this.element.nextSibling, t3[this.hash].prevElementWidth = this.element.style.width, t3[this.hash].prevElementHeight = this.element.style.height, n4 = r3.childNodes.length, o3 = 0; o3 < n4; o3++)
          this.previousBody.push(r3.childNodes[0]), r3.removeChild(r3.childNodes[0]);
        this.toolbar && this.toolbar.element && (this.toolbar.parentNode = this.toolbar.element.parentNode, this.toolbar.nextSibling = this.toolbar.element.nextSibling, r3.appendChild(this.toolbar.element), e4.addClass(this.toolbar.element, "fullpage")), e4.addClass(this.element, "fullpage"), r3.appendChild(this.element), this.element.style.height = "100vh", this.element.style.width = "100vw", this.toolbar && this.toolbar.element && (this.element.style.height = e4.getElementSize(this.element).y - e4.getElementSize(this.toolbar.element).y + "px"), t3[this.hash].fullPage = true, e4.delegate(this, B2)({});
      } else {
        for (this.element.style.margin = this.elementMargin, this.element.style.padding = this.elementPadding, s3.margin = this.bodyMargin, a3.margin = this.docMargin, s3.padding = this.bodyPadding, a3.padding = this.docPadding, s3.width = this.bodyWidth, a3.width = this.docWidth, s3.height = this.bodyHeight, a3.height = this.docHeight, s3.display = this.bodyDisplay, r3.removeChild(this.element), n4 = this.previousBody.length, o3 = 0; o3 < n4; o3++)
          r3.appendChild(this.previousBody.shift());
        e4.removeClass(this.element, "fullpage"), t3[this.hash].prevElementParent.insertBefore(this.element, t3[this.hash].prevNextSibling), this.toolbar && this.toolbar.element && (r3.removeChild(this.toolbar.element), e4.removeClass(this.toolbar.element, "fullpage"), this.toolbar.parentNode.insertBefore(this.toolbar.element, this.toolbar.nextSibling), delete this.toolbar.parentNode, delete this.toolbar.nextSibling), this.element.style.width = t3[this.hash].prevElementWidth, this.element.style.height = t3[this.hash].prevElementHeight;
        var h3 = 0, u3 = function() {
          e4.setPageScroll(l3.pageScroll);
          var t4 = e4.getPageScroll();
          ++h3 < 10 && (t4.x !== l3.pageScroll.x || t4.y !== l3.pageScroll.y) && e4.requestAnimationFrame(u3);
        };
        e4.requestAnimationFrame(u3), t3[this.hash].fullPage = false, e4.delegate(this, M2)({});
      }
      return this.navigator && this.viewport && this.navigator.update(this.viewport), this.raiseEvent("full-page", { fullPage: i4 }), this;
    }, setFullScreen: function(t4) {
      var i4 = this;
      if (!e4.supportsFullScreen)
        return this.setFullPage(t4);
      if (e4.isFullScreen() === t4)
        return this;
      var n4 = { fullScreen: t4, preventDefaultAction: false };
      if (this.raiseEvent("pre-full-screen", n4), n4.preventDefaultAction)
        return this;
      if (t4) {
        if (this.setFullPage(true), !this.isFullPage())
          return this;
        this.fullPageStyleWidth = this.element.style.width, this.fullPageStyleHeight = this.element.style.height, this.element.style.width = "100%", this.element.style.height = "100%";
        var o3 = function() {
          var t5 = e4.isFullScreen();
          t5 || (e4.removeEvent(document, e4.fullScreenEventName, o3), e4.removeEvent(document, e4.fullScreenErrorEventName, o3), i4.setFullPage(false), i4.isFullPage() && (i4.element.style.width = i4.fullPageStyleWidth, i4.element.style.height = i4.fullPageStyleHeight)), i4.navigator && i4.viewport && setTimeout(function() {
            i4.navigator.update(i4.viewport);
          }), i4.raiseEvent("full-screen", { fullScreen: t5 });
        };
        e4.addEvent(document, e4.fullScreenEventName, o3), e4.addEvent(document, e4.fullScreenErrorEventName, o3), e4.requestFullScreen(document.body);
      } else
        e4.exitFullScreen();
      return this;
    }, isVisible: function() {
      return "hidden" !== this.container.style.visibility;
    }, isFullScreen: function() {
      return e4.isFullScreen() && this.isFullPage();
    }, setVisible: function(e5) {
      return this.container.style.visibility = e5 ? "" : "hidden", this.raiseEvent("visible", { visible: e5 }), this;
    }, addTiledImage: function(t4) {
      e4.console.assert(t4, "[Viewer.addTiledImage] options is required"), e4.console.assert(t4.tileSource, "[Viewer.addTiledImage] options.tileSource is required"), e4.console.assert(!t4.replace || t4.index > -1 && t4.index < this.world.getItemCount(), "[Viewer.addTiledImage] if options.replace is used, options.index must be a valid index in Viewer.world");
      var i4 = this;
      t4.replace && (t4.replaceItem = i4.world.getItemAt(t4.index)), this._hideMessage(), void 0 === t4.placeholderFillStyle && (t4.placeholderFillStyle = this.placeholderFillStyle), void 0 === t4.opacity && (t4.opacity = this.opacity), void 0 === t4.preload && (t4.preload = this.preload), void 0 === t4.compositeOperation && (t4.compositeOperation = this.compositeOperation), void 0 === t4.crossOriginPolicy && (t4.crossOriginPolicy = void 0 !== t4.tileSource.crossOriginPolicy ? t4.tileSource.crossOriginPolicy : this.crossOriginPolicy), void 0 === t4.ajaxWithCredentials && (t4.ajaxWithCredentials = this.ajaxWithCredentials), void 0 === t4.loadTilesWithAjax && (t4.loadTilesWithAjax = this.loadTilesWithAjax), e4.isPlainObject(t4.ajaxHeaders) || (t4.ajaxHeaders = {});
      var n4 = { options: t4 };
      function o3(e5) {
        for (var o4 = 0; o4 < i4._loadQueue.length; o4++)
          if (i4._loadQueue[o4] === n4) {
            i4._loadQueue.splice(o4, 1);
            break;
          }
        0 === i4._loadQueue.length && r3(n4), i4.raiseEvent("add-item-failed", e5), t4.error && t4.error(e5);
      }
      function r3(e5) {
        i4.collectionMode && (i4.world.arrange({ immediately: e5.options.collectionImmediately, rows: i4.collectionRows, columns: i4.collectionColumns, layout: i4.collectionLayout, tileSize: i4.collectionTileSize, tileMargin: i4.collectionTileMargin }), i4.world.setAutoRefigureSizes(true));
      }
      function s3() {
        for (var t5, n5, o4; i4._loadQueue.length && (t5 = i4._loadQueue[0]).tileSource; ) {
          if (i4._loadQueue.splice(0, 1), t5.options.replace) {
            var s4 = i4.world.getIndexOfItem(t5.options.replaceItem);
            -1 !== s4 && (t5.options.index = s4), i4.world.removeItem(t5.options.replaceItem);
          }
          n5 = new e4.TiledImage({ viewer: i4, source: t5.tileSource, viewport: i4.viewport, drawer: i4.drawer, tileCache: i4.tileCache, imageLoader: i4.imageLoader, x: t5.options.x, y: t5.options.y, width: t5.options.width, height: t5.options.height, fitBounds: t5.options.fitBounds, fitBoundsPlacement: t5.options.fitBoundsPlacement, clip: t5.options.clip, placeholderFillStyle: t5.options.placeholderFillStyle, opacity: t5.options.opacity, preload: t5.options.preload, degrees: t5.options.degrees, flipped: t5.options.flipped, compositeOperation: t5.options.compositeOperation, springStiffness: i4.springStiffness, animationTime: i4.animationTime, minZoomImageRatio: i4.minZoomImageRatio, wrapHorizontal: i4.wrapHorizontal, wrapVertical: i4.wrapVertical, immediateRender: i4.immediateRender, blendTime: i4.blendTime, alwaysBlend: i4.alwaysBlend, minPixelRatio: i4.minPixelRatio, smoothTileEdgesMinZoom: i4.smoothTileEdgesMinZoom, iOSDevice: i4.iOSDevice, crossOriginPolicy: t5.options.crossOriginPolicy, ajaxWithCredentials: t5.options.ajaxWithCredentials, loadTilesWithAjax: t5.options.loadTilesWithAjax, ajaxHeaders: t5.options.ajaxHeaders, debugMode: i4.debugMode, subPixelRoundingForTransparency: i4.subPixelRoundingForTransparency }), i4.collectionMode && i4.world.setAutoRefigureSizes(false), i4.navigator && (o4 = e4.extend({}, t5.options, { replace: false, originalTiledImage: n5, tileSource: t5.tileSource }), i4.navigator.addTiledImage(o4)), i4.world.addItem(n5, { index: t5.options.index }), 0 === i4._loadQueue.length && r3(t5), 1 !== i4.world.getItemCount() || i4.preserveViewport || i4.viewport.goHome(true), t5.options.success && t5.options.success({ item: n5 });
        }
      }
      e4.isArray(t4.tileSource) ? setTimeout(function() {
        o3({ message: "[Viewer.addTiledImage] Sequences can not be added; add them one at a time instead.", source: t4.tileSource, options: t4 });
      }) : (this._loadQueue.push(n4), function(t5, i5, n5, o4, r4) {
        var s4 = t5;
        if ("string" === e4.type(i5)) {
          if (i5.match(/^\s*<.*>\s*$/))
            i5 = e4.parseXml(i5);
          else if (i5.match(/^\s*[{[].*[}\]]\s*$/))
            try {
              var a3 = e4.parseJSON(i5);
              i5 = a3;
            } catch (e5) {
            }
        }
        function l3(e5, t6) {
          e5.ready ? o4(e5) : (e5.addHandler("ready", function() {
            o4(e5);
          }), e5.addHandler("open-failed", function(e6) {
            r4({ message: e6.message, source: t6 });
          }));
        }
        setTimeout(function() {
          if ("string" === e4.type(i5))
            i5 = new e4.TileSource({ url: i5, crossOriginPolicy: void 0 !== n5.crossOriginPolicy ? n5.crossOriginPolicy : t5.crossOriginPolicy, ajaxWithCredentials: t5.ajaxWithCredentials, ajaxHeaders: n5.ajaxHeaders ? n5.ajaxHeaders : t5.ajaxHeaders, splitHashDataForPost: t5.splitHashDataForPost, useCanvas: t5.useCanvas, success: function(e5) {
              o4(e5.tileSource);
            } }), i5.addHandler("open-failed", function(e5) {
              r4(e5);
            });
          else if (e4.isPlainObject(i5) || i5.nodeType)
            if (void 0 !== i5.crossOriginPolicy || void 0 === n5.crossOriginPolicy && void 0 === t5.crossOriginPolicy || (i5.crossOriginPolicy = void 0 !== n5.crossOriginPolicy ? n5.crossOriginPolicy : t5.crossOriginPolicy), void 0 === i5.ajaxWithCredentials && (i5.ajaxWithCredentials = t5.ajaxWithCredentials), void 0 === i5.useCanvas && (i5.useCanvas = t5.useCanvas), e4.isFunction(i5.getTileUrl)) {
              var a4 = new e4.TileSource(i5);
              a4.getTileUrl = i5.getTileUrl, o4(a4);
            } else {
              var c3 = e4.TileSource.determineType(s4, i5);
              if (!c3)
                return void r4({ message: "Unable to load TileSource", source: i5 });
              var h3 = c3.prototype.configure.apply(s4, [i5]);
              l3(new c3(h3), i5);
            }
          else
            l3(i5, i5);
        });
      }(this, t4.tileSource, t4, function(e5) {
        n4.tileSource = e5, s3();
      }, function(e5) {
        e5.options = t4, o3(e5), s3();
      }));
    }, addSimpleImage: function(t4) {
      e4.console.assert(t4, "[Viewer.addSimpleImage] options is required"), e4.console.assert(t4.url, "[Viewer.addSimpleImage] options.url is required");
      var i4 = e4.extend({}, t4, { tileSource: { type: "image", url: t4.url } });
      delete i4.url, this.addTiledImage(i4);
    }, addLayer: function(t4) {
      var i4 = this;
      e4.console.error("[Viewer.addLayer] this function is deprecated; use Viewer.addTiledImage() instead.");
      var n4 = e4.extend({}, t4, { success: function(e5) {
        i4.raiseEvent("add-layer", { options: t4, drawer: e5.item });
      }, error: function(e5) {
        i4.raiseEvent("add-layer-failed", e5);
      } });
      return this.addTiledImage(n4), this;
    }, getLayerAtLevel: function(t4) {
      return e4.console.error("[Viewer.getLayerAtLevel] this function is deprecated; use World.getItemAt() instead."), this.world.getItemAt(t4);
    }, getLevelOfLayer: function(t4) {
      return e4.console.error("[Viewer.getLevelOfLayer] this function is deprecated; use World.getIndexOfItem() instead."), this.world.getIndexOfItem(t4);
    }, getLayersCount: function() {
      return e4.console.error("[Viewer.getLayersCount] this function is deprecated; use World.getItemCount() instead."), this.world.getItemCount();
    }, setLayerLevel: function(t4, i4) {
      return e4.console.error("[Viewer.setLayerLevel] this function is deprecated; use World.setItemIndex() instead."), this.world.setItemIndex(t4, i4);
    }, removeLayer: function(t4) {
      return e4.console.error("[Viewer.removeLayer] this function is deprecated; use World.removeItem() instead."), this.world.removeItem(t4);
    }, forceRedraw: function() {
      return t3[this.hash].forceRedraw = true, this;
    }, forceResize: function() {
      t3[this.hash].needsResize = true, t3[this.hash].forceResize = true;
    }, bindSequenceControls: function() {
      var t4 = e4.delegate(this, h2), i4 = e4.delegate(this, u2), n4 = e4.delegate(this, this.goToNextPage), o3 = e4.delegate(this, this.goToPreviousPage), r3 = this.navImages, s3 = true;
      return this.showSequenceControl && ((this.previousButton || this.nextButton) && (s3 = false), this.previousButton = new e4.Button({ element: this.previousButton ? e4.getElement(this.previousButton) : null, clickTimeThreshold: this.clickTimeThreshold, clickDistThreshold: this.clickDistThreshold, tooltip: e4.getString("Tooltips.PreviousPage"), srcRest: R2(this.prefixUrl, r3.previous.REST), srcGroup: R2(this.prefixUrl, r3.previous.GROUP), srcHover: R2(this.prefixUrl, r3.previous.HOVER), srcDown: R2(this.prefixUrl, r3.previous.DOWN), onRelease: o3, onFocus: t4, onBlur: i4 }), this.nextButton = new e4.Button({ element: this.nextButton ? e4.getElement(this.nextButton) : null, clickTimeThreshold: this.clickTimeThreshold, clickDistThreshold: this.clickDistThreshold, tooltip: e4.getString("Tooltips.NextPage"), srcRest: R2(this.prefixUrl, r3.next.REST), srcGroup: R2(this.prefixUrl, r3.next.GROUP), srcHover: R2(this.prefixUrl, r3.next.HOVER), srcDown: R2(this.prefixUrl, r3.next.DOWN), onRelease: n4, onFocus: t4, onBlur: i4 }), this.navPrevNextWrap || this.previousButton.disable(), this.tileSources && this.tileSources.length || this.nextButton.disable(), s3 && (this.paging = new e4.ButtonGroup({ buttons: [this.previousButton, this.nextButton], clickTimeThreshold: this.clickTimeThreshold, clickDistThreshold: this.clickDistThreshold }), this.pagingControl = this.paging.element, this.toolbar ? this.toolbar.addControl(this.pagingControl, { anchor: e4.ControlAnchor.BOTTOM_RIGHT }) : this.addControl(this.pagingControl, { anchor: this.sequenceControlAnchor || e4.ControlAnchor.TOP_LEFT }))), this;
    }, bindStandardControls: function() {
      var t4 = e4.delegate(this, P2), i4 = e4.delegate(this, L2), n4 = e4.delegate(this, O2), o3 = e4.delegate(this, D2), r3 = e4.delegate(this, z2), s3 = e4.delegate(this, H2), a3 = e4.delegate(this, Q2), l3 = e4.delegate(this, V2), c3 = e4.delegate(this, G2), d3 = e4.delegate(this, $2), p3 = e4.delegate(this, h2), _3 = e4.delegate(this, u2), g3 = this.navImages, m3 = [], f3 = true;
      return this.showNavigationControl && ((this.zoomInButton || this.zoomOutButton || this.homeButton || this.fullPageButton || this.rotateLeftButton || this.rotateRightButton || this.flipButton) && (f3 = false), this.showZoomControl && (m3.push(this.zoomInButton = new e4.Button({ element: this.zoomInButton ? e4.getElement(this.zoomInButton) : null, clickTimeThreshold: this.clickTimeThreshold, clickDistThreshold: this.clickDistThreshold, tooltip: e4.getString("Tooltips.ZoomIn"), srcRest: R2(this.prefixUrl, g3.zoomIn.REST), srcGroup: R2(this.prefixUrl, g3.zoomIn.GROUP), srcHover: R2(this.prefixUrl, g3.zoomIn.HOVER), srcDown: R2(this.prefixUrl, g3.zoomIn.DOWN), onPress: t4, onRelease: i4, onClick: n4, onEnter: t4, onExit: i4, onFocus: p3, onBlur: _3 })), m3.push(this.zoomOutButton = new e4.Button({ element: this.zoomOutButton ? e4.getElement(this.zoomOutButton) : null, clickTimeThreshold: this.clickTimeThreshold, clickDistThreshold: this.clickDistThreshold, tooltip: e4.getString("Tooltips.ZoomOut"), srcRest: R2(this.prefixUrl, g3.zoomOut.REST), srcGroup: R2(this.prefixUrl, g3.zoomOut.GROUP), srcHover: R2(this.prefixUrl, g3.zoomOut.HOVER), srcDown: R2(this.prefixUrl, g3.zoomOut.DOWN), onPress: o3, onRelease: i4, onClick: r3, onEnter: o3, onExit: i4, onFocus: p3, onBlur: _3 }))), this.showHomeControl && m3.push(this.homeButton = new e4.Button({ element: this.homeButton ? e4.getElement(this.homeButton) : null, clickTimeThreshold: this.clickTimeThreshold, clickDistThreshold: this.clickDistThreshold, tooltip: e4.getString("Tooltips.Home"), srcRest: R2(this.prefixUrl, g3.home.REST), srcGroup: R2(this.prefixUrl, g3.home.GROUP), srcHover: R2(this.prefixUrl, g3.home.HOVER), srcDown: R2(this.prefixUrl, g3.home.DOWN), onRelease: s3, onFocus: p3, onBlur: _3 })), this.showFullPageControl && m3.push(this.fullPageButton = new e4.Button({ element: this.fullPageButton ? e4.getElement(this.fullPageButton) : null, clickTimeThreshold: this.clickTimeThreshold, clickDistThreshold: this.clickDistThreshold, tooltip: e4.getString("Tooltips.FullPage"), srcRest: R2(this.prefixUrl, g3.fullpage.REST), srcGroup: R2(this.prefixUrl, g3.fullpage.GROUP), srcHover: R2(this.prefixUrl, g3.fullpage.HOVER), srcDown: R2(this.prefixUrl, g3.fullpage.DOWN), onRelease: a3, onFocus: p3, onBlur: _3 })), this.showRotationControl && (m3.push(this.rotateLeftButton = new e4.Button({ element: this.rotateLeftButton ? e4.getElement(this.rotateLeftButton) : null, clickTimeThreshold: this.clickTimeThreshold, clickDistThreshold: this.clickDistThreshold, tooltip: e4.getString("Tooltips.RotateLeft"), srcRest: R2(this.prefixUrl, g3.rotateleft.REST), srcGroup: R2(this.prefixUrl, g3.rotateleft.GROUP), srcHover: R2(this.prefixUrl, g3.rotateleft.HOVER), srcDown: R2(this.prefixUrl, g3.rotateleft.DOWN), onRelease: l3, onFocus: p3, onBlur: _3 })), m3.push(this.rotateRightButton = new e4.Button({ element: this.rotateRightButton ? e4.getElement(this.rotateRightButton) : null, clickTimeThreshold: this.clickTimeThreshold, clickDistThreshold: this.clickDistThreshold, tooltip: e4.getString("Tooltips.RotateRight"), srcRest: R2(this.prefixUrl, g3.rotateright.REST), srcGroup: R2(this.prefixUrl, g3.rotateright.GROUP), srcHover: R2(this.prefixUrl, g3.rotateright.HOVER), srcDown: R2(this.prefixUrl, g3.rotateright.DOWN), onRelease: c3, onFocus: p3, onBlur: _3 }))), this.showFlipControl && m3.push(this.flipButton = new e4.Button({ element: this.flipButton ? e4.getElement(this.flipButton) : null, clickTimeThreshold: this.clickTimeThreshold, clickDistThreshold: this.clickDistThreshold, tooltip: e4.getString("Tooltips.Flip"), srcRest: R2(this.prefixUrl, g3.flip.REST), srcGroup: R2(this.prefixUrl, g3.flip.GROUP), srcHover: R2(this.prefixUrl, g3.flip.HOVER), srcDown: R2(this.prefixUrl, g3.flip.DOWN), onRelease: d3, onFocus: p3, onBlur: _3 })), f3 ? (this.buttonGroup = new e4.ButtonGroup({ buttons: m3, clickTimeThreshold: this.clickTimeThreshold, clickDistThreshold: this.clickDistThreshold }), this.navControl = this.buttonGroup.element, this.addHandler("open", e4.delegate(this, U2)), this.toolbar ? this.toolbar.addControl(this.navControl, { anchor: this.navigationControlAnchor || e4.ControlAnchor.TOP_LEFT }) : this.addControl(this.navControl, { anchor: this.navigationControlAnchor || e4.ControlAnchor.TOP_LEFT })) : this.customButtons = m3), this;
    }, currentPage: function() {
      return this._sequenceIndex;
    }, goToPage: function(e5) {
      return this.tileSources && e5 >= 0 && e5 < this.tileSources.length && (this._sequenceIndex = e5, this._updateSequenceButtons(e5), this.open(this.tileSources[e5]), this.referenceStrip && this.referenceStrip.setFocus(e5), this.raiseEvent("page", { page: e5 })), this;
    }, addOverlay: function(t4, i4, n4, s3) {
      var a3;
      if (a3 = e4.isPlainObject(t4) ? t4 : { element: t4, location: i4, placement: n4, onDraw: s3 }, t4 = e4.getElement(a3.element), r2(this.currentOverlays, t4) >= 0)
        return this;
      var l3 = o2(this, a3);
      return this.currentOverlays.push(l3), l3.drawHTML(this.overlaysContainer, this.viewport), this.raiseEvent("add-overlay", { element: t4, location: a3.location, placement: a3.placement }), this;
    }, updateOverlay: function(i4, n4, o3) {
      var s3;
      return i4 = e4.getElement(i4), (s3 = r2(this.currentOverlays, i4)) >= 0 && (this.currentOverlays[s3].update(n4, o3), t3[this.hash].forceRedraw = true, this.raiseEvent("update-overlay", { element: i4, location: n4, placement: o3 })), this;
    }, removeOverlay: function(i4) {
      var n4;
      return i4 = e4.getElement(i4), (n4 = r2(this.currentOverlays, i4)) >= 0 && (this.currentOverlays[n4].destroy(), this.currentOverlays.splice(n4, 1), t3[this.hash].forceRedraw = true, this.raiseEvent("remove-overlay", { element: i4 })), this;
    }, clearOverlays: function() {
      for (; this.currentOverlays.length > 0; )
        this.currentOverlays.pop().destroy();
      return t3[this.hash].forceRedraw = true, this.raiseEvent("clear-overlay", {}), this;
    }, getOverlayById: function(t4) {
      var i4;
      return t4 = e4.getElement(t4), (i4 = r2(this.currentOverlays, t4)) >= 0 ? this.currentOverlays[i4] : null;
    }, _updateSequenceButtons: function(e5) {
      this.nextButton && (this.tileSources && this.tileSources.length - 1 !== e5 ? this.nextButton.enable() : this.navPrevNextWrap || this.nextButton.disable()), this.previousButton && (e5 > 0 ? this.previousButton.enable() : this.navPrevNextWrap || this.previousButton.disable());
    }, _showMessage: function(t4) {
      this._hideMessage();
      var i4 = e4.makeNeutralElement("div");
      i4.appendChild(document.createTextNode(t4)), this.messageDiv = e4.makeCenteredNode(i4), e4.addClass(this.messageDiv, "openseadragon-message"), this.container.appendChild(this.messageDiv);
    }, _hideMessage: function() {
      var e5 = this.messageDiv;
      e5 && (e5.parentNode.removeChild(e5), delete this.messageDiv);
    }, gestureSettingsByDeviceType: function(e5) {
      switch (e5) {
        case "mouse":
          return this.gestureSettingsMouse;
        case "touch":
          return this.gestureSettingsTouch;
        case "pen":
          return this.gestureSettingsPen;
        default:
          return this.gestureSettingsUnknown;
      }
    }, _drawOverlays: function() {
      var e5, t4 = this.currentOverlays.length;
      for (e5 = 0; e5 < t4; e5++)
        this.currentOverlays[e5].drawHTML(this.overlaysContainer, this.viewport);
    }, _cancelPendingImages: function() {
      this._loadQueue = [];
    }, removeReferenceStrip: function() {
      this.showReferenceStrip = false, this.referenceStrip && (this.referenceStrip.destroy(), this.referenceStrip = null);
    }, addReferenceStrip: function() {
      if (this.showReferenceStrip = true, this.sequenceMode) {
        if (this.referenceStrip)
          return;
        this.tileSources.length && this.tileSources.length > 1 && (this.referenceStrip = new e4.ReferenceStrip({ id: this.referenceStripElement, position: this.referenceStripPosition, sizeRatio: this.referenceStripSizeRatio, scroll: this.referenceStripScroll, height: this.referenceStripHeight, width: this.referenceStripWidth, tileSources: this.tileSources, prefixUrl: this.prefixUrl, useCanvas: this.useCanvas, viewer: this }), this.referenceStrip.setFocus(this._sequenceIndex));
      } else
        e4.console.warn('Attempting to display a reference strip while "sequenceMode" is off.');
    }, _addUpdatePixelDensityRatioEvent: function() {
      this._updatePixelDensityRatioBind = this._updatePixelDensityRatio.bind(this), e4.addEvent(window, "resize", this._updatePixelDensityRatioBind);
    }, _removeUpdatePixelDensityRatioEvent: function() {
      e4.removeEvent(window, "resize", this._updatePixelDensityRatioBind);
    }, _updatePixelDensityRatio: function() {
      var t4 = e4.pixelDensityRatio, i4 = e4.getCurrentPixelDensityRatio();
      t4 !== i4 && (e4.pixelDensityRatio = i4, this.world.resetItems(), this.forceRedraw());
    }, goToPreviousPage: function() {
      var e5 = this._sequenceIndex - 1;
      this.navPrevNextWrap && e5 < 0 && (e5 += this.tileSources.length), this.goToPage(e5);
    }, goToNextPage: function() {
      var e5 = this._sequenceIndex + 1;
      this.navPrevNextWrap && e5 >= this.tileSources.length && (e5 = 0), this.goToPage(e5);
    }, isAnimating: function() {
      return t3[this.hash].animating;
    } });
  }(t2), function(e4) {
    function t3(e5) {
      var t4 = { tracker: e5.eventSource, position: e5.position, quick: e5.quick, shift: e5.shift, originalEvent: e5.originalEvent, preventDefaultAction: false };
      if (this.viewer.raiseEvent("navigator-click", t4), !t4.preventDefaultAction && e5.quick && this.viewer.viewport && (this.panVertical || this.panHorizontal)) {
        this.viewer.viewport.flipped && (e5.position.x = this.viewport.getContainerSize().x - e5.position.x);
        var i4 = this.viewport.pointFromPixel(e5.position);
        this.panVertical ? this.panHorizontal || (i4.x = this.viewer.viewport.getCenter(true).x) : i4.y = this.viewer.viewport.getCenter(true).y, this.viewer.viewport.panTo(i4), this.viewer.viewport.applyConstraints();
      }
    }
    function i3(e5) {
      var t4 = { tracker: e5.eventSource, position: e5.position, delta: e5.delta, speed: e5.speed, direction: e5.direction, shift: e5.shift, originalEvent: e5.originalEvent, preventDefaultAction: false };
      this.viewer.raiseEvent("navigator-drag", t4), !t4.preventDefaultAction && this.viewer.viewport && (this.panHorizontal || (e5.delta.x = 0), this.panVertical || (e5.delta.y = 0), this.viewer.viewport.flipped && (e5.delta.x = -e5.delta.x), this.viewer.viewport.panBy(this.viewport.deltaPointsFromPixels(e5.delta)), this.viewer.constrainDuringPan && this.viewer.viewport.applyConstraints());
    }
    function n3(e5) {
      e5.insideElementPressed && this.viewer.viewport && this.viewer.viewport.applyConstraints();
    }
    function o2(e5) {
      var t4 = { tracker: e5.eventSource, position: e5.position, scroll: e5.scroll, shift: e5.shift, originalEvent: e5.originalEvent, preventDefault: e5.preventDefault };
      this.viewer.raiseEvent("navigator-scroll", t4), e5.preventDefault = t4.preventDefault;
    }
    function r2(e5, t4) {
      s2(e5, "rotate(" + t4 + "deg)");
    }
    function s2(e5, t4) {
      e5.style.webkitTransform = t4, e5.style.mozTransform = t4, e5.style.msTransform = t4, e5.style.oTransform = t4, e5.style.transform = t4;
    }
    e4.Navigator = function(s3) {
      var a2, l2, c2 = s3.viewer, h2 = this;
      function u2(e5, t4) {
        r2(h2.displayRegionContainer, e5), r2(h2.displayRegion, -e5), h2.viewport.setRotation(e5, t4);
      }
      (s3.element || s3.id ? (s3.element ? (s3.id && e4.console.warn("Given option.id for Navigator was ignored since option.element was provided and is being used instead."), s3.element.id ? s3.id = s3.element.id : s3.id = "navigator-" + e4.now(), this.element = s3.element) : this.element = document.getElementById(s3.id), s3.controlOptions = { anchor: e4.ControlAnchor.NONE, attachToViewer: false, autoFade: false }) : (s3.id = "navigator-" + e4.now(), this.element = e4.makeNeutralElement("div"), s3.controlOptions = { anchor: e4.ControlAnchor.TOP_RIGHT, attachToViewer: true, autoFade: s3.autoFade }, s3.position && ("BOTTOM_RIGHT" === s3.position ? s3.controlOptions.anchor = e4.ControlAnchor.BOTTOM_RIGHT : "BOTTOM_LEFT" === s3.position ? s3.controlOptions.anchor = e4.ControlAnchor.BOTTOM_LEFT : "TOP_RIGHT" === s3.position ? s3.controlOptions.anchor = e4.ControlAnchor.TOP_RIGHT : "TOP_LEFT" === s3.position ? s3.controlOptions.anchor = e4.ControlAnchor.TOP_LEFT : "ABSOLUTE" === s3.position && (s3.controlOptions.anchor = e4.ControlAnchor.ABSOLUTE, s3.controlOptions.top = s3.top, s3.controlOptions.left = s3.left, s3.controlOptions.height = s3.height, s3.controlOptions.width = s3.width))), this.element.id = s3.id, this.element.className += " navigator", (s3 = e4.extend(true, { sizeRatio: e4.DEFAULT_SETTINGS.navigatorSizeRatio }, s3, { element: this.element, tabIndex: -1, showNavigator: false, mouseNavEnabled: false, showNavigationControl: false, showSequenceControl: false, immediateRender: true, blendTime: 0, animationTime: s3.animationTime, autoResize: false, minZoomImageRatio: 1, background: s3.background, opacity: s3.opacity, borderColor: s3.borderColor, displayRegionColor: s3.displayRegionColor })).minPixelRatio = this.minPixelRatio = c2.minPixelRatio, e4.setElementTouchActionNone(this.element), this.borderWidth = 2, this.fudge = new e4.Point(1, 1), this.totalBorderWidths = new e4.Point(2 * this.borderWidth, 2 * this.borderWidth).minus(this.fudge), s3.controlOptions.anchor !== e4.ControlAnchor.NONE && function(e5, t4) {
        e5.margin = "0px", e5.border = t4 + "px solid " + s3.borderColor, e5.padding = "0px", e5.background = s3.background, e5.opacity = s3.opacity, e5.overflow = "hidden";
      }(this.element.style, this.borderWidth), this.displayRegion = e4.makeNeutralElement("div"), this.displayRegion.id = this.element.id + "-displayregion", this.displayRegion.className = "displayregion", function(e5, t4) {
        e5.position = "relative", e5.top = "0px", e5.left = "0px", e5.fontSize = "0px", e5.overflow = "hidden", e5.border = t4 + "px solid " + s3.displayRegionColor, e5.margin = "0px", e5.padding = "0px", e5.background = "transparent", e5.float = "left", e5.cssFloat = "left", e5.styleFloat = "left", e5.zIndex = 999999999, e5.cursor = "default", e5.boxSizing = "content-box";
      }(this.displayRegion.style, this.borderWidth), e4.setElementPointerEventsNone(this.displayRegion), e4.setElementTouchActionNone(this.displayRegion), this.displayRegionContainer = e4.makeNeutralElement("div"), this.displayRegionContainer.id = this.element.id + "-displayregioncontainer", this.displayRegionContainer.className = "displayregioncontainer", this.displayRegionContainer.style.width = "100%", this.displayRegionContainer.style.height = "100%", e4.setElementPointerEventsNone(this.displayRegionContainer), e4.setElementTouchActionNone(this.displayRegionContainer), c2.addControl(this.element, s3.controlOptions), this._resizeWithViewer = s3.controlOptions.anchor !== e4.ControlAnchor.ABSOLUTE && s3.controlOptions.anchor !== e4.ControlAnchor.NONE, s3.width && s3.height ? (this.setWidth(s3.width), this.setHeight(s3.height)) : this._resizeWithViewer && (a2 = e4.getElementSize(c2.element), this.element.style.height = Math.round(a2.y * s3.sizeRatio) + "px", this.element.style.width = Math.round(a2.x * s3.sizeRatio) + "px", this.oldViewerSize = a2, l2 = e4.getElementSize(this.element), this.elementArea = l2.x * l2.y), this.oldContainerSize = new e4.Point(0, 0), e4.Viewer.apply(this, [s3]), this.displayRegionContainer.appendChild(this.displayRegion), this.element.getElementsByTagName("div")[0].appendChild(this.displayRegionContainer), s3.navigatorRotate) && (u2(s3.viewer.viewport ? s3.viewer.viewport.getRotation() : s3.viewer.degrees || 0, true), s3.viewer.addHandler("rotate", function(e5) {
        u2(e5.degrees, e5.immediately);
      }));
      this.innerTracker.destroy(), this.innerTracker = new e4.MouseTracker({ userData: "Navigator.innerTracker", element: this.element, dragHandler: e4.delegate(this, i3), clickHandler: e4.delegate(this, t3), releaseHandler: e4.delegate(this, n3), scrollHandler: e4.delegate(this, o2), preProcessEventHandler: function(e5) {
        "wheel" === e5.eventType && (e5.preventDefault = true);
      } }), this.outerTracker.userData = "Navigator.outerTracker", e4.setElementPointerEventsNone(this.canvas), e4.setElementPointerEventsNone(this.container), this.addHandler("reset-size", function() {
        h2.viewport && h2.viewport.goHome(true);
      }), c2.world.addHandler("item-index-change", function(e5) {
        window.setTimeout(function() {
          var t4 = h2.world.getItemAt(e5.previousIndex);
          h2.world.setItemIndex(t4, e5.newIndex);
        }, 1);
      }), c2.world.addHandler("remove-item", function(e5) {
        var t4 = e5.item, i4 = h2._getMatchingItem(t4);
        i4 && h2.world.removeItem(i4);
      }), this.update(c2.viewport);
    }, e4.extend(e4.Navigator.prototype, e4.EventSource.prototype, e4.Viewer.prototype, { updateSize: function() {
      if (this.viewport) {
        var t4 = new e4.Point(0 === this.container.clientWidth ? 1 : this.container.clientWidth, 0 === this.container.clientHeight ? 1 : this.container.clientHeight);
        t4.equals(this.oldContainerSize) || (this.viewport.resize(t4, true), this.viewport.goHome(true), this.oldContainerSize = t4, this.drawer.clear(), this.world.draw());
      }
    }, setWidth: function(e5) {
      this.width = e5, this.element.style.width = "number" == typeof e5 ? e5 + "px" : e5, this._resizeWithViewer = false, this.updateSize();
    }, setHeight: function(e5) {
      this.height = e5, this.element.style.height = "number" == typeof e5 ? e5 + "px" : e5, this._resizeWithViewer = false, this.updateSize();
    }, setFlip: function(e5) {
      return this.viewport.setFlip(e5), this.setDisplayTransform(this.viewer.viewport.getFlip() ? "scale(-1,1)" : "scale(1,1)"), this;
    }, setDisplayTransform: function(e5) {
      s2(this.displayRegion, e5), s2(this.canvas, e5), s2(this.element, e5);
    }, update: function(t4) {
      var i4, n4, o3, s3, a2, l2;
      if (i4 = e4.getElementSize(this.viewer.element), this._resizeWithViewer && i4.x && i4.y && !i4.equals(this.oldViewerSize) && (this.oldViewerSize = i4, this.maintainSizeRatio || !this.elementArea ? (n4 = i4.x * this.sizeRatio, o3 = i4.y * this.sizeRatio) : (n4 = Math.sqrt(this.elementArea * (i4.x / i4.y)), o3 = this.elementArea / n4), this.element.style.width = Math.round(n4) + "px", this.element.style.height = Math.round(o3) + "px", this.elementArea || (this.elementArea = n4 * o3), this.updateSize()), t4 && this.viewport) {
        if (s3 = t4.getBoundsNoRotate(true), a2 = this.viewport.pixelFromPointNoRotate(s3.getTopLeft(), false), l2 = this.viewport.pixelFromPointNoRotate(s3.getBottomRight(), false).minus(this.totalBorderWidths), !this.navigatorRotate) {
          var c2 = t4.getRotation(true);
          r2(this.displayRegion, -c2);
        }
        var h2 = this.displayRegion.style;
        h2.display = this.world.getItemCount() ? "block" : "none", h2.top = a2.y.toFixed(2) + "px", h2.left = a2.x.toFixed(2) + "px";
        var u2 = l2.x - a2.x, d2 = l2.y - a2.y;
        h2.width = Math.round(Math.max(u2, 0)) + "px", h2.height = Math.round(Math.max(d2, 0)) + "px";
      }
    }, addTiledImage: function(t4) {
      var i4 = this, n4 = t4.originalTiledImage;
      delete t4.original;
      var o3 = e4.extend({}, t4, { success: function(e5) {
        var t5 = e5.item;
        function o4() {
          i4._matchBounds(t5, n4);
        }
        t5._originalForNavigator = n4, i4._matchBounds(t5, n4, true), i4._matchOpacity(t5, n4), i4._matchCompositeOperation(t5, n4), n4.addHandler("bounds-change", o4), n4.addHandler("clip-change", o4), n4.addHandler("opacity-change", function() {
          i4._matchOpacity(t5, n4);
        }), n4.addHandler("composite-operation-change", function() {
          i4._matchCompositeOperation(t5, n4);
        });
      } });
      return e4.Viewer.prototype.addTiledImage.apply(this, [o3]);
    }, destroy: function() {
      return e4.Viewer.prototype.destroy.apply(this);
    }, _getMatchingItem: function(e5) {
      for (var t4, i4 = this.world.getItemCount(), n4 = 0; n4 < i4; n4++)
        if ((t4 = this.world.getItemAt(n4))._originalForNavigator === e5)
          return t4;
      return null;
    }, _matchBounds: function(e5, t4, i4) {
      var n4 = t4.getBoundsNoRotate();
      e5.setPosition(n4.getTopLeft(), i4), e5.setWidth(n4.width, i4), e5.setRotation(t4.getRotation(), i4), e5.setClip(t4.getClip()), e5.setFlip(t4.getFlip());
    }, _matchOpacity: function(e5, t4) {
      e5.setOpacity(t4.opacity);
    }, _matchCompositeOperation: function(e5, t4) {
      e5.setCompositeOperation(t4.compositeOperation);
    } });
  }(t2), function(e4) {
    var t3 = { Errors: { Dzc: "Sorry, we don't support Deep Zoom Collections!", Dzi: "Hmm, this doesn't appear to be a valid Deep Zoom Image.", Xml: "Hmm, this doesn't appear to be a valid Deep Zoom Image.", ImageFormat: "Sorry, we don't support {0}-based Deep Zoom Images.", Security: "It looks like a security restriction stopped us from loading this Deep Zoom Image.", Status: "This space unintentionally left blank ({0} {1}).", OpenFailed: "Unable to open {0}: {1}" }, Tooltips: { FullPage: "Toggle full page", Home: "Go home", ZoomIn: "Zoom in", ZoomOut: "Zoom out", NextPage: "Next page", PreviousPage: "Previous page", RotateLeft: "Rotate left", RotateRight: "Rotate right", Flip: "Flip Horizontally" } };
    e4.extend(e4, { getString: function(i3) {
      var n3, o2 = i3.split("."), r2 = null, s2 = arguments, a2 = t3;
      for (n3 = 0; n3 < o2.length - 1; n3++)
        a2 = a2[o2[n3]] || {};
      return "string" != typeof (r2 = a2[o2[n3]]) && (e4.console.error("Untranslated source string:", i3), r2 = ""), r2.replace(/\{\d+\}/g, function(e5) {
        var t4 = parseInt(e5.match(/\d+/), 10) + 1;
        return t4 < s2.length ? s2[t4] : "";
      });
    }, setString: function(e5, i3) {
      var n3, o2 = e5.split("."), r2 = t3;
      for (n3 = 0; n3 < o2.length - 1; n3++)
        r2[o2[n3]] || (r2[o2[n3]] = {}), r2 = r2[o2[n3]];
      r2[o2[n3]] = i3;
    } });
  }(t2), function(e4) {
    e4.Point = function(e5, t3) {
      this.x = "number" == typeof e5 ? e5 : 0, this.y = "number" == typeof t3 ? t3 : 0;
    }, e4.Point.prototype = { clone: function() {
      return new e4.Point(this.x, this.y);
    }, plus: function(t3) {
      return new e4.Point(this.x + t3.x, this.y + t3.y);
    }, minus: function(t3) {
      return new e4.Point(this.x - t3.x, this.y - t3.y);
    }, times: function(t3) {
      return new e4.Point(this.x * t3, this.y * t3);
    }, divide: function(t3) {
      return new e4.Point(this.x / t3, this.y / t3);
    }, negate: function() {
      return new e4.Point(-this.x, -this.y);
    }, distanceTo: function(e5) {
      return Math.sqrt(Math.pow(this.x - e5.x, 2) + Math.pow(this.y - e5.y, 2));
    }, squaredDistanceTo: function(e5) {
      return Math.pow(this.x - e5.x, 2) + Math.pow(this.y - e5.y, 2);
    }, apply: function(t3) {
      return new e4.Point(t3(this.x), t3(this.y));
    }, equals: function(t3) {
      return t3 instanceof e4.Point && this.x === t3.x && this.y === t3.y;
    }, rotate: function(t3, i3) {
      var n3, o2;
      if (i3 = i3 || new e4.Point(0, 0), t3 % 90 == 0) {
        switch (e4.positiveModulo(t3, 360)) {
          case 0:
            n3 = 1, o2 = 0;
            break;
          case 90:
            n3 = 0, o2 = 1;
            break;
          case 180:
            n3 = -1, o2 = 0;
            break;
          case 270:
            n3 = 0, o2 = -1;
        }
      } else {
        var r2 = t3 * Math.PI / 180;
        n3 = Math.cos(r2), o2 = Math.sin(r2);
      }
      var s2 = n3 * (this.x - i3.x) - o2 * (this.y - i3.y) + i3.x, a2 = o2 * (this.x - i3.x) + n3 * (this.y - i3.y) + i3.y;
      return new e4.Point(s2, a2);
    }, toString: function() {
      return "(" + Math.round(100 * this.x) / 100 + "," + Math.round(100 * this.y) / 100 + ")";
    } };
  }(t2), function(e4) {
    e4.TileSource = function(t3, i3, n3, o2, r2, s2) {
      var a2, l2, c2 = this, h2 = arguments;
      if (a2 = e4.isPlainObject(t3) ? t3 : { width: h2[0], height: h2[1], tileSize: h2[2], tileOverlap: h2[3], minLevel: h2[4], maxLevel: h2[5] }, e4.EventSource.call(this), e4.extend(true, this, a2), !this.success) {
        for (l2 = 0; l2 < arguments.length; l2++)
          if (e4.isFunction(arguments[l2])) {
            this.success = arguments[l2];
            break;
          }
      }
      this.success && this.addHandler("ready", function(e5) {
        c2.success(e5);
      }), "string" === e4.type(arguments[0]) && (this.url = arguments[0]), this.url ? (this.aspectRatio = 1, this.dimensions = new e4.Point(10, 10), this._tileWidth = 0, this._tileHeight = 0, this.tileOverlap = 0, this.minLevel = 0, this.maxLevel = 0, this.ready = false, this.getImageInfo(this.url)) : (this.ready = true, this.aspectRatio = a2.width && a2.height ? a2.width / a2.height : 1, this.dimensions = new e4.Point(a2.width, a2.height), this.tileSize ? (this._tileWidth = this._tileHeight = this.tileSize, delete this.tileSize) : (this.tileWidth ? (this._tileWidth = this.tileWidth, delete this.tileWidth) : this._tileWidth = 0, this.tileHeight ? (this._tileHeight = this.tileHeight, delete this.tileHeight) : this._tileHeight = 0), this.tileOverlap = a2.tileOverlap ? a2.tileOverlap : 0, this.minLevel = a2.minLevel ? a2.minLevel : 0, this.maxLevel = void 0 !== a2.maxLevel && null !== a2.maxLevel ? a2.maxLevel : a2.width && a2.height ? Math.ceil(Math.log(Math.max(a2.width, a2.height)) / Math.log(2)) : 0, this.success && e4.isFunction(this.success) && this.success(this));
    }, e4.TileSource.prototype = { getTileSize: function(t3) {
      return e4.console.error("[TileSource.getTileSize] is deprecated. Use TileSource.getTileWidth() and TileSource.getTileHeight() instead"), this._tileWidth;
    }, getTileWidth: function(e5) {
      return this._tileWidth ? this._tileWidth : this.getTileSize(e5);
    }, getTileHeight: function(e5) {
      return this._tileHeight ? this._tileHeight : this.getTileSize(e5);
    }, setMaxLevel: function(e5) {
      this.maxLevel = e5, this._memoizeLevelScale();
    }, getLevelScale: function(e5) {
      return this._memoizeLevelScale(), this.getLevelScale(e5);
    }, _memoizeLevelScale: function() {
      var e5, t3 = {};
      for (e5 = 0; e5 <= this.maxLevel; e5++)
        t3[e5] = 1 / Math.pow(2, this.maxLevel - e5);
      this.getLevelScale = function(e6) {
        return t3[e6];
      };
    }, getNumTiles: function(t3) {
      var i3 = this.getLevelScale(t3), n3 = Math.ceil(i3 * this.dimensions.x / this.getTileWidth(t3)), o2 = Math.ceil(i3 * this.dimensions.y / this.getTileHeight(t3));
      return new e4.Point(n3, o2);
    }, getPixelRatio: function(t3) {
      var i3 = this.dimensions.times(this.getLevelScale(t3)), n3 = 1 / i3.x * e4.pixelDensityRatio, o2 = 1 / i3.y * e4.pixelDensityRatio;
      return new e4.Point(n3, o2);
    }, getClosestLevel: function() {
      var e5, t3;
      for (e5 = this.minLevel + 1; e5 <= this.maxLevel && !((t3 = this.getNumTiles(e5)).x > 1 || t3.y > 1); e5++)
        ;
      return e5 - 1;
    }, getTileAtPoint: function(t3, i3) {
      var n3 = i3.x >= 0 && i3.x <= 1 && i3.y >= 0 && i3.y <= 1 / this.aspectRatio;
      e4.console.assert(n3, "[TileSource.getTileAtPoint] must be called with a valid point.");
      var o2 = this.dimensions.x * this.getLevelScale(t3), r2 = i3.x * o2, s2 = i3.y * o2, a2 = Math.floor(r2 / this.getTileWidth(t3)), l2 = Math.floor(s2 / this.getTileHeight(t3));
      i3.x >= 1 && (a2 = this.getNumTiles(t3).x - 1);
      return i3.y >= 1 / this.aspectRatio - 1e-15 && (l2 = this.getNumTiles(t3).y - 1), new e4.Point(a2, l2);
    }, getTileBounds: function(t3, i3, n3, o2) {
      var r2 = this.dimensions.times(this.getLevelScale(t3)), s2 = this.getTileWidth(t3), a2 = this.getTileHeight(t3), l2 = 0 === i3 ? 0 : s2 * i3 - this.tileOverlap, c2 = 0 === n3 ? 0 : a2 * n3 - this.tileOverlap, h2 = s2 + (0 === i3 ? 1 : 2) * this.tileOverlap, u2 = a2 + (0 === n3 ? 1 : 2) * this.tileOverlap, d2 = 1 / r2.x;
      return h2 = Math.min(h2, r2.x - l2), u2 = Math.min(u2, r2.y - c2), o2 ? new e4.Rect(0, 0, h2, u2) : new e4.Rect(l2 * d2, c2 * d2, h2 * d2, u2 * d2);
    }, getImageInfo: function(t3) {
      var i3, n3, o2, r2, s2, a2, l2, c2 = this;
      t3 && (l2 = (a2 = (s2 = t3.split("/"))[s2.length - 1]).lastIndexOf(".")) > -1 && (s2[s2.length - 1] = a2.slice(0, l2));
      var h2 = null;
      if (this.splitHashDataForPost) {
        var u2 = t3.indexOf("#");
        -1 !== u2 && (h2 = t3.substring(u2 + 1), t3 = t3.substr(0, u2));
      }
      n3 = function(i4) {
        "string" == typeof i4 && (i4 = e4.parseXml(i4));
        var n4 = e4.TileSource.determineType(c2, i4, t3);
        n4 ? (void 0 === (r2 = n4.prototype.configure.apply(c2, [i4, t3, h2])).ajaxWithCredentials && (r2.ajaxWithCredentials = c2.ajaxWithCredentials), o2 = new n4(r2), c2.ready = true, c2.raiseEvent("ready", { tileSource: o2 })) : c2.raiseEvent("open-failed", { message: "Unable to load TileSource", source: t3 });
      }, t3.match(/\.js$/) ? (i3 = t3.split("/").pop().replace(".js", ""), e4.jsonp({ url: t3, async: false, callbackName: i3, callback: n3 })) : e4.makeAjaxRequest({ url: t3, postData: h2, withCredentials: this.ajaxWithCredentials, headers: this.ajaxHeaders, success: function(t4) {
        var i4 = function(t5) {
          var i5, n4, o3 = t5.responseText, r3 = t5.status;
          if (!t5)
            throw new Error(e4.getString("Errors.Security"));
          if (200 !== t5.status && 0 !== t5.status)
            throw i5 = 404 === (r3 = t5.status) ? "Not Found" : t5.statusText, new Error(e4.getString("Errors.Status", r3, i5));
          if (o3.match(/^\s*<.*/))
            try {
              n4 = t5.responseXML && t5.responseXML.documentElement ? t5.responseXML : e4.parseXml(o3);
            } catch (e5) {
              n4 = t5.responseText;
            }
          else if (o3.match(/\s*[{[].*/))
            try {
              n4 = e4.parseJSON(o3);
            } catch (e5) {
              n4 = o3;
            }
          else
            n4 = o3;
          return n4;
        }(t4);
        n3(i4);
      }, error: function(i4, n4) {
        var o3;
        try {
          o3 = "HTTP " + i4.status + " attempting to load TileSource: " + t3;
        } catch (e5) {
          o3 = (void 0 !== n4 && n4.toString ? n4.toString() : "Unknown error") + " attempting to load TileSource: " + t3;
        }
        e4.console.error(o3), c2.raiseEvent("open-failed", { message: o3, source: t3, postData: h2 });
      } });
    }, supports: function(e5, t3) {
      return false;
    }, configure: function(e5, t3, i3) {
      throw new Error("Method not implemented.");
    }, getTileUrl: function(e5, t3, i3) {
      throw new Error("Method not implemented.");
    }, getTilePostData: function(e5, t3, i3) {
      return null;
    }, getTileAjaxHeaders: function(e5, t3, i3) {
      return {};
    }, getTileHashKey: function(e5, t3, i3, n3, o2, r2) {
      function s2(e6) {
        return o2 ? e6 + "+" + JSON.stringify(o2) : e6;
      }
      return s2("string" != typeof n3 ? e5 + "/" + t3 + "_" + i3 : n3);
    }, tileExists: function(e5, t3, i3) {
      var n3 = this.getNumTiles(e5);
      return e5 >= this.minLevel && e5 <= this.maxLevel && t3 >= 0 && i3 >= 0 && t3 < n3.x && i3 < n3.y;
    }, hasTransparency: function(e5, t3, i3, n3) {
      return !!e5 || t3.match(".png");
    }, downloadTileStart: function(t3) {
      var i3 = t3.userData, n3 = new Image();
      i3.image = n3, i3.request = null;
      var o2 = function(e5) {
        n3 ? (n3.onload = n3.onerror = n3.onabort = null, t3.finish(e5 ? null : n3, i3.request, e5)) : t3.finish(null, i3.request, "Image load failed: undefined Image instance.");
      };
      n3.onload = function() {
        o2();
      }, n3.onabort = n3.onerror = function() {
        o2("Image load aborted.");
      }, t3.loadWithAjax ? i3.request = e4.makeAjaxRequest({ url: t3.src, withCredentials: t3.ajaxWithCredentials, headers: t3.ajaxHeaders, responseType: "arraybuffer", postData: t3.postData, success: function(e5) {
        var t4;
        try {
          t4 = new window.Blob([e5.response]);
        } catch (n4) {
          var i4 = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
          if ("TypeError" === n4.name && i4) {
            var r2 = new i4();
            r2.append(e5.response), t4 = r2.getBlob();
          }
        }
        0 === t4.size ? o2("Empty image response.") : n3.src = (window.URL || window.webkitURL).createObjectURL(t4);
      }, error: function(e5) {
        o2("Image load aborted - XHR error");
      } }) : (false !== t3.crossOriginPolicy && (n3.crossOrigin = t3.crossOriginPolicy), n3.src = t3.src);
    }, downloadTileAbort: function(e5) {
      e5.userData.request && e5.userData.request.abort();
      var t3 = e5.userData.image;
      e5.userData.image && (t3.onload = t3.onerror = t3.onabort = null);
    }, createTileCache: function(e5, t3, i3) {
      e5._data = t3;
    }, destroyTileCache: function(e5) {
      e5._data = null, e5._renderedContext = null;
    }, getTileCacheData: function(e5) {
      return e5._data;
    }, getTileCacheDataAsImage: function(e5) {
      return e5._data;
    }, getTileCacheDataAsContext2D: function(e5) {
      if (!e5._renderedContext) {
        var t3 = document.createElement("canvas");
        t3.width = e5._data.width, t3.height = e5._data.height, e5._renderedContext = t3.getContext("2d"), e5._renderedContext.drawImage(e5._data, 0, 0), e5._data = null;
      }
      return e5._renderedContext;
    } }, e4.extend(true, e4.TileSource.prototype, e4.EventSource.prototype), e4.TileSource.determineType = function(i3, n3, o2) {
      var r2;
      for (r2 in t2)
        if (r2.match(/.+TileSource$/) && e4.isFunction(t2[r2]) && e4.isFunction(t2[r2].prototype.supports) && t2[r2].prototype.supports.call(i3, n3, o2))
          return t2[r2];
      return e4.console.error("No TileSource was able to open %s %s", o2, n3), null;
    };
  }(t2), function(e4) {
    function t3(t4, i3) {
      var n3, o2, r2 = i3.Image, s2 = r2.Url, a2 = r2.Format, l2 = r2.Size, c2 = r2.DisplayRect || [], h2 = parseInt(l2.Width, 10), u2 = parseInt(l2.Height, 10), d2 = parseInt(r2.TileSize, 10), p2 = parseInt(r2.Overlap, 10), _2 = [];
      for (o2 = 0; o2 < c2.length; o2++)
        n3 = c2[o2].Rect, _2.push(new e4.DisplayRect(parseInt(n3.X, 10), parseInt(n3.Y, 10), parseInt(n3.Width, 10), parseInt(n3.Height, 10), parseInt(n3.MinLevel, 10), parseInt(n3.MaxLevel, 10)));
      return e4.extend(true, { width: h2, height: u2, tileSize: d2, tileOverlap: p2, minLevel: null, maxLevel: null, tilesUrl: s2, fileFormat: a2, displayRects: _2 }, i3);
    }
    e4.DziTileSource = function(t4, i3, n3, o2, r2, s2, a2, l2, c2) {
      var h2, u2, d2, p2;
      if (p2 = e4.isPlainObject(t4) ? t4 : { width: arguments[0], height: arguments[1], tileSize: arguments[2], tileOverlap: arguments[3], tilesUrl: arguments[4], fileFormat: arguments[5], displayRects: arguments[6], minLevel: arguments[7], maxLevel: arguments[8] }, this._levelRects = {}, this.tilesUrl = p2.tilesUrl, this.fileFormat = p2.fileFormat, this.displayRects = p2.displayRects, this.displayRects)
        for (h2 = this.displayRects.length - 1; h2 >= 0; h2--)
          for (d2 = (u2 = this.displayRects[h2]).minLevel; d2 <= u2.maxLevel; d2++)
            this._levelRects[d2] || (this._levelRects[d2] = []), this._levelRects[d2].push(u2);
      e4.TileSource.apply(this, [p2]);
    }, e4.extend(e4.DziTileSource.prototype, e4.TileSource.prototype, { supports: function(e5, t4) {
      var i3;
      return e5.Image ? i3 = e5.Image.xmlns : e5.documentElement && ("Image" !== e5.documentElement.localName && "Image" !== e5.documentElement.tagName || (i3 = e5.documentElement.namespaceURI)), -1 !== (i3 = (i3 || "").toLowerCase()).indexOf("schemas.microsoft.com/deepzoom/2008") || -1 !== i3.indexOf("schemas.microsoft.com/deepzoom/2009");
    }, configure: function(i3, n3, o2) {
      var r2;
      return r2 = e4.isPlainObject(i3) ? t3(this, i3) : function(i4, n4) {
        if (!n4 || !n4.documentElement)
          throw new Error(e4.getString("Errors.Xml"));
        var o3, r3, s2, a2, l2, c2 = n4.documentElement, h2 = c2.localName || c2.tagName, u2 = n4.documentElement.namespaceURI, d2 = null, p2 = [];
        if ("Image" === h2)
          try {
            if (void 0 === (a2 = c2.getElementsByTagName("Size")[0]) && (a2 = c2.getElementsByTagNameNS(u2, "Size")[0]), d2 = { Image: { xmlns: "http://schemas.microsoft.com/deepzoom/2008", Url: c2.getAttribute("Url"), Format: c2.getAttribute("Format"), DisplayRect: null, Overlap: parseInt(c2.getAttribute("Overlap"), 10), TileSize: parseInt(c2.getAttribute("TileSize"), 10), Size: { Height: parseInt(a2.getAttribute("Height"), 10), Width: parseInt(a2.getAttribute("Width"), 10) } } }, !e4.imageFormatSupported(d2.Image.Format))
              throw new Error(e4.getString("Errors.ImageFormat", d2.Image.Format.toUpperCase()));
            for (void 0 === (o3 = c2.getElementsByTagName("DisplayRect")) && (o3 = c2.getElementsByTagNameNS(u2, "DisplayRect")[0]), l2 = 0; l2 < o3.length; l2++)
              void 0 === (s2 = (r3 = o3[l2]).getElementsByTagName("Rect")[0]) && (s2 = r3.getElementsByTagNameNS(u2, "Rect")[0]), p2.push({ Rect: { X: parseInt(s2.getAttribute("X"), 10), Y: parseInt(s2.getAttribute("Y"), 10), Width: parseInt(s2.getAttribute("Width"), 10), Height: parseInt(s2.getAttribute("Height"), 10), MinLevel: parseInt(r3.getAttribute("MinLevel"), 10), MaxLevel: parseInt(r3.getAttribute("MaxLevel"), 10) } });
            return p2.length && (d2.Image.DisplayRect = p2), t3(i4, d2);
          } catch (t4) {
            throw t4 instanceof Error ? t4 : new Error(e4.getString("Errors.Dzi"));
          }
        else {
          if ("Collection" === h2)
            throw new Error(e4.getString("Errors.Dzc"));
          if ("Error" === h2) {
            var _2 = c2.getElementsByTagName("Message")[0].firstChild.nodeValue;
            throw new Error(_2);
          }
        }
        throw new Error(e4.getString("Errors.Dzi"));
      }(this, i3), n3 && !r2.tilesUrl && (r2.tilesUrl = n3.replace(/([^/]+?)(\.(dzi|xml|js)?(\?[^/]*)?)?\/?$/, "$1_files/"), -1 !== n3.search(/\.(dzi|xml|js)\?/) ? r2.queryParams = n3.match(/\?.*/) : r2.queryParams = ""), r2;
    }, getTileUrl: function(e5, t4, i3) {
      return [this.tilesUrl, e5, "/", t4, "_", i3, ".", this.fileFormat, this.queryParams].join("");
    }, tileExists: function(e5, t4, i3) {
      var n3, o2, r2, s2, a2, l2, c2, h2 = this._levelRects[e5];
      if (this.minLevel && e5 < this.minLevel || this.maxLevel && e5 > this.maxLevel)
        return false;
      if (!h2 || !h2.length)
        return true;
      for (c2 = h2.length - 1; c2 >= 0; c2--)
        if (!(e5 < (n3 = h2[c2]).minLevel || e5 > n3.maxLevel) && (o2 = this.getLevelScale(e5), r2 = n3.x * o2, s2 = n3.y * o2, a2 = r2 + n3.width * o2, l2 = s2 + n3.height * o2, r2 = Math.floor(r2 / this._tileWidth), s2 = Math.floor(s2 / this._tileWidth), a2 = Math.ceil(a2 / this._tileWidth), l2 = Math.ceil(l2 / this._tileWidth), r2 <= t4 && t4 < a2 && s2 <= i3 && i3 < l2))
          return true;
      return false;
    } });
  }(t2), function(e4) {
    function i3(e5) {
      var t3 = Array.isArray(e5.profile) ? e5.profile[0] : e5.profile, i4 = -1 !== ["http://library.stanford.edu/iiif/image-api/compliance.html#level0", "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level0", "http://iiif.io/api/image/2/level0.json", "level0", "https://iiif.io/api/image/3/level0.json"].indexOf(t3), n4 = false;
      return 2 === e5.version && e5.profile.length > 1 && e5.profile[1].supports && (n4 = -1 !== e5.profile[1].supports.indexOf("sizeByW")), 3 === e5.version && e5.extraFeatures && (n4 = -1 !== e5.extraFeatures.indexOf("sizeByWh")), !i4 || n4;
    }
    function n3(e5) {
      for (var t3 = [], i4 = 0; i4 < e5.sizes.length; i4++)
        t3.push({ url: e5._id + "/full/" + e5.sizes[i4].width + "," + (3 === e5.version ? e5.sizes[i4].height : "") + "/0/default." + e5.tileFormat, width: e5.sizes[i4].width, height: e5.sizes[i4].height });
      return t3.sort(function(e6, t4) {
        return e6.width - t4.width;
      });
    }
    function o2(t3, i4, n4) {
      var r2, s2;
      if (3 === t3.nodeType && n4)
        (s2 = t3.nodeValue.trim()).match(/^\d*$/) && (s2 = Number(s2)), i4[n4] ? (e4.isArray(i4[n4]) || (i4[n4] = [i4[n4]]), i4[n4].push(s2)) : i4[n4] = s2;
      else if (1 === t3.nodeType)
        for (r2 = 0; r2 < t3.childNodes.length; r2++)
          o2(t3.childNodes[r2], i4, t3.nodeName);
    }
    e4.IIIFTileSource = function(t3) {
      if (e4.extend(true, this, t3), this._id = this["@id"] || this.id || this.identifier || null, !(this.height && this.width && this._id))
        throw new Error("IIIF required parameters (width, height, or id) not provided.");
      if (t3.tileSizePerScaleFactor = {}, this.tileFormat = this.tileFormat || "jpg", this.version = t3.version, this.tile_width && this.tile_height)
        t3.tileWidth = this.tile_width, t3.tileHeight = this.tile_height;
      else if (this.tile_width)
        t3.tileSize = this.tile_width;
      else if (this.tile_height)
        t3.tileSize = this.tile_height;
      else if (this.tiles)
        if (1 === this.tiles.length)
          t3.tileWidth = this.tiles[0].width, t3.tileHeight = this.tiles[0].height || this.tiles[0].width, this.scale_factors = this.tiles[0].scaleFactors;
        else {
          this.scale_factors = [];
          for (var o3 = 0; o3 < this.tiles.length; o3++)
            for (var r2 = 0; r2 < this.tiles[o3].scaleFactors.length; r2++) {
              var s2 = this.tiles[o3].scaleFactors[r2];
              this.scale_factors.push(s2), t3.tileSizePerScaleFactor[s2] = { width: this.tiles[o3].width, height: this.tiles[o3].height || this.tiles[o3].width };
            }
        }
      else if (i3(t3)) {
        for (var a2 = Math.min(this.height, this.width), l2 = [256, 512, 1024], c2 = [], h2 = 0; h2 < l2.length; h2++)
          l2[h2] <= a2 && c2.push(l2[h2]);
        c2.length > 0 ? t3.tileSize = Math.max.apply(null, c2) : t3.tileSize = a2;
      } else
        this.sizes && this.sizes.length > 0 ? (this.emulateLegacyImagePyramid = true, t3.levels = n3(this), e4.extend(true, t3, { width: t3.levels[t3.levels.length - 1].width, height: t3.levels[t3.levels.length - 1].height, tileSize: Math.max(t3.height, t3.width), tileOverlap: 0, minLevel: 0, maxLevel: t3.levels.length - 1 }), this.levels = t3.levels) : e4.console.error("Nothing in the info.json to construct image pyramids from");
      if (!t3.maxLevel && !this.emulateLegacyImagePyramid)
        if (this.scale_factors) {
          var u2 = Math.max.apply(null, this.scale_factors);
          t3.maxLevel = Math.round(Math.log(u2) * Math.LOG2E);
        } else
          t3.maxLevel = Number(Math.round(Math.log(Math.max(this.width, this.height), 2)));
      if (this.sizes) {
        var d2 = this.sizes.length;
        d2 !== t3.maxLevel && d2 !== t3.maxLevel + 1 || (this.levelSizes = this.sizes, d2 === t3.maxLevel && this.levelSizes.push({ width: this.width, height: this.height }));
      }
      e4.TileSource.apply(this, [t3]);
    }, e4.extend(e4.IIIFTileSource.prototype, e4.TileSource.prototype, { supports: function(e5, t3) {
      return !(!e5.protocol || "http://iiif.io/api/image" !== e5.protocol) || (!(!e5["@context"] || "http://library.stanford.edu/iiif/image-api/1.1/context.json" !== e5["@context"] && "http://iiif.io/api/image/1/context.json" !== e5["@context"]) || (!(!e5.profile || 0 !== e5.profile.indexOf("http://library.stanford.edu/iiif/image-api/compliance.html")) || (!!(e5.identifier && e5.width && e5.height) || !(!e5.documentElement || "info" !== e5.documentElement.tagName || "http://library.stanford.edu/iiif/image-api/ns/" !== e5.documentElement.namespaceURI))));
    }, configure: function(i4, n4, r2) {
      if (e4.isPlainObject(i4)) {
        if (i4["@context"]) {
          var s2 = i4["@context"];
          if (Array.isArray(s2)) {
            for (var a2 = 0; a2 < s2.length; a2++)
              if ("string" == typeof s2[a2] && (/^http:\/\/iiif\.io\/api\/image\/[1-3]\/context\.json$/.test(s2[a2]) || "http://library.stanford.edu/iiif/image-api/1.1/context.json" === s2[a2])) {
                s2 = s2[a2];
                break;
              }
          }
          switch (s2) {
            case "http://iiif.io/api/image/1/context.json":
            case "http://library.stanford.edu/iiif/image-api/1.1/context.json":
              i4.version = 1;
              break;
            case "http://iiif.io/api/image/2/context.json":
              i4.version = 2;
              break;
            case "http://iiif.io/api/image/3/context.json":
              i4.version = 3;
              break;
            default:
              e4.console.error("Data has a @context property which contains no known IIIF context URI.");
          }
        } else
          i4["@context"] = "http://iiif.io/api/image/1.0/context.json", i4["@id"] = n4.replace("/info.json", ""), i4.version = 1;
        if (i4.preferredFormats) {
          for (var l2 = 0; l2 < i4.preferredFormats.length; l2++)
            if (t2.imageFormatSupported(i4.preferredFormats[l2])) {
              i4.tileFormat = i4.preferredFormats[l2];
              break;
            }
        }
        return i4;
      }
      var c2 = function(t3) {
        if (!t3 || !t3.documentElement)
          throw new Error(e4.getString("Errors.Xml"));
        var i5 = t3.documentElement, n5 = i5.tagName, r3 = null;
        if ("info" === n5)
          try {
            return o2(i5, r3 = {}), r3;
          } catch (t4) {
            throw t4 instanceof Error ? t4 : new Error(e4.getString("Errors.IIIF"));
          }
        throw new Error(e4.getString("Errors.IIIF"));
      }(i4);
      return c2["@context"] = "http://iiif.io/api/image/1.0/context.json", c2["@id"] = n4.replace("/info.xml", ""), c2.version = 1, c2;
    }, getTileWidth: function(t3) {
      if (this.emulateLegacyImagePyramid)
        return e4.TileSource.prototype.getTileWidth.call(this, t3);
      var i4 = Math.pow(2, this.maxLevel - t3);
      return this.tileSizePerScaleFactor && this.tileSizePerScaleFactor[i4] ? this.tileSizePerScaleFactor[i4].width : this._tileWidth;
    }, getTileHeight: function(t3) {
      if (this.emulateLegacyImagePyramid)
        return e4.TileSource.prototype.getTileHeight.call(this, t3);
      var i4 = Math.pow(2, this.maxLevel - t3);
      return this.tileSizePerScaleFactor && this.tileSizePerScaleFactor[i4] ? this.tileSizePerScaleFactor[i4].height : this._tileHeight;
    }, getLevelScale: function(t3) {
      if (this.emulateLegacyImagePyramid) {
        var i4 = NaN;
        return this.levels.length > 0 && t3 >= this.minLevel && t3 <= this.maxLevel && (i4 = this.levels[t3].width / this.levels[this.maxLevel].width), i4;
      }
      return e4.TileSource.prototype.getLevelScale.call(this, t3);
    }, getNumTiles: function(t3) {
      if (this.emulateLegacyImagePyramid)
        return this.getLevelScale(t3) ? new e4.Point(1, 1) : new e4.Point(0, 0);
      if (this.levelSizes) {
        var i4 = this.levelSizes[t3], n4 = Math.ceil(i4.width / this.getTileWidth(t3)), o3 = Math.ceil(i4.height / this.getTileHeight(t3));
        return new e4.Point(n4, o3);
      }
      return e4.TileSource.prototype.getNumTiles.call(this, t3);
    }, getTileAtPoint: function(t3, i4) {
      if (this.emulateLegacyImagePyramid)
        return new e4.Point(0, 0);
      if (this.levelSizes) {
        var n4 = i4.x >= 0 && i4.x <= 1 && i4.y >= 0 && i4.y <= 1 / this.aspectRatio;
        e4.console.assert(n4, "[TileSource.getTileAtPoint] must be called with a valid point.");
        var o3 = this.levelSizes[t3].width, r2 = i4.x * o3, s2 = i4.y * o3, a2 = Math.floor(r2 / this.getTileWidth(t3)), l2 = Math.floor(s2 / this.getTileHeight(t3));
        i4.x >= 1 && (a2 = this.getNumTiles(t3).x - 1);
        return i4.y >= 1 / this.aspectRatio - 1e-15 && (l2 = this.getNumTiles(t3).y - 1), new e4.Point(a2, l2);
      }
      return e4.TileSource.prototype.getTileAtPoint.call(this, t3, i4);
    }, getTileUrl: function(e5, t3, i4) {
      if (this.emulateLegacyImagePyramid) {
        var n4 = null;
        return this.levels.length > 0 && e5 >= this.minLevel && e5 <= this.maxLevel && (n4 = this.levels[e5].url), n4;
      }
      var o3, r2, s2, a2, l2, c2, h2, u2, d2, p2, _2, g2, m2, f2, v2, A2 = Math.pow(0.5, this.maxLevel - e5);
      return this.levelSizes ? (o3 = this.levelSizes[e5].width, r2 = this.levelSizes[e5].height) : (o3 = Math.ceil(this.width * A2), r2 = Math.ceil(this.height * A2)), s2 = this.getTileWidth(e5), a2 = this.getTileHeight(e5), l2 = Math.round(s2 / A2), c2 = Math.round(a2 / A2), v2 = 1 === this.version ? "native." + this.tileFormat : "default." + this.tileFormat, o3 < s2 && r2 < a2 ? (g2 = 2 === this.version && o3 === this.width ? "full" : 3 === this.version && o3 === this.width && r2 === this.height ? "max" : 3 === this.version ? o3 + "," + r2 : o3 + ",", h2 = "full") : (u2 = t3 * l2, d2 = i4 * c2, p2 = Math.min(l2, this.width - u2), _2 = Math.min(c2, this.height - d2), h2 = 0 === t3 && 0 === i4 && p2 === this.width && _2 === this.height ? "full" : [u2, d2, p2, _2].join(","), m2 = Math.min(s2, o3 - t3 * s2), f2 = Math.min(a2, r2 - i4 * a2), g2 = 2 === this.version && m2 === this.width ? "full" : 3 === this.version && m2 === this.width && f2 === this.height ? "max" : 3 === this.version ? m2 + "," + f2 : m2 + ","), [this._id, h2, g2, "0", v2].join("/");
    }, __testonly__: { canBeTiled: i3, constructLevels: n3 } });
  }(t2), function(e4) {
    e4.OsmTileSource = function(t3, i3, n3, o2, r2) {
      var s2;
      (s2 = e4.isPlainObject(t3) ? t3 : { width: arguments[0], height: arguments[1], tileSize: arguments[2], tileOverlap: arguments[3], tilesUrl: arguments[4] }).width && s2.height || (s2.width = 65572864, s2.height = 65572864), s2.tileSize || (s2.tileSize = 256, s2.tileOverlap = 0), s2.tilesUrl || (s2.tilesUrl = "http://tile.openstreetmap.org/"), s2.minLevel = 8, e4.TileSource.apply(this, [s2]);
    }, e4.extend(e4.OsmTileSource.prototype, e4.TileSource.prototype, { supports: function(e5, t3) {
      return e5.type && "openstreetmaps" === e5.type;
    }, configure: function(e5, t3, i3) {
      return e5;
    }, getTileUrl: function(e5, t3, i3) {
      return this.tilesUrl + (e5 - 8) + "/" + t3 + "/" + i3 + ".png";
    } });
  }(t2), function(e4) {
    e4.TmsTileSource = function(t3, i3, n3, o2, r2) {
      var s2;
      s2 = e4.isPlainObject(t3) ? t3 : { width: arguments[0], height: arguments[1], tileSize: arguments[2], tileOverlap: arguments[3], tilesUrl: arguments[4] };
      var a2, l2 = 256 * Math.ceil(s2.width / 256), c2 = 256 * Math.ceil(s2.height / 256);
      a2 = l2 > c2 ? l2 / 256 : c2 / 256, s2.maxLevel = Math.ceil(Math.log(a2) / Math.log(2)) - 1, s2.tileSize = 256, s2.width = l2, s2.height = c2, e4.TileSource.apply(this, [s2]);
    }, e4.extend(e4.TmsTileSource.prototype, e4.TileSource.prototype, { supports: function(e5, t3) {
      return e5.type && "tiledmapservice" === e5.type;
    }, configure: function(e5, t3, i3) {
      return e5;
    }, getTileUrl: function(e5, t3, i3) {
      var n3 = this.getNumTiles(e5).y - 1;
      return this.tilesUrl + e5 + "/" + t3 + "/" + (n3 - i3) + ".png";
    } });
  }(t2), function(e4) {
    e4.ZoomifyTileSource = function(e5) {
      void 0 === e5.tileSize && (e5.tileSize = 256), void 0 === e5.fileFormat && (e5.fileFormat = "jpg", this.fileFormat = e5.fileFormat);
      var i3 = { x: e5.width, y: e5.height };
      for (e5.imageSizes = [{ x: e5.width, y: e5.height }], e5.gridSize = [this._getGridSize(e5.width, e5.height, e5.tileSize)]; parseInt(i3.x, 10) > e5.tileSize || parseInt(i3.y, 10) > e5.tileSize; )
        i3.x = Math.floor(i3.x / 2), i3.y = Math.floor(i3.y / 2), e5.imageSizes.push({ x: i3.x, y: i3.y }), e5.gridSize.push(this._getGridSize(i3.x, i3.y, e5.tileSize));
      e5.imageSizes.reverse(), e5.gridSize.reverse(), e5.minLevel = 0, e5.maxLevel = e5.gridSize.length - 1, t2.TileSource.apply(this, [e5]);
    }, e4.extend(e4.ZoomifyTileSource.prototype, e4.TileSource.prototype, { _getGridSize: function(e5, t3, i3) {
      return { x: Math.ceil(e5 / i3), y: Math.ceil(t3 / i3) };
    }, _calculateAbsoluteTileNumber: function(e5, t3, i3) {
      for (var n3 = 0, o2 = {}, r2 = 0; r2 < e5; r2++)
        n3 += (o2 = this.gridSize[r2]).x * o2.y;
      return n3 += (o2 = this.gridSize[e5]).x * i3 + t3;
    }, supports: function(e5, t3) {
      return e5.type && "zoomifytileservice" === e5.type;
    }, configure: function(e5, t3, i3) {
      return e5;
    }, getTileUrl: function(e5, t3, i3) {
      var n3, o2 = this._calculateAbsoluteTileNumber(e5, t3, i3);
      return n3 = Math.floor(o2 / 256), this.tilesUrl + "TileGroup" + n3 + "/" + e5 + "-" + t3 + "-" + i3 + "." + this.fileFormat;
    } });
  }(t2), function(e4) {
    function t3(e5, t4) {
      return t4.levels;
    }
    e4.LegacyTileSource = function(t4) {
      var i3, n3, o2;
      e4.isArray(t4) && (i3 = { type: "legacy-image-pyramid", levels: t4 }), i3.levels = function(t5) {
        var i4, n4, o3 = [];
        for (n4 = 0; n4 < t5.length; n4++)
          (i4 = t5[n4]).height && i4.width && i4.url ? o3.push({ url: i4.url, width: Number(i4.width), height: Number(i4.height) }) : e4.console.error("Unsupported image format: %s", i4.url ? i4.url : "<no URL>");
        return o3.sort(function(e5, t6) {
          return e5.height - t6.height;
        });
      }(i3.levels), i3.levels.length > 0 ? (n3 = i3.levels[i3.levels.length - 1].width, o2 = i3.levels[i3.levels.length - 1].height) : (n3 = 0, o2 = 0, e4.console.error("No supported image formats found")), e4.extend(true, i3, { width: n3, height: o2, tileSize: Math.max(o2, n3), tileOverlap: 0, minLevel: 0, maxLevel: i3.levels.length > 0 ? i3.levels.length - 1 : 0 }), e4.TileSource.apply(this, [i3]), this.levels = i3.levels;
    }, e4.extend(e4.LegacyTileSource.prototype, e4.TileSource.prototype, { supports: function(e5, t4) {
      return e5.type && "legacy-image-pyramid" === e5.type || e5.documentElement && "legacy-image-pyramid" === e5.documentElement.getAttribute("type");
    }, configure: function(i3, n3, o2) {
      var r2;
      return r2 = e4.isPlainObject(i3) ? t3(this, i3) : function(i4, n4) {
        if (!n4 || !n4.documentElement)
          throw new Error(e4.getString("Errors.Xml"));
        var o3, r3, s2 = n4.documentElement, a2 = s2.tagName, l2 = null, c2 = [];
        if ("image" === a2)
          try {
            for (l2 = { type: s2.getAttribute("type"), levels: [] }, c2 = s2.getElementsByTagName("level"), r3 = 0; r3 < c2.length; r3++)
              o3 = c2[r3], l2.levels.push({ url: o3.getAttribute("url"), width: parseInt(o3.getAttribute("width"), 10), height: parseInt(o3.getAttribute("height"), 10) });
            return t3(i4, l2);
          } catch (e5) {
            throw e5 instanceof Error ? e5 : new Error("Unknown error parsing Legacy Image Pyramid XML.");
          }
        else {
          if ("collection" === a2)
            throw new Error("Legacy Image Pyramid Collections not yet supported.");
          if ("error" === a2)
            throw new Error("Error: " + n4);
        }
        throw new Error("Unknown element " + a2);
      }(this, i3), r2;
    }, getLevelScale: function(e5) {
      var t4 = NaN;
      return this.levels.length > 0 && e5 >= this.minLevel && e5 <= this.maxLevel && (t4 = this.levels[e5].width / this.levels[this.maxLevel].width), t4;
    }, getNumTiles: function(t4) {
      return this.getLevelScale(t4) ? new e4.Point(1, 1) : new e4.Point(0, 0);
    }, getTileUrl: function(e5, t4, i3) {
      var n3 = null;
      return this.levels.length > 0 && e5 >= this.minLevel && e5 <= this.maxLevel && (n3 = this.levels[e5].url), n3;
    } });
  }(t2), function(e4) {
    e4.ImageTileSource = function(t3) {
      t3 = e4.extend({ buildPyramid: true, crossOriginPolicy: false, ajaxWithCredentials: false, useCanvas: true }, t3), e4.TileSource.apply(this, [t3]);
    }, e4.extend(e4.ImageTileSource.prototype, e4.TileSource.prototype, { supports: function(e5, t3) {
      return e5.type && "image" === e5.type;
    }, configure: function(e5, t3, i3) {
      return e5;
    }, getImageInfo: function(t3) {
      var i3 = this._image = new Image(), n3 = this;
      this.crossOriginPolicy && (i3.crossOrigin = this.crossOriginPolicy), this.ajaxWithCredentials && (i3.useCredentials = this.ajaxWithCredentials), e4.addEvent(i3, "load", function() {
        n3.width = i3.naturalWidth, n3.height = i3.naturalHeight, n3.aspectRatio = n3.width / n3.height, n3.dimensions = new e4.Point(n3.width, n3.height), n3._tileWidth = n3.width, n3._tileHeight = n3.height, n3.tileOverlap = 0, n3.minLevel = 0, n3.levels = n3._buildLevels(), n3.maxLevel = n3.levels.length - 1, n3.ready = true, n3.raiseEvent("ready", { tileSource: n3 });
      }), e4.addEvent(i3, "error", function() {
        n3.raiseEvent("open-failed", { message: "Error loading image at " + t3, source: t3 });
      }), i3.src = t3;
    }, getLevelScale: function(e5) {
      var t3 = NaN;
      return e5 >= this.minLevel && e5 <= this.maxLevel && (t3 = this.levels[e5].width / this.levels[this.maxLevel].width), t3;
    }, getNumTiles: function(t3) {
      return this.getLevelScale(t3) ? new e4.Point(1, 1) : new e4.Point(0, 0);
    }, getTileUrl: function(e5, t3, i3) {
      var n3 = null;
      return e5 >= this.minLevel && e5 <= this.maxLevel && (n3 = this.levels[e5].url), n3;
    }, getContext2D: function(e5, t3, i3) {
      var n3 = null;
      return e5 >= this.minLevel && e5 <= this.maxLevel && (n3 = this.levels[e5].context2D), n3;
    }, destroy: function() {
      this._freeupCanvasMemory();
    }, _buildLevels: function() {
      var t3 = [{ url: this._image.src, width: this._image.naturalWidth, height: this._image.naturalHeight }];
      if (!this.buildPyramid || !e4.supportsCanvas || !this.useCanvas)
        return delete this._image, t3;
      var i3 = this._image.naturalWidth, n3 = this._image.naturalHeight, o2 = document.createElement("canvas"), r2 = o2.getContext("2d");
      if (o2.width = i3, o2.height = n3, r2.drawImage(this._image, 0, 0, i3, n3), t3[0].context2D = r2, delete this._image, e4.isCanvasTainted(o2))
        return t3;
      for (; i3 >= 2 && n3 >= 2; ) {
        i3 = Math.floor(i3 / 2), n3 = Math.floor(n3 / 2);
        var s2 = document.createElement("canvas"), a2 = s2.getContext("2d");
        s2.width = i3, s2.height = n3, a2.drawImage(o2, 0, 0, i3, n3), t3.splice(0, 0, { context2D: a2, width: i3, height: n3 }), o2 = s2, r2 = a2;
      }
      return t3;
    }, _freeupCanvasMemory: function() {
      for (var e5 = 0; e5 < this.levels.length; e5++)
        this.levels[e5].context2D && (this.levels[e5].context2D.canvas.height = 0, this.levels[e5].context2D.canvas.width = 0);
    } });
  }(t2), function(e4) {
    e4.TileSourceCollection = function(t3, i3, n3, o2) {
      e4.console.error("TileSourceCollection is deprecated; use World instead");
    };
  }(t2), function(e4) {
    function t3(i4) {
      e4.requestAnimationFrame(function() {
        !function(i5) {
          var n4;
          i5.shouldFade && (n4 = 1 - (e4.now() - i5.fadeBeginTime) / i5.fadeLength, n4 = Math.min(1, n4), n4 = Math.max(0, n4), i5.imgGroup && e4.setElementOpacity(i5.imgGroup, n4, true), n4 > 0 && t3(i5));
        }(i4);
      });
    }
    function i3(t4, i4) {
      t4.element.disabled || (i4 >= e4.ButtonState.GROUP && t4.currentState === e4.ButtonState.REST && (!function(t5) {
        t5.shouldFade = false, t5.imgGroup && e4.setElementOpacity(t5.imgGroup, 1, true);
      }(t4), t4.currentState = e4.ButtonState.GROUP), i4 >= e4.ButtonState.HOVER && t4.currentState === e4.ButtonState.GROUP && (t4.imgHover && (t4.imgHover.style.visibility = ""), t4.currentState = e4.ButtonState.HOVER), i4 >= e4.ButtonState.DOWN && t4.currentState === e4.ButtonState.HOVER && (t4.imgDown && (t4.imgDown.style.visibility = ""), t4.currentState = e4.ButtonState.DOWN));
    }
    function n3(i4, n4) {
      i4.element.disabled || (n4 <= e4.ButtonState.HOVER && i4.currentState === e4.ButtonState.DOWN && (i4.imgDown && (i4.imgDown.style.visibility = "hidden"), i4.currentState = e4.ButtonState.HOVER), n4 <= e4.ButtonState.GROUP && i4.currentState === e4.ButtonState.HOVER && (i4.imgHover && (i4.imgHover.style.visibility = "hidden"), i4.currentState = e4.ButtonState.GROUP), n4 <= e4.ButtonState.REST && i4.currentState === e4.ButtonState.GROUP && (!function(i5) {
        i5.shouldFade = true, i5.fadeBeginTime = e4.now() + i5.fadeDelay, window.setTimeout(function() {
          t3(i5);
        }, i5.fadeDelay);
      }(i4), i4.currentState = e4.ButtonState.REST));
    }
    e4.ButtonState = { REST: 0, GROUP: 1, HOVER: 2, DOWN: 3 }, e4.Button = function(t4) {
      var o2 = this;
      e4.EventSource.call(this), e4.extend(true, this, { tooltip: null, srcRest: null, srcGroup: null, srcHover: null, srcDown: null, clickTimeThreshold: e4.DEFAULT_SETTINGS.clickTimeThreshold, clickDistThreshold: e4.DEFAULT_SETTINGS.clickDistThreshold, fadeDelay: 0, fadeLength: 2e3, onPress: null, onRelease: null, onClick: null, onEnter: null, onExit: null, onFocus: null, onBlur: null, userData: null }, t4), this.element = t4.element || e4.makeNeutralElement("div"), t4.element || (this.imgRest = e4.makeTransparentImage(this.srcRest), this.imgGroup = e4.makeTransparentImage(this.srcGroup), this.imgHover = e4.makeTransparentImage(this.srcHover), this.imgDown = e4.makeTransparentImage(this.srcDown), this.imgRest.alt = this.imgGroup.alt = this.imgHover.alt = this.imgDown.alt = this.tooltip, e4.setElementPointerEventsNone(this.imgRest), e4.setElementPointerEventsNone(this.imgGroup), e4.setElementPointerEventsNone(this.imgHover), e4.setElementPointerEventsNone(this.imgDown), this.element.style.position = "relative", e4.setElementTouchActionNone(this.element), this.imgGroup.style.position = this.imgHover.style.position = this.imgDown.style.position = "absolute", this.imgGroup.style.top = this.imgHover.style.top = this.imgDown.style.top = "0px", this.imgGroup.style.left = this.imgHover.style.left = this.imgDown.style.left = "0px", this.imgHover.style.visibility = this.imgDown.style.visibility = "hidden", e4.Browser.vendor === e4.BROWSERS.FIREFOX && e4.Browser.version < 3 && (this.imgGroup.style.top = this.imgHover.style.top = this.imgDown.style.top = ""), this.element.appendChild(this.imgRest), this.element.appendChild(this.imgGroup), this.element.appendChild(this.imgHover), this.element.appendChild(this.imgDown)), this.addHandler("press", this.onPress), this.addHandler("release", this.onRelease), this.addHandler("click", this.onClick), this.addHandler("enter", this.onEnter), this.addHandler("exit", this.onExit), this.addHandler("focus", this.onFocus), this.addHandler("blur", this.onBlur), this.currentState = e4.ButtonState.GROUP, this.fadeBeginTime = null, this.shouldFade = false, this.element.style.display = "inline-block", this.element.style.position = "relative", this.element.title = this.tooltip, this.tracker = new e4.MouseTracker({ userData: "Button.tracker", element: this.element, clickTimeThreshold: this.clickTimeThreshold, clickDistThreshold: this.clickDistThreshold, enterHandler: function(t5) {
        t5.insideElementPressed ? (i3(o2, e4.ButtonState.DOWN), o2.raiseEvent("enter", { originalEvent: t5.originalEvent })) : t5.buttonDownAny || i3(o2, e4.ButtonState.HOVER);
      }, focusHandler: function(e5) {
        o2.tracker.enterHandler(e5), o2.raiseEvent("focus", { originalEvent: e5.originalEvent });
      }, leaveHandler: function(t5) {
        n3(o2, e4.ButtonState.GROUP), t5.insideElementPressed && o2.raiseEvent("exit", { originalEvent: t5.originalEvent });
      }, blurHandler: function(e5) {
        o2.tracker.leaveHandler(e5), o2.raiseEvent("blur", { originalEvent: e5.originalEvent });
      }, pressHandler: function(t5) {
        i3(o2, e4.ButtonState.DOWN), o2.raiseEvent("press", { originalEvent: t5.originalEvent });
      }, releaseHandler: function(t5) {
        t5.insideElementPressed && t5.insideElementReleased ? (n3(o2, e4.ButtonState.HOVER), o2.raiseEvent("release", { originalEvent: t5.originalEvent })) : t5.insideElementPressed ? n3(o2, e4.ButtonState.GROUP) : i3(o2, e4.ButtonState.HOVER);
      }, clickHandler: function(e5) {
        e5.quick && o2.raiseEvent("click", { originalEvent: e5.originalEvent });
      }, keyHandler: function(e5) {
        13 === e5.keyCode ? (o2.raiseEvent("click", { originalEvent: e5.originalEvent }), o2.raiseEvent("release", { originalEvent: e5.originalEvent }), e5.preventDefault = true) : e5.preventDefault = false;
      } }), n3(this, e4.ButtonState.REST);
    }, e4.extend(e4.Button.prototype, e4.EventSource.prototype, { notifyGroupEnter: function() {
      i3(this, e4.ButtonState.GROUP);
    }, notifyGroupExit: function() {
      n3(this, e4.ButtonState.REST);
    }, disable: function() {
      this.notifyGroupExit(), this.element.disabled = true, this.tracker.setTracking(false), e4.setElementOpacity(this.element, 0.2, true);
    }, enable: function() {
      this.element.disabled = false, this.tracker.setTracking(true), e4.setElementOpacity(this.element, 1, true), this.notifyGroupEnter();
    }, destroy: function() {
      this.imgRest && (this.element.removeChild(this.imgRest), this.imgRest = null), this.imgGroup && (this.element.removeChild(this.imgGroup), this.imgGroup = null), this.imgHover && (this.element.removeChild(this.imgHover), this.imgHover = null), this.imgDown && (this.element.removeChild(this.imgDown), this.imgDown = null), this.removeAllHandlers(), this.tracker.destroy(), this.element = null;
    } });
  }(t2), function(e4) {
    e4.ButtonGroup = function(t3) {
      e4.extend(true, this, { buttons: [], clickTimeThreshold: e4.DEFAULT_SETTINGS.clickTimeThreshold, clickDistThreshold: e4.DEFAULT_SETTINGS.clickDistThreshold, labelText: "" }, t3);
      var i3, n3 = this.buttons.concat([]), o2 = this;
      if (this.element = t3.element || e4.makeNeutralElement("div"), !t3.group)
        for (this.element.style.display = "inline-block", i3 = 0; i3 < n3.length; i3++)
          this.element.appendChild(n3[i3].element);
      e4.setElementTouchActionNone(this.element), this.tracker = new e4.MouseTracker({ userData: "ButtonGroup.tracker", element: this.element, clickTimeThreshold: this.clickTimeThreshold, clickDistThreshold: this.clickDistThreshold, enterHandler: function(e5) {
        var t4;
        for (t4 = 0; t4 < o2.buttons.length; t4++)
          o2.buttons[t4].notifyGroupEnter();
      }, leaveHandler: function(e5) {
        var t4;
        if (!e5.insideElementPressed)
          for (t4 = 0; t4 < o2.buttons.length; t4++)
            o2.buttons[t4].notifyGroupExit();
      } });
    }, e4.ButtonGroup.prototype = { addButton: function(e5) {
      this.buttons.push(e5), this.element.appendChild(e5.element);
    }, emulateEnter: function() {
      this.tracker.enterHandler({ eventSource: this.tracker });
    }, emulateLeave: function() {
      this.tracker.leaveHandler({ eventSource: this.tracker });
    }, destroy: function() {
      for (; this.buttons.length; ) {
        var e5 = this.buttons.pop();
        this.element.removeChild(e5.element), e5.destroy();
      }
      this.tracker.destroy(), this.element = null;
    } };
  }(t2), function(e4) {
    e4.Rect = function(t3, i3, n3, o2, r2) {
      var s2, a2;
      this.x = "number" == typeof t3 ? t3 : 0, this.y = "number" == typeof i3 ? i3 : 0, this.width = "number" == typeof n3 ? n3 : 0, this.height = "number" == typeof o2 ? o2 : 0, this.degrees = "number" == typeof r2 ? r2 : 0, this.degrees = e4.positiveModulo(this.degrees, 360), this.degrees >= 270 ? (s2 = this.getTopRight(), this.x = s2.x, this.y = s2.y, a2 = this.height, this.height = this.width, this.width = a2, this.degrees -= 270) : this.degrees >= 180 ? (s2 = this.getBottomRight(), this.x = s2.x, this.y = s2.y, this.degrees -= 180) : this.degrees >= 90 && (s2 = this.getBottomLeft(), this.x = s2.x, this.y = s2.y, a2 = this.height, this.height = this.width, this.width = a2, this.degrees -= 90);
    }, e4.Rect.fromSummits = function(t3, i3, n3) {
      var o2 = t3.distanceTo(i3), r2 = t3.distanceTo(n3), s2 = i3.minus(t3), a2 = Math.atan(s2.y / s2.x);
      return s2.x < 0 ? a2 += Math.PI : s2.y < 0 && (a2 += 2 * Math.PI), new e4.Rect(t3.x, t3.y, o2, r2, a2 / Math.PI * 180);
    }, e4.Rect.prototype = { clone: function() {
      return new e4.Rect(this.x, this.y, this.width, this.height, this.degrees);
    }, getAspectRatio: function() {
      return this.width / this.height;
    }, getTopLeft: function() {
      return new e4.Point(this.x, this.y);
    }, getBottomRight: function() {
      return new e4.Point(this.x + this.width, this.y + this.height).rotate(this.degrees, this.getTopLeft());
    }, getTopRight: function() {
      return new e4.Point(this.x + this.width, this.y).rotate(this.degrees, this.getTopLeft());
    }, getBottomLeft: function() {
      return new e4.Point(this.x, this.y + this.height).rotate(this.degrees, this.getTopLeft());
    }, getCenter: function() {
      return new e4.Point(this.x + this.width / 2, this.y + this.height / 2).rotate(this.degrees, this.getTopLeft());
    }, getSize: function() {
      return new e4.Point(this.width, this.height);
    }, equals: function(t3) {
      return t3 instanceof e4.Rect && this.x === t3.x && this.y === t3.y && this.width === t3.width && this.height === t3.height && this.degrees === t3.degrees;
    }, times: function(t3) {
      return new e4.Rect(this.x * t3, this.y * t3, this.width * t3, this.height * t3, this.degrees);
    }, translate: function(t3) {
      return new e4.Rect(this.x + t3.x, this.y + t3.y, this.width, this.height, this.degrees);
    }, union: function(t3) {
      var i3 = this.getBoundingBox(), n3 = t3.getBoundingBox(), o2 = Math.min(i3.x, n3.x), r2 = Math.min(i3.y, n3.y), s2 = Math.max(i3.x + i3.width, n3.x + n3.width), a2 = Math.max(i3.y + i3.height, n3.y + n3.height);
      return new e4.Rect(o2, r2, s2 - o2, a2 - r2);
    }, intersection: function(t3) {
      var i3 = 1e-10, n3 = [], o2 = this.getTopLeft();
      t3.containsPoint(o2, i3) && n3.push(o2);
      var r2 = this.getTopRight();
      t3.containsPoint(r2, i3) && n3.push(r2);
      var s2 = this.getBottomLeft();
      t3.containsPoint(s2, i3) && n3.push(s2);
      var a2 = this.getBottomRight();
      t3.containsPoint(a2, i3) && n3.push(a2);
      var l2 = t3.getTopLeft();
      this.containsPoint(l2, i3) && n3.push(l2);
      var c2 = t3.getTopRight();
      this.containsPoint(c2, i3) && n3.push(c2);
      var h2 = t3.getBottomLeft();
      this.containsPoint(h2, i3) && n3.push(h2);
      var u2 = t3.getBottomRight();
      this.containsPoint(u2, i3) && n3.push(u2);
      for (var d2 = this._getSegments(), p2 = t3._getSegments(), _2 = 0; _2 < d2.length; _2++)
        for (var g2 = d2[_2], m2 = 0; m2 < p2.length; m2++) {
          var f2 = p2[m2], v2 = A2(g2[0], g2[1], f2[0], f2[1]);
          v2 && n3.push(v2);
        }
      function A2(t4, n4, o3, r3) {
        var s3 = n4.minus(t4), a3 = r3.minus(o3), l3 = -a3.x * s3.y + s3.x * a3.y;
        if (0 === l3)
          return null;
        var c3 = (s3.x * (t4.y - o3.y) - s3.y * (t4.x - o3.x)) / l3, h3 = (a3.x * (t4.y - o3.y) - a3.y * (t4.x - o3.x)) / l3;
        return -1e-10 <= c3 && c3 <= 1 - i3 && -1e-10 <= h3 && h3 <= 1 - i3 ? new e4.Point(t4.x + h3 * s3.x, t4.y + h3 * s3.y) : null;
      }
      if (0 === n3.length)
        return null;
      for (var b2 = n3[0].x, y2 = n3[0].x, w2 = n3[0].y, x2 = n3[0].y, C2 = 1; C2 < n3.length; C2++) {
        var S2 = n3[C2];
        S2.x < b2 && (b2 = S2.x), S2.x > y2 && (y2 = S2.x), S2.y < w2 && (w2 = S2.y), S2.y > x2 && (x2 = S2.y);
      }
      return new e4.Rect(b2, w2, y2 - b2, x2 - w2);
    }, _getSegments: function() {
      var e5 = this.getTopLeft(), t3 = this.getTopRight(), i3 = this.getBottomLeft(), n3 = this.getBottomRight();
      return [[e5, t3], [t3, n3], [n3, i3], [i3, e5]];
    }, rotate: function(t3, i3) {
      if (0 === (t3 = e4.positiveModulo(t3, 360)))
        return this.clone();
      i3 = i3 || this.getCenter();
      var n3 = this.getTopLeft().rotate(t3, i3), o2 = this.getTopRight().rotate(t3, i3).minus(n3);
      o2 = o2.apply(function(e5) {
        return Math.abs(e5) < 1e-15 ? 0 : e5;
      });
      var r2 = Math.atan(o2.y / o2.x);
      return o2.x < 0 ? r2 += Math.PI : o2.y < 0 && (r2 += 2 * Math.PI), new e4.Rect(n3.x, n3.y, this.width, this.height, r2 / Math.PI * 180);
    }, getBoundingBox: function() {
      if (0 === this.degrees)
        return this.clone();
      var t3 = this.getTopLeft(), i3 = this.getTopRight(), n3 = this.getBottomLeft(), o2 = this.getBottomRight(), r2 = Math.min(t3.x, i3.x, n3.x, o2.x), s2 = Math.max(t3.x, i3.x, n3.x, o2.x), a2 = Math.min(t3.y, i3.y, n3.y, o2.y), l2 = Math.max(t3.y, i3.y, n3.y, o2.y);
      return new e4.Rect(r2, a2, s2 - r2, l2 - a2);
    }, getIntegerBoundingBox: function() {
      var t3 = this.getBoundingBox(), i3 = Math.floor(t3.x), n3 = Math.floor(t3.y), o2 = Math.ceil(t3.width + t3.x - i3), r2 = Math.ceil(t3.height + t3.y - n3);
      return new e4.Rect(i3, n3, o2, r2);
    }, containsPoint: function(e5, t3) {
      t3 = t3 || 0;
      var i3 = this.getTopLeft(), n3 = this.getTopRight(), o2 = this.getBottomLeft(), r2 = n3.minus(i3), s2 = o2.minus(i3);
      return (e5.x - i3.x) * r2.x + (e5.y - i3.y) * r2.y >= -t3 && (e5.x - n3.x) * r2.x + (e5.y - n3.y) * r2.y <= t3 && (e5.x - i3.x) * s2.x + (e5.y - i3.y) * s2.y >= -t3 && (e5.x - o2.x) * s2.x + (e5.y - o2.y) * s2.y <= t3;
    }, toString: function() {
      return "[" + Math.round(100 * this.x) / 100 + ", " + Math.round(100 * this.y) / 100 + ", " + Math.round(100 * this.width) / 100 + "x" + Math.round(100 * this.height) / 100 + ", " + Math.round(100 * this.degrees) / 100 + "deg]";
    } };
  }(t2), function(e4) {
    var t3 = {};
    function i3(e5) {
      var t4;
      e5.quick && (t4 = "horizontal" === this.scroll ? Math.floor(e5.position.x / (this.panelWidth + 4)) : Math.floor(e5.position.y / this.panelHeight), this.viewer.goToPage(t4));
      this.element.focus();
    }
    function n3(t4) {
      if (this.dragging = true, this.element) {
        var i4 = Number(this.element.style.marginLeft.replace("px", "")), n4 = Number(this.element.style.marginTop.replace("px", "")), o3 = Number(this.element.style.width.replace("px", "")), s3 = Number(this.element.style.height.replace("px", "")), a3 = e4.getElementSize(this.viewer.canvas);
        "horizontal" === this.scroll ? -t4.delta.x > 0 ? i4 > -(o3 - a3.x) && (this.element.style.marginLeft = i4 + 2 * t4.delta.x + "px", r2(this, a3.x, i4 + 2 * t4.delta.x)) : -t4.delta.x < 0 && i4 < 0 && (this.element.style.marginLeft = i4 + 2 * t4.delta.x + "px", r2(this, a3.x, i4 + 2 * t4.delta.x)) : -t4.delta.y > 0 ? n4 > -(s3 - a3.y) && (this.element.style.marginTop = n4 + 2 * t4.delta.y + "px", r2(this, a3.y, n4 + 2 * t4.delta.y)) : -t4.delta.y < 0 && n4 < 0 && (this.element.style.marginTop = n4 + 2 * t4.delta.y + "px", r2(this, a3.y, n4 + 2 * t4.delta.y));
      }
    }
    function o2(t4) {
      if (this.element) {
        var i4 = Number(this.element.style.marginLeft.replace("px", "")), n4 = Number(this.element.style.marginTop.replace("px", "")), o3 = Number(this.element.style.width.replace("px", "")), s3 = Number(this.element.style.height.replace("px", "")), a3 = e4.getElementSize(this.viewer.canvas);
        "horizontal" === this.scroll ? t4.scroll > 0 ? i4 > -(o3 - a3.x) && (this.element.style.marginLeft = i4 - 60 * t4.scroll + "px", r2(this, a3.x, i4 - 60 * t4.scroll)) : t4.scroll < 0 && i4 < 0 && (this.element.style.marginLeft = i4 - 60 * t4.scroll + "px", r2(this, a3.x, i4 - 60 * t4.scroll)) : t4.scroll < 0 ? n4 > a3.y - s3 && (this.element.style.marginTop = n4 + 60 * t4.scroll + "px", r2(this, a3.y, n4 + 60 * t4.scroll)) : t4.scroll > 0 && n4 < 0 && (this.element.style.marginTop = n4 + 60 * t4.scroll + "px", r2(this, a3.y, n4 + 60 * t4.scroll)), t4.preventDefault = true;
      }
    }
    function r2(t4, i4, n4) {
      var o3, r3, s3, a3, l3, c3;
      for (o3 = "horizontal" === t4.scroll ? t4.panelWidth : t4.panelHeight, r3 = Math.ceil(i4 / o3) + 5, l3 = r3 = (r3 = (s3 = Math.ceil((Math.abs(n4) + i4) / o3) + 1) - r3) < 0 ? 0 : r3; l3 < s3 && l3 < t4.panels.length; l3++)
        if (!(c3 = t4.panels[l3]).activePanel) {
          var h2, u2 = t4.viewer.tileSources[l3];
          h2 = u2.referenceStripThumbnailUrl ? { type: "image", url: u2.referenceStripThumbnailUrl } : u2, a3 = new e4.Viewer({ id: c3.id, tileSources: [h2], element: c3, navigatorSizeRatio: t4.sizeRatio, showNavigator: false, mouseNavEnabled: false, showNavigationControl: false, showSequenceControl: false, immediateRender: true, blendTime: 0, animationTime: 0, loadTilesWithAjax: t4.viewer.loadTilesWithAjax, ajaxHeaders: t4.viewer.ajaxHeaders, useCanvas: t4.useCanvas }), e4.setElementPointerEventsNone(a3.canvas), e4.setElementPointerEventsNone(a3.container), a3.innerTracker.setTracking(false), a3.outerTracker.setTracking(false), t4.miniViewers[c3.id] = a3, c3.activePanel = true;
        }
    }
    function s2(e5) {
      var t4 = e5.eventSource.element;
      "horizontal" === this.scroll ? t4.style.marginBottom = "0px" : t4.style.marginLeft = "0px";
    }
    function a2(t4) {
      var i4 = t4.eventSource.element;
      "horizontal" === this.scroll ? i4.style.marginBottom = "-" + e4.getElementSize(i4).y / 2 + "px" : i4.style.marginLeft = "-" + e4.getElementSize(i4).x / 2 + "px";
    }
    function l2(e5) {
      if (e5.ctrl || e5.alt || e5.meta)
        e5.preventDefault = false;
      else
        switch (e5.keyCode) {
          case 38:
          case 39:
            o2.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null }), e5.preventDefault = true;
            break;
          case 40:
          case 37:
            o2.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null }), e5.preventDefault = true;
            break;
          default:
            e5.preventDefault = false;
        }
    }
    function c2(e5) {
      if (e5.ctrl || e5.alt || e5.meta)
        e5.preventDefault = false;
      else
        switch (e5.keyCode) {
          case 61:
          case 48:
          case 119:
          case 87:
          case 100:
            o2.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null }), e5.preventDefault = true;
            break;
          case 45:
          case 115:
          case 83:
          case 97:
            o2.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null }), e5.preventDefault = true;
            break;
          default:
            e5.preventDefault = false;
        }
    }
    e4.ReferenceStrip = function(h2) {
      var u2, d2, p2, _2 = h2.viewer, g2 = e4.getElementSize(_2.element);
      for (h2.id || (h2.id = "referencestrip-" + e4.now(), this.element = e4.makeNeutralElement("div"), this.element.id = h2.id, this.element.className = "referencestrip"), h2 = e4.extend(true, { sizeRatio: e4.DEFAULT_SETTINGS.referenceStripSizeRatio, position: e4.DEFAULT_SETTINGS.referenceStripPosition, scroll: e4.DEFAULT_SETTINGS.referenceStripScroll, clickTimeThreshold: e4.DEFAULT_SETTINGS.clickTimeThreshold }, h2, { element: this.element }), e4.extend(this, h2), t3[this.id] = { animating: false }, this.minPixelRatio = this.viewer.minPixelRatio, this.element.tabIndex = 0, (d2 = this.element.style).marginTop = "0px", d2.marginRight = "0px", d2.marginBottom = "0px", d2.marginLeft = "0px", d2.left = "0px", d2.bottom = "0px", d2.border = "0px", d2.background = "#000", d2.position = "relative", e4.setElementTouchActionNone(this.element), e4.setElementOpacity(this.element, 0.8), this.viewer = _2, this.tracker = new e4.MouseTracker({ userData: "ReferenceStrip.tracker", element: this.element, clickHandler: e4.delegate(this, i3), dragHandler: e4.delegate(this, n3), scrollHandler: e4.delegate(this, o2), enterHandler: e4.delegate(this, s2), leaveHandler: e4.delegate(this, a2), keyDownHandler: e4.delegate(this, l2), keyHandler: e4.delegate(this, c2), preProcessEventHandler: function(e5) {
        "wheel" === e5.eventType && (e5.preventDefault = true);
      } }), h2.width && h2.height ? (this.element.style.width = h2.width + "px", this.element.style.height = h2.height + "px", _2.addControl(this.element, { anchor: e4.ControlAnchor.BOTTOM_LEFT })) : "horizontal" === h2.scroll ? (this.element.style.width = g2.x * h2.sizeRatio * _2.tileSources.length + 12 * _2.tileSources.length + "px", this.element.style.height = g2.y * h2.sizeRatio + "px", _2.addControl(this.element, { anchor: e4.ControlAnchor.BOTTOM_LEFT })) : (this.element.style.height = g2.y * h2.sizeRatio * _2.tileSources.length + 12 * _2.tileSources.length + "px", this.element.style.width = g2.x * h2.sizeRatio + "px", _2.addControl(this.element, { anchor: e4.ControlAnchor.TOP_LEFT })), this.panelWidth = g2.x * this.sizeRatio + 8, this.panelHeight = g2.y * this.sizeRatio + 8, this.panels = [], this.miniViewers = {}, p2 = 0; p2 < _2.tileSources.length; p2++)
        (u2 = e4.makeNeutralElement("div")).id = this.element.id + "-" + p2, u2.style.width = this.panelWidth + "px", u2.style.height = this.panelHeight + "px", u2.style.display = "inline", u2.style.float = "left", u2.style.cssFloat = "left", u2.style.styleFloat = "left", u2.style.padding = "2px", e4.setElementTouchActionNone(u2), e4.setElementPointerEventsNone(u2), this.element.appendChild(u2), u2.activePanel = false, this.panels.push(u2);
      r2(this, "vertical" === this.scroll ? g2.y : g2.x, 0), this.setFocus(0);
    }, e4.ReferenceStrip.prototype = { setFocus: function(t4) {
      var i4, n4 = this.element.querySelector("#" + this.element.id + "-" + t4), o3 = e4.getElementSize(this.viewer.canvas), a3 = Number(this.element.style.width.replace("px", "")), l3 = Number(this.element.style.height.replace("px", "")), c3 = -Number(this.element.style.marginLeft.replace("px", "")), h2 = -Number(this.element.style.marginTop.replace("px", ""));
      this.currentSelected !== n4 && (this.currentSelected && (this.currentSelected.style.background = "#000"), this.currentSelected = n4, this.currentSelected.style.background = "#999", "horizontal" === this.scroll ? (i4 = Number(t4) * (this.panelWidth + 3)) > c3 + o3.x - this.panelWidth ? (i4 = Math.min(i4, a3 - o3.x), this.element.style.marginLeft = -i4 + "px", r2(this, o3.x, -i4)) : i4 < c3 && (i4 = Math.max(0, i4 - o3.x / 2), this.element.style.marginLeft = -i4 + "px", r2(this, o3.x, -i4)) : (i4 = Number(t4) * (this.panelHeight + 3)) > h2 + o3.y - this.panelHeight ? (i4 = Math.min(i4, l3 - o3.y), this.element.style.marginTop = -i4 + "px", r2(this, o3.y, -i4)) : i4 < h2 && (i4 = Math.max(0, i4 - o3.y / 2), this.element.style.marginTop = -i4 + "px", r2(this, o3.y, -i4)), this.currentPage = t4, s2.call(this, { eventSource: this.tracker }));
    }, update: function() {
      return !!t3[this.id].animating;
    }, destroy: function() {
      if (this.miniViewers)
        for (var e5 in this.miniViewers)
          this.miniViewers[e5].destroy();
      this.tracker.destroy(), this.element && this.viewer.removeControl(this.element);
    } };
  }(t2), function(e4) {
    e4.DisplayRect = function(t3, i3, n3, o2, r2, s2) {
      e4.Rect.apply(this, [t3, i3, n3, o2]), this.minLevel = r2, this.maxLevel = s2;
    }, e4.extend(e4.DisplayRect.prototype, e4.Rect.prototype);
  }(t2), function(e4) {
    e4.Spring = function(t3) {
      var i3 = arguments;
      "object" != typeof t3 && (t3 = { initial: i3.length && "number" == typeof i3[0] ? i3[0] : void 0, springStiffness: i3.length > 1 ? i3[1].springStiffness : 5, animationTime: i3.length > 1 ? i3[1].animationTime : 1.5 }), e4.console.assert("number" == typeof t3.springStiffness && 0 !== t3.springStiffness, "[OpenSeadragon.Spring] options.springStiffness must be a non-zero number"), e4.console.assert("number" == typeof t3.animationTime && t3.animationTime >= 0, "[OpenSeadragon.Spring] options.animationTime must be a number greater than or equal to 0"), t3.exponential && (this._exponential = true, delete t3.exponential), e4.extend(true, this, t3), this.current = { value: "number" == typeof this.initial ? this.initial : this._exponential ? 0 : 1, time: e4.now() }, e4.console.assert(!this._exponential || 0 !== this.current.value, "[OpenSeadragon.Spring] value must be non-zero for exponential springs"), this.start = { value: this.current.value, time: this.current.time }, this.target = { value: this.current.value, time: this.current.time }, this._exponential && (this.start._logValue = Math.log(this.start.value), this.target._logValue = Math.log(this.target.value), this.current._logValue = Math.log(this.current.value));
    }, e4.Spring.prototype = { resetTo: function(t3) {
      e4.console.assert(!this._exponential || 0 !== t3, "[OpenSeadragon.Spring.resetTo] target must be non-zero for exponential springs"), this.start.value = this.target.value = this.current.value = t3, this.start.time = this.target.time = this.current.time = e4.now(), this._exponential && (this.start._logValue = Math.log(this.start.value), this.target._logValue = Math.log(this.target.value), this.current._logValue = Math.log(this.current.value));
    }, springTo: function(t3) {
      e4.console.assert(!this._exponential || 0 !== t3, "[OpenSeadragon.Spring.springTo] target must be non-zero for exponential springs"), this.start.value = this.current.value, this.start.time = this.current.time, this.target.value = t3, this.target.time = this.start.time + 1e3 * this.animationTime, this._exponential && (this.start._logValue = Math.log(this.start.value), this.target._logValue = Math.log(this.target.value));
    }, shiftBy: function(t3) {
      this.start.value += t3, this.target.value += t3, this._exponential && (e4.console.assert(0 !== this.target.value && 0 !== this.start.value, "[OpenSeadragon.Spring.shiftBy] spring value must be non-zero for exponential springs"), this.start._logValue = Math.log(this.start.value), this.target._logValue = Math.log(this.target.value));
    }, setExponential: function(t3) {
      this._exponential = t3, this._exponential && (e4.console.assert(0 !== this.current.value && 0 !== this.target.value && 0 !== this.start.value, "[OpenSeadragon.Spring.setExponential] spring value must be non-zero for exponential springs"), this.start._logValue = Math.log(this.start.value), this.target._logValue = Math.log(this.target.value), this.current._logValue = Math.log(this.current.value));
    }, update: function() {
      var t3, i3;
      this.current.time = e4.now(), this._exponential ? (t3 = this.start._logValue, i3 = this.target._logValue) : (t3 = this.start.value, i3 = this.target.value);
      var n3 = this.current.time >= this.target.time ? i3 : t3 + (i3 - t3) * function(e5, t4) {
        return (1 - Math.exp(e5 * -t4)) / (1 - Math.exp(-e5));
      }(this.springStiffness, (this.current.time - this.start.time) / (this.target.time - this.start.time)), o2 = this.current.value;
      return this._exponential ? this.current.value = Math.exp(n3) : this.current.value = n3, o2 !== this.current.value;
    }, isAtTargetValue: function() {
      return this.current.value === this.target.value;
    } };
  }(t2), function(e4) {
    e4.ImageJob = function(t3) {
      e4.extend(true, this, { timeout: e4.DEFAULT_SETTINGS.timeout, jobId: null, tries: 0 }, t3), this.data = null, this.userData = {}, this.errorMsg = null;
    }, e4.ImageJob.prototype = { start: function() {
      this.tries++;
      var e5 = this, t3 = this.abort;
      this.jobId = window.setTimeout(function() {
        e5.finish(null, null, "Image load exceeded timeout (" + e5.timeout + " ms)");
      }, this.timeout), this.abort = function() {
        e5.source.downloadTileAbort(e5), "function" == typeof t3 && t3();
      }, this.source.downloadTileStart(this);
    }, finish: function(e5, t3, i3) {
      this.data = e5, this.request = t3, this.errorMsg = i3, this.jobId && window.clearTimeout(this.jobId), this.callback(this);
    } }, e4.ImageLoader = function(t3) {
      e4.extend(true, this, { jobLimit: e4.DEFAULT_SETTINGS.imageLoaderLimit, timeout: e4.DEFAULT_SETTINGS.timeout, jobQueue: [], failedTiles: [], jobsInProgress: 0 }, t3);
    }, e4.ImageLoader.prototype = { addJob: function(t3) {
      if (!t3.source) {
        e4.console.error("ImageLoader.prototype.addJob() requires [options.source]. TileSource since new API defines how images are fetched. Creating a dummy TileSource.");
        var i3 = e4.TileSource.prototype;
        t3.source = { downloadTileStart: i3.downloadTileStart, downloadTileAbort: i3.downloadTileAbort };
      }
      var n3 = this, o2 = { src: t3.src, tile: t3.tile || {}, source: t3.source, loadWithAjax: t3.loadWithAjax, ajaxHeaders: t3.loadWithAjax ? t3.ajaxHeaders : null, crossOriginPolicy: t3.crossOriginPolicy, ajaxWithCredentials: t3.ajaxWithCredentials, postData: t3.postData, callback: function(e5) {
        !function(e6, t4, i4) {
          "" !== t4.errorMsg && (null === t4.data || void 0 === t4.data) && t4.tries < 1 + e6.tileRetryMax && e6.failedTiles.push(t4);
          var n4;
          e6.jobsInProgress--, (!e6.jobLimit || e6.jobsInProgress < e6.jobLimit) && e6.jobQueue.length > 0 && ((n4 = e6.jobQueue.shift()).start(), e6.jobsInProgress++);
          e6.tileRetryMax > 0 && 0 === e6.jobQueue.length && (!e6.jobLimit || e6.jobsInProgress < e6.jobLimit) && e6.failedTiles.length > 0 && (n4 = e6.failedTiles.shift(), setTimeout(function() {
            n4.start();
          }, e6.tileRetryDelay), e6.jobsInProgress++);
          i4(t4.data, t4.errorMsg, t4.request);
        }(n3, e5, t3.callback);
      }, abort: t3.abort, timeout: this.timeout }, r2 = new e4.ImageJob(o2);
      !this.jobLimit || this.jobsInProgress < this.jobLimit ? (r2.start(), this.jobsInProgress++) : this.jobQueue.push(r2);
    }, clear: function() {
      for (var e5 = 0; e5 < this.jobQueue.length; e5++) {
        var t3 = this.jobQueue[e5];
        "function" == typeof t3.abort && t3.abort();
      }
      this.jobQueue = [];
    } };
  }(t2), function(e4) {
    e4.Tile = function(t3, i3, n3, o2, r2, s2, a2, l2, c2, h2, u2, d2) {
      this.level = t3, this.x = i3, this.y = n3, this.bounds = o2, this.sourceBounds = h2, this.exists = r2, this._url = s2, this.postData = u2, this.context2D = a2, this.loadWithAjax = l2, this.ajaxHeaders = c2, void 0 === d2 && (e4.console.warn("Tile constructor needs 'cacheKey' variable: creation tile cache in Tile class is deprecated. TileSource.prototype.getTileHashKey will be used."), d2 = e4.TileSource.prototype.getTileHashKey(t3, i3, n3, s2, c2, u2)), this.cacheKey = d2, this.loaded = false, this.loading = false, this.element = null, this.imgElement = null, this.style = null, this.position = null, this.size = null, this.flipped = false, this.blendStart = null, this.opacity = null, this.squaredDistance = null, this.visibility = null, this.hasTransparency = false, this.beingDrawn = false, this.lastTouchTime = 0, this.isRightMost = false, this.isBottomMost = false;
    }, e4.Tile.prototype = { toString: function() {
      return this.level + "/" + this.x + "_" + this.y;
    }, _hasTransparencyChannel: function() {
      return console.warn("Tile.prototype._hasTransparencyChannel() has been deprecated and will be removed in the future. Use TileSource.prototype.hasTransparency() instead."), !!this.context2D || this.getUrl().match(".png");
    }, drawHTML: function(t3) {
      if (this.cacheImageRecord)
        if (this.loaded) {
          if (!this.element) {
            var i3 = this.getImage();
            if (!i3)
              return;
            this.element = e4.makeNeutralElement("div"), this.imgElement = i3.cloneNode(), this.imgElement.style.msInterpolationMode = "nearest-neighbor", this.imgElement.style.width = "100%", this.imgElement.style.height = "100%", this.style = this.element.style, this.style.position = "absolute";
          }
          this.element.parentNode !== t3 && t3.appendChild(this.element), this.imgElement.parentNode !== this.element && this.element.appendChild(this.imgElement), this.style.top = this.position.y + "px", this.style.left = this.position.x + "px", this.style.height = this.size.y + "px", this.style.width = this.size.x + "px", this.flipped && (this.style.transform = "scaleX(-1)"), e4.setElementOpacity(this.element, this.opacity);
        } else
          e4.console.warn("Attempting to draw tile %s when it's not yet loaded.", this.toString());
      else
        e4.console.warn("[Tile.drawHTML] attempting to draw tile %s when it's not cached", this.toString());
    }, get image() {
      return e4.console.error("[Tile.image] property has been deprecated. Use [Tile.prototype.getImage] instead."), this.getImage();
    }, get url() {
      return e4.console.error("[Tile.url] property has been deprecated. Use [Tile.prototype.getUrl] instead."), this.getUrl();
    }, getImage: function() {
      return this.cacheImageRecord.getImage();
    }, getUrl: function() {
      return "function" == typeof this._url ? this._url() : this._url;
    }, getCanvasContext: function() {
      return this.context2D || this.cacheImageRecord.getRenderedContext();
    }, drawCanvas: function(t3, i3, n3, o2, r2, s2) {
      var a2, l2, c2, h2 = this.position.times(e4.pixelDensityRatio), u2 = this.size.times(e4.pixelDensityRatio);
      this.context2D || this.cacheImageRecord ? (a2 = this.getCanvasContext(), this.loaded && a2 ? (t3.save(), t3.globalAlpha = this.opacity, "number" == typeof n3 && 1 !== n3 && (h2 = h2.times(n3), u2 = u2.times(n3)), o2 instanceof e4.Point && (h2 = h2.plus(o2)), 1 === t3.globalAlpha && this.hasTransparency && (r2 && (h2.x = Math.round(h2.x), h2.y = Math.round(h2.y), u2.x = Math.round(u2.x), u2.y = Math.round(u2.y)), t3.clearRect(h2.x, h2.y, u2.x, u2.y)), i3({ context: t3, tile: this, rendered: a2 }), this.sourceBounds ? (l2 = Math.min(this.sourceBounds.width, a2.canvas.width), c2 = Math.min(this.sourceBounds.height, a2.canvas.height)) : (l2 = a2.canvas.width, c2 = a2.canvas.height), t3.translate(h2.x + u2.x / 2, 0), this.flipped && t3.scale(-1, 1), t3.drawImage(a2.canvas, 0, 0, l2, c2, -u2.x / 2, h2.y, u2.x, u2.y), t3.restore()) : e4.console.warn("Attempting to draw tile %s when it's not yet loaded.", this.toString())) : e4.console.warn("[Tile.drawCanvas] attempting to draw tile %s when it's not cached", this.toString());
    }, getScaleForEdgeSmoothing: function() {
      var t3;
      if (this.cacheImageRecord)
        t3 = this.cacheImageRecord.getRenderedContext();
      else {
        if (!this.context2D)
          return e4.console.warn("[Tile.drawCanvas] attempting to get tile scale %s when tile's not cached", this.toString()), 1;
        t3 = this.context2D;
      }
      return t3.canvas.width / (this.size.x * e4.pixelDensityRatio);
    }, getTranslationForEdgeSmoothing: function(t3, i3, n3) {
      var o2 = Math.max(1, Math.ceil((n3.x - i3.x) / 2)), r2 = Math.max(1, Math.ceil((n3.y - i3.y) / 2));
      return new e4.Point(o2, r2).minus(this.position.times(e4.pixelDensityRatio).times(t3 || 1).apply(function(e5) {
        return e5 % 1;
      }));
    }, unload: function() {
      this.imgElement && this.imgElement.parentNode && this.imgElement.parentNode.removeChild(this.imgElement), this.element && this.element.parentNode && this.element.parentNode.removeChild(this.element), this.element = null, this.imgElement = null, this.loaded = false, this.loading = false;
    } };
  }(t2), function(e4) {
    e4.OverlayPlacement = e4.Placement, e4.OverlayRotationMode = e4.freezeObject({ NO_ROTATION: 1, EXACT: 2, BOUNDING_BOX: 3 }), e4.Overlay = function(t3, i3, n3) {
      var o2;
      o2 = e4.isPlainObject(t3) ? t3 : { element: t3, location: i3, placement: n3 }, this.element = o2.element, this.style = o2.element.style, this._init(o2);
    }, e4.Overlay.prototype = { _init: function(t3) {
      this.location = t3.location, this.placement = void 0 === t3.placement ? e4.Placement.TOP_LEFT : t3.placement, this.onDraw = t3.onDraw, this.checkResize = void 0 === t3.checkResize || t3.checkResize, this.width = void 0 === t3.width ? null : t3.width, this.height = void 0 === t3.height ? null : t3.height, this.rotationMode = t3.rotationMode || e4.OverlayRotationMode.EXACT, this.location instanceof e4.Rect && (this.width = this.location.width, this.height = this.location.height, this.location = this.location.getTopLeft(), this.placement = e4.Placement.TOP_LEFT), this.scales = null !== this.width && null !== this.height, this.bounds = new e4.Rect(this.location.x, this.location.y, this.width, this.height), this.position = this.location;
    }, adjust: function(t3, i3) {
      var n3 = e4.Placement.properties[this.placement];
      n3 && (n3.isHorizontallyCentered ? t3.x -= i3.x / 2 : n3.isRight && (t3.x -= i3.x), n3.isVerticallyCentered ? t3.y -= i3.y / 2 : n3.isBottom && (t3.y -= i3.y));
    }, destroy: function() {
      var t3 = this.element, i3 = this.style;
      t3.parentNode && (t3.parentNode.removeChild(t3), t3.prevElementParent && (i3.display = "none", document.body.appendChild(t3))), this.onDraw = null, i3.top = "", i3.left = "", i3.position = "", null !== this.width && (i3.width = ""), null !== this.height && (i3.height = "");
      var n3 = e4.getCssPropertyWithVendorPrefix("transformOrigin"), o2 = e4.getCssPropertyWithVendorPrefix("transform");
      n3 && o2 && (i3[n3] = "", i3[o2] = "");
    }, drawHTML: function(t3, i3) {
      var n3 = this.element;
      n3.parentNode !== t3 && (n3.prevElementParent = n3.parentNode, n3.prevNextSibling = n3.nextSibling, t3.appendChild(n3), this.style.position = "absolute", this.size = e4.getElementSize(n3));
      var o2 = this._getOverlayPositionAndSize(i3), r2 = o2.position, s2 = this.size = o2.size, a2 = o2.rotate;
      if (this.onDraw)
        this.onDraw(r2, s2, this.element);
      else {
        var l2 = this.style;
        l2.left = r2.x + "px", l2.top = r2.y + "px", null !== this.width && (l2.width = s2.x + "px"), null !== this.height && (l2.height = s2.y + "px");
        var c2 = e4.getCssPropertyWithVendorPrefix("transformOrigin"), h2 = e4.getCssPropertyWithVendorPrefix("transform");
        c2 && h2 && (a2 ? (l2[c2] = this._getTransformOrigin(), l2[h2] = "rotate(" + a2 + "deg)") : (l2[c2] = "", l2[h2] = "")), l2.display = "block";
      }
    }, _getOverlayPositionAndSize: function(t3) {
      var i3 = t3.pixelFromPoint(this.location, true), n3 = this._getSizeInPixels(t3);
      this.adjust(i3, n3);
      var o2 = 0;
      if (t3.getRotation(true) && this.rotationMode !== e4.OverlayRotationMode.NO_ROTATION)
        if (this.rotationMode === e4.OverlayRotationMode.BOUNDING_BOX && null !== this.width && null !== this.height) {
          var r2 = new e4.Rect(i3.x, i3.y, n3.x, n3.y), s2 = this._getBoundingBox(r2, t3.getRotation(true));
          i3 = s2.getTopLeft(), n3 = s2.getSize();
        } else
          o2 = t3.getRotation(true);
      return { position: i3, size: n3, rotate: o2 };
    }, _getSizeInPixels: function(t3) {
      var i3 = this.size.x, n3 = this.size.y;
      if (null !== this.width || null !== this.height) {
        var o2 = t3.deltaPixelsFromPointsNoRotate(new e4.Point(this.width || 0, this.height || 0), true);
        null !== this.width && (i3 = o2.x), null !== this.height && (n3 = o2.y);
      }
      if (this.checkResize && (null === this.width || null === this.height)) {
        var r2 = this.size = e4.getElementSize(this.element);
        null === this.width && (i3 = r2.x), null === this.height && (n3 = r2.y);
      }
      return new e4.Point(i3, n3);
    }, _getBoundingBox: function(e5, t3) {
      var i3 = this._getPlacementPoint(e5);
      return e5.rotate(t3, i3).getBoundingBox();
    }, _getPlacementPoint: function(t3) {
      var i3 = new e4.Point(t3.x, t3.y), n3 = e4.Placement.properties[this.placement];
      return n3 && (n3.isHorizontallyCentered ? i3.x += t3.width / 2 : n3.isRight && (i3.x += t3.width), n3.isVerticallyCentered ? i3.y += t3.height / 2 : n3.isBottom && (i3.y += t3.height)), i3;
    }, _getTransformOrigin: function() {
      var t3 = "", i3 = e4.Placement.properties[this.placement];
      return i3 ? (i3.isLeft ? t3 = "left" : i3.isRight && (t3 = "right"), i3.isTop ? t3 += " top" : i3.isBottom && (t3 += " bottom"), t3) : t3;
    }, update: function(t3, i3) {
      var n3 = e4.isPlainObject(t3) ? t3 : { location: t3, placement: i3 };
      this._init({ location: n3.location || this.location, placement: void 0 !== n3.placement ? n3.placement : this.placement, onDraw: n3.onDraw || this.onDraw, checkResize: n3.checkResize || this.checkResize, width: void 0 !== n3.width ? n3.width : this.width, height: void 0 !== n3.height ? n3.height : this.height, rotationMode: n3.rotationMode || this.rotationMode });
    }, getBounds: function(t3) {
      e4.console.assert(t3, "A viewport must now be passed to Overlay.getBounds.");
      var i3 = this.width, n3 = this.height;
      if (null === i3 || null === n3) {
        var o2 = t3.deltaPointsFromPixelsNoRotate(this.size, true);
        null === i3 && (i3 = o2.x), null === n3 && (n3 = o2.y);
      }
      var r2 = this.location.clone();
      return this.adjust(r2, new e4.Point(i3, n3)), this._adjustBoundsForRotation(t3, new e4.Rect(r2.x, r2.y, i3, n3));
    }, _adjustBoundsForRotation: function(t3, i3) {
      if (!t3 || 0 === t3.getRotation(true) || this.rotationMode === e4.OverlayRotationMode.EXACT)
        return i3;
      if (this.rotationMode === e4.OverlayRotationMode.BOUNDING_BOX) {
        if (null === this.width || null === this.height)
          return i3;
        var n3 = this._getOverlayPositionAndSize(t3);
        return t3.viewerElementToViewportRectangle(new e4.Rect(n3.position.x, n3.position.y, n3.size.x, n3.size.y));
      }
      return i3.rotate(-t3.getRotation(true), this._getPlacementPoint(i3));
    } };
  }(t2), function(e4) {
    e4.Drawer = function(t3) {
      e4.console.assert(t3.viewer, "[Drawer] options.viewer is required");
      var i3 = arguments;
      if (e4.isPlainObject(t3) || (t3 = { source: i3[0], viewport: i3[1], element: i3[2] }), e4.console.assert(t3.viewport, "[Drawer] options.viewport is required"), e4.console.assert(t3.element, "[Drawer] options.element is required"), t3.source && e4.console.error("[Drawer] options.source is no longer accepted; use TiledImage instead"), this.viewer = t3.viewer, this.viewport = t3.viewport, this.debugGridColor = "string" == typeof t3.debugGridColor ? [t3.debugGridColor] : t3.debugGridColor || e4.DEFAULT_SETTINGS.debugGridColor, t3.opacity && e4.console.error("[Drawer] options.opacity is no longer accepted; set the opacity on the TiledImage instead"), this.useCanvas = e4.supportsCanvas && (!this.viewer || this.viewer.useCanvas), this.container = e4.getElement(t3.element), this.canvas = e4.makeNeutralElement(this.useCanvas ? "canvas" : "div"), this.context = this.useCanvas ? this.canvas.getContext("2d") : null, this.sketchCanvas = null, this.sketchContext = null, this.element = this.container, this.container.dir = "ltr", this.useCanvas) {
        var n3 = this._calculateCanvasSize();
        this.canvas.width = n3.x, this.canvas.height = n3.y;
      }
      this.canvas.style.width = "100%", this.canvas.style.height = "100%", this.canvas.style.position = "absolute", e4.setElementOpacity(this.canvas, this.opacity, true), e4.setElementPointerEventsNone(this.canvas), e4.setElementTouchActionNone(this.canvas), this.container.style.textAlign = "left", this.container.appendChild(this.canvas), this._imageSmoothingEnabled = true;
    }, e4.Drawer.prototype = { addOverlay: function(t3, i3, n3, o2) {
      return e4.console.error("drawer.addOverlay is deprecated. Use viewer.addOverlay instead."), this.viewer.addOverlay(t3, i3, n3, o2), this;
    }, updateOverlay: function(t3, i3, n3) {
      return e4.console.error("drawer.updateOverlay is deprecated. Use viewer.updateOverlay instead."), this.viewer.updateOverlay(t3, i3, n3), this;
    }, removeOverlay: function(t3) {
      return e4.console.error("drawer.removeOverlay is deprecated. Use viewer.removeOverlay instead."), this.viewer.removeOverlay(t3), this;
    }, clearOverlays: function() {
      return e4.console.error("drawer.clearOverlays is deprecated. Use viewer.clearOverlays instead."), this.viewer.clearOverlays(), this;
    }, viewportCoordToDrawerCoord: function(t3) {
      var i3 = this.viewport.pixelFromPointNoRotate(t3, true);
      return new e4.Point(i3.x * e4.pixelDensityRatio, i3.y * e4.pixelDensityRatio);
    }, clipWithPolygons: function(e5, t3) {
      if (this.useCanvas) {
        var i3 = this._getContext(t3);
        i3.beginPath(), e5.forEach(function(e6) {
          e6.forEach(function(e7, t4) {
            i3[0 === t4 ? "moveTo" : "lineTo"](e7.x, e7.y);
          });
        }), i3.clip();
      }
    }, setOpacity: function(t3) {
      e4.console.error("drawer.setOpacity is deprecated. Use tiledImage.setOpacity instead.");
      for (var i3 = this.viewer.world, n3 = 0; n3 < i3.getItemCount(); n3++)
        i3.getItemAt(n3).setOpacity(t3);
      return this;
    }, getOpacity: function() {
      e4.console.error("drawer.getOpacity is deprecated. Use tiledImage.getOpacity instead.");
      for (var t3 = this.viewer.world, i3 = 0, n3 = 0; n3 < t3.getItemCount(); n3++) {
        var o2 = t3.getItemAt(n3).getOpacity();
        o2 > i3 && (i3 = o2);
      }
      return i3;
    }, needsUpdate: function() {
      return e4.console.error("[Drawer.needsUpdate] this function is deprecated. Use World.needsDraw instead."), this.viewer.world.needsDraw();
    }, numTilesLoaded: function() {
      return e4.console.error("[Drawer.numTilesLoaded] this function is deprecated. Use TileCache.numTilesLoaded instead."), this.viewer.tileCache.numTilesLoaded();
    }, reset: function() {
      return e4.console.error("[Drawer.reset] this function is deprecated. Use World.resetItems instead."), this.viewer.world.resetItems(), this;
    }, update: function() {
      return e4.console.error("[Drawer.update] this function is deprecated. Use Drawer.clear and World.draw instead."), this.clear(), this.viewer.world.draw(), this;
    }, canRotate: function() {
      return this.useCanvas;
    }, destroy: function() {
      this.canvas.width = 1, this.canvas.height = 1, this.sketchCanvas = null, this.sketchContext = null;
    }, clear: function() {
      if (this.canvas.innerHTML = "", this.useCanvas) {
        var e5 = this._calculateCanvasSize();
        if ((this.canvas.width !== e5.x || this.canvas.height !== e5.y) && (this.canvas.width = e5.x, this.canvas.height = e5.y, this._updateImageSmoothingEnabled(this.context), null !== this.sketchCanvas)) {
          var t3 = this._calculateSketchCanvasSize();
          this.sketchCanvas.width = t3.x, this.sketchCanvas.height = t3.y, this._updateImageSmoothingEnabled(this.sketchContext);
        }
        this._clear();
      }
    }, _clear: function(e5, t3) {
      if (this.useCanvas) {
        var i3 = this._getContext(e5);
        if (t3)
          i3.clearRect(t3.x, t3.y, t3.width, t3.height);
        else {
          var n3 = i3.canvas;
          i3.clearRect(0, 0, n3.width, n3.height);
        }
      }
    }, viewportToDrawerRectangle: function(t3) {
      var i3 = this.viewport.pixelFromPointNoRotate(t3.getTopLeft(), true), n3 = this.viewport.deltaPixelsFromPointsNoRotate(t3.getSize(), true);
      return new e4.Rect(i3.x * e4.pixelDensityRatio, i3.y * e4.pixelDensityRatio, n3.x * e4.pixelDensityRatio, n3.y * e4.pixelDensityRatio);
    }, drawTile: function(t3, i3, n3, o2, r2, s2, a2) {
      if (e4.console.assert(t3, "[Drawer.drawTile] tile is required"), e4.console.assert(i3, "[Drawer.drawTile] drawingHandler is required"), this.useCanvas) {
        var l2 = this._getContext(n3);
        o2 = o2 || 1, t3.drawCanvas(l2, i3, o2, r2, s2, a2);
      } else
        t3.drawHTML(this.canvas);
    }, _getContext: function(e5) {
      var t3 = this.context;
      if (e5) {
        if (null === this.sketchCanvas) {
          this.sketchCanvas = document.createElement("canvas");
          var i3 = this._calculateSketchCanvasSize();
          if (this.sketchCanvas.width = i3.x, this.sketchCanvas.height = i3.y, this.sketchContext = this.sketchCanvas.getContext("2d"), 0 === this.viewport.getRotation()) {
            var n3 = this;
            this.viewer.addHandler("rotate", function e6() {
              if (0 !== n3.viewport.getRotation()) {
                n3.viewer.removeHandler("rotate", e6);
                var t4 = n3._calculateSketchCanvasSize();
                n3.sketchCanvas.width = t4.x, n3.sketchCanvas.height = t4.y;
              }
            });
          }
          this._updateImageSmoothingEnabled(this.sketchContext);
        }
        t3 = this.sketchContext;
      }
      return t3;
    }, saveContext: function(e5) {
      this.useCanvas && this._getContext(e5).save();
    }, restoreContext: function(e5) {
      this.useCanvas && this._getContext(e5).restore();
    }, setClip: function(e5, t3) {
      if (this.useCanvas) {
        var i3 = this._getContext(t3);
        i3.beginPath(), i3.rect(e5.x, e5.y, e5.width, e5.height), i3.clip();
      }
    }, drawRectangle: function(e5, t3, i3) {
      if (this.useCanvas) {
        var n3 = this._getContext(i3);
        n3.save(), n3.fillStyle = t3, n3.fillRect(e5.x, e5.y, e5.width, e5.height), n3.restore();
      }
    }, blendSketch: function(t3, i3, n3, o2) {
      var r2 = t3;
      if (e4.isPlainObject(r2) || (r2 = { opacity: t3, scale: i3, translate: n3, compositeOperation: o2 }), this.useCanvas && this.sketchCanvas) {
        t3 = r2.opacity, o2 = r2.compositeOperation;
        var s2 = r2.bounds;
        if (this.context.save(), this.context.globalAlpha = t3, o2 && (this.context.globalCompositeOperation = o2), s2)
          s2.x < 0 && (s2.width += s2.x, s2.x = 0), s2.x + s2.width > this.canvas.width && (s2.width = this.canvas.width - s2.x), s2.y < 0 && (s2.height += s2.y, s2.y = 0), s2.y + s2.height > this.canvas.height && (s2.height = this.canvas.height - s2.y), this.context.drawImage(this.sketchCanvas, s2.x, s2.y, s2.width, s2.height, s2.x, s2.y, s2.width, s2.height);
        else {
          i3 = r2.scale || 1;
          var a2 = (n3 = r2.translate) instanceof e4.Point ? n3 : new e4.Point(0, 0), l2 = 0, c2 = 0;
          if (n3) {
            var h2 = this.sketchCanvas.width - this.canvas.width, u2 = this.sketchCanvas.height - this.canvas.height;
            l2 = Math.round(h2 / 2), c2 = Math.round(u2 / 2);
          }
          this.context.drawImage(this.sketchCanvas, a2.x - l2 * i3, a2.y - c2 * i3, (this.canvas.width + 2 * l2) * i3, (this.canvas.height + 2 * c2) * i3, -l2, -c2, this.canvas.width + 2 * l2, this.canvas.height + 2 * c2);
        }
        this.context.restore();
      }
    }, drawDebugInfo: function(t3, i3, n3, o2) {
      if (this.useCanvas) {
        var r2 = this.viewer.world.getIndexOfItem(o2) % this.debugGridColor.length, s2 = this.context;
        s2.save(), s2.lineWidth = 2 * e4.pixelDensityRatio, s2.font = "small-caps bold " + 13 * e4.pixelDensityRatio + "px arial", s2.strokeStyle = this.debugGridColor[r2], s2.fillStyle = this.debugGridColor[r2], this.viewport.getRotation(true) % 360 != 0 && this._offsetForRotation({ degrees: this.viewport.getRotation(true) }), o2.getRotation(true) % 360 != 0 && this._offsetForRotation({ degrees: o2.getRotation(true), point: o2.viewport.pixelFromPointNoRotate(o2._getRotationPoint(true), true) }), o2.viewport.getRotation(true) % 360 == 0 && o2.getRotation(true) % 360 == 0 && o2._drawer.viewer.viewport.getFlip() && o2._drawer._flip(), s2.strokeRect(t3.position.x * e4.pixelDensityRatio, t3.position.y * e4.pixelDensityRatio, t3.size.x * e4.pixelDensityRatio, t3.size.y * e4.pixelDensityRatio);
        var a2 = (t3.position.x + t3.size.x / 2) * e4.pixelDensityRatio, l2 = (t3.position.y + t3.size.y / 2) * e4.pixelDensityRatio;
        s2.translate(a2, l2), s2.rotate(Math.PI / 180 * -this.viewport.getRotation(true)), s2.translate(-a2, -l2), 0 === t3.x && 0 === t3.y && (s2.fillText("Zoom: " + this.viewport.getZoom(), t3.position.x * e4.pixelDensityRatio, (t3.position.y - 30) * e4.pixelDensityRatio), s2.fillText("Pan: " + this.viewport.getBounds().toString(), t3.position.x * e4.pixelDensityRatio, (t3.position.y - 20) * e4.pixelDensityRatio)), s2.fillText("Level: " + t3.level, (t3.position.x + 10) * e4.pixelDensityRatio, (t3.position.y + 20) * e4.pixelDensityRatio), s2.fillText("Column: " + t3.x, (t3.position.x + 10) * e4.pixelDensityRatio, (t3.position.y + 30) * e4.pixelDensityRatio), s2.fillText("Row: " + t3.y, (t3.position.x + 10) * e4.pixelDensityRatio, (t3.position.y + 40) * e4.pixelDensityRatio), s2.fillText("Order: " + n3 + " of " + i3, (t3.position.x + 10) * e4.pixelDensityRatio, (t3.position.y + 50) * e4.pixelDensityRatio), s2.fillText("Size: " + t3.size.toString(), (t3.position.x + 10) * e4.pixelDensityRatio, (t3.position.y + 60) * e4.pixelDensityRatio), s2.fillText("Position: " + t3.position.toString(), (t3.position.x + 10) * e4.pixelDensityRatio, (t3.position.y + 70) * e4.pixelDensityRatio), this.viewport.getRotation(true) % 360 != 0 && this._restoreRotationChanges(), o2.getRotation(true) % 360 != 0 && this._restoreRotationChanges(), o2.viewport.getRotation(true) % 360 == 0 && o2.getRotation(true) % 360 == 0 && o2._drawer.viewer.viewport.getFlip() && o2._drawer._flip(), s2.restore();
      }
    }, debugRect: function(t3) {
      if (this.useCanvas) {
        var i3 = this.context;
        i3.save(), i3.lineWidth = 2 * e4.pixelDensityRatio, i3.strokeStyle = this.debugGridColor[0], i3.fillStyle = this.debugGridColor[0], i3.strokeRect(t3.x * e4.pixelDensityRatio, t3.y * e4.pixelDensityRatio, t3.width * e4.pixelDensityRatio, t3.height * e4.pixelDensityRatio), i3.restore();
      }
    }, setImageSmoothingEnabled: function(e5) {
      this.useCanvas && (this._imageSmoothingEnabled = e5, this._updateImageSmoothingEnabled(this.context), this.viewer.forceRedraw());
    }, _updateImageSmoothingEnabled: function(e5) {
      e5.msImageSmoothingEnabled = this._imageSmoothingEnabled, e5.imageSmoothingEnabled = this._imageSmoothingEnabled;
    }, getCanvasSize: function(t3) {
      var i3 = this._getContext(t3).canvas;
      return new e4.Point(i3.width, i3.height);
    }, getCanvasCenter: function() {
      return new e4.Point(this.canvas.width / 2, this.canvas.height / 2);
    }, _offsetForRotation: function(t3) {
      var i3 = t3.point ? t3.point.times(e4.pixelDensityRatio) : this.getCanvasCenter(), n3 = this._getContext(t3.useSketch);
      n3.save(), n3.translate(i3.x, i3.y), this.viewer.viewport.flipped ? (n3.rotate(Math.PI / 180 * -t3.degrees), n3.scale(-1, 1)) : n3.rotate(Math.PI / 180 * t3.degrees), n3.translate(-i3.x, -i3.y);
    }, _flip: function(t3) {
      var i3 = (t3 = t3 || {}).point ? t3.point.times(e4.pixelDensityRatio) : this.getCanvasCenter(), n3 = this._getContext(t3.useSketch);
      n3.translate(i3.x, 0), n3.scale(-1, 1), n3.translate(-i3.x, 0);
    }, _restoreRotationChanges: function(e5) {
      this._getContext(e5).restore();
    }, _calculateCanvasSize: function() {
      var t3 = e4.pixelDensityRatio, i3 = this.viewport.getContainerSize();
      return { x: Math.round(i3.x * t3), y: Math.round(i3.y * t3) };
    }, _calculateSketchCanvasSize: function() {
      var e5 = this._calculateCanvasSize();
      if (0 === this.viewport.getRotation())
        return e5;
      var t3 = Math.ceil(Math.sqrt(e5.x * e5.x + e5.y * e5.y));
      return { x: t3, y: t3 };
    } };
  }(t2), function(e4) {
    e4.Viewport = function(t3) {
      var i3 = arguments;
      i3.length && i3[0] instanceof e4.Point && (t3 = { containerSize: i3[0], contentSize: i3[1], config: i3[2] }), t3.config && (e4.extend(true, t3, t3.config), delete t3.config), this._margins = e4.extend({ left: 0, top: 0, right: 0, bottom: 0 }, t3.margins || {}), delete t3.margins, t3.initialDegrees = t3.degrees, delete t3.degrees, e4.extend(true, this, { containerSize: null, contentSize: null, zoomPoint: null, rotationPivot: null, viewer: null, springStiffness: e4.DEFAULT_SETTINGS.springStiffness, animationTime: e4.DEFAULT_SETTINGS.animationTime, minZoomImageRatio: e4.DEFAULT_SETTINGS.minZoomImageRatio, maxZoomPixelRatio: e4.DEFAULT_SETTINGS.maxZoomPixelRatio, visibilityRatio: e4.DEFAULT_SETTINGS.visibilityRatio, wrapHorizontal: e4.DEFAULT_SETTINGS.wrapHorizontal, wrapVertical: e4.DEFAULT_SETTINGS.wrapVertical, defaultZoomLevel: e4.DEFAULT_SETTINGS.defaultZoomLevel, minZoomLevel: e4.DEFAULT_SETTINGS.minZoomLevel, maxZoomLevel: e4.DEFAULT_SETTINGS.maxZoomLevel, initialDegrees: e4.DEFAULT_SETTINGS.degrees, flipped: e4.DEFAULT_SETTINGS.flipped, homeFillsViewer: e4.DEFAULT_SETTINGS.homeFillsViewer, silenceMultiImageWarnings: e4.DEFAULT_SETTINGS.silenceMultiImageWarnings }, t3), this._updateContainerInnerSize(), this.centerSpringX = new e4.Spring({ initial: 0, springStiffness: this.springStiffness, animationTime: this.animationTime }), this.centerSpringY = new e4.Spring({ initial: 0, springStiffness: this.springStiffness, animationTime: this.animationTime }), this.zoomSpring = new e4.Spring({ exponential: true, initial: 1, springStiffness: this.springStiffness, animationTime: this.animationTime }), this.degreesSpring = new e4.Spring({ initial: t3.initialDegrees, springStiffness: this.springStiffness, animationTime: this.animationTime }), this._oldCenterX = this.centerSpringX.current.value, this._oldCenterY = this.centerSpringY.current.value, this._oldZoom = this.zoomSpring.current.value, this._oldDegrees = this.degreesSpring.current.value, this._setContentBounds(new e4.Rect(0, 0, 1, 1), 1), this.goHome(true), this.update();
    }, e4.Viewport.prototype = { get degrees() {
      return e4.console.warn("Accessing [Viewport.degrees] is deprecated. Use viewport.getRotation instead."), this.getRotation();
    }, set degrees(t3) {
      e4.console.warn("Setting [Viewport.degrees] is deprecated. Use viewport.rotateTo, viewport.rotateBy, or viewport.setRotation instead."), this.rotateTo(t3);
    }, resetContentSize: function(t3) {
      return e4.console.assert(t3, "[Viewport.resetContentSize] contentSize is required"), e4.console.assert(t3 instanceof e4.Point, "[Viewport.resetContentSize] contentSize must be an OpenSeadragon.Point"), e4.console.assert(t3.x > 0, "[Viewport.resetContentSize] contentSize.x must be greater than 0"), e4.console.assert(t3.y > 0, "[Viewport.resetContentSize] contentSize.y must be greater than 0"), this._setContentBounds(new e4.Rect(0, 0, 1, t3.y / t3.x), t3.x), this;
    }, setHomeBounds: function(t3, i3) {
      e4.console.error("[Viewport.setHomeBounds] this function is deprecated; The content bounds should not be set manually."), this._setContentBounds(t3, i3);
    }, _setContentBounds: function(t3, i3) {
      e4.console.assert(t3, "[Viewport._setContentBounds] bounds is required"), e4.console.assert(t3 instanceof e4.Rect, "[Viewport._setContentBounds] bounds must be an OpenSeadragon.Rect"), e4.console.assert(t3.width > 0, "[Viewport._setContentBounds] bounds.width must be greater than 0"), e4.console.assert(t3.height > 0, "[Viewport._setContentBounds] bounds.height must be greater than 0"), this._contentBoundsNoRotate = t3.clone(), this._contentSizeNoRotate = this._contentBoundsNoRotate.getSize().times(i3), this._contentBounds = t3.rotate(this.getRotation()).getBoundingBox(), this._contentSize = this._contentBounds.getSize().times(i3), this._contentAspectRatio = this._contentSize.x / this._contentSize.y, this.viewer && this.viewer.raiseEvent("reset-size", { contentSize: this._contentSizeNoRotate.clone(), contentFactor: i3, homeBounds: this._contentBoundsNoRotate.clone(), contentBounds: this._contentBounds.clone() });
    }, getHomeZoom: function() {
      if (this.defaultZoomLevel)
        return this.defaultZoomLevel;
      var e5 = this._contentAspectRatio / this.getAspectRatio();
      return (this.homeFillsViewer ? e5 >= 1 ? e5 : 1 : e5 >= 1 ? 1 : e5) / this._contentBounds.width;
    }, getHomeBounds: function() {
      return this.getHomeBoundsNoRotate().rotate(-this.getRotation());
    }, getHomeBoundsNoRotate: function() {
      var t3 = this._contentBounds.getCenter(), i3 = 1 / this.getHomeZoom(), n3 = i3 / this.getAspectRatio();
      return new e4.Rect(t3.x - i3 / 2, t3.y - n3 / 2, i3, n3);
    }, goHome: function(e5) {
      return this.viewer && this.viewer.raiseEvent("home", { immediately: e5 }), this.fitBounds(this.getHomeBounds(), e5);
    }, getMinZoom: function() {
      var e5 = this.getHomeZoom();
      return this.minZoomLevel ? this.minZoomLevel : this.minZoomImageRatio * e5;
    }, getMaxZoom: function() {
      var e5 = this.maxZoomLevel;
      return e5 || (e5 = this._contentSize.x * this.maxZoomPixelRatio / this._containerInnerSize.x, e5 /= this._contentBounds.width), Math.max(e5, this.getHomeZoom());
    }, getAspectRatio: function() {
      return this._containerInnerSize.x / this._containerInnerSize.y;
    }, getContainerSize: function() {
      return new e4.Point(this.containerSize.x, this.containerSize.y);
    }, getMargins: function() {
      return e4.extend({}, this._margins);
    }, setMargins: function(t3) {
      e4.console.assert("object" === e4.type(t3), "[Viewport.setMargins] margins must be an object"), this._margins = e4.extend({ left: 0, top: 0, right: 0, bottom: 0 }, t3), this._updateContainerInnerSize(), this.viewer && this.viewer.forceRedraw();
    }, getBounds: function(e5) {
      return this.getBoundsNoRotate(e5).rotate(-this.getRotation(e5));
    }, getBoundsNoRotate: function(t3) {
      var i3 = this.getCenter(t3), n3 = 1 / this.getZoom(t3), o2 = n3 / this.getAspectRatio();
      return new e4.Rect(i3.x - n3 / 2, i3.y - o2 / 2, n3, o2);
    }, getBoundsWithMargins: function(e5) {
      return this.getBoundsNoRotateWithMargins(e5).rotate(-this.getRotation(e5), this.getCenter(e5));
    }, getBoundsNoRotateWithMargins: function(e5) {
      var t3 = this.getBoundsNoRotate(e5), i3 = this._containerInnerSize.x * this.getZoom(e5);
      return t3.x -= this._margins.left / i3, t3.y -= this._margins.top / i3, t3.width += (this._margins.left + this._margins.right) / i3, t3.height += (this._margins.top + this._margins.bottom) / i3, t3;
    }, getCenter: function(t3) {
      var i3, n3, o2, r2, s2, a2, l2 = new e4.Point(this.centerSpringX.current.value, this.centerSpringY.current.value), c2 = new e4.Point(this.centerSpringX.target.value, this.centerSpringY.target.value);
      return t3 ? l2 : this.zoomPoint ? (i3 = this.pixelFromPoint(this.zoomPoint, true), r2 = (o2 = 1 / (n3 = this.getZoom())) / this.getAspectRatio(), s2 = new e4.Rect(l2.x - o2 / 2, l2.y - r2 / 2, o2, r2), a2 = this._pixelFromPoint(this.zoomPoint, s2).minus(i3).rotate(-this.getRotation(true)).divide(this._containerInnerSize.x * n3), c2.plus(a2)) : c2;
    }, getZoom: function(e5) {
      return e5 ? this.zoomSpring.current.value : this.zoomSpring.target.value;
    }, _applyZoomConstraints: function(e5) {
      return Math.max(Math.min(e5, this.getMaxZoom()), this.getMinZoom());
    }, _applyBoundaryConstraints: function(e5) {
      var t3 = this.viewportToViewerElementRectangle(e5).getBoundingBox(), i3 = this.viewportToViewerElementRectangle(this._contentBoundsNoRotate).getBoundingBox(), n3 = false, o2 = false;
      if (this.wrapHorizontal)
        ;
      else {
        var r2, s2, a2, l2 = t3.x + t3.width, c2 = i3.x + i3.width;
        r2 = t3.width > i3.width ? this.visibilityRatio * i3.width : this.visibilityRatio * t3.width, s2 = i3.x - l2 + r2, a2 = c2 - t3.x - r2, r2 > i3.width ? (t3.x += (s2 + a2) / 2, n3 = true) : a2 < 0 ? (t3.x += a2, n3 = true) : s2 > 0 && (t3.x += s2, n3 = true);
      }
      if (this.wrapVertical)
        ;
      else {
        var h2, u2, d2, p2 = t3.y + t3.height, _2 = i3.y + i3.height;
        h2 = t3.height > i3.height ? this.visibilityRatio * i3.height : this.visibilityRatio * t3.height, u2 = i3.y - p2 + h2, d2 = _2 - t3.y - h2, h2 > i3.height ? (t3.y += (u2 + d2) / 2, o2 = true) : d2 < 0 ? (t3.y += d2, o2 = true) : u2 > 0 && (t3.y += u2, o2 = true);
      }
      var g2 = n3 || o2, m2 = g2 ? this.viewerElementToViewportRectangle(t3) : e5.clone();
      return m2.xConstrained = n3, m2.yConstrained = o2, m2.constraintApplied = g2, m2;
    }, _raiseConstraintsEvent: function(e5) {
      this.viewer && this.viewer.raiseEvent("constrain", { immediately: e5 });
    }, applyConstraints: function(e5) {
      var t3 = this.getZoom(), i3 = this._applyZoomConstraints(t3);
      t3 !== i3 && this.zoomTo(i3, this.zoomPoint, e5);
      var n3 = this.getConstrainedBounds(false);
      return n3.constraintApplied && (this.fitBounds(n3, e5), this._raiseConstraintsEvent(e5)), this;
    }, ensureVisible: function(e5) {
      return this.applyConstraints(e5);
    }, _fitBounds: function(t3, i3) {
      var n3 = (i3 = i3 || {}).immediately || false, o2 = i3.constraints || false, r2 = this.getAspectRatio(), s2 = t3.getCenter(), a2 = new e4.Rect(t3.x, t3.y, t3.width, t3.height, t3.degrees + this.getRotation()).getBoundingBox();
      a2.getAspectRatio() >= r2 ? a2.height = a2.width / r2 : a2.width = a2.height * r2, a2.x = s2.x - a2.width / 2, a2.y = s2.y - a2.height / 2;
      var l2 = 1 / a2.width;
      if (n3)
        return this.panTo(s2, true), this.zoomTo(l2, null, true), o2 && this.applyConstraints(true), this;
      var c2 = this.getCenter(true), h2 = this.getZoom(true);
      this.panTo(c2, true), this.zoomTo(h2, null, true);
      var u2 = this.getBounds(), d2 = this.getZoom();
      if (0 === d2 || Math.abs(l2 / d2 - 1) < 1e-8)
        return this.zoomTo(l2, null, true), this.panTo(s2, n3), o2 && this.applyConstraints(false), this;
      if (o2) {
        this.panTo(s2, false), l2 = this._applyZoomConstraints(l2), this.zoomTo(l2, null, false);
        var p2 = this.getConstrainedBounds();
        this.panTo(c2, true), this.zoomTo(h2, null, true), this.fitBounds(p2);
      } else {
        var _2 = a2.rotate(-this.getRotation()).getTopLeft().times(l2).minus(u2.getTopLeft().times(d2)).divide(l2 - d2);
        this.zoomTo(l2, _2, n3);
      }
      return this;
    }, fitBounds: function(e5, t3) {
      return this._fitBounds(e5, { immediately: t3, constraints: false });
    }, fitBoundsWithConstraints: function(e5, t3) {
      return this._fitBounds(e5, { immediately: t3, constraints: true });
    }, fitVertically: function(t3) {
      var i3 = new e4.Rect(this._contentBounds.x + this._contentBounds.width / 2, this._contentBounds.y, 0, this._contentBounds.height);
      return this.fitBounds(i3, t3);
    }, fitHorizontally: function(t3) {
      var i3 = new e4.Rect(this._contentBounds.x, this._contentBounds.y + this._contentBounds.height / 2, this._contentBounds.width, 0);
      return this.fitBounds(i3, t3);
    }, getConstrainedBounds: function(e5) {
      var t3;
      return t3 = this.getBounds(e5), this._applyBoundaryConstraints(t3);
    }, panBy: function(t3, i3) {
      var n3 = new e4.Point(this.centerSpringX.target.value, this.centerSpringY.target.value);
      return this.panTo(n3.plus(t3), i3);
    }, panTo: function(e5, t3) {
      return t3 ? (this.centerSpringX.resetTo(e5.x), this.centerSpringY.resetTo(e5.y)) : (this.centerSpringX.springTo(e5.x), this.centerSpringY.springTo(e5.y)), this.viewer && this.viewer.raiseEvent("pan", { center: e5, immediately: t3 }), this;
    }, zoomBy: function(e5, t3, i3) {
      return this.zoomTo(this.zoomSpring.target.value * e5, t3, i3);
    }, zoomTo: function(t3, i3, n3) {
      var o2 = this;
      return this.zoomPoint = i3 instanceof e4.Point && !isNaN(i3.x) && !isNaN(i3.y) ? i3 : null, n3 ? this._adjustCenterSpringsForZoomPoint(function() {
        o2.zoomSpring.resetTo(t3);
      }) : this.zoomSpring.springTo(t3), this.viewer && this.viewer.raiseEvent("zoom", { zoom: t3, refPoint: i3, immediately: n3 }), this;
    }, setRotation: function(e5, t3) {
      return this.rotateTo(e5, null, t3);
    }, getRotation: function(e5) {
      return e5 ? this.degreesSpring.current.value : this.degreesSpring.target.value;
    }, setRotationWithPivot: function(e5, t3, i3) {
      return this.rotateTo(e5, t3, i3);
    }, rotateTo: function(t3, i3, n3) {
      if (!this.viewer || !this.viewer.drawer.canRotate())
        return this;
      if (this.degreesSpring.target.value === t3 && this.degreesSpring.isAtTargetValue())
        return this;
      if (this.rotationPivot = i3 instanceof e4.Point && !isNaN(i3.x) && !isNaN(i3.y) ? i3 : null, n3)
        if (this.rotationPivot) {
          if (!(t3 - this._oldDegrees))
            return this.rotationPivot = null, this;
          this._rotateAboutPivot(t3);
        } else
          this.degreesSpring.resetTo(t3);
      else {
        var o2 = e4.positiveModulo(this.degreesSpring.current.value, 360), r2 = e4.positiveModulo(t3, 360), s2 = r2 - o2;
        s2 > 180 ? r2 -= 360 : s2 < -180 && (r2 += 360);
        var a2 = o2 - r2;
        this.degreesSpring.resetTo(t3 + a2), this.degreesSpring.springTo(t3);
      }
      return this._setContentBounds(this.viewer.world.getHomeBounds(), this.viewer.world.getContentFactor()), this.viewer.forceRedraw(), this.viewer.raiseEvent("rotate", { degrees: t3, immediately: !!n3, pivot: this.rotationPivot || this.getCenter() }), this;
    }, rotateBy: function(e5, t3, i3) {
      return this.rotateTo(this.degreesSpring.target.value + e5, t3, i3);
    }, resize: function(e5, t3) {
      var i3, n3 = this.getBoundsNoRotate(), o2 = n3;
      this.containerSize.x = e5.x, this.containerSize.y = e5.y, this._updateContainerInnerSize(), t3 && (i3 = e5.x / this.containerSize.x, o2.width = n3.width * i3, o2.height = o2.width / this.getAspectRatio()), this.viewer && this.viewer.raiseEvent("resize", { newContainerSize: e5, maintain: t3 });
      var r2 = this.fitBounds(o2, true);
      return this.viewer && this.viewer.raiseEvent("after-resize", { newContainerSize: e5, maintain: t3 }), r2;
    }, _updateContainerInnerSize: function() {
      this._containerInnerSize = new e4.Point(Math.max(1, this.containerSize.x - (this._margins.left + this._margins.right)), Math.max(1, this.containerSize.y - (this._margins.top + this._margins.bottom)));
    }, update: function() {
      var e5 = this;
      this._adjustCenterSpringsForZoomPoint(function() {
        e5.zoomSpring.update();
      }), this.degreesSpring.isAtTargetValue() && (this.rotationPivot = null), this.centerSpringX.update(), this.centerSpringY.update(), this.rotationPivot ? this._rotateAboutPivot(true) : this.degreesSpring.update();
      var t3 = this.centerSpringX.current.value !== this._oldCenterX || this.centerSpringY.current.value !== this._oldCenterY || this.zoomSpring.current.value !== this._oldZoom || this.degreesSpring.current.value !== this._oldDegrees;
      return this._oldCenterX = this.centerSpringX.current.value, this._oldCenterY = this.centerSpringY.current.value, this._oldZoom = this.zoomSpring.current.value, this._oldDegrees = this.degreesSpring.current.value, t3;
    }, _rotateAboutPivot: function(e5) {
      var t3 = true === e5, i3 = this.rotationPivot.minus(this.getCenter());
      this.centerSpringX.shiftBy(i3.x), this.centerSpringY.shiftBy(i3.y), t3 ? this.degreesSpring.update() : this.degreesSpring.resetTo(e5);
      var n3 = this.degreesSpring.current.value - this._oldDegrees, o2 = i3.rotate(-1 * n3).times(-1);
      this.centerSpringX.shiftBy(o2.x), this.centerSpringY.shiftBy(o2.y);
    }, _adjustCenterSpringsForZoomPoint: function(e5) {
      if (this.zoomPoint) {
        var t3 = this.pixelFromPoint(this.zoomPoint, true);
        e5();
        var i3 = this.pixelFromPoint(this.zoomPoint, true).minus(t3), n3 = this.deltaPointsFromPixels(i3, true);
        this.centerSpringX.shiftBy(n3.x), this.centerSpringY.shiftBy(n3.y), this.zoomSpring.isAtTargetValue() && (this.zoomPoint = null);
      } else
        e5();
    }, deltaPixelsFromPointsNoRotate: function(e5, t3) {
      return e5.times(this._containerInnerSize.x * this.getZoom(t3));
    }, deltaPixelsFromPoints: function(e5, t3) {
      return this.deltaPixelsFromPointsNoRotate(e5.rotate(this.getRotation(t3)), t3);
    }, deltaPointsFromPixelsNoRotate: function(e5, t3) {
      return e5.divide(this._containerInnerSize.x * this.getZoom(t3));
    }, deltaPointsFromPixels: function(e5, t3) {
      return this.deltaPointsFromPixelsNoRotate(e5, t3).rotate(-this.getRotation(t3));
    }, pixelFromPointNoRotate: function(e5, t3) {
      return this._pixelFromPointNoRotate(e5, this.getBoundsNoRotate(t3));
    }, pixelFromPoint: function(e5, t3) {
      return this._pixelFromPoint(e5, this.getBoundsNoRotate(t3));
    }, _pixelFromPointNoRotate: function(t3, i3) {
      return t3.minus(i3.getTopLeft()).times(this._containerInnerSize.x / i3.width).plus(new e4.Point(this._margins.left, this._margins.top));
    }, _pixelFromPoint: function(e5, t3) {
      return this._pixelFromPointNoRotate(e5.rotate(this.getRotation(true), this.getCenter(true)), t3);
    }, pointFromPixelNoRotate: function(t3, i3) {
      var n3 = this.getBoundsNoRotate(i3);
      return t3.minus(new e4.Point(this._margins.left, this._margins.top)).divide(this._containerInnerSize.x / n3.width).plus(n3.getTopLeft());
    }, pointFromPixel: function(e5, t3) {
      return this.pointFromPixelNoRotate(e5, t3).rotate(-this.getRotation(t3), this.getCenter(t3));
    }, _viewportToImageDelta: function(t3, i3) {
      var n3 = this._contentBoundsNoRotate.width;
      return new e4.Point(t3 * this._contentSizeNoRotate.x / n3, i3 * this._contentSizeNoRotate.x / n3);
    }, viewportToImageCoordinates: function(t3, i3) {
      if (t3 instanceof e4.Point)
        return this.viewportToImageCoordinates(t3.x, t3.y);
      if (this.viewer) {
        var n3 = this.viewer.world.getItemCount();
        if (n3 > 1)
          this.silenceMultiImageWarnings || e4.console.error("[Viewport.viewportToImageCoordinates] is not accurate with multi-image; use TiledImage.viewportToImageCoordinates instead.");
        else if (1 === n3) {
          return this.viewer.world.getItemAt(0).viewportToImageCoordinates(t3, i3, true);
        }
      }
      return this._viewportToImageDelta(t3 - this._contentBoundsNoRotate.x, i3 - this._contentBoundsNoRotate.y);
    }, _imageToViewportDelta: function(t3, i3) {
      var n3 = this._contentBoundsNoRotate.width;
      return new e4.Point(t3 / this._contentSizeNoRotate.x * n3, i3 / this._contentSizeNoRotate.x * n3);
    }, imageToViewportCoordinates: function(t3, i3) {
      if (t3 instanceof e4.Point)
        return this.imageToViewportCoordinates(t3.x, t3.y);
      if (this.viewer) {
        var n3 = this.viewer.world.getItemCount();
        if (n3 > 1)
          this.silenceMultiImageWarnings || e4.console.error("[Viewport.imageToViewportCoordinates] is not accurate with multi-image; use TiledImage.imageToViewportCoordinates instead.");
        else if (1 === n3) {
          return this.viewer.world.getItemAt(0).imageToViewportCoordinates(t3, i3, true);
        }
      }
      var o2 = this._imageToViewportDelta(t3, i3);
      return o2.x += this._contentBoundsNoRotate.x, o2.y += this._contentBoundsNoRotate.y, o2;
    }, imageToViewportRectangle: function(t3, i3, n3, o2) {
      var r2 = t3;
      if (r2 instanceof e4.Rect || (r2 = new e4.Rect(t3, i3, n3, o2)), this.viewer) {
        var s2 = this.viewer.world.getItemCount();
        if (s2 > 1)
          this.silenceMultiImageWarnings || e4.console.error("[Viewport.imageToViewportRectangle] is not accurate with multi-image; use TiledImage.imageToViewportRectangle instead.");
        else if (1 === s2) {
          return this.viewer.world.getItemAt(0).imageToViewportRectangle(t3, i3, n3, o2, true);
        }
      }
      var a2 = this.imageToViewportCoordinates(r2.x, r2.y), l2 = this._imageToViewportDelta(r2.width, r2.height);
      return new e4.Rect(a2.x, a2.y, l2.x, l2.y, r2.degrees);
    }, viewportToImageRectangle: function(t3, i3, n3, o2) {
      var r2 = t3;
      if (r2 instanceof e4.Rect || (r2 = new e4.Rect(t3, i3, n3, o2)), this.viewer) {
        var s2 = this.viewer.world.getItemCount();
        if (s2 > 1)
          this.silenceMultiImageWarnings || e4.console.error("[Viewport.viewportToImageRectangle] is not accurate with multi-image; use TiledImage.viewportToImageRectangle instead.");
        else if (1 === s2) {
          return this.viewer.world.getItemAt(0).viewportToImageRectangle(t3, i3, n3, o2, true);
        }
      }
      var a2 = this.viewportToImageCoordinates(r2.x, r2.y), l2 = this._viewportToImageDelta(r2.width, r2.height);
      return new e4.Rect(a2.x, a2.y, l2.x, l2.y, r2.degrees);
    }, viewerElementToImageCoordinates: function(e5) {
      var t3 = this.pointFromPixel(e5, true);
      return this.viewportToImageCoordinates(t3);
    }, imageToViewerElementCoordinates: function(e5) {
      var t3 = this.imageToViewportCoordinates(e5);
      return this.pixelFromPoint(t3, true);
    }, windowToImageCoordinates: function(t3) {
      e4.console.assert(this.viewer, "[Viewport.windowToImageCoordinates] the viewport must have a viewer.");
      var i3 = t3.minus(e4.getElementPosition(this.viewer.element));
      return this.viewerElementToImageCoordinates(i3);
    }, imageToWindowCoordinates: function(t3) {
      return e4.console.assert(this.viewer, "[Viewport.imageToWindowCoordinates] the viewport must have a viewer."), this.imageToViewerElementCoordinates(t3).plus(e4.getElementPosition(this.viewer.element));
    }, viewerElementToViewportCoordinates: function(e5) {
      return this.pointFromPixel(e5, true);
    }, viewportToViewerElementCoordinates: function(e5) {
      return this.pixelFromPoint(e5, true);
    }, viewerElementToViewportRectangle: function(t3) {
      return e4.Rect.fromSummits(this.pointFromPixel(t3.getTopLeft(), true), this.pointFromPixel(t3.getTopRight(), true), this.pointFromPixel(t3.getBottomLeft(), true));
    }, viewportToViewerElementRectangle: function(t3) {
      return e4.Rect.fromSummits(this.pixelFromPoint(t3.getTopLeft(), true), this.pixelFromPoint(t3.getTopRight(), true), this.pixelFromPoint(t3.getBottomLeft(), true));
    }, windowToViewportCoordinates: function(t3) {
      e4.console.assert(this.viewer, "[Viewport.windowToViewportCoordinates] the viewport must have a viewer.");
      var i3 = t3.minus(e4.getElementPosition(this.viewer.element));
      return this.viewerElementToViewportCoordinates(i3);
    }, viewportToWindowCoordinates: function(t3) {
      return e4.console.assert(this.viewer, "[Viewport.viewportToWindowCoordinates] the viewport must have a viewer."), this.viewportToViewerElementCoordinates(t3).plus(e4.getElementPosition(this.viewer.element));
    }, viewportToImageZoom: function(t3) {
      if (this.viewer) {
        var i3 = this.viewer.world.getItemCount();
        if (i3 > 1)
          this.silenceMultiImageWarnings || e4.console.error("[Viewport.viewportToImageZoom] is not accurate with multi-image.");
        else if (1 === i3) {
          return this.viewer.world.getItemAt(0).viewportToImageZoom(t3);
        }
      }
      var n3 = this._contentSizeNoRotate.x;
      return t3 * (this._containerInnerSize.x / n3 * this._contentBoundsNoRotate.width);
    }, imageToViewportZoom: function(t3) {
      if (this.viewer) {
        var i3 = this.viewer.world.getItemCount();
        if (i3 > 1)
          this.silenceMultiImageWarnings || e4.console.error("[Viewport.imageToViewportZoom] is not accurate with multi-image.");
        else if (1 === i3) {
          return this.viewer.world.getItemAt(0).imageToViewportZoom(t3);
        }
      }
      return t3 * (this._contentSizeNoRotate.x / this._containerInnerSize.x / this._contentBoundsNoRotate.width);
    }, toggleFlip: function() {
      return this.setFlip(!this.getFlip()), this;
    }, getFlip: function() {
      return this.flipped;
    }, setFlip: function(e5) {
      return this.flipped === e5 || (this.flipped = e5, this.viewer.navigator && this.viewer.navigator.setFlip(this.getFlip()), this.viewer.forceRedraw(), this.viewer.raiseEvent("flip", { flipped: e5 })), this;
    } };
  }(t2), function(e4) {
    e4.TiledImage = function(i4) {
      var n4 = this;
      e4.console.assert(i4.tileCache, "[TiledImage] options.tileCache is required"), e4.console.assert(i4.drawer, "[TiledImage] options.drawer is required"), e4.console.assert(i4.viewer, "[TiledImage] options.viewer is required"), e4.console.assert(i4.imageLoader, "[TiledImage] options.imageLoader is required"), e4.console.assert(i4.source, "[TiledImage] options.source is required"), e4.console.assert(!i4.clip || i4.clip instanceof e4.Rect, "[TiledImage] options.clip must be an OpenSeadragon.Rect if present"), e4.EventSource.call(this), this._tileCache = i4.tileCache, delete i4.tileCache, this._drawer = i4.drawer, delete i4.drawer, this._imageLoader = i4.imageLoader, delete i4.imageLoader, i4.clip instanceof e4.Rect && (this._clip = i4.clip.clone()), delete i4.clip;
      var o3 = i4.x || 0;
      delete i4.x;
      var r2 = i4.y || 0;
      delete i4.y, this.normHeight = i4.source.dimensions.y / i4.source.dimensions.x, this.contentAspectX = i4.source.dimensions.x / i4.source.dimensions.y;
      var s2 = 1;
      i4.width ? (s2 = i4.width, delete i4.width, i4.height && (e4.console.error("specifying both width and height to a tiledImage is not supported"), delete i4.height)) : i4.height && (s2 = i4.height / this.normHeight, delete i4.height);
      var a2 = i4.fitBounds;
      delete i4.fitBounds;
      var l2 = i4.fitBoundsPlacement || t2.Placement.CENTER;
      delete i4.fitBoundsPlacement;
      var c2 = i4.degrees || 0;
      delete i4.degrees;
      var h2 = i4.ajaxHeaders;
      delete i4.ajaxHeaders, e4.extend(true, this, { viewer: null, tilesMatrix: {}, coverage: {}, loadingCoverage: {}, lastDrawn: [], lastResetTime: 0, _midDraw: false, _needsDraw: true, _hasOpaqueTile: false, _tilesLoading: 0, springStiffness: e4.DEFAULT_SETTINGS.springStiffness, animationTime: e4.DEFAULT_SETTINGS.animationTime, minZoomImageRatio: e4.DEFAULT_SETTINGS.minZoomImageRatio, wrapHorizontal: e4.DEFAULT_SETTINGS.wrapHorizontal, wrapVertical: e4.DEFAULT_SETTINGS.wrapVertical, immediateRender: e4.DEFAULT_SETTINGS.immediateRender, blendTime: e4.DEFAULT_SETTINGS.blendTime, alwaysBlend: e4.DEFAULT_SETTINGS.alwaysBlend, minPixelRatio: e4.DEFAULT_SETTINGS.minPixelRatio, smoothTileEdgesMinZoom: e4.DEFAULT_SETTINGS.smoothTileEdgesMinZoom, iOSDevice: e4.DEFAULT_SETTINGS.iOSDevice, debugMode: e4.DEFAULT_SETTINGS.debugMode, crossOriginPolicy: e4.DEFAULT_SETTINGS.crossOriginPolicy, ajaxWithCredentials: e4.DEFAULT_SETTINGS.ajaxWithCredentials, placeholderFillStyle: e4.DEFAULT_SETTINGS.placeholderFillStyle, opacity: e4.DEFAULT_SETTINGS.opacity, preload: e4.DEFAULT_SETTINGS.preload, compositeOperation: e4.DEFAULT_SETTINGS.compositeOperation, subPixelRoundingForTransparency: e4.DEFAULT_SETTINGS.subPixelRoundingForTransparency }, i4), this._preload = this.preload, delete this.preload, this._fullyLoaded = false, this._xSpring = new e4.Spring({ initial: o3, springStiffness: this.springStiffness, animationTime: this.animationTime }), this._ySpring = new e4.Spring({ initial: r2, springStiffness: this.springStiffness, animationTime: this.animationTime }), this._scaleSpring = new e4.Spring({ initial: s2, springStiffness: this.springStiffness, animationTime: this.animationTime }), this._degreesSpring = new e4.Spring({ initial: c2, springStiffness: this.springStiffness, animationTime: this.animationTime }), this._updateForScale(), a2 && this.fitBounds(a2, l2, true), this._drawingHandler = function(t3) {
        n4.viewer.raiseEvent("tile-drawing", e4.extend({ tiledImage: n4 }, t3));
      }, this._ownAjaxHeaders = {}, this.setAjaxHeaders(h2, false);
    }, e4.extend(e4.TiledImage.prototype, e4.EventSource.prototype, { needsDraw: function() {
      return this._needsDraw;
    }, getFullyLoaded: function() {
      return this._fullyLoaded;
    }, _setFullyLoaded: function(e5) {
      e5 !== this._fullyLoaded && (this._fullyLoaded = e5, this.raiseEvent("fully-loaded-change", { fullyLoaded: this._fullyLoaded }));
    }, reset: function() {
      this._tileCache.clearTilesFor(this), this.lastResetTime = e4.now(), this._needsDraw = true;
    }, update: function() {
      var e5 = this._xSpring.update(), t3 = this._ySpring.update(), i4 = this._scaleSpring.update(), n4 = this._degreesSpring.update();
      return !!(e5 || t3 || i4 || n4) && (this._updateForScale(), this._needsDraw = true, true);
    }, draw: function() {
      0 !== this.opacity || this._preload ? (this._midDraw = true, this._updateViewport(), this._midDraw = false) : this._needsDraw = false;
    }, destroy: function() {
      this.reset(), this.source.destroy && this.source.destroy();
    }, getBounds: function(e5) {
      return this.getBoundsNoRotate(e5).rotate(this.getRotation(e5), this._getRotationPoint(e5));
    }, getBoundsNoRotate: function(t3) {
      return t3 ? new e4.Rect(this._xSpring.current.value, this._ySpring.current.value, this._worldWidthCurrent, this._worldHeightCurrent) : new e4.Rect(this._xSpring.target.value, this._ySpring.target.value, this._worldWidthTarget, this._worldHeightTarget);
    }, getWorldBounds: function() {
      return e4.console.error("[TiledImage.getWorldBounds] is deprecated; use TiledImage.getBounds instead"), this.getBounds();
    }, getClippedBounds: function(t3) {
      var i4 = this.getBoundsNoRotate(t3);
      if (this._clip) {
        var n4 = (t3 ? this._worldWidthCurrent : this._worldWidthTarget) / this.source.dimensions.x, o3 = this._clip.times(n4);
        i4 = new e4.Rect(i4.x + o3.x, i4.y + o3.y, o3.width, o3.height);
      }
      return i4.rotate(this.getRotation(t3), this._getRotationPoint(t3));
    }, getTileBounds: function(e5, t3, i4) {
      var n4 = this.source.getNumTiles(e5), o3 = (n4.x + t3 % n4.x) % n4.x, r2 = (n4.y + i4 % n4.y) % n4.y, s2 = this.source.getTileBounds(e5, o3, r2);
      return this.getFlip() && (s2.x = 1 - s2.x - s2.width), s2.x += (t3 - o3) / n4.x, s2.y += this._worldHeightCurrent / this._worldWidthCurrent * ((i4 - r2) / n4.y), s2;
    }, getContentSize: function() {
      return new e4.Point(this.source.dimensions.x, this.source.dimensions.y);
    }, getSizeInWindowCoordinates: function() {
      var t3 = this.imageToWindowCoordinates(new e4.Point(0, 0)), i4 = this.imageToWindowCoordinates(this.getContentSize());
      return new e4.Point(i4.x - t3.x, i4.y - t3.y);
    }, _viewportToImageDelta: function(t3, i4, n4) {
      var o3 = n4 ? this._scaleSpring.current.value : this._scaleSpring.target.value;
      return new e4.Point(t3 * (this.source.dimensions.x / o3), i4 * (this.source.dimensions.y * this.contentAspectX / o3));
    }, viewportToImageCoordinates: function(t3, i4, n4) {
      var o3;
      return t3 instanceof e4.Point ? (n4 = i4, o3 = t3) : o3 = new e4.Point(t3, i4), o3 = o3.rotate(-this.getRotation(n4), this._getRotationPoint(n4)), n4 ? this._viewportToImageDelta(o3.x - this._xSpring.current.value, o3.y - this._ySpring.current.value) : this._viewportToImageDelta(o3.x - this._xSpring.target.value, o3.y - this._ySpring.target.value);
    }, _imageToViewportDelta: function(t3, i4, n4) {
      var o3 = n4 ? this._scaleSpring.current.value : this._scaleSpring.target.value;
      return new e4.Point(t3 / this.source.dimensions.x * o3, i4 / this.source.dimensions.y / this.contentAspectX * o3);
    }, imageToViewportCoordinates: function(t3, i4, n4) {
      t3 instanceof e4.Point && (n4 = i4, i4 = t3.y, t3 = t3.x);
      var o3 = this._imageToViewportDelta(t3, i4);
      return n4 ? (o3.x += this._xSpring.current.value, o3.y += this._ySpring.current.value) : (o3.x += this._xSpring.target.value, o3.y += this._ySpring.target.value), o3.rotate(this.getRotation(n4), this._getRotationPoint(n4));
    }, imageToViewportRectangle: function(t3, i4, n4, o3, r2) {
      var s2 = t3;
      s2 instanceof e4.Rect ? r2 = i4 : s2 = new e4.Rect(t3, i4, n4, o3);
      var a2 = this.imageToViewportCoordinates(s2.getTopLeft(), r2), l2 = this._imageToViewportDelta(s2.width, s2.height, r2);
      return new e4.Rect(a2.x, a2.y, l2.x, l2.y, s2.degrees + this.getRotation(r2));
    }, viewportToImageRectangle: function(t3, i4, n4, o3, r2) {
      var s2 = t3;
      t3 instanceof e4.Rect ? r2 = i4 : s2 = new e4.Rect(t3, i4, n4, o3);
      var a2 = this.viewportToImageCoordinates(s2.getTopLeft(), r2), l2 = this._viewportToImageDelta(s2.width, s2.height, r2);
      return new e4.Rect(a2.x, a2.y, l2.x, l2.y, s2.degrees - this.getRotation(r2));
    }, viewerElementToImageCoordinates: function(e5) {
      var t3 = this.viewport.pointFromPixel(e5, true);
      return this.viewportToImageCoordinates(t3);
    }, imageToViewerElementCoordinates: function(e5) {
      var t3 = this.imageToViewportCoordinates(e5);
      return this.viewport.pixelFromPoint(t3, true);
    }, windowToImageCoordinates: function(e5) {
      var i4 = e5.minus(t2.getElementPosition(this.viewer.element));
      return this.viewerElementToImageCoordinates(i4);
    }, imageToWindowCoordinates: function(e5) {
      return this.imageToViewerElementCoordinates(e5).plus(t2.getElementPosition(this.viewer.element));
    }, _viewportToTiledImageRectangle: function(t3) {
      var i4 = this._scaleSpring.current.value;
      return t3 = t3.rotate(-this.getRotation(true), this._getRotationPoint(true)), new e4.Rect((t3.x - this._xSpring.current.value) / i4, (t3.y - this._ySpring.current.value) / i4, t3.width / i4, t3.height / i4, t3.degrees);
    }, viewportToImageZoom: function(e5) {
      return this._scaleSpring.current.value * this.viewport._containerInnerSize.x / this.source.dimensions.x * e5;
    }, imageToViewportZoom: function(e5) {
      return e5 / (this._scaleSpring.current.value * this.viewport._containerInnerSize.x / this.source.dimensions.x);
    }, setPosition: function(e5, t3) {
      var i4 = this._xSpring.target.value === e5.x && this._ySpring.target.value === e5.y;
      if (t3) {
        if (i4 && this._xSpring.current.value === e5.x && this._ySpring.current.value === e5.y)
          return;
        this._xSpring.resetTo(e5.x), this._ySpring.resetTo(e5.y), this._needsDraw = true;
      } else {
        if (i4)
          return;
        this._xSpring.springTo(e5.x), this._ySpring.springTo(e5.y), this._needsDraw = true;
      }
      i4 || this._raiseBoundsChange();
    }, setWidth: function(e5, t3) {
      this._setScale(e5, t3);
    }, setHeight: function(e5, t3) {
      this._setScale(e5 / this.normHeight, t3);
    }, setCroppingPolygons: function(t3) {
      var i4 = function(t4) {
        return t4.map(function(t5) {
          try {
            if (function(t6) {
              return t6 instanceof e4.Point || "number" == typeof t6.x && "number" == typeof t6.y;
            }(t5))
              return { x: t5.x, y: t5.y };
            throw new Error();
          } catch (e5) {
            throw new Error("A Provided cropping polygon point is not supported");
          }
        });
      };
      try {
        if (!e4.isArray(t3))
          throw new Error("Provided cropping polygon is not an array");
        this._croppingPolygons = t3.map(function(e5) {
          return i4(e5);
        });
      } catch (t4) {
        e4.console.error("[TiledImage.setCroppingPolygons] Cropping polygon format not supported"), e4.console.error(t4), this._croppingPolygons = null;
      }
    }, resetCroppingPolygons: function() {
      this._croppingPolygons = null;
    }, fitBounds: function(t3, i4, n4) {
      i4 = i4 || e4.Placement.CENTER;
      var o3 = e4.Placement.properties[i4], r2 = this.contentAspectX, s2 = 0, a2 = 0, l2 = 1, c2 = 1;
      if (this._clip && (r2 = this._clip.getAspectRatio(), l2 = this._clip.width / this.source.dimensions.x, c2 = this._clip.height / this.source.dimensions.y, t3.getAspectRatio() > r2 ? (s2 = this._clip.x / this._clip.height * t3.height, a2 = this._clip.y / this._clip.height * t3.height) : (s2 = this._clip.x / this._clip.width * t3.width, a2 = this._clip.y / this._clip.width * t3.width)), t3.getAspectRatio() > r2) {
        var h2 = t3.height / c2, u2 = 0;
        o3.isHorizontallyCentered ? u2 = (t3.width - t3.height * r2) / 2 : o3.isRight && (u2 = t3.width - t3.height * r2), this.setPosition(new e4.Point(t3.x - s2 + u2, t3.y - a2), n4), this.setHeight(h2, n4);
      } else {
        var d2 = t3.width / l2, p2 = 0;
        o3.isVerticallyCentered ? p2 = (t3.height - t3.width / r2) / 2 : o3.isBottom && (p2 = t3.height - t3.width / r2), this.setPosition(new e4.Point(t3.x - s2, t3.y - a2 + p2), n4), this.setWidth(d2, n4);
      }
    }, getClip: function() {
      return this._clip ? this._clip.clone() : null;
    }, setClip: function(t3) {
      e4.console.assert(!t3 || t3 instanceof e4.Rect, "[TiledImage.setClip] newClip must be an OpenSeadragon.Rect or null"), t3 instanceof e4.Rect ? this._clip = t3.clone() : this._clip = null, this._needsDraw = true, this.raiseEvent("clip-change");
    }, getFlip: function() {
      return !!this.flipped;
    }, setFlip: function(e5) {
      this.flipped = !!e5, this._needsDraw = true, this._raiseBoundsChange();
    }, getOpacity: function() {
      return this.opacity;
    }, setOpacity: function(e5) {
      e5 !== this.opacity && (this.opacity = e5, this._needsDraw = true, this.raiseEvent("opacity-change", { opacity: this.opacity }));
    }, getPreload: function() {
      return this._preload;
    }, setPreload: function(e5) {
      this._preload = !!e5, this._needsDraw = true;
    }, getRotation: function(e5) {
      return e5 ? this._degreesSpring.current.value : this._degreesSpring.target.value;
    }, setRotation: function(e5, t3) {
      this._degreesSpring.target.value === e5 && this._degreesSpring.isAtTargetValue() || (t3 ? this._degreesSpring.resetTo(e5) : this._degreesSpring.springTo(e5), this._needsDraw = true, this._raiseBoundsChange());
    }, _getRotationPoint: function(e5) {
      return this.getBoundsNoRotate(e5).getCenter();
    }, getCompositeOperation: function() {
      return this.compositeOperation;
    }, setCompositeOperation: function(e5) {
      e5 !== this.compositeOperation && (this.compositeOperation = e5, this._needsDraw = true, this.raiseEvent("composite-operation-change", { compositeOperation: this.compositeOperation }));
    }, setAjaxHeaders: function(t3, i4) {
      null === t3 && (t3 = {}), e4.isPlainObject(t3) ? (this._ownAjaxHeaders = t3, this._updateAjaxHeaders(i4)) : console.error("[TiledImage.setAjaxHeaders] Ignoring invalid headers, must be a plain object");
    }, _updateAjaxHeaders: function(t3) {
      if (void 0 === t3 && (t3 = true), e4.isPlainObject(this.viewer.ajaxHeaders) ? this.ajaxHeaders = e4.extend({}, this.viewer.ajaxHeaders, this._ownAjaxHeaders) : this.ajaxHeaders = this._ownAjaxHeaders, t3) {
        var i4, n4, o3, r2;
        for (var s2 in this.tilesMatrix)
          for (var a2 in i4 = this.source.getNumTiles(s2), this.tilesMatrix[s2])
            for (var l2 in n4 = (i4.x + a2 % i4.x) % i4.x, this.tilesMatrix[s2][a2])
              if (o3 = (i4.y + l2 % i4.y) % i4.y, (r2 = this.tilesMatrix[s2][a2][l2]).loadWithAjax = this.loadTilesWithAjax, r2.loadWithAjax) {
                var c2 = this.source.getTileAjaxHeaders(s2, n4, o3);
                r2.ajaxHeaders = e4.extend({}, this.ajaxHeaders, c2);
              } else
                r2.ajaxHeaders = null;
        for (var h2 = 0; h2 < this._imageLoader.jobQueue.length; h2++) {
          var u2 = this._imageLoader.jobQueue[h2];
          u2.loadWithAjax = u2.tile.loadWithAjax, u2.ajaxHeaders = u2.tile.loadWithAjax ? u2.tile.ajaxHeaders : null;
        }
      }
    }, _setScale: function(e5, t3) {
      var i4 = this._scaleSpring.target.value === e5;
      if (t3) {
        if (i4 && this._scaleSpring.current.value === e5)
          return;
        this._scaleSpring.resetTo(e5), this._updateForScale(), this._needsDraw = true;
      } else {
        if (i4)
          return;
        this._scaleSpring.springTo(e5), this._updateForScale(), this._needsDraw = true;
      }
      i4 || this._raiseBoundsChange();
    }, _updateForScale: function() {
      this._worldWidthTarget = this._scaleSpring.target.value, this._worldHeightTarget = this.normHeight * this._scaleSpring.target.value, this._worldWidthCurrent = this._scaleSpring.current.value, this._worldHeightCurrent = this.normHeight * this._scaleSpring.current.value;
    }, _raiseBoundsChange: function() {
      this.raiseEvent("bounds-change");
    }, _isBottomItem: function() {
      return this.viewer.world.getItemAt(0) === this;
    }, _getLevelsInterval: function() {
      var e5 = Math.max(this.source.minLevel, Math.floor(Math.log(this.minZoomImageRatio) / Math.log(2))), t3 = this.viewport.deltaPixelsFromPointsNoRotate(this.source.getPixelRatio(0), true).x * this._scaleSpring.current.value, i4 = Math.min(Math.abs(this.source.maxLevel), Math.abs(Math.floor(Math.log(t3 / this.minPixelRatio) / Math.log(2))));
      return i4 = Math.max(i4, this.source.minLevel || 0), { lowestLevel: e5 = Math.min(e5, i4), highestLevel: i4 };
    }, _updateViewport: function() {
      for (this._needsDraw = false, this._tilesLoading = 0, this.loadingCoverage = {}; this.lastDrawn.length > 0; ) {
        this.lastDrawn.pop().beingDrawn = false;
      }
      var t3 = this.viewport, i4 = this._viewportToTiledImageRectangle(t3.getBoundsWithMargins(true));
      if (!this.wrapHorizontal && !this.wrapVertical) {
        var n4 = this._viewportToTiledImageRectangle(this.getClippedBounds(true));
        if (null === (i4 = i4.intersection(n4)))
          return;
      }
      for (var o3 = this._getLevelsInterval(), r2 = o3.lowestLevel, s2 = o3.highestLevel, a2 = null, l2 = false, c2 = e4.now(), h2 = s2; h2 >= r2; h2--) {
        var u2 = false, d2 = t3.deltaPixelsFromPointsNoRotate(this.source.getPixelRatio(h2), true).x * this._scaleSpring.current.value;
        if (h2 === r2 || !l2 && d2 >= this.minPixelRatio)
          u2 = true, l2 = true;
        else if (!l2)
          continue;
        var p2 = t3.deltaPixelsFromPointsNoRotate(this.source.getPixelRatio(h2), false).x * this._scaleSpring.current.value, _2 = t3.deltaPixelsFromPointsNoRotate(this.source.getPixelRatio(Math.max(this.source.getClosestLevel(), 0)), false).x * this._scaleSpring.current.value, g2 = this.immediateRender ? 1 : _2, m2 = Math.min(1, (d2 - 0.5) / 0.5), f2 = g2 / Math.abs(g2 - p2);
        if (a2 = this._updateLevel(l2, u2, h2, m2, f2, i4, c2, a2), this._providesCoverage(this.coverage, h2))
          break;
      }
      this._drawTiles(this.lastDrawn), a2 && !a2.context2D ? (this._loadTile(a2, c2), this._needsDraw = true, this._setFullyLoaded(false)) : this._setFullyLoaded(0 === this._tilesLoading);
    }, _getCornerTiles: function(t3, i4, n4) {
      var o3, r2, s2, a2;
      this.wrapHorizontal ? (o3 = e4.positiveModulo(i4.x, 1), r2 = e4.positiveModulo(n4.x, 1)) : (o3 = Math.max(0, i4.x), r2 = Math.min(1, n4.x));
      var l2 = 1 / this.source.aspectRatio;
      this.wrapVertical ? (s2 = e4.positiveModulo(i4.y, l2), a2 = e4.positiveModulo(n4.y, l2)) : (s2 = Math.max(0, i4.y), a2 = Math.min(l2, n4.y));
      var c2 = this.source.getTileAtPoint(t3, new e4.Point(o3, s2)), h2 = this.source.getTileAtPoint(t3, new e4.Point(r2, a2)), u2 = this.source.getNumTiles(t3);
      return this.wrapHorizontal && (c2.x += u2.x * Math.floor(i4.x), h2.x += u2.x * Math.floor(n4.x)), this.wrapVertical && (c2.y += u2.y * Math.floor(i4.y / l2), h2.y += u2.y * Math.floor(n4.y / l2)), { topLeft: c2, bottomRight: h2 };
    }, _updateLevel: function(e5, t3, i4, n4, o3, r2, s2, a2) {
      var l2 = r2.getBoundingBox().getTopLeft(), c2 = r2.getBoundingBox().getBottomRight();
      this.viewer && this.viewer.raiseEvent("update-level", { tiledImage: this, havedrawn: e5, level: i4, opacity: n4, visibility: o3, drawArea: r2, topleft: l2, bottomright: c2, currenttime: s2, best: a2 }), this._resetCoverage(this.coverage, i4), this._resetCoverage(this.loadingCoverage, i4);
      var h2 = this._getCornerTiles(i4, l2, c2), u2 = h2.topLeft, d2 = h2.bottomRight, p2 = this.source.getNumTiles(i4), _2 = this.viewport.pixelFromPoint(this.viewport.getCenter());
      this.getFlip() && (d2.x += 1, this.wrapHorizontal || (d2.x = Math.min(d2.x, p2.x - 1)));
      for (var g2 = u2.x; g2 <= d2.x; g2++)
        for (var m2 = u2.y; m2 <= d2.y; m2++) {
          var f2;
          if (this.getFlip()) {
            var v2 = (p2.x + g2 % p2.x) % p2.x;
            f2 = g2 + p2.x - v2 - v2 - 1;
          } else
            f2 = g2;
          null !== r2.intersection(this.getTileBounds(i4, f2, m2)) && (a2 = this._updateTile(t3, e5, f2, m2, i4, n4, o3, _2, p2, s2, a2));
        }
      return a2;
    }, _updateTile: function(e5, t3, i4, n4, o3, r2, s2, a2, l2, c2, h2) {
      var u2 = this._getTile(i4, n4, o3, c2, l2, this._worldWidthCurrent, this._worldHeightCurrent), d2 = t3;
      this.viewer && this.viewer.raiseEvent("update-tile", { tiledImage: this, tile: u2 }), this._setCoverage(this.coverage, o3, i4, n4, false);
      var p2 = u2.loaded || u2.loading || this._isCovered(this.loadingCoverage, o3, i4, n4);
      if (this._setCoverage(this.loadingCoverage, o3, i4, n4, p2), !u2.exists)
        return h2;
      if (e5 && !d2 && (this._isCovered(this.coverage, o3, i4, n4) ? this._setCoverage(this.coverage, o3, i4, n4, true) : d2 = true), !d2)
        return h2;
      if (this._positionTile(u2, this.source.tileOverlap, this.viewport, a2, s2), !u2.loaded)
        if (u2.context2D)
          this._setTileLoaded(u2);
        else {
          var _2 = this._tileCache.getImageRecord(u2.cacheKey);
          _2 && this._setTileLoaded(u2, _2.getData());
        }
      u2.loaded ? this._blendTile(u2, i4, n4, o3, r2, c2) && (this._needsDraw = true) : u2.loading ? this._tilesLoading++ : p2 || (h2 = this._compareTiles(h2, u2));
      return h2;
    }, _getTile: function(t3, i4, n4, o3, r2, s2, a2) {
      var l2, c2, h2, u2, d2, p2, _2, g2, m2, f2, v2 = this.tilesMatrix, A2 = this.source;
      return v2[n4] || (v2[n4] = {}), v2[n4][t3] || (v2[n4][t3] = {}), v2[n4][t3][i4] && !v2[n4][t3][i4].flipped == !this.flipped || (l2 = (r2.x + t3 % r2.x) % r2.x, c2 = (r2.y + i4 % r2.y) % r2.y, h2 = this.getTileBounds(n4, t3, i4), u2 = A2.getTileBounds(n4, l2, c2, true), d2 = A2.tileExists(n4, l2, c2), p2 = A2.getTileUrl(n4, l2, c2), _2 = A2.getTilePostData(n4, l2, c2), this.loadTilesWithAjax ? (g2 = A2.getTileAjaxHeaders(n4, l2, c2), e4.isPlainObject(this.ajaxHeaders) && (g2 = e4.extend({}, this.ajaxHeaders, g2))) : g2 = null, m2 = A2.getContext2D ? A2.getContext2D(n4, l2, c2) : void 0, f2 = new e4.Tile(n4, t3, i4, h2, d2, p2, m2, this.loadTilesWithAjax, g2, u2, _2, A2.getTileHashKey(n4, l2, c2, p2, g2, _2)), this.getFlip() ? 0 === l2 && (f2.isRightMost = true) : l2 === r2.x - 1 && (f2.isRightMost = true), c2 === r2.y - 1 && (f2.isBottomMost = true), f2.flipped = this.flipped, v2[n4][t3][i4] = f2), (f2 = v2[n4][t3][i4]).lastTouchTime = o3, f2;
    }, _loadTile: function(e5, t3) {
      var i4 = this;
      e5.loading = true, this._imageLoader.addJob({ src: e5.getUrl(), tile: e5, source: this.source, postData: e5.postData, loadWithAjax: e5.loadWithAjax, ajaxHeaders: e5.ajaxHeaders, crossOriginPolicy: this.crossOriginPolicy, ajaxWithCredentials: this.ajaxWithCredentials, callback: function(n4, o3, r2) {
        i4._onTileLoad(e5, t3, n4, o3, r2);
      }, abort: function() {
        e5.loading = false;
      } });
    }, _onTileLoad: function(t3, i4, n4, o3, r2) {
      if (!n4)
        return e4.console.error("Tile %s failed to load: %s - error: %s", t3, t3.getUrl(), o3), this.viewer.raiseEvent("tile-load-failed", { tile: t3, tiledImage: this, time: i4, message: o3, tileRequest: r2 }), t3.loading = false, void (t3.exists = false);
      if (t3.exists = true, i4 < this.lastResetTime)
        return e4.console.warn("Ignoring tile %s loaded before reset: %s", t3, t3.getUrl()), void (t3.loading = false);
      var s2 = this, a2 = function() {
        var e5 = s2.source.getClosestLevel();
        s2._setTileLoaded(t3, n4, e5, r2);
      };
      this._midDraw ? window.setTimeout(a2, 1) : a2();
    }, _setTileLoaded: function(t3, i4, n4, o3) {
      var r2 = 0, s2 = false, a2 = this;
      function l2() {
        return s2 && e4.console.error("Event 'tile-loaded' argument getCompletionCallback must be called synchronously. Its return value should be called asynchronously."), r2++, c2;
      }
      function c2() {
        0 === --r2 && (t3.loading = false, t3.loaded = true, t3.hasTransparency = a2.source.hasTransparency(t3.context2D, t3.getUrl(), t3.ajaxHeaders, t3.postData), t3.context2D || a2._tileCache.cacheTile({ data: i4, tile: t3, cutoff: n4, tiledImage: a2 }), a2._needsDraw = true);
      }
      var h2 = l2();
      this.viewer.raiseEvent("tile-loaded", { tile: t3, tiledImage: this, tileRequest: o3, get image() {
        return e4.console.error("[tile-loaded] event 'image' has been deprecated. Use 'data' property instead."), i4;
      }, data: i4, getCompletionCallback: l2 }), s2 = true, h2();
    }, _positionTile: function(t3, i4, n4, o3, r2) {
      var s2 = t3.bounds.getTopLeft();
      s2.x *= this._scaleSpring.current.value, s2.y *= this._scaleSpring.current.value, s2.x += this._xSpring.current.value, s2.y += this._ySpring.current.value;
      var a2 = t3.bounds.getSize();
      a2.x *= this._scaleSpring.current.value, a2.y *= this._scaleSpring.current.value;
      var l2 = n4.pixelFromPointNoRotate(s2, true), c2 = n4.pixelFromPointNoRotate(s2, false), h2 = n4.deltaPixelsFromPointsNoRotate(a2, true), u2 = n4.deltaPixelsFromPointsNoRotate(a2, false), d2 = c2.plus(u2.divide(2)), p2 = o3.squaredDistanceTo(d2);
      i4 || (h2 = h2.plus(new e4.Point(1, 1))), t3.isRightMost && this.wrapHorizontal && (h2.x += 0.75), t3.isBottomMost && this.wrapVertical && (h2.y += 0.75), t3.position = l2, t3.size = h2, t3.squaredDistance = p2, t3.visibility = r2;
    }, _blendTile: function(e5, t3, i4, n4, o3, r2) {
      var s2, a2, l2 = 1e3 * this.blendTime;
      if (e5.blendStart || (e5.blendStart = r2), s2 = r2 - e5.blendStart, a2 = l2 ? Math.min(1, s2 / l2) : 1, this.alwaysBlend && (a2 *= o3), e5.opacity = a2, this.lastDrawn.push(e5), 1 === a2)
        this._setCoverage(this.coverage, n4, t3, i4, true), this._hasOpaqueTile = true;
      else if (s2 < l2)
        return true;
      return false;
    }, _compareTiles: function(e5, t3) {
      return e5 ? t3.visibility > e5.visibility || t3.visibility === e5.visibility && t3.squaredDistance < e5.squaredDistance ? t3 : e5 : t3;
    }, _drawTiles: function(t3) {
      if (0 !== this.opacity && (0 !== t3.length || this.placeholderFillStyle)) {
        var r2, s2, a2, l2 = t3[0];
        l2 && (r2 = this.opacity < 1 || this.compositeOperation && "source-over" !== this.compositeOperation || !this._isBottomItem() && this.source.hasTransparency(l2.context2D, l2.getUrl(), l2.ajaxHeaders, l2.postData));
        var c2, h2 = this.viewport.getZoom(true), u2 = this.viewportToImageZoom(h2);
        t3.length > 1 && u2 > this.smoothTileEdgesMinZoom && !this.iOSDevice && this.getRotation(true) % 360 == 0 && e4.supportsCanvas && this.viewer.useCanvas && (r2 = true, s2 = l2.getScaleForEdgeSmoothing(), a2 = l2.getTranslationForEdgeSmoothing(s2, this._drawer.getCanvasSize(false), this._drawer.getCanvasSize(true))), r2 && (s2 || (c2 = this.viewport.viewportToViewerElementRectangle(this.getClippedBounds(true)).getIntegerBoundingBox(), this._drawer.viewer.viewport.getFlip() && (this.viewport.getRotation(true) % 360 == 0 && this.getRotation(true) % 360 == 0 || (c2.x = this._drawer.viewer.container.clientWidth - (c2.x + c2.width))), c2 = c2.times(e4.pixelDensityRatio)), this._drawer._clear(true, c2)), s2 || (this.viewport.getRotation(true) % 360 != 0 && this._drawer._offsetForRotation({ degrees: this.viewport.getRotation(true), useSketch: r2 }), this.getRotation(true) % 360 != 0 && this._drawer._offsetForRotation({ degrees: this.getRotation(true), point: this.viewport.pixelFromPointNoRotate(this._getRotationPoint(true), true), useSketch: r2 }), this.viewport.getRotation(true) % 360 == 0 && this.getRotation(true) % 360 == 0 && this._drawer.viewer.viewport.getFlip() && this._drawer._flip());
        var d2 = false;
        if (this._clip) {
          this._drawer.saveContext(r2);
          var p2 = this.imageToViewportRectangle(this._clip, true);
          p2 = p2.rotate(-this.getRotation(true), this._getRotationPoint(true));
          var _2 = this._drawer.viewportToDrawerRectangle(p2);
          s2 && (_2 = _2.times(s2)), a2 && (_2 = _2.translate(a2)), this._drawer.setClip(_2, r2), d2 = true;
        }
        if (this._croppingPolygons) {
          var g2 = this;
          this._drawer.saveContext(r2);
          try {
            var m2 = this._croppingPolygons.map(function(e5) {
              return e5.map(function(e6) {
                var t4 = g2.imageToViewportCoordinates(e6.x, e6.y, true).rotate(-g2.getRotation(true), g2._getRotationPoint(true)), i4 = g2._drawer.viewportCoordToDrawerCoord(t4);
                return s2 && (i4 = i4.times(s2)), a2 && (i4 = i4.plus(a2)), i4;
              });
            });
            this._drawer.clipWithPolygons(m2, r2);
          } catch (t4) {
            e4.console.error(t4);
          }
          d2 = true;
        }
        if (this.placeholderFillStyle && false === this._hasOpaqueTile) {
          var f2 = this._drawer.viewportToDrawerRectangle(this.getBounds(true));
          s2 && (f2 = f2.times(s2)), a2 && (f2 = f2.translate(a2));
          var v2 = null;
          v2 = "function" == typeof this.placeholderFillStyle ? this.placeholderFillStyle(this, this._drawer.context) : this.placeholderFillStyle, this._drawer.drawRectangle(f2, v2, r2);
        }
        var A2 = function(t4) {
          if ("number" == typeof t4)
            return o2(t4);
          if (!t4 || !e4.Browser)
            return i3;
          var r3 = t4[e4.Browser.vendor];
          n3(r3) && (r3 = t4["*"]);
          return o2(r3);
        }(this.subPixelRoundingForTransparency), b2 = false;
        if (A2 === e4.SUBPIXEL_ROUNDING_OCCURRENCES.ALWAYS)
          b2 = true;
        else if (A2 === e4.SUBPIXEL_ROUNDING_OCCURRENCES.ONLY_AT_REST) {
          b2 = !(this.viewer && this.viewer.isAnimating());
        }
        for (var y2 = t3.length - 1; y2 >= 0; y2--)
          l2 = t3[y2], this._drawer.drawTile(l2, this._drawingHandler, r2, s2, a2, b2, this.source), l2.beingDrawn = true, this.viewer && this.viewer.raiseEvent("tile-drawn", { tiledImage: this, tile: l2 });
        d2 && this._drawer.restoreContext(r2), s2 || (this.getRotation(true) % 360 != 0 && this._drawer._restoreRotationChanges(r2), this.viewport.getRotation(true) % 360 != 0 && this._drawer._restoreRotationChanges(r2)), r2 && (s2 && (this.viewport.getRotation(true) % 360 != 0 && this._drawer._offsetForRotation({ degrees: this.viewport.getRotation(true), useSketch: false }), this.getRotation(true) % 360 != 0 && this._drawer._offsetForRotation({ degrees: this.getRotation(true), point: this.viewport.pixelFromPointNoRotate(this._getRotationPoint(true), true), useSketch: false })), this._drawer.blendSketch({ opacity: this.opacity, scale: s2, translate: a2, compositeOperation: this.compositeOperation, bounds: c2 }), s2 && (this.getRotation(true) % 360 != 0 && this._drawer._restoreRotationChanges(false), this.viewport.getRotation(true) % 360 != 0 && this._drawer._restoreRotationChanges(false))), s2 || this.viewport.getRotation(true) % 360 == 0 && this.getRotation(true) % 360 == 0 && this._drawer.viewer.viewport.getFlip() && this._drawer._flip(), this._drawDebugInfo(t3);
      }
    }, _drawDebugInfo: function(t3) {
      if (this.debugMode)
        for (var i4 = t3.length - 1; i4 >= 0; i4--) {
          var n4 = t3[i4];
          try {
            this._drawer.drawDebugInfo(n4, t3.length, i4, this);
          } catch (t4) {
            e4.console.error(t4);
          }
        }
    }, _providesCoverage: function(e5, t3, i4, n4) {
      var o3, r2, s2, a2;
      if (!e5[t3])
        return false;
      if (void 0 === i4 || void 0 === n4) {
        for (s2 in o3 = e5[t3])
          if (Object.prototype.hasOwnProperty.call(o3, s2)) {
            for (a2 in r2 = o3[s2])
              if (Object.prototype.hasOwnProperty.call(r2, a2) && !r2[a2])
                return false;
          }
        return true;
      }
      return void 0 === e5[t3][i4] || void 0 === e5[t3][i4][n4] || true === e5[t3][i4][n4];
    }, _isCovered: function(e5, t3, i4, n4) {
      return void 0 === i4 || void 0 === n4 ? this._providesCoverage(e5, t3 + 1) : this._providesCoverage(e5, t3 + 1, 2 * i4, 2 * n4) && this._providesCoverage(e5, t3 + 1, 2 * i4, 2 * n4 + 1) && this._providesCoverage(e5, t3 + 1, 2 * i4 + 1, 2 * n4) && this._providesCoverage(e5, t3 + 1, 2 * i4 + 1, 2 * n4 + 1);
    }, _setCoverage: function(t3, i4, n4, o3, r2) {
      t3[i4] ? (t3[i4][n4] || (t3[i4][n4] = {}), t3[i4][n4][o3] = r2) : e4.console.warn("Setting coverage for a tile before its level's coverage has been reset: %s", i4);
    }, _resetCoverage: function(e5, t3) {
      e5[t3] = {};
    } });
    var i3 = e4.SUBPIXEL_ROUNDING_OCCURRENCES.NEVER;
    function n3(t3) {
      return t3 !== e4.SUBPIXEL_ROUNDING_OCCURRENCES.ALWAYS && t3 !== e4.SUBPIXEL_ROUNDING_OCCURRENCES.ONLY_AT_REST && t3 !== e4.SUBPIXEL_ROUNDING_OCCURRENCES.NEVER;
    }
    function o2(e5) {
      return n3(e5) ? i3 : e5;
    }
  }(t2), function(e4) {
    var t3 = function(t4) {
      e4.console.assert(t4, "[TileCache.cacheTile] options is required"), e4.console.assert(t4.tile, "[TileCache.cacheTile] options.tile is required"), e4.console.assert(t4.tiledImage, "[TileCache.cacheTile] options.tiledImage is required"), this.tile = t4.tile, this.tiledImage = t4.tiledImage;
    }, i3 = function(t4) {
      e4.console.assert(t4, "[ImageRecord] options is required"), e4.console.assert(t4.data, "[ImageRecord] options.data is required"), this._tiles = [], t4.create.apply(null, [this, t4.data, t4.ownerTile]), this._destroyImplementation = t4.destroy.bind(null, this), this.getImage = t4.getImage.bind(null, this), this.getData = t4.getData.bind(null, this), this.getRenderedContext = t4.getRenderedContext.bind(null, this);
    };
    i3.prototype = { destroy: function() {
      this._destroyImplementation(), this._tiles = null;
    }, addTile: function(t4) {
      e4.console.assert(t4, "[ImageRecord.addTile] tile is required"), this._tiles.push(t4);
    }, removeTile: function(t4) {
      for (var i4 = 0; i4 < this._tiles.length; i4++)
        if (this._tiles[i4] === t4)
          return void this._tiles.splice(i4, 1);
      e4.console.warn("[ImageRecord.removeTile] trying to remove unknown tile", t4);
    }, getTileCount: function() {
      return this._tiles.length;
    } }, e4.TileCache = function(t4) {
      t4 = t4 || {}, this._maxImageCacheCount = t4.maxImageCacheCount || e4.DEFAULT_SETTINGS.maxImageCacheCount, this._tilesLoaded = [], this._imagesLoaded = [], this._imagesLoadedCount = 0;
    }, e4.TileCache.prototype = { numTilesLoaded: function() {
      return this._tilesLoaded.length;
    }, cacheTile: function(n3) {
      e4.console.assert(n3, "[TileCache.cacheTile] options is required"), e4.console.assert(n3.tile, "[TileCache.cacheTile] options.tile is required"), e4.console.assert(n3.tile.cacheKey, "[TileCache.cacheTile] options.tile.cacheKey is required"), e4.console.assert(n3.tiledImage, "[TileCache.cacheTile] options.tiledImage is required");
      var o2 = n3.cutoff || 0, r2 = this._tilesLoaded.length, s2 = this._imagesLoaded[n3.tile.cacheKey];
      if (s2 || (n3.data || (e4.console.error("[TileCache.cacheTile] options.image was renamed to options.data. '.image' attribute has been deprecated and will be removed in the future."), n3.data = n3.image), e4.console.assert(n3.data, "[TileCache.cacheTile] options.data is required to create an ImageRecord"), s2 = this._imagesLoaded[n3.tile.cacheKey] = new i3({ data: n3.data, ownerTile: n3.tile, create: n3.tiledImage.source.createTileCache, destroy: n3.tiledImage.source.destroyTileCache, getImage: n3.tiledImage.source.getTileCacheDataAsImage, getData: n3.tiledImage.source.getTileCacheData, getRenderedContext: n3.tiledImage.source.getTileCacheDataAsContext2D }), this._imagesLoadedCount++), s2.addTile(n3.tile), n3.tile.cacheImageRecord = s2, this._imagesLoadedCount > this._maxImageCacheCount) {
        for (var a2, l2, c2, h2, u2, d2, p2 = null, _2 = -1, g2 = null, m2 = this._tilesLoaded.length - 1; m2 >= 0; m2--)
          (a2 = (d2 = this._tilesLoaded[m2]).tile).level <= o2 || a2.beingDrawn || (p2 ? (h2 = a2.lastTouchTime, l2 = p2.lastTouchTime, u2 = a2.level, c2 = p2.level, (h2 < l2 || h2 === l2 && u2 > c2) && (p2 = a2, _2 = m2, g2 = d2)) : (p2 = a2, _2 = m2, g2 = d2));
        p2 && _2 >= 0 && (this._unloadTile(g2), r2 = _2);
      }
      this._tilesLoaded[r2] = new t3({ tile: n3.tile, tiledImage: n3.tiledImage });
    }, clearTilesFor: function(t4) {
      var i4;
      e4.console.assert(t4, "[TileCache.clearTilesFor] tiledImage is required");
      for (var n3 = 0; n3 < this._tilesLoaded.length; ++n3)
        (i4 = this._tilesLoaded[n3]).tiledImage === t4 && (this._unloadTile(i4), this._tilesLoaded.splice(n3, 1), n3--);
    }, getImageRecord: function(t4) {
      return e4.console.assert(t4, "[TileCache.getImageRecord] cacheKey is required"), this._imagesLoaded[t4];
    }, _unloadTile: function(t4) {
      e4.console.assert(t4, "[TileCache._unloadTile] tileRecord is required");
      var i4 = t4.tile, n3 = t4.tiledImage;
      i4.unload(), i4.cacheImageRecord = null;
      var o2 = this._imagesLoaded[i4.cacheKey];
      o2.removeTile(i4), o2.getTileCount() || (o2.destroy(), delete this._imagesLoaded[i4.cacheKey], this._imagesLoadedCount--), n3.viewer.raiseEvent("tile-unloaded", { tile: i4, tiledImage: n3 });
    } };
  }(t2), function(e4) {
    e4.World = function(t3) {
      var i3 = this;
      e4.console.assert(t3.viewer, "[World] options.viewer is required"), e4.EventSource.call(this), this.viewer = t3.viewer, this._items = [], this._needsDraw = false, this._autoRefigureSizes = true, this._needsSizesFigured = false, this._delegatedFigureSizes = function(e5) {
        i3._autoRefigureSizes ? i3._figureSizes() : i3._needsSizesFigured = true;
      }, this._figureSizes();
    }, e4.extend(e4.World.prototype, e4.EventSource.prototype, { addItem: function(t3, i3) {
      if (e4.console.assert(t3, "[World.addItem] item is required"), e4.console.assert(t3 instanceof e4.TiledImage, "[World.addItem] only TiledImages supported at this time"), void 0 !== (i3 = i3 || {}).index) {
        var n3 = Math.max(0, Math.min(this._items.length, i3.index));
        this._items.splice(n3, 0, t3);
      } else
        this._items.push(t3);
      this._autoRefigureSizes ? this._figureSizes() : this._needsSizesFigured = true, this._needsDraw = true, t3.addHandler("bounds-change", this._delegatedFigureSizes), t3.addHandler("clip-change", this._delegatedFigureSizes), this.raiseEvent("add-item", { item: t3 });
    }, getItemAt: function(t3) {
      return e4.console.assert(void 0 !== t3, "[World.getItemAt] index is required"), this._items[t3];
    }, getIndexOfItem: function(t3) {
      return e4.console.assert(t3, "[World.getIndexOfItem] item is required"), e4.indexOf(this._items, t3);
    }, getItemCount: function() {
      return this._items.length;
    }, setItemIndex: function(t3, i3) {
      e4.console.assert(t3, "[World.setItemIndex] item is required"), e4.console.assert(void 0 !== i3, "[World.setItemIndex] index is required");
      var n3 = this.getIndexOfItem(t3);
      if (i3 >= this._items.length)
        throw new Error("Index bigger than number of layers.");
      i3 !== n3 && -1 !== n3 && (this._items.splice(n3, 1), this._items.splice(i3, 0, t3), this._needsDraw = true, this.raiseEvent("item-index-change", { item: t3, previousIndex: n3, newIndex: i3 }));
    }, removeItem: function(t3) {
      e4.console.assert(t3, "[World.removeItem] item is required");
      var i3 = e4.indexOf(this._items, t3);
      -1 !== i3 && (t3.removeHandler("bounds-change", this._delegatedFigureSizes), t3.removeHandler("clip-change", this._delegatedFigureSizes), t3.destroy(), this._items.splice(i3, 1), this._figureSizes(), this._needsDraw = true, this._raiseRemoveItem(t3));
    }, removeAll: function() {
      var e5, t3;
      for (this.viewer._cancelPendingImages(), t3 = 0; t3 < this._items.length; t3++)
        (e5 = this._items[t3]).removeHandler("bounds-change", this._delegatedFigureSizes), e5.removeHandler("clip-change", this._delegatedFigureSizes), e5.destroy();
      var i3 = this._items;
      for (this._items = [], this._figureSizes(), this._needsDraw = true, t3 = 0; t3 < i3.length; t3++)
        e5 = i3[t3], this._raiseRemoveItem(e5);
    }, resetItems: function() {
      for (var e5 = 0; e5 < this._items.length; e5++)
        this._items[e5].reset();
    }, update: function() {
      for (var e5 = false, t3 = 0; t3 < this._items.length; t3++)
        e5 = this._items[t3].update() || e5;
      return e5;
    }, draw: function() {
      for (var e5 = 0; e5 < this._items.length; e5++)
        this._items[e5].draw();
      this._needsDraw = false;
    }, needsDraw: function() {
      for (var e5 = 0; e5 < this._items.length; e5++)
        if (this._items[e5].needsDraw())
          return true;
      return this._needsDraw;
    }, getHomeBounds: function() {
      return this._homeBounds.clone();
    }, getContentFactor: function() {
      return this._contentFactor;
    }, setAutoRefigureSizes: function(e5) {
      this._autoRefigureSizes = e5, e5 & this._needsSizesFigured && (this._figureSizes(), this._needsSizesFigured = false);
    }, arrange: function(t3) {
      var i3, n3 = (t3 = t3 || {}).immediately || false, o2 = t3.layout || e4.DEFAULT_SETTINGS.collectionLayout, r2 = t3.rows || e4.DEFAULT_SETTINGS.collectionRows, s2 = t3.columns || e4.DEFAULT_SETTINGS.collectionColumns, a2 = t3.tileSize || e4.DEFAULT_SETTINGS.collectionTileSize, l2 = a2 + (t3.tileMargin || e4.DEFAULT_SETTINGS.collectionTileMargin);
      i3 = !t3.rows && s2 ? s2 : Math.ceil(this._items.length / r2);
      var c2, h2, u2, d2, p2, _2 = 0, g2 = 0;
      this.setAutoRefigureSizes(false);
      for (var m2 = 0; m2 < this._items.length; m2++)
        m2 && m2 % i3 == 0 && ("horizontal" === o2 ? (g2 += l2, _2 = 0) : (_2 += l2, g2 = 0)), d2 = (u2 = (h2 = (c2 = this._items[m2]).getBounds()).width > h2.height ? a2 : a2 * (h2.width / h2.height)) * (h2.height / h2.width), p2 = new e4.Point(_2 + (a2 - u2) / 2, g2 + (a2 - d2) / 2), c2.setPosition(p2, n3), c2.setWidth(u2, n3), "horizontal" === o2 ? _2 += l2 : g2 += l2;
      this.setAutoRefigureSizes(true);
    }, _figureSizes: function() {
      var t3 = this._homeBounds ? this._homeBounds.clone() : null, i3 = this._contentSize ? this._contentSize.clone() : null, n3 = this._contentFactor || 0;
      if (this._items.length) {
        var o2 = this._items[0], r2 = o2.getBounds();
        this._contentFactor = o2.getContentSize().x / r2.width;
        for (var s2 = o2.getClippedBounds().getBoundingBox(), a2 = s2.x, l2 = s2.y, c2 = s2.x + s2.width, h2 = s2.y + s2.height, u2 = 1; u2 < this._items.length; u2++)
          r2 = (o2 = this._items[u2]).getBounds(), this._contentFactor = Math.max(this._contentFactor, o2.getContentSize().x / r2.width), s2 = o2.getClippedBounds().getBoundingBox(), a2 = Math.min(a2, s2.x), l2 = Math.min(l2, s2.y), c2 = Math.max(c2, s2.x + s2.width), h2 = Math.max(h2, s2.y + s2.height);
        this._homeBounds = new e4.Rect(a2, l2, c2 - a2, h2 - l2), this._contentSize = new e4.Point(this._homeBounds.width * this._contentFactor, this._homeBounds.height * this._contentFactor);
      } else
        this._homeBounds = new e4.Rect(0, 0, 1, 1), this._contentSize = new e4.Point(1, 1), this._contentFactor = 1;
      this._contentFactor === n3 && this._homeBounds.equals(t3) && this._contentSize.equals(i3) || this.raiseEvent("metrics-change", {});
    }, _raiseRemoveItem: function(e5) {
      this.raiseEvent("remove-item", { item: e5 });
    } });
  }(t2);
}(wy);
const xy = Kb(wy.exports);
var Cy = Object.defineProperty, Sy = Object.getOwnPropertyDescriptor, Ey = (e3, t2, i2, n2) => {
  for (var o2, r2 = n2 > 1 ? void 0 : n2 ? Sy(t2, i2) : t2, s2 = e3.length - 1; s2 >= 0; s2--)
    (o2 = e3[s2]) && (r2 = (n2 ? o2(t2, i2, r2) : o2(r2)) || r2);
  return n2 && r2 && Cy(t2, i2, r2), r2;
};
let Iy = class extends ae {
  constructor() {
    super(...arguments), this.src2D = "", this.imageType = ".jpeg", this._imageFiles = [], this._currentImageIdx = -1, this._currentSyncRotationAngle = 0, this._imageCenter = new xy.Point(0, 0), this._deltaX = 0, this._deltaY = 0, this._minZoomLevel = -1, this._lastDoublePressPointer = { clientX: -1, clientY: -1, id: -1 }, this._lastDoublePressTimeStamp = 0, this._isDown = false, this._viewer = null, this._viewerHomeBounds = new xy.Rect(0, 0, 0, 0, 0), this._checkIfZoomIsInvalid = gy(() => {
      if (null == this._viewer)
        return;
      const e3 = this._viewer.viewport;
      e3.getZoom(true) < e3.getMinZoom() && (console.log("Zoom is invalid", e3.getZoom(true)), e3.applyConstraints());
    }, 250), this._checkIfCenterPosIsUpdated = gy(() => {
      const [e3, t2] = this.getImageCenter();
      this._deltaX == e3 && this._deltaY == t2 || (this._deltaX = e3, this._deltaY = t2, this.dispatchEvent(new CustomEvent("image-shifted", { detail: { deltaX: e3, deltaY: t2 } })));
    }, 15);
  }
  render() {
    return z`
      <div id="image_viewer"
      @pointermove= "${this._handlePointerMove}"></div>
      <div id="overlay"></div>
    `;
  }
  firstUpdated() {
    const e3 = this.renderRoot.querySelector("#image_viewer");
    if (null == e3)
      return void console.log("coudn't find element #image_viewer");
    this._viewer = xy({ element: e3, autoResize: true, showFullPageControl: false, showZoomControl: false, showHomeControl: false, showNavigator: false, navigatorPosition: "TOP_LEFT", minZoomImageRatio: 1, maxZoomLevel: 100, imageSmoothingEnabled: false, visibilityRatio: 1, constrainDuringPan: true, defaultZoomLevel: 0, placeholderFillStyle: "#FF8800", preserveViewport: true, loadTilesWithAjax: true, imageLoaderLimit: 1, zoomPerScroll: 1.4, gestureSettingsMouse: { scrollToZoom: true, clickToZoom: false, dblClickToZoom: false, pinchToZoom: false, zoomToRefPoint: false }, gestureSettingsPen: { scrollToZoom: true, clickToZoom: false, dblClickToZoom: false, pinchToZoom: false, zoomToRefPoint: false }, gestureSettingsUnknown: { scrollToZoom: true, clickToZoom: false, dblClickToZoom: false, pinchToZoom: false, zoomToRefPoint: false }, preserveOverlays: true }), console.log("Viewer 2D", this._viewer, this.clientHeight, this.clientWidth), this._viewer.addHandler("resize", this._handleImageResizeEvent.bind(this)), this._viewer.addHandler("tile-loaded", this._handleTileLoaded.bind(this)), this._viewer.addHandler("zoom", this._handleZoomChanged.bind(this)), this._viewer.addHandler("rotate", this._checkIfMinZoomChanged.bind(this)), this._viewer.addHandler("update-viewport", this._checkIfCenterPosIsUpdated.bind(this)), this._viewer.addHandler("canvas-press", function(e4, t2 = 300) {
      let i2, n2 = 0;
      return function(...o2) {
        n2++, 1 === n2 ? i2 = window.setTimeout(() => {
          n2 = 0;
        }, t2) : (window.clearTimeout(i2), e4(...o2), n2 = 0);
      };
    }(this._handleCanvasDoublePressEvent.bind(this))), this._viewer.addHandler("viewport-change", this._handleViewportChangedEvent.bind(this)), this._viewer.addOverlay(this.hotspotOverlay, new xy.Point(0, 0), xy.Placement.CENTER), this.hotspotOverlay.style.opacity = "0";
    new my(this.parentElement, "pointerdown").on("single-click", this._handleSingleClickEvent.bind(this)), this.measurementTool.on("change-image-hotspot-visibility", (e4) => this.hotspotOverlay.style.opacity = e4 ? "1" : "0"), this.measurementTool.on("update-image-hotspot-position-requested", this._updateImageHotspotPosition.bind(this));
  }
  connectWithSettings(e3) {
    e3.imageRotation.on("rotation-angle-changed", this.rotateImage.bind(this));
  }
  resize(e3, t2, i2) {
    this.style.height = e3 + "px", this.style.width = t2 + "px", this.style.transform = i2, this._checkIfZoomIsInvalid();
  }
  setImageFiles(e3) {
    this._imageFiles = e3, console.log("Image Files has been set");
  }
  loadNextImage(e3) {
    if (e3 >= this._imageFiles.length)
      return void console.log("Image with index", e3, "cannot be loaded because only", this._imageFiles.length, "images exist");
    if (this._currentImageIdx == e3)
      return;
    if (this._currentImageIdx = e3, null == this._viewer)
      return;
    const t2 = this.src2D + this._imageFiles[this._currentImageIdx] + this.imageType;
    this._viewer.open({ type: "image", url: t2 }), console.log("Loaded image", t2);
  }
  rotateImage(e3) {
    this._currentSyncRotationAngle != e3 && (this._currentSyncRotationAngle = e3, null != this._viewer && (this._viewer.viewport.setRotation(this._currentSyncRotationAngle), this._checkIfZoomIsInvalid()));
  }
  updatePointerEventsState(e3) {
    var _a2;
    (_a2 = this._viewer) == null ? void 0 : _a2.setMouseNavEnabled(!e3);
  }
  zoomImage(e3) {
    null != this._viewer && this._viewer.viewport.getZoom() != e3 && (console.log("Zooom image, ", e3), this._viewer.viewport.zoomTo(e3, void 0, true));
  }
  getZoomLevel() {
    return null == this._viewer ? 1 : this._viewer.viewport.getZoom();
  }
  getImageCenter() {
    if (null == this._viewer)
      return [0, 0];
    const e3 = this._viewer.viewport.imageToViewerElementCoordinates(this._imageCenter);
    return [0.5 * this.clientWidth - e3.x, 0.5 * this.clientHeight - e3.y];
  }
  _handlePointerMove(e3) {
    if (null == this._viewer || this._viewer.isMouseNavEnabled() || e3.pointerId != this._lastDoublePressPointer.id || !this._isDown)
      return;
    const t2 = e3.clientX - this._lastDoublePressPointer.clientX, i2 = e3.clientY - this._lastDoublePressPointer.clientY;
    0 === t2 && 0 === i2 || (this._lastDoublePressPointer.clientX = e3.clientX, this._lastDoublePressPointer.clientY = e3.clientY, this.dispatchEvent(new CustomEvent("pointer-move-in-disable-mode", { detail: { dx: t2, dy: i2 } })));
  }
  _handlePointerUpAfterDoublePress(e3) {
    this._isDown = false, null == this._viewer || this._viewer.isMouseNavEnabled() || e3.timeStamp - this._lastDoublePressTimeStamp > 700 && this.dispatchEvent(new Event("double-press-completed"));
  }
  _updateImageHotspotPosition(e3, t2) {
    console.log("Hotspot update-image-hotspot-position", e3, t2), null != this._viewer && this._viewer.updateOverlay(this.hotspotOverlay, this._viewer.viewport.imageToViewportCoordinates(e3, t2), xy.Placement.CENTER);
  }
  _handleSingleClickEvent(e3) {
    if (null == this._viewer || !this.measurementTool.isEditModeActive)
      return;
    const t2 = this.parentElement.getBoundingClientRect();
    var i2 = this._viewer.viewport.pointFromPixel(new xy.Point(e3.clientX - t2.x, e3.clientY - t2.y)), n2 = this._viewer.viewport.viewportToImageCoordinates(i2);
    this.measurementTool.addPointFromImage(n2.x, n2.y), this._viewer.updateOverlay(this.hotspotOverlay, i2, xy.Placement.CENTER), console.log("Hotspot in image added");
  }
  _handleCanvasDoublePressEvent(e3) {
    this._isDown = true;
    const t2 = e3.originalEvent;
    this._lastDoublePressPointer = { clientX: t2.clientX, clientY: t2.clientX, id: t2.pointerId }, this.dispatchEvent(new CustomEvent("double-press", { detail: { pointerEvent: t2 } })), null != this._viewer && (console.log("Add event handler"), this._lastDoublePressTimeStamp = t2.timeStamp, this.parentElement.addEventListener("pointerup", this._handlePointerUpAfterDoublePress.bind(this), { once: true }));
  }
  _handleViewportChangedEvent() {
    null != this._viewer && (this._viewerHomeBounds.equals(this._viewer.viewport.getHomeBounds()) || (this._viewerHomeBounds = this._viewer.viewport.getHomeBounds(), this.dispatchEvent(new CustomEvent("image-zoom-changed", { detail: { zoomLevel: this._viewer.viewport.getZoom(false) } }))));
  }
  _handleImageResizeEvent() {
    this._checkIfMinZoomChanged();
  }
  _handleTileLoaded(e3) {
    this._checkIfZoomIsInvalid(), this._checkIfMinZoomChanged(), this._checkIfCenterPosIsUpdated();
    const t2 = e3.tiledImage.source.dimensions;
    this._imageCenter.x = 0.5 * t2.x, this._imageCenter.y = 0.5 * t2.y;
  }
  _checkIfMinZoomChanged() {
    null != this._viewer && this._minZoomLevel != this._viewer.viewport.getMinZoom() && (this._minZoomLevel = this._viewer.viewport.getMinZoom(), console.log("emit min zoom changed", this._minZoomLevel), this.dispatchEvent(new CustomEvent("min-zoom-level-changed", { detail: { zoomLevel: this._minZoomLevel } })));
  }
  _handleZoomChanged(e3) {
    null != this._viewer && 1 != e3.immediately ? (console.log("image zoom changed 1", e3.zoom), this._checkIfZoomIsInvalid(), this.dispatchEvent(new CustomEvent("image-zoom-changed", { detail: { zoomLevel: e3.zoom } }))) : console.log("Return zoom", e3.zoom);
  }
};
Iy.styles = r`
    :host {
      background-color: black;
    }

    #image_viewer {
      height: inherit;
      width: inherit;
      background-color: transparent;
    }

    .hotspot{
      display: block;
      width: 20px;
      height: 20px;
      border-radius: 20px;
      border: none;
      background-color: #fff;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.25);
      box-sizing: border-box;
      cursor: pointer;
      transition: opacity 0.3s;
      position: relative;
      font-size: 12px;
      padding: 0;
  }

  #overlay{
    display: none;
    background-color: transparent;
    opacity: 0;
    width: 20px;
    height: 20px;
    border-radius: 20px;
    border: 3px solid rgb(0, 128, 200) ;
  }
  `, Ey([ue()], Iy.prototype, "src2D", 2), Ey([ue()], Iy.prototype, "imageType", 2), Ey([de("#image_viewer")], Iy.prototype, "parentElement", 2), Ey([de("#overlay")], Iy.prototype, "hotspotOverlay", 2), Ey([ue({ type: Object })], Iy.prototype, "measurementTool", 2), Iy = Ey([ce("viewer-2d")], Iy);
const Ty = 1, By = 2, My = (e3) => (...t2) => ({ _$litDirective$: e3, values: t2 });
class ky {
  constructor(e3) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(e3, t2, i2) {
    this._$Ct = e3, this._$AM = t2, this._$Ci = i2;
  }
  _$AS(e3, t2) {
    return this.update(e3, t2);
  }
  update(e3, t2) {
    return this.render(...t2);
  }
}
class Ry extends ky {
  constructor(e3) {
    if (super(e3), this.et = Q, e3.type !== By)
      throw Error(this.constructor.directiveName + "() can only be used in child bindings");
  }
  render(e3) {
    if (e3 === Q || null == e3)
      return this.ft = void 0, this.et = e3;
    if (e3 === H)
      return e3;
    if ("string" != typeof e3)
      throw Error(this.constructor.directiveName + "() called with a non-string value");
    if (e3 === this.et)
      return this.ft;
    this.et = e3;
    const t2 = [e3];
    return t2.raw = t2, this.ft = { _$litType$: this.constructor.resultType, strings: t2, values: [] };
  }
}
Ry.directiveName = "unsafeHTML", Ry.resultType = 1;
const Py = My(Ry);
class Dy extends Ry {
}
Dy.directiveName = "unsafeSVG", Dy.resultType = 2;
const Ly = My(Dy), Fy = (e3, t2 = document.body, i2) => {
  let n2 = document.querySelector(e3);
  return n2 || (n2 = i2 ? i2() : document.createElement(e3), t2.insertBefore(n2, t2.firstChild));
}, Ny = () => {
  const e3 = document.createElement("meta");
  return e3.setAttribute("name", "ui5-shared-resources"), e3.setAttribute("content", ""), e3;
}, Oy = (e3, t2) => {
  const i2 = e3.split(".");
  let n2 = "undefined" == typeof document ? null : Fy('meta[name="ui5-shared-resources"]', document.head, Ny);
  if (!n2)
    return t2;
  for (let e4 = 0; e4 < i2.length; e4++) {
    const o2 = i2[e4], r2 = e4 === i2.length - 1;
    Object.prototype.hasOwnProperty.call(n2, o2) || (n2[o2] = r2 ? t2 : {}), n2 = n2[o2];
  }
  return n2;
};
var zy;
!function(e3) {
  e3["SAP-icons"] = "SAP-icons-v4", e3.horizon = "SAP-icons-v5", e3["SAP-icons-TNT"] = "tnt", e3.BusinessSuiteInAppSymbols = "business-suite";
}(zy || (zy = {}));
const Uy = (e3) => zy[e3] ? zy[e3] : e3;
var Hy = {}, Qy = Hy.hasOwnProperty, Vy = Hy.toString, Gy = Qy.toString, $y = Gy.call(Object), Wy = function(e3) {
  var t2, i2;
  return !(!e3 || "[object Object]" !== Vy.call(e3)) && (!(t2 = Object.getPrototypeOf(e3)) || "function" == typeof (i2 = Qy.call(t2, "constructor") && t2.constructor) && Gy.call(i2) === $y);
}, qy = /* @__PURE__ */ Object.create(null), jy = function(e3, t2, i2, n2) {
  var o2, r2, s2, a2, l2, c2, h2 = arguments[2] || {}, u2 = 3, d2 = arguments.length, p2 = arguments[0] || false, _2 = arguments[1] ? void 0 : qy;
  for ("object" != typeof h2 && "function" != typeof h2 && (h2 = {}); u2 < d2; u2++)
    if (null != (l2 = arguments[u2]))
      for (a2 in l2)
        o2 = h2[a2], s2 = l2[a2], "__proto__" !== a2 && h2 !== s2 && (p2 && s2 && (Wy(s2) || (r2 = Array.isArray(s2))) ? (r2 ? (r2 = false, c2 = o2 && Array.isArray(o2) ? o2 : []) : c2 = o2 && Wy(o2) ? o2 : {}, h2[a2] = jy(p2, arguments[1], c2, s2)) : s2 !== _2 && (h2[a2] = s2));
  return h2;
};
const Xy = function(e3, t2) {
  return jy(true, false, ...arguments);
}, Yy = /* @__PURE__ */ new Map(), Ky = (e3) => Yy.get(e3), Zy = { default: "sap_fiori_3", all: ["sap_fiori_3", "sap_fiori_3_dark", "sap_belize", "sap_belize_hcb", "sap_belize_hcw", "sap_fiori_3_hcb", "sap_fiori_3_hcw", "sap_horizon", "sap_horizon_dark", "sap_horizon_hcb", "sap_horizon_hcw", "sap_horizon_exp"] }, Jy = { default: "en", all: ["ar", "bg", "ca", "cs", "cy", "da", "de", "el", "en", "en_GB", "en_US_sappsd", "en_US_saprigi", "en_US_saptrc", "es", "es_MX", "et", "fi", "fr", "fr_CA", "hi", "hr", "hu", "in", "it", "iw", "ja", "kk", "ko", "lt", "lv", "ms", "nl", "no", "pl", "pt_PT", "pt", "ro", "ru", "sh", "sk", "sl", "sv", "th", "tr", "uk", "vi", "zh_CN", "zh_TW"] }, ew = { default: "en", all: ["ar", "ar_EG", "ar_SA", "bg", "ca", "cs", "da", "de", "de_AT", "de_CH", "el", "el_CY", "en", "en_AU", "en_GB", "en_HK", "en_IE", "en_IN", "en_NZ", "en_PG", "en_SG", "en_ZA", "es", "es_AR", "es_BO", "es_CL", "es_CO", "es_MX", "es_PE", "es_UY", "es_VE", "et", "fa", "fi", "fr", "fr_BE", "fr_CA", "fr_CH", "fr_LU", "he", "hi", "hr", "hu", "id", "it", "it_CH", "ja", "kk", "ko", "lt", "lv", "ms", "nb", "nl", "nl_BE", "pl", "pt", "pt_PT", "ro", "ru", "ru_UA", "sk", "sl", "sr", "sr_Latn", "sv", "th", "tr", "uk", "vi", "zh_CN", "zh_HK", "zh_SG", "zh_TW"] }, tw = Zy.default, iw = Zy.all, nw = Jy.default, ow = ew.default, rw = (e3) => {
  const t2 = ((e4) => {
    const t3 = document.querySelector(`META[name="${e4}"]`);
    return t3 && t3.getAttribute("content");
  })("sap-allowedThemeOrigins");
  return t2 && t2.split(",").some((t3) => "*" === t3 || e3 === t3.trim());
}, sw = (e3) => {
  let t2;
  try {
    if (e3.startsWith(".") || e3.startsWith("/"))
      t2 = new URL(e3, window.location.href).toString();
    else {
      const i2 = new URL(e3), n2 = i2.origin;
      t2 = n2 && rw(n2) ? i2.toString() : ((e4, t3) => {
        const i3 = new URL(e4).pathname;
        return new URL(i3, t3).toString();
      })(i2.toString(), window.location.href);
    }
    return t2.endsWith("/") || (t2 = `${t2}/`), `${t2}UI5/`;
  } catch (e4) {
  }
};
var aw;
!function(e3) {
  e3.Full = "full", e3.Basic = "basic", e3.Minimal = "minimal", e3.None = "none";
}(aw || (aw = {}));
const lw = aw;
let cw = false, hw = { animationMode: lw.Full, theme: tw, themeRoot: void 0, rtl: void 0, language: void 0, timezone: void 0, calendarType: void 0, noConflict: false, formatSettings: {}, fetchDefaultLanguage: false };
const uw = /* @__PURE__ */ new Map();
uw.set("true", true), uw.set("false", false);
const dw = (e3, t2, i2) => {
  const n2 = t2.toLowerCase(), o2 = e3.split(`${i2}-`)[1];
  uw.has(t2) && (t2 = uw.get(n2)), "theme" === o2 ? (hw.theme = ((e4, t3) => "theme" === e4 && t3.includes("@") ? t3.split("@")[0] : t3)(o2, t2), t2 && t2.includes("@") && (hw.themeRoot = ((e4) => {
    const t3 = e4.split("@")[1];
    return sw(t3);
  })(t2))) : hw[o2] = t2;
}, pw = () => {
  "undefined" == typeof document || cw || ((() => {
    const e3 = document.querySelector("[data-ui5-config]") || document.querySelector("[data-id='sap-ui-config']");
    let t2;
    if (e3) {
      try {
        t2 = JSON.parse(e3.innerHTML);
      } catch (e4) {
        console.warn("Incorrect data-sap-ui-config format. Please use JSON");
      }
      t2 && (hw = Xy(hw, t2));
    }
  })(), (() => {
    const e3 = new URLSearchParams(window.location.search);
    e3.forEach((e4, t2) => {
      const i2 = t2.split("sap-").length;
      0 !== i2 && i2 !== t2.split("sap-ui-").length && dw(t2, e4, "sap");
    }), e3.forEach((e4, t2) => {
      t2.startsWith("sap-ui") && dw(t2, e4, "sap-ui");
    });
  })(), (() => {
    const e3 = Ky("OpenUI5Support");
    if (!e3 || !e3.isLoaded())
      return;
    const t2 = e3.getConfigurationSettingsObject();
    hw = Xy(hw, t2);
  })(), cw = true);
};
class _w {
  constructor() {
    this._eventRegistry = /* @__PURE__ */ new Map();
  }
  attachEvent(e3, t2) {
    const i2 = this._eventRegistry, n2 = i2.get(e3);
    Array.isArray(n2) ? n2.includes(t2) || n2.push(t2) : i2.set(e3, [t2]);
  }
  detachEvent(e3, t2) {
    const i2 = this._eventRegistry, n2 = i2.get(e3);
    if (!n2)
      return;
    const o2 = n2.indexOf(t2);
    -1 !== o2 && n2.splice(o2, 1), 0 === n2.length && i2.delete(e3);
  }
  fireEvent(e3, t2) {
    const i2 = this._eventRegistry.get(e3);
    return i2 ? i2.map((e4) => e4.call(this, t2)) : [];
  }
  fireEventAsync(e3, t2) {
    return Promise.all(this.fireEvent(e3, t2));
  }
  isHandlerAttached(e3, t2) {
    const i2 = this._eventRegistry.get(e3);
    return !!i2 && i2.includes(t2);
  }
  hasListeners(e3) {
    return !!this._eventRegistry.get(e3);
  }
}
const gw = { version: "1.13.3", major: 1, minor: 13, patch: 3, suffix: "", isNext: false, buildTime: 1684402228 };
let mw;
const fw = /* @__PURE__ */ new Map(), vw = Oy("Runtimes", []), Aw = () => mw, bw = Oy("Tags", /* @__PURE__ */ new Map()), yw = /* @__PURE__ */ new Set();
let ww, xw = /* @__PURE__ */ new Map();
const Cw = () => {
  const e3 = vw, t2 = Aw(), i2 = e3[t2];
  let n2 = "Multiple UI5 Web Components instances detected.";
  e3.length > 1 && (n2 = `${n2}
Loading order (versions before 1.1.0 not listed): ${e3.map((e4) => `
${e4.description}`).join("")}`), [...xw.keys()].forEach((o2) => {
    let r2, s2, a2;
    -1 === o2 ? (r2 = 1, s2 = { description: "Older unknown runtime" }) : (r2 = ((e4, t3) => {
      const i3 = `${e4},${t3}`;
      if (fw.has(i3))
        return fw.get(i3);
      const n3 = vw[e4], o3 = vw[t3];
      if (!n3 || !o3)
        throw new Error("Invalid runtime index supplied");
      if (n3.isNext || o3.isNext)
        return n3.buildTime - o3.buildTime;
      const r3 = n3.major - o3.major;
      if (r3)
        return r3;
      const s3 = n3.minor - o3.minor;
      if (s3)
        return s3;
      const a3 = n3.patch - o3.patch;
      if (a3)
        return a3;
      const l2 = new Intl.Collator(void 0, { numeric: true, sensitivity: "base" }).compare(n3.suffix, o3.suffix);
      return fw.set(i3, l2), l2;
    })(t2, o2), s2 = e3[o2]), a2 = r2 > 0 ? "an older" : r2 < 0 ? "a newer" : "the same", n2 = `${n2}

"${i2.description}" failed to define ${xw.get(o2).size} tag(s) as they were defined by a runtime of ${a2} version "${s2.description}": ${[...xw.get(o2)].sort().join(", ")}.`, n2 = r2 > 0 ? `${n2}
WARNING! If your code uses features of the above web components, unavailable in ${s2.description}, it might not work as expected!` : `${n2}
Since the above web components were defined by the same or newer version runtime, they should be compatible with your code.`;
  }), n2 = `${n2}

To prevent other runtimes from defining tags that you use, consider using scoping or have third-party libraries use scoping: https://github.com/SAP/ui5-webcomponents/blob/main/docs/2-advanced/03-scoping.md.`, console.warn(n2);
}, Sw = /* @__PURE__ */ new Set(), Ew = /* @__PURE__ */ new Set(), Iw = new _w(), Tw = new class {
  constructor() {
    this.list = [], this.lookup = /* @__PURE__ */ new Set();
  }
  add(e3) {
    this.lookup.has(e3) || (this.list.push(e3), this.lookup.add(e3));
  }
  remove(e3) {
    this.lookup.has(e3) && (this.list = this.list.filter((t2) => t2 !== e3), this.lookup.delete(e3));
  }
  shift() {
    const e3 = this.list.shift();
    if (e3)
      return this.lookup.delete(e3), e3;
  }
  isEmpty() {
    return 0 === this.list.length;
  }
  isAdded(e3) {
    return this.lookup.has(e3);
  }
  process(e3) {
    let t2;
    const i2 = /* @__PURE__ */ new Map();
    for (t2 = this.shift(); t2; ) {
      const n2 = i2.get(t2) || 0;
      if (n2 > 10)
        throw new Error("Web component processed too many times this task, max allowed is: 10");
      e3(t2), i2.set(t2, n2 + 1), t2 = this.shift();
    }
  }
}();
let Bw, Mw, kw, Rw;
const Pw = async (e3) => {
  Tw.add(e3), await Lw();
}, Dw = (e3) => {
  Iw.fireEvent("beforeComponentRender", e3), Ew.add(e3), e3._render();
}, Lw = async () => {
  Rw || (Rw = new Promise((e3) => {
    window.requestAnimationFrame(() => {
      Tw.process(Dw), Rw = null, e3(), kw || (kw = setTimeout(() => {
        kw = void 0, Tw.isEmpty() && Ow();
      }, 200));
    });
  })), await Rw;
}, Fw = () => {
  const e3 = [...yw.values()].map((e4) => customElements.whenDefined(e4));
  return Promise.all(e3);
}, Nw = async () => {
  await Fw(), await (Bw || (Bw = new Promise((e3) => {
    Mw = e3, window.requestAnimationFrame(() => {
      Tw.isEmpty() && (Bw = void 0, e3());
    });
  }), Bw));
}, Ow = () => {
  Tw.isEmpty() && Mw && (Mw(), Mw = void 0, Bw = void 0);
}, zw = async (e3) => {
  Ew.forEach((t2) => {
    const i2 = t2.constructor, n2 = i2.getMetadata().getTag(), o2 = (r2 = i2, Sw.has(r2));
    var r2;
    const s2 = i2.getMetadata().isLanguageAware(), a2 = i2.getMetadata().isThemeAware();
    (!e3 || e3.tag === n2 || e3.rtlAware && o2 || e3.languageAware && s2 || e3.themeAware && a2) && Pw(t2);
  }), await Nw();
}, Uw = new _w(), Hw = "themeRegistered", Qw = /* @__PURE__ */ new Map(), Vw = /* @__PURE__ */ new Map(), Gw = /* @__PURE__ */ new Set(), $w = /* @__PURE__ */ new Set(), Ww = (e3, t2, i2) => {
  var n2;
  Vw.set(`${e3}/${t2}`, i2), Gw.add(e3), $w.add(t2), n2 = t2, Uw.fireEvent(Hw, n2);
}, qw = async (e3, t2) => {
  const i2 = Qw.get(`${e3}_${t2}`);
  if (void 0 !== i2)
    return i2;
  if (!$w.has(t2)) {
    const i3 = [...$w.values()].join(", ");
    return console.warn(`You have requested a non-registered theme ${t2} - falling back to ${tw}. Registered themes are: ${i3}`), jw(e3, tw);
  }
  return jw(e3, t2);
}, jw = async (e3, t2) => {
  const i2 = Vw.get(`${e3}/${t2}`);
  if (!i2)
    return void console.error(`Theme [${t2}] not registered for package [${e3}]`);
  let n2;
  try {
    n2 = await i2(t2);
  } catch (t3) {
    const i3 = t3;
    return void console.error(e3, i3.message);
  }
  const o2 = n2._ || n2;
  return Qw.set(`${e3}_${t2}`, o2), o2;
}, Xw = () => Gw, Yw = (e3, t2) => t2 ? `${e3}|${t2}` : e3, Kw = (e3, t2, i2 = "") => {
  const n2 = "string" == typeof e3 ? e3 : e3.content;
  if (document.adoptedStyleSheets) {
    const e4 = new CSSStyleSheet();
    e4.replaceSync(n2), e4._ui5StyleId = Yw(t2, i2), document.adoptedStyleSheets = [...document.adoptedStyleSheets, e4];
  } else {
    const e4 = {};
    e4[t2] = i2, ((e5, t3) => {
      const i3 = document.createElement("style");
      i3.type = "text/css", t3 && Object.entries(t3).forEach((e6) => i3.setAttribute(...e6)), i3.textContent = e5, document.head.appendChild(i3);
    })(n2, e4);
  }
}, Zw = (e3, t2 = "") => document.adoptedStyleSheets ? !!document.adoptedStyleSheets.find((i2) => i2._ui5StyleId === Yw(e3, t2)) : !!document.querySelector(`head>style[${e3}="${t2}"]`), Jw = (e3, t2, i2 = "") => {
  Zw(t2, i2) ? ((e4, t3, i3 = "") => {
    const n2 = "string" == typeof e4 ? e4 : e4.content;
    if (document.adoptedStyleSheets) {
      const e5 = document.adoptedStyleSheets.find((e6) => e6._ui5StyleId === Yw(t3, i3));
      e5 && e5.replaceSync(n2 || "");
    } else {
      const e5 = document.querySelector(`head>style[${t3}="${i3}"]`);
      e5 && (e5.textContent = n2 || "");
    }
  })(e3, t2, i2) : Kw(e3, t2, i2);
}, ex = /* @__PURE__ */ new Set(), tx = () => {
  const e3 = (() => {
    let e4 = document.querySelector(".sapThemeMetaData-Base-baseLib") || document.querySelector(".sapThemeMetaData-UI5-sap-ui-core");
    if (e4)
      return getComputedStyle(e4).backgroundImage;
    e4 = document.createElement("span"), e4.style.display = "none", e4.classList.add("sapThemeMetaData-Base-baseLib"), document.body.appendChild(e4);
    let t3 = getComputedStyle(e4).backgroundImage;
    return "none" === t3 && (e4.classList.add("sapThemeMetaData-UI5-sap-ui-core"), t3 = getComputedStyle(e4).backgroundImage), document.body.removeChild(e4), t3;
  })();
  if (!e3 || "none" === e3)
    return;
  const t2 = ((e4) => {
    const t3 = /\(["']?data:text\/plain;utf-8,(.*?)['"]?\)$/i.exec(e4);
    if (t3 && t3.length >= 2) {
      let e5 = t3[1];
      if (e5 = e5.replace(/\\"/g, '"'), "{" !== e5.charAt(0) && "}" !== e5.charAt(e5.length - 1))
        try {
          e5 = decodeURIComponent(e5);
        } catch (e6) {
          return void (ex.has("decode") || (console.warn("Malformed theme metadata string, unable to decodeURIComponent"), ex.add("decode")));
        }
      try {
        return JSON.parse(e5);
      } catch (e6) {
        ex.has("parse") || (console.warn("Malformed theme metadata string, unable to parse JSON"), ex.add("parse"));
      }
    }
  })(e3);
  return t2 ? ((e4) => {
    let t3, i2;
    try {
      t3 = e4.Path.match(/\.([^.]+)\.css_variables$/)[1], i2 = e4.Extends[0];
    } catch (t4) {
      return void (ex.has("object") || (console.warn("Malformed theme metadata Object", e4), ex.add("object")));
    }
    return { themeName: t3, baseThemeName: i2 };
  })(t2) : void 0;
}, ix = new _w();
let nx;
const ox = () => (void 0 === nx && (pw(), nx = hw.themeRoot), nx), rx = async (e3) => {
  const t2 = document.querySelector(`[sap-ui-webcomponents-theme="${e3}"]`);
  t2 && document.head.removeChild(t2), await ((e4, t3) => {
    const i2 = document.createElement("link");
    return i2.type = "text/css", i2.rel = "stylesheet", t3 && Object.entries(t3).forEach((e5) => i2.setAttribute(...e5)), i2.href = e4, document.head.appendChild(i2), new Promise((e5) => {
      i2.addEventListener("load", e5), i2.addEventListener("error", e5);
    });
  })(((e4) => `${ox()}Base/baseLib/${e4}/css_variables.css`)(e3), { "sap-ui-webcomponents-theme": e3 });
}, sx = "@ui5/webcomponents-theming", ax = async (e3) => {
  if (!Xw().has(sx))
    return;
  const t2 = await qw(sx, e3);
  t2 && Jw(t2, "data-ui5-theme-properties", sx);
}, lx = () => {
  ((e3, t2 = "") => {
    var _a2;
    if (document.adoptedStyleSheets)
      document.adoptedStyleSheets = document.adoptedStyleSheets.filter((i2) => i2._ui5StyleId !== Yw(e3, t2));
    else {
      const i2 = document.querySelector(`head > style[${e3}="${t2}"]`);
      (_a2 = i2 == null ? void 0 : i2.parentElement) == null ? void 0 : _a2.removeChild(i2);
    }
  })("data-ui5-theme-properties", sx);
}, cx = async (e3) => {
  const t2 = await (async (e4) => {
    var _a2;
    const t3 = tx();
    if (t3)
      return t3;
    const i3 = Ky("OpenUI5Support");
    if (i3) {
      if (i3.cssVariablesLoaded())
        return { themeName: (_a2 = i3.getConfigurationSettingsObject()) == null ? void 0 : _a2.theme, baseThemeName: "" };
    } else if (ox())
      return await rx(e4), tx();
  })(e3);
  t2 && e3 === t2.themeName ? lx() : await ax(e3);
  const i2 = ((e4) => $w.has(e4))(e3) ? e3 : t2 && t2.baseThemeName;
  await (async (e4) => {
    const t3 = [...Xw()].map(async (t4) => {
      if (t4 === sx)
        return;
      const i3 = await qw(t4, e4);
      i3 && Jw(i3, "data-ui5-theme-properties", t4);
    });
    return Promise.all(t3);
  })(i2 || tw), ((e4) => {
    ix.fireEvent("themeLoaded", e4);
  })(e3);
};
let hx;
const ux = () => (void 0 === hx && (pw(), hx = hw.theme), hx), dx = () => {
  var _a2, _b2;
  const e3 = ux();
  return px(e3) ? !e3.startsWith("sap_horizon") : !((_b2 = (_a2 = tx()) == null ? void 0 : _a2.baseThemeName) == null ? void 0 : _b2.startsWith("sap_horizon"));
}, px = (e3) => iw.includes(e3), _x = /* @__PURE__ */ new Map();
var gx;
!function(e3) {
  e3.SAPIconsV4 = "SAP-icons-v4", e3.SAPIconsV5 = "SAP-icons-v5", e3.SAPIconsTNTV2 = "tnt-v2", e3.SAPIconsTNTV3 = "tnt-v3", e3.SAPBSIconsV1 = "business-suite-v1", e3.SAPBSIconsV2 = "business-suite-v2";
}(gx || (gx = {}));
const mx = (e3) => {
  const t2 = dx();
  return e3 ? "tnt" === e3 ? t2 ? gx.SAPIconsTNTV2 : gx.SAPIconsTNTV3 : "business-suite" === e3 ? t2 ? gx.SAPBSIconsV1 : gx.SAPBSIconsV2 : e3 : t2 ? gx.SAPIconsV4 : gx.SAPIconsV5;
}, fx = () => {
  const e3 = navigator.languages;
  return e3 && e3[0] || navigator.language || nw;
}, vx = new _w();
let Ax, bx;
const yx = () => (void 0 === Ax && (pw(), Ax = hw.language), Ax), wx = () => {
  var e3;
  return void 0 === bx && (pw(), e3 = hw.fetchDefaultLanguage, bx = e3), bx;
}, xx = /^((?:[A-Z]{2,3}(?:-[A-Z]{3}){0,3})|[A-Z]{4}|[A-Z]{5,8})(?:-([A-Z]{4}))?(?:-([A-Z]{2}|[0-9]{3}))?((?:-[0-9A-Z]{5,8}|-[0-9][0-9A-Z]{3})*)((?:-[0-9A-WYZ](?:-[0-9A-Z]{2,8})+)*)(?:-(X(?:-[0-9A-Z]{1,8})+))?$/i;
class Cx {
  constructor(e3) {
    const t2 = xx.exec(e3.replace(/_/g, "-"));
    if (null === t2)
      throw new Error(`The given language ${e3} does not adhere to BCP-47.`);
    this.sLocaleId = e3, this.sLanguage = t2[1] || nw, this.sScript = t2[2] || "", this.sRegion = t2[3] || "", this.sVariant = t2[4] && t2[4].slice(1) || null, this.sExtension = t2[5] && t2[5].slice(1) || null, this.sPrivateUse = t2[6] || null, this.sLanguage && (this.sLanguage = this.sLanguage.toLowerCase()), this.sScript && (this.sScript = this.sScript.toLowerCase().replace(/^[a-z]/, (e4) => e4.toUpperCase())), this.sRegion && (this.sRegion = this.sRegion.toUpperCase());
  }
  getLanguage() {
    return this.sLanguage;
  }
  getScript() {
    return this.sScript;
  }
  getRegion() {
    return this.sRegion;
  }
  getVariant() {
    return this.sVariant;
  }
  getVariantSubtags() {
    return this.sVariant ? this.sVariant.split("-") : [];
  }
  getExtension() {
    return this.sExtension;
  }
  getExtensionSubtags() {
    return this.sExtension ? this.sExtension.slice(2).split("-") : [];
  }
  getPrivateUse() {
    return this.sPrivateUse;
  }
  getPrivateUseSubtags() {
    return this.sPrivateUse ? this.sPrivateUse.slice(2).split("-") : [];
  }
  hasPrivateUseSubtag(e3) {
    return this.getPrivateUseSubtags().indexOf(e3) >= 0;
  }
  toString() {
    const e3 = [this.sLanguage];
    return this.sScript && e3.push(this.sScript), this.sRegion && e3.push(this.sRegion), this.sVariant && e3.push(this.sVariant), this.sExtension && e3.push(this.sExtension), this.sPrivateUse && e3.push(this.sPrivateUse), e3.join("-");
  }
}
const Sx = /* @__PURE__ */ new Map(), Ex = (e3) => (Sx.has(e3) || Sx.set(e3, new Cx(e3)), Sx.get(e3)), Ix = (e3) => {
  try {
    if (e3 && "string" == typeof e3)
      return Ex(e3);
  } catch (e4) {
  }
  return new Cx(ow);
}, Tx = (e3) => {
  if (e3)
    return Ix(e3);
  const t2 = yx();
  return t2 ? Ex(t2) : Ix(fx());
}, Bx = /^((?:[A-Z]{2,3}(?:-[A-Z]{3}){0,3})|[A-Z]{4}|[A-Z]{5,8})(?:-([A-Z]{4}))?(?:-([A-Z]{2}|[0-9]{3}))?((?:-[0-9A-Z]{5,8}|-[0-9][0-9A-Z]{3})*)((?:-[0-9A-WYZ](?:-[0-9A-Z]{2,8})+)*)(?:-(X(?:-[0-9A-Z]{1,8})+))?$/i, Mx = /(?:^|-)(saptrc|sappsd)(?:-|$)/i, kx = { he: "iw", yi: "ji", nb: "no", sr: "sh" }, Rx = (e3) => {
  if (!e3)
    return ow;
  if ("zh_HK" === e3)
    return "zh_TW";
  const t2 = e3.lastIndexOf("_");
  return t2 >= 0 ? e3.slice(0, t2) : e3 !== ow ? ow : "";
}, Px = /* @__PURE__ */ new Set(), Dx = /* @__PURE__ */ new Set(), Lx = /* @__PURE__ */ new Map(), Fx = /* @__PURE__ */ new Map(), Nx = /* @__PURE__ */ new Map(), Ox = (e3, t2) => {
  Lx.set(e3, t2);
}, zx = (e3, t2) => {
  const i2 = `${e3}/${t2}`;
  return Nx.has(i2);
}, Ux = (e3, t2) => t2 !== nw && !zx(e3, t2), Hx = async (e3) => {
  const t2 = Tx().getLanguage(), i2 = Tx().getRegion();
  let n2 = t2 + (i2 ? `-${i2}` : "");
  if (Ux(e3, n2))
    for (n2 = ((e4) => {
      let t3;
      if (!e4)
        return ow;
      if ("string" == typeof e4 && (t3 = Bx.exec(e4.replace(/_/g, "-")))) {
        let e5 = t3[1].toLowerCase(), i3 = t3[3] ? t3[3].toUpperCase() : void 0;
        const n3 = t3[2] ? t3[2].toLowerCase() : void 0, o3 = t3[4] ? t3[4].slice(1) : void 0, r2 = t3[6];
        return e5 = kx[e5] || e5, r2 && (t3 = Mx.exec(r2)) || o3 && (t3 = Mx.exec(o3)) ? `en_US_${t3[1].toLowerCase()}` : ("zh" !== e5 || i3 || ("hans" === n3 ? i3 = "CN" : "hant" === n3 && (i3 = "TW")), e5 + (i3 ? "_" + i3 + (o3 ? "_" + o3.replace("-", "_") : "") : ""));
      }
      return ow;
    })(n2); Ux(e3, n2); )
      n2 = Rx(n2);
  const o2 = wx();
  if (n2 !== nw || o2)
    if (zx(e3, n2))
      try {
        const t3 = await ((e4, t4) => {
          const i3 = `${e4}/${t4}`, n3 = Nx.get(i3);
          return n3 && !Fx.get(i3) && Fx.set(i3, n3(t4)), Fx.get(i3);
        })(e3, n2);
        Ox(e3, t3);
      } catch (e4) {
        const t3 = e4;
        Dx.has(t3.message) || (Dx.add(t3.message), console.error(t3.message));
      }
    else
      ((e4) => {
        Px.has(e4) || (console.warn(`[${e4}]: Message bundle assets are not configured. Falling back to English texts.`, ` Add \`import "${e4}/dist/Assets.js"\` in your bundle and make sure your build tool supports dynamic imports and JSON imports. See section "Assets" in the documentation for more information.`), Px.add(e4));
      })(e3);
  else
    Ox(e3, null);
};
var Qx;
Qx = (e3) => {
  const t2 = [...Lx.keys()];
  return Promise.all(t2.map(Hx));
}, vx.attachEvent("languageChange", Qx);
const Vx = /('')|'([^']+(?:''[^']*)*)(?:'|$)|\{([0-9]+(?:\s*,[^{}]*)?)\}|[{}]/g, Gx = /* @__PURE__ */ new Map();
class $x {
  constructor(e3) {
    this.packageName = e3;
  }
  getText(e3, ...t2) {
    if ("string" == typeof e3 && (e3 = { key: e3, defaultText: e3 }), !e3 || !e3.key)
      return "";
    const i2 = ((e4) => Lx.get(e4))(this.packageName);
    i2 && !i2[e3.key] && console.warn(`Key ${e3.key} not found in the i18n bundle, the default text will be used`);
    const n2 = i2 && i2[e3.key] ? i2[e3.key] : e3.defaultText || e3.key;
    return o2 = (o2 = t2) || [], n2.replace(Vx, (e4, t3, i3, n3, r2) => {
      if (t3)
        return "'";
      if (i3)
        return i3.replace(/''/g, "'");
      if (n3) {
        const e5 = "string" == typeof n3 ? parseInt(n3) : n3;
        return String(o2[e5]);
      }
      throw new Error(`[i18n]: pattern syntax error at pos ${r2}`);
    });
    var o2;
  }
}
const Wx = async (e3) => (await Hx(e3), ((e4) => {
  if (Gx.has(e4))
    return Gx.get(e4);
  const t2 = new $x(e4);
  return Gx.set(e4, t2), t2;
})(e3)), qx = /* @__PURE__ */ new Map(), jx = Oy("SVGIcons.registry", /* @__PURE__ */ new Map()), Xx = Oy("SVGIcons.promises", /* @__PURE__ */ new Map()), Yx = "ICON_NOT_FOUND", Kx = (e3, t2) => {
  const i2 = `${t2.collection}/${e3}`;
  jx.set(i2, { pathData: t2.pathData, ltr: t2.ltr, accData: t2.accData, packageName: t2.packageName, customTemplate: t2.customTemplate, viewBox: t2.viewBox, collection: t2.collection });
}, Zx = (e3) => {
  let t2;
  e3.startsWith("sap-icon://") && (e3 = e3.replace("sap-icon://", "")), [e3, t2] = e3.split("/").reverse(), e3 = e3.replace("icon-", ""), t2 && (t2 = Uy(t2)), t2 = ((e4) => {
    const t3 = ux(), i2 = _x.get(t3);
    return !e4 && i2 ? Uy(i2) : mx(e4);
  })(t2);
  return { name: e3, collection: t2, registryKey: `${t2}/${e3}` };
}, Jx = (e3) => {
  const { registryKey: t2 } = Zx(e3);
  return jx.get(t2);
}, eC = async (e3) => {
  const { collection: t2, registryKey: i2 } = Zx(e3);
  let n2 = Yx;
  try {
    n2 = await (async (e4) => {
      if (!Xx.has(e4)) {
        if (!qx.has(e4))
          throw new Error(`No loader registered for the ${e4} icons collection. Probably you forgot to import the "AllIcons.js" module for the respective package.`);
        const t3 = qx.get(e4);
        Xx.set(e4, t3(e4));
      }
      return Xx.get(e4);
    })(t2);
  } catch (e4) {
    const t3 = e4;
    console.error(t3.message);
  }
  return n2 === Yx ? n2 : (jx.has(i2) || ((e4) => {
    Object.keys(e4.data).forEach((t3) => {
      const i3 = e4.data[t3];
      Kx(t3, { pathData: i3.path || i3.paths, ltr: i3.ltr, accData: i3.acc, collection: e4.collection, packageName: e4.packageName });
    });
  })(n2), jx.get(i2));
}, tC = { packageName: "@ui5/webcomponents-base", fileName: "FontFace.css", content: `@font-face{font-family:"72";font-style:normal;font-weight:400;src:local("72"),url(https://sdk.openui5.org/resources/sap/ui/core/themes/sap_fiori_3/fonts/72-Regular.woff2?ui5-webcomponents) format("woff2")}@font-face{font-family:"72full";font-style:normal;font-weight:400;src:local('72-full'),url(https://sdk.openui5.org/resources/sap/ui/core/themes/sap_fiori_3/fonts/72-Regular-full.woff2?ui5-webcomponents) format("woff2")}@font-face{font-family:"72";font-style:normal;font-weight:700;src:local('72-Bold'),url(https://sdk.openui5.org/resources/sap/ui/core/themes/sap_fiori_3/fonts/72-Bold.woff2?ui5-webcomponents) format("woff2")}@font-face{font-family:"72full";font-style:normal;font-weight:700;src:local('72-Bold-full'),url(https://sdk.openui5.org/resources/sap/ui/core/themes/sap_fiori_3/fonts/72-Bold-full.woff2?ui5-webcomponents) format("woff2")}@font-face{font-family:'72-Bold';font-style:normal;src:local('72-Bold'),url(https://sdk.openui5.org/resources/sap/ui/core/themes/sap_fiori_3/fonts/72-Bold.woff2?ui5-webcomponents) format("woff2")}@font-face{font-family:'72-Boldfull';font-style:normal;src:url(https://sdk.openui5.org/resources/sap/ui/core/themes/sap_fiori_3/fonts/72-Bold-full.woff2?ui5-webcomponents) format("woff2")}@font-face{font-family:'72-Light';font-style:normal;src:local('72-Light'),url(https://sdk.openui5.org/resources/sap/ui/core/themes/sap_fiori_3/fonts/72-Light.woff2?ui5-webcomponents) format("woff2")}@font-face{font-family:'72-Lightfull';font-style:normal;src:url(https://sdk.openui5.org/resources/sap/ui/core/themes/sap_fiori_3/fonts/72-Light-full.woff2?ui5-webcomponents) format("woff2")}@font-face{font-family:"72Black";font-style:bold;font-weight:900;src:local('72Black'),url(https://sdk.openui5.org/resources/sap/ui/core/themes/sap_horizon/fonts/72-Black.woff2?ui5-webcomponents) format("woff2")}` }, iC = { packageName: "@ui5/webcomponents-base", fileName: "OverrideFontFace.css", content: "@font-face{font-family:'72override';unicode-range:U+0102-0103,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EB7,U+1EB8-1EC7,U+1EC8-1ECB,U+1ECC-1EE3,U+1EE4-1EF1,U+1EF4-1EF7;src:local('Arial'),local('Helvetica'),local('sans-serif')}" }, nC = () => {
  Zw("data-ui5-font-face") || Kw(tC, "data-ui5-font-face");
}, oC = () => {
  Zw("data-ui5-font-face-override") || Kw(iC, "data-ui5-font-face-override");
}, rC = { packageName: "@ui5/webcomponents-base", fileName: "SystemCSSVars.css", content: ":root{--_ui5_content_density:cozy}.sapUiSizeCompact,.ui5-content-density-compact,[data-ui5-compact-size]{--_ui5_content_density:compact}[dir=rtl]{--_ui5_dir:rtl}[dir=ltr]{--_ui5_dir:ltr}" };
let sC, aC = false;
const lC = new _w(), cC = async () => {
  if (void 0 !== sC)
    return sC;
  return sC = new Promise(async (e3) => {
    if ("undefined" == typeof document)
      return void e3();
    ((e4) => {
      Uw.attachEvent(Hw, e4);
    })(hC), (() => {
      if (void 0 === mw) {
        mw = vw.length;
        const e4 = gw;
        vw.push({ ...e4, alias: "", description: `Runtime ${mw} - ver ${e4.version}` });
      }
    })();
    const t2 = Ky("OpenUI5Support"), i2 = !!t2 && t2.isLoaded(), n2 = Ky("F6Navigation");
    t2 && await t2.init(), n2 && !i2 && n2.init(), await new Promise((e4) => {
      document.body ? e4() : document.addEventListener("DOMContentLoaded", () => {
        e4();
      });
    }), await cx(ux()), t2 && t2.attachListeners(), (() => {
      const e4 = Ky("OpenUI5Support");
      e4 && e4.isLoaded() || nC(), oC();
    })(), Zw("data-ui5-system-css-vars") || Kw(rC, "data-ui5-system-css-vars"), e3(), aC = true, await lC.fireEventAsync("boot");
  }), sC;
}, hC = (e3) => {
  const t2 = ux();
  aC && e3 === t2 && cx(t2);
}, uC = /* @__PURE__ */ new Map(), dC = /* @__PURE__ */ new Map(), pC = (e3) => {
  if (!uC.has(e3)) {
    const t2 = gC(e3.split("-"));
    uC.set(e3, t2);
  }
  return uC.get(e3);
}, _C = (e3) => {
  if (!dC.has(e3)) {
    const t2 = e3.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
    dC.set(e3, t2);
  }
  return dC.get(e3);
}, gC = (e3) => e3.map((e4, t2) => 0 === t2 ? e4.toLowerCase() : e4.charAt(0).toUpperCase() + e4.slice(1).toLowerCase()).join(""), mC = (e3) => e3 instanceof HTMLSlotElement ? e3.assignedNodes({ flatten: true }).filter((e4) => e4 instanceof HTMLElement) : [e3];
let fC = { include: [/^ui5-/], exclude: [] };
const vC = /* @__PURE__ */ new Map(), AC = (e3) => {
  if (!vC.has(e3)) {
    const t2 = fC.include.some((t3) => e3.match(t3)) && !fC.exclude.some((t3) => e3.match(t3));
    vC.set(e3, t2);
  }
  return vC.get(e3);
}, bC = (e3) => {
  AC(e3);
};
class yC {
  constructor(e3) {
    this.metadata = e3;
  }
  getInitialState() {
    if (Object.prototype.hasOwnProperty.call(this, "_initialState"))
      return this._initialState;
    const e3 = {}, t2 = this.slotsAreManaged(), i2 = this.getProperties();
    for (const t3 in i2) {
      const n2 = i2[t3].type, o2 = i2[t3].defaultValue;
      n2 === Boolean ? (e3[t3] = false, void 0 !== o2 && console.warn("The 'defaultValue' metadata key is ignored for all booleans properties, they would be initialized with 'false' by default")) : i2[t3].multiple ? e3[t3] = [] : e3[t3] = n2 === Object ? "defaultValue" in i2[t3] ? i2[t3].defaultValue : {} : n2 === String ? "defaultValue" in i2[t3] ? i2[t3].defaultValue : "" : o2;
    }
    if (t2) {
      const t3 = this.getSlots();
      for (const [i3, n2] of Object.entries(t3)) {
        e3[n2.propertyName || i3] = [];
      }
    }
    return this._initialState = e3, e3;
  }
  static validatePropertyValue(e3, t2) {
    return t2.multiple && e3 ? e3.map((e4) => wC(e4, t2)) : wC(e3, t2);
  }
  static validateSlotValue(e3, t2) {
    return xC(e3, t2);
  }
  getPureTag() {
    return this.metadata.tag || "";
  }
  getTag() {
    const e3 = this.metadata.tag;
    if (!e3)
      return "";
    const t2 = bC(e3);
    return t2 ? `${e3}-${t2}` : e3;
  }
  hasAttribute(e3) {
    const t2 = this.getProperties()[e3];
    return t2.type !== Object && !t2.noAttribute && !t2.multiple;
  }
  getPropertiesList() {
    return Object.keys(this.getProperties());
  }
  getAttributesList() {
    return this.getPropertiesList().filter(this.hasAttribute.bind(this)).map(_C);
  }
  canSlotText() {
    const e3 = this.getSlots().default;
    return e3 && e3.type === Node;
  }
  hasSlots() {
    return !!Object.entries(this.getSlots()).length;
  }
  hasIndividualSlots() {
    return this.slotsAreManaged() && Object.values(this.getSlots()).some((e3) => e3.individualSlots);
  }
  slotsAreManaged() {
    return !!this.metadata.managedSlots;
  }
  supportsF6FastNavigation() {
    return !!this.metadata.fastNavigation;
  }
  getProperties() {
    return this.metadata.properties || (this.metadata.properties = {}), this.metadata.properties;
  }
  getEvents() {
    return this.metadata.events || (this.metadata.events = {}), this.metadata.events;
  }
  getSlots() {
    return this.metadata.slots || (this.metadata.slots = {}), this.metadata.slots;
  }
  isLanguageAware() {
    return !!this.metadata.languageAware;
  }
  isThemeAware() {
    return !!this.metadata.themeAware;
  }
  shouldInvalidateOnChildChange(e3, t2, i2) {
    const n2 = this.getSlots()[e3].invalidateOnChildChange;
    if (void 0 === n2)
      return false;
    if ("boolean" == typeof n2)
      return n2;
    if ("object" == typeof n2) {
      if ("property" === t2) {
        if (void 0 === n2.properties)
          return false;
        if ("boolean" == typeof n2.properties)
          return n2.properties;
        if (Array.isArray(n2.properties))
          return n2.properties.includes(i2);
        throw new Error("Wrong format for invalidateOnChildChange.properties: boolean or array is expected");
      }
      if ("slot" === t2) {
        if (void 0 === n2.slots)
          return false;
        if ("boolean" == typeof n2.slots)
          return n2.slots;
        if (Array.isArray(n2.slots))
          return n2.slots.includes(i2);
        throw new Error("Wrong format for invalidateOnChildChange.slots: boolean or array is expected");
      }
    }
    throw new Error("Wrong format for invalidateOnChildChange: boolean or object is expected");
  }
}
const wC = (e3, t2) => {
  const i2 = t2.type;
  let n2 = t2.validator;
  return i2 && i2.isDataTypeClass && (n2 = i2), n2 ? n2.isValid(e3) ? e3 : t2.defaultValue : i2 && i2 !== String ? i2 === Boolean ? "boolean" == typeof e3 && e3 : i2 === Object ? "object" == typeof e3 ? e3 : t2.defaultValue : e3 in i2 ? e3 : t2.defaultValue : "string" == typeof e3 || null == e3 ? e3 : e3.toString();
}, xC = (e3, t2) => (e3 && mC(e3).forEach((e4) => {
  if (!(e4 instanceof t2.type))
    throw new Error(`The element is not of type ${t2.type.toString()}`);
}), e3);
class CC extends HTMLElement {
}
customElements.get("ui5-static-area") || customElements.define("ui5-static-area", CC);
const SC = (e3) => {
  Oy("CustomStyle.eventProvider", new _w()).attachEvent("CustomCSSChange", e3);
};
SC((e3) => {
  zw({ tag: e3 });
});
const EC = (e3) => {
  const t2 = Oy("CustomStyle.customCSSFor", {});
  return t2[e3] ? t2[e3].join("") : "";
}, IC = (e3) => Array.isArray(e3) ? e3.filter((e4) => !!e4).flat(10).map((e4) => "string" == typeof e4 ? e4 : e4.content).join(" ") : "string" == typeof e3 ? e3 : e3.content, TC = /* @__PURE__ */ new Map();
SC((e3) => {
  TC.delete(`${e3}_normal`);
});
const BC = (e3, t2 = false) => {
  const i2 = e3.getMetadata().getTag(), n2 = `${i2}_${t2 ? "static" : "normal"}`, o2 = Ky("OpenUI5Enablement");
  if (!TC.has(n2)) {
    let r2, s2 = "";
    if (o2 && (s2 = IC(o2.getBusyIndicatorStyles())), t2)
      r2 = IC(e3.staticAreaStyles);
    else {
      const t3 = EC(i2) || "";
      r2 = `${IC(e3.styles)} ${t3}`;
    }
    r2 = `${r2} ${s2}`, TC.set(n2, r2);
  }
  return TC.get(n2);
}, MC = /* @__PURE__ */ new Map();
SC((e3) => {
  MC.delete(`${e3}_normal`);
});
const kC = (e3, t2 = false) => {
  let i2;
  const n2 = e3.constructor, o2 = t2 ? e3.staticAreaItem.shadowRoot : e3.shadowRoot;
  let r2;
  r2 = t2 ? e3.renderStatic() : e3.render(), o2 ? (document.adoptedStyleSheets ? o2.adoptedStyleSheets = ((e4, t3 = false) => {
    const i3 = `${e4.getMetadata().getTag()}_${t3 ? "static" : "normal"}`;
    if (!MC.has(i3)) {
      const n3 = BC(e4, t3), o3 = new CSSStyleSheet();
      o3.replaceSync(n3), MC.set(i3, [o3]);
    }
    return MC.get(i3);
  })(n2, t2) : i2 = BC(n2, t2), n2.renderer ? n2.renderer(r2, o2, i2, t2, { host: e3 }) : n2.render(r2, o2, i2, t2, { host: e3 })) : console.warn("There is no shadow root to update");
}, RC = { iw: "he", ji: "yi", in: "id", sh: "sr" }, PC = ((e3) => {
  const t2 = /\$([-a-z0-9A-Z._]+)(?::([^$]*))?\$/.exec(e3);
  return t2 && t2[2] ? t2[2].split(/,/) : null;
})("$cldr-rtl-locales:ar,fa,he$") || [], DC = () => {
  if ("undefined" == typeof document)
    return false;
  const e3 = (pw(), hw.rtl);
  return void 0 !== e3 ? !!e3 : (t2 = (t2 = yx() || fx()) && RC[t2] || t2, PC.indexOf(t2) >= 0);
  var t2;
}, LC = (e3) => {
  const t2 = window.document, i2 = ["ltr", "rtl"], n2 = getComputedStyle(e3).getPropertyValue("--_ui5_dir");
  return i2.includes(n2) ? n2 : i2.includes(e3.dir) ? e3.dir : i2.includes(t2.documentElement.dir) ? t2.documentElement.dir : i2.includes(t2.body.dir) ? t2.body.dir : DC() ? "rtl" : void 0;
}, FC = "ui5-static-area-item";
class NC extends HTMLElement {
  constructor() {
    super(), this._rendered = false, this.attachShadow({ mode: "open" });
  }
  setOwnerElement(e3) {
    this.ownerElement = e3, this.classList.add(this.ownerElement._id), this.ownerElement.hasAttribute("data-ui5-static-stable") && this.setAttribute("data-ui5-stable", this.ownerElement.getAttribute("data-ui5-static-stable"));
  }
  update() {
    this._rendered && (this._updateAdditionalAttrs(), this._updateContentDensity(), this._updateDirection(), kC(this.ownerElement, true));
  }
  _updateContentDensity() {
    var e3;
    "compact" === (e3 = this.ownerElement, getComputedStyle(e3).getPropertyValue("--_ui5_content_density")) ? (this.classList.add("sapUiSizeCompact"), this.classList.add("ui5-content-density-compact")) : (this.classList.remove("sapUiSizeCompact"), this.classList.remove("ui5-content-density-compact"));
  }
  _updateDirection() {
    if (this.ownerElement) {
      const e3 = LC(this.ownerElement);
      e3 ? this.setAttribute("dir", e3) : this.removeAttribute("dir");
    }
  }
  _updateAdditionalAttrs() {
    this.setAttribute(FC, ""), this.setAttribute("data-sap-ui-integration-popup-content", "");
  }
  async getDomRef() {
    return this._updateContentDensity(), this._rendered || (this._rendered = true, kC(this.ownerElement, true)), await Nw(), this.shadowRoot;
  }
  static getTag() {
    const e3 = bC(FC);
    return e3 ? `${FC}-${e3}` : FC;
  }
  static createInstance() {
    return customElements.get(NC.getTag()) || customElements.define(NC.getTag(), NC), document.createElement(this.getTag());
  }
}
const OC = /* @__PURE__ */ new WeakMap(), zC = ["value-changed", "click"];
let UC;
const HC = () => (void 0 === UC && (pw(), UC = hw.noConflict), UC), QC = (e3) => {
  const t2 = HC();
  return !((e4) => zC.includes(e4))(e3) && (true === t2 || !((e4) => {
    const t3 = HC();
    return !("boolean" != typeof t3 && t3.events && t3.events.includes && t3.events.includes(e4));
  })(e3));
}, VC = ["disabled", "title", "hidden", "role", "draggable"], GC = (e3) => {
  if (VC.includes(e3) || e3.startsWith("aria"))
    return true;
  return ![HTMLElement, Element, Node].some((t2) => t2.prototype.hasOwnProperty(e3));
}, $C = (e3, t2) => {
  if (e3.length !== t2.length)
    return false;
  for (let i2 = 0; i2 < e3.length; i2++)
    if (e3[i2] !== t2[i2])
      return false;
  return true;
}, WC = (e3, t2) => {
  const i2 = qC(t2);
  return e3.call(t2, t2, i2, void 0);
}, qC = (e3) => {
  const t2 = e3.constructor, i2 = t2.getMetadata().getPureTag(), n2 = t2.getUniqueDependencies().map((e4) => e4.getMetadata().getPureTag()).filter(AC);
  return AC(i2) && n2.push(i2), n2;
};
let jC = 0;
const XC = /* @__PURE__ */ new Map(), YC = /* @__PURE__ */ new Map();
function KC(e3) {
  this._suppressInvalidation || (this.onInvalidation(e3), this._changedState.push(e3), Pw(this), this._eventProvider.fireEvent("invalidate", { ...e3, target: this }));
}
class ZC extends HTMLElement {
  constructor() {
    super();
    const e3 = this.constructor;
    let t2;
    this._changedState = [], this._suppressInvalidation = true, this._inDOM = false, this._fullyConnected = false, this._childChangeListeners = /* @__PURE__ */ new Map(), this._slotChangeListeners = /* @__PURE__ */ new Map(), this._eventProvider = new _w(), this._domRefReadyPromise = new Promise((e4) => {
      t2 = e4;
    }), this._domRefReadyPromise._deferredResolve = t2, this._doNotSyncAttributes = /* @__PURE__ */ new Set(), this._state = { ...e3.getMetadata().getInitialState() }, this._upgradeAllProperties(), e3._needsShadowDOM() && this.attachShadow({ mode: "open" });
  }
  get _id() {
    return this.__id || (this.__id = "ui5wc_" + ++jC), this.__id;
  }
  render() {
    const e3 = this.constructor.template;
    return WC(e3, this);
  }
  renderStatic() {
    const e3 = this.constructor.staticAreaTemplate;
    return WC(e3, this);
  }
  async connectedCallback() {
    const e3 = this.constructor;
    this.setAttribute(e3.getMetadata().getPureTag(), ""), e3.getMetadata().supportsF6FastNavigation() && this.setAttribute("data-sap-ui-fastnavgroup", "true");
    const t2 = e3.getMetadata().slotsAreManaged();
    this._inDOM = true, t2 && (this._startObservingDOMChildren(), await this._processChildren()), this._inDOM && (Dw(this), this._domRefReadyPromise._deferredResolve(), this._fullyConnected = true, this.onEnterDOM());
  }
  disconnectedCallback() {
    const e3 = this.constructor.getMetadata().slotsAreManaged();
    var t2;
    this._inDOM = false, e3 && this._stopObservingDOMChildren(), this._fullyConnected && (this.onExitDOM(), this._fullyConnected = false), this.staticAreaItem && this.staticAreaItem.parentElement && this.staticAreaItem.parentElement.removeChild(this.staticAreaItem), t2 = this, Tw.remove(t2), Ew.delete(t2);
  }
  onBeforeRendering() {
  }
  onAfterRendering() {
  }
  onEnterDOM() {
  }
  onExitDOM() {
  }
  _startObservingDOMChildren() {
    const e3 = this.constructor;
    if (!e3.getMetadata().hasSlots())
      return;
    const t2 = e3.getMetadata().canSlotText(), i2 = { childList: true, subtree: t2, characterData: t2 };
    ((e4, t3, i3) => {
      const n2 = new MutationObserver(t3);
      OC.set(e4, n2), n2.observe(e4, i3);
    })(this, this._processChildren.bind(this), i2);
  }
  _stopObservingDOMChildren() {
    ((e3) => {
      const t2 = OC.get(e3);
      t2 && (t2.disconnect(), OC.delete(e3));
    })(this);
  }
  async _processChildren() {
    this.constructor.getMetadata().hasSlots() && await this._updateSlots();
  }
  async _updateSlots() {
    const e3 = this.constructor, t2 = e3.getMetadata().getSlots(), i2 = e3.getMetadata().canSlotText(), n2 = Array.from(i2 ? this.childNodes : this.children), o2 = /* @__PURE__ */ new Map(), r2 = /* @__PURE__ */ new Map();
    for (const [e4, i3] of Object.entries(t2)) {
      const t3 = i3.propertyName || e4;
      r2.set(t3, e4), o2.set(t3, [...this._state[t3]]), this._clearSlot(e4, i3);
    }
    const s2 = /* @__PURE__ */ new Map(), a2 = /* @__PURE__ */ new Map(), l2 = n2.map(async (i3, n3) => {
      const o3 = ((e4) => {
        if (!(e4 instanceof HTMLElement))
          return "default";
        const t3 = e4.getAttribute("slot");
        if (t3) {
          const e5 = t3.match(/^(.+?)-\d+$/);
          return e5 ? e5[1] : t3;
        }
        return "default";
      })(i3), r3 = t2[o3];
      if (void 0 === r3) {
        if ("default" !== o3) {
          const e4 = Object.keys(t2).join(", ");
          console.warn(`Unknown slotName: ${o3}, ignoring`, i3, `Valid values are: ${e4}`);
        }
        return;
      }
      if (r3.individualSlots) {
        const e4 = (s2.get(o3) || 0) + 1;
        s2.set(o3, e4), i3._individualSlot = `${o3}-${e4}`;
      }
      if (i3 instanceof HTMLElement) {
        const e4 = i3.localName;
        if (e4.includes("-")) {
          if (!window.customElements.get(e4)) {
            const t3 = window.customElements.whenDefined(e4);
            let i4 = XC.get(e4);
            i4 || (i4 = new Promise((e5) => setTimeout(e5, 1e3)), XC.set(e4, i4)), await Promise.race([t3, i4]);
          }
          window.customElements.upgrade(i3);
        }
      }
      if (i3 = e3.getMetadata().constructor.validateSlotValue(i3, r3), JC(i3) && r3.invalidateOnChildChange) {
        const e4 = this._getChildChangeListener(o3);
        e4 && i3.attachInvalidate.call(i3, e4);
      }
      i3 instanceof HTMLSlotElement && this._attachSlotChange(i3, o3);
      const l3 = r3.propertyName || o3;
      a2.has(l3) ? a2.get(l3).push({ child: i3, idx: n3 }) : a2.set(l3, [{ child: i3, idx: n3 }]);
    });
    await Promise.all(l2), a2.forEach((e4, t3) => {
      this._state[t3] = e4.sort((e5, t4) => e5.idx - t4.idx).map((e5) => e5.child);
    });
    let c2 = false;
    for (const [e4, i3] of Object.entries(t2)) {
      const t3 = i3.propertyName || e4;
      $C(o2.get(t3), this._state[t3]) || (KC.call(this, { type: "slot", name: r2.get(t3), reason: "children" }), c2 = true);
    }
    c2 || KC.call(this, { type: "slot", name: "default", reason: "textcontent" });
  }
  _clearSlot(e3, t2) {
    const i2 = t2.propertyName || e3;
    this._state[i2].forEach((t3) => {
      if (JC(t3)) {
        const i3 = this._getChildChangeListener(e3);
        i3 && t3.detachInvalidate.call(t3, i3);
      }
      t3 instanceof HTMLSlotElement && this._detachSlotChange(t3, e3);
    }), this._state[i2] = [];
  }
  attachInvalidate(e3) {
    this._eventProvider.attachEvent("invalidate", e3);
  }
  detachInvalidate(e3) {
    this._eventProvider.detachEvent("invalidate", e3);
  }
  _onChildChange(e3, t2) {
    this.constructor.getMetadata().shouldInvalidateOnChildChange(e3, t2.type, t2.name) && KC.call(this, { type: "slot", name: e3, reason: "childchange", child: t2.target });
  }
  attributeChangedCallback(e3, t2, i2) {
    let n2;
    if (this._doNotSyncAttributes.has(e3))
      return;
    const o2 = this.constructor.getMetadata().getProperties(), r2 = e3.replace(/^ui5-/, ""), s2 = pC(r2);
    if (o2.hasOwnProperty(s2)) {
      const e4 = o2[s2], t3 = e4.type;
      let r3 = e4.validator;
      t3 && t3.isDataTypeClass && (r3 = t3), n2 = r3 ? r3.attributeToProperty(i2) : t3 === Boolean ? null !== i2 : i2, this[s2] = n2;
    }
  }
  _updateAttribute(e3, t2) {
    const i2 = this.constructor;
    if (!i2.getMetadata().hasAttribute(e3))
      return;
    const n2 = i2.getMetadata().getProperties()[e3], o2 = n2.type;
    let r2 = n2.validator;
    const s2 = _C(e3), a2 = this.getAttribute(s2);
    if (o2 && o2.isDataTypeClass && (r2 = o2), r2) {
      const e4 = r2.propertyToAttribute(t2);
      null === e4 ? (this._doNotSyncAttributes.add(s2), this.removeAttribute(s2), this._doNotSyncAttributes.delete(s2)) : this.setAttribute(s2, e4);
    } else
      o2 === Boolean ? true === t2 && null === a2 ? this.setAttribute(s2, "") : false === t2 && null !== a2 && this.removeAttribute(s2) : "object" != typeof t2 && a2 !== t2 && this.setAttribute(s2, t2);
  }
  _upgradeProperty(e3) {
    if (this.hasOwnProperty(e3)) {
      const t2 = this[e3];
      delete this[e3], this[e3] = t2;
    }
  }
  _upgradeAllProperties() {
    this.constructor.getMetadata().getPropertiesList().forEach(this._upgradeProperty.bind(this));
  }
  _getChildChangeListener(e3) {
    return this._childChangeListeners.has(e3) || this._childChangeListeners.set(e3, this._onChildChange.bind(this, e3)), this._childChangeListeners.get(e3);
  }
  _getSlotChangeListener(e3) {
    return this._slotChangeListeners.has(e3) || this._slotChangeListeners.set(e3, this._onSlotChange.bind(this, e3)), this._slotChangeListeners.get(e3);
  }
  _attachSlotChange(e3, t2) {
    const i2 = this._getSlotChangeListener(t2);
    i2 && e3.addEventListener("slotchange", i2);
  }
  _detachSlotChange(e3, t2) {
    e3.removeEventListener("slotchange", this._getSlotChangeListener(t2));
  }
  _onSlotChange(e3) {
    KC.call(this, { type: "slot", name: e3, reason: "slotchange" });
  }
  onInvalidation(e3) {
  }
  _render() {
    const e3 = this.constructor, t2 = e3.getMetadata().hasIndividualSlots();
    this._suppressInvalidation = true, this.onBeforeRendering(), this._onComponentStateFinalized && this._onComponentStateFinalized(), this._suppressInvalidation = false, this._changedState = [], e3._needsShadowDOM() && kC(this), this.staticAreaItem && this.staticAreaItem.update(), t2 && this._assignIndividualSlotsToChildren(), this.onAfterRendering();
  }
  _assignIndividualSlotsToChildren() {
    Array.from(this.children).forEach((e3) => {
      e3._individualSlot && e3.setAttribute("slot", e3._individualSlot);
    });
  }
  _waitForDomRef() {
    return this._domRefReadyPromise;
  }
  getDomRef() {
    if ("function" == typeof this._getRealDomRef)
      return this._getRealDomRef();
    if (!this.shadowRoot || 0 === this.shadowRoot.children.length)
      return;
    const e3 = [...this.shadowRoot.children].filter((e4) => !["link", "style"].includes(e4.localName));
    return 1 !== e3.length && console.warn(`The shadow DOM for ${this.constructor.getMetadata().getTag()} does not have a top level element, the getDomRef() method might not work as expected`), e3[0];
  }
  getFocusDomRef() {
    const e3 = this.getDomRef();
    if (e3) {
      return e3.querySelector("[data-sap-focus-ref]") || e3;
    }
  }
  async getFocusDomRefAsync() {
    return await this._waitForDomRef(), this.getFocusDomRef();
  }
  async focus(e3) {
    await this._waitForDomRef();
    const t2 = this.getFocusDomRef();
    t2 && "function" == typeof t2.focus && t2.focus(e3);
  }
  fireEvent(e3, t2, i2 = false, n2 = true) {
    const o2 = this._fireEvent(e3, t2, i2, n2), r2 = pC(e3);
    return r2 !== e3 ? o2 && this._fireEvent(r2, t2, i2) : o2;
  }
  _fireEvent(e3, t2, i2 = false, n2 = true) {
    const o2 = new CustomEvent(`ui5-${e3}`, { detail: t2, composed: false, bubbles: n2, cancelable: i2 }), r2 = this.dispatchEvent(o2);
    if (QC(e3))
      return r2;
    const s2 = new CustomEvent(e3, { detail: t2, composed: false, bubbles: n2, cancelable: i2 });
    return this.dispatchEvent(s2) && r2;
  }
  getSlottedNodes(e3) {
    return this[e3].reduce((e4, t2) => e4.concat(mC(t2)), []);
  }
  get effectiveDir() {
    var e3;
    return e3 = this.constructor, Sw.add(e3), LC(this);
  }
  get isUI5Element() {
    return true;
  }
  get classes() {
    return {};
  }
  static get observedAttributes() {
    return this.getMetadata().getAttributesList();
  }
  static _needsShadowDOM() {
    return !!this.template || Object.prototype.hasOwnProperty.call(this.prototype, "render");
  }
  static _needsStaticArea() {
    return !!this.staticAreaTemplate || Object.prototype.hasOwnProperty.call(this.prototype, "renderStatic");
  }
  getStaticAreaItemDomRef() {
    if (!this.constructor._needsStaticArea())
      throw new Error("This component does not use the static area");
    return this.staticAreaItem || (this.staticAreaItem = NC.createInstance(), this.staticAreaItem.setOwnerElement(this)), this.staticAreaItem.parentElement || Fy("ui5-static-area").appendChild(this.staticAreaItem), this.staticAreaItem.getDomRef();
  }
  static _generateAccessors() {
    const e3 = this.prototype, t2 = this.getMetadata().slotsAreManaged(), i2 = this.getMetadata().getProperties();
    for (const [t3, n2] of Object.entries(i2)) {
      if (GC(t3) || console.warn(`"${t3}" is not a valid property name. Use a name that does not collide with DOM APIs`), n2.type === Boolean && n2.defaultValue)
        throw new Error(`Cannot set a default value for property "${t3}". All booleans are false by default.`);
      if (n2.type === Array)
        throw new Error(`Wrong type for property "${t3}". Properties cannot be of type Array - use "multiple: true" and set "type" to the single value type, such as "String", "Object", etc...`);
      if (n2.type === Object && n2.defaultValue)
        throw new Error(`Cannot set a default value for property "${t3}". All properties of type "Object" are empty objects by default.`);
      if (n2.multiple && n2.defaultValue)
        throw new Error(`Cannot set a default value for property "${t3}". All multiple properties are empty arrays by default.`);
      Object.defineProperty(e3, t3, { get() {
        if (void 0 !== this._state[t3])
          return this._state[t3];
        const e4 = n2.defaultValue;
        return n2.type !== Boolean && (n2.type === String ? e4 : n2.multiple ? [] : e4);
      }, set(e4) {
        let i3;
        e4 = this.constructor.getMetadata().constructor.validatePropertyValue(e4, n2);
        const o2 = n2.type;
        let r2 = n2.validator;
        const s2 = this._state[t3];
        o2 && o2.isDataTypeClass && (r2 = o2), i3 = r2 ? !r2.valuesAreEqual(s2, e4) : Array.isArray(s2) && Array.isArray(e4) && n2.multiple && n2.compareValues ? !$C(s2, e4) : s2 !== e4, i3 && (this._state[t3] = e4, KC.call(this, { type: "property", name: t3, newValue: e4, oldValue: s2 }), this._updateAttribute(t3, e4));
      } });
    }
    if (t2) {
      const t3 = this.getMetadata().getSlots();
      for (const [i3, n2] of Object.entries(t3)) {
        GC(i3) || console.warn(`"${i3}" is not a valid property name. Use a name that does not collide with DOM APIs`);
        const t4 = n2.propertyName || i3;
        Object.defineProperty(e3, t4, { get() {
          return void 0 !== this._state[t4] ? this._state[t4] : [];
        }, set() {
          throw new Error("Cannot set slot content directly, use the DOM APIs (appendChild, removeChild, etc...)");
        } });
      }
    }
  }
  static get styles() {
    return "";
  }
  static get staticAreaStyles() {
    return "";
  }
  static get dependencies() {
    return [];
  }
  static getUniqueDependencies() {
    if (!YC.has(this)) {
      const e3 = this.dependencies.filter((e4, t2, i2) => i2.indexOf(e4) === t2);
      YC.set(this, e3);
    }
    return YC.get(this) || [];
  }
  static whenDependenciesDefined() {
    return Promise.all(this.getUniqueDependencies().map((e3) => e3.define()));
  }
  static async onDefine() {
    return Promise.resolve();
  }
  static async define() {
    await cC(), await Promise.all([this.whenDependenciesDefined(), this.onDefine()]);
    const e3 = this.getMetadata().getTag(), t2 = ((e4) => yw.has(e4))(e3), i2 = customElements.get(e3);
    return i2 && !t2 ? ((e4) => {
      let t3 = bw.get(e4);
      void 0 === t3 && (t3 = -1), xw.has(t3) || xw.set(t3, /* @__PURE__ */ new Set()), xw.get(t3).add(e4), ww || (ww = setTimeout(() => {
        Cw(), xw = /* @__PURE__ */ new Map(), ww = void 0;
      }, 1e3));
    })(e3) : i2 || (this._generateAccessors(), ((e4) => {
      yw.add(e4), bw.set(e4, Aw());
    })(e3), window.customElements.define(e3, this)), this;
  }
  static getMetadata() {
    if (this.hasOwnProperty("_metadata"))
      return this._metadata;
    const e3 = [this.metadata];
    let t2 = this;
    for (; t2 !== ZC; )
      t2 = Object.getPrototypeOf(t2), e3.unshift(t2.metadata);
    const i2 = Xy({}, ...e3);
    return this._metadata = new yC(i2), this._metadata;
  }
}
ZC.metadata = {};
const JC = (e3) => "isUI5Element" in e3, eS = (e3) => (t2) => {
  if (Object.prototype.hasOwnProperty.call(t2, "metadata") || (t2.metadata = {}), "string" == typeof e3)
    return void (t2.metadata.tag = e3);
  const { tag: i2, languageAware: n2, themeAware: o2, fastNavigation: r2 } = e3;
  t2.metadata.tag = i2, n2 && (t2.metadata.languageAware = n2), o2 && (t2.metadata.themeAware = o2), r2 && (t2.metadata.fastNavigation = r2), ["render", "renderer", "template", "staticAreaTemplate", "styles", "staticAreaStyles", "dependencies"].forEach((i3) => {
    const n3 = e3["render" === i3 ? "renderer" : i3];
    n3 && Object.defineProperty(t2, i3, { get: () => n3 });
  });
}, tS = (e3) => (t2, i2) => {
  const n2 = t2.constructor;
  Object.prototype.hasOwnProperty.call(n2, "metadata") || (n2.metadata = {});
  const o2 = n2.metadata;
  o2.properties || (o2.properties = {});
  const r2 = o2.properties;
  r2[i2] || (r2[i2] = e3 || { type: String });
}, iS = (e3, t2 = {}) => (i2) => {
  Object.prototype.hasOwnProperty.call(i2, "metadata") || (i2.metadata = {});
  const n2 = i2.metadata;
  n2.events || (n2.events = {});
  const o2 = n2.events;
  o2[e3] || (o2[e3] = t2);
}, nS = (e3) => (t2, i2) => {
  const n2 = t2.constructor;
  Object.prototype.hasOwnProperty.call(n2, "metadata") || (n2.metadata = {});
  const o2 = n2.metadata;
  o2.slots || (o2.slots = {});
  const r2 = o2.slots;
  if (e3 && e3.default && r2.default)
    throw new Error("Only one slot can be the default slot.");
  const s2 = e3 && e3.default ? "default" : i2;
  (e3 = e3 || { type: HTMLElement }).type || (e3.type = HTMLElement), r2[s2] || (r2[s2] = e3), e3.default && (delete r2.default.default, r2.default.propertyName = i2), n2.metadata.managedSlots = true;
};
var oS;
!function(e3) {
  e3[e3.BACKSPACE = 8] = "BACKSPACE", e3[e3.TAB = 9] = "TAB", e3[e3.ENTER = 13] = "ENTER", e3[e3.SHIFT = 16] = "SHIFT", e3[e3.CONTROL = 17] = "CONTROL", e3[e3.ALT = 18] = "ALT", e3[e3.BREAK = 19] = "BREAK", e3[e3.CAPS_LOCK = 20] = "CAPS_LOCK", e3[e3.ESCAPE = 27] = "ESCAPE", e3[e3.SPACE = 32] = "SPACE", e3[e3.PAGE_UP = 33] = "PAGE_UP", e3[e3.PAGE_DOWN = 34] = "PAGE_DOWN", e3[e3.END = 35] = "END", e3[e3.HOME = 36] = "HOME", e3[e3.ARROW_LEFT = 37] = "ARROW_LEFT", e3[e3.ARROW_UP = 38] = "ARROW_UP", e3[e3.ARROW_RIGHT = 39] = "ARROW_RIGHT", e3[e3.ARROW_DOWN = 40] = "ARROW_DOWN", e3[e3.PRINT = 44] = "PRINT", e3[e3.INSERT = 45] = "INSERT", e3[e3.DELETE = 46] = "DELETE", e3[e3.DIGIT_0 = 48] = "DIGIT_0", e3[e3.DIGIT_1 = 49] = "DIGIT_1", e3[e3.DIGIT_2 = 50] = "DIGIT_2", e3[e3.DIGIT_3 = 51] = "DIGIT_3", e3[e3.DIGIT_4 = 52] = "DIGIT_4", e3[e3.DIGIT_5 = 53] = "DIGIT_5", e3[e3.DIGIT_6 = 54] = "DIGIT_6", e3[e3.DIGIT_7 = 55] = "DIGIT_7", e3[e3.DIGIT_8 = 56] = "DIGIT_8", e3[e3.DIGIT_9 = 57] = "DIGIT_9", e3[e3.A = 65] = "A", e3[e3.B = 66] = "B", e3[e3.C = 67] = "C", e3[e3.D = 68] = "D", e3[e3.E = 69] = "E", e3[e3.F = 70] = "F", e3[e3.G = 71] = "G", e3[e3.H = 72] = "H", e3[e3.I = 73] = "I", e3[e3.J = 74] = "J", e3[e3.K = 75] = "K", e3[e3.L = 76] = "L", e3[e3.M = 77] = "M", e3[e3.N = 78] = "N", e3[e3.O = 79] = "O", e3[e3.P = 80] = "P", e3[e3.Q = 81] = "Q", e3[e3.R = 82] = "R", e3[e3.S = 83] = "S", e3[e3.T = 84] = "T", e3[e3.U = 85] = "U", e3[e3.V = 86] = "V", e3[e3.W = 87] = "W", e3[e3.X = 88] = "X", e3[e3.Y = 89] = "Y", e3[e3.Z = 90] = "Z", e3[e3.WINDOWS = 91] = "WINDOWS", e3[e3.CONTEXT_MENU = 93] = "CONTEXT_MENU", e3[e3.TURN_OFF = 94] = "TURN_OFF", e3[e3.SLEEP = 95] = "SLEEP", e3[e3.NUMPAD_0 = 96] = "NUMPAD_0", e3[e3.NUMPAD_1 = 97] = "NUMPAD_1", e3[e3.NUMPAD_2 = 98] = "NUMPAD_2", e3[e3.NUMPAD_3 = 99] = "NUMPAD_3", e3[e3.NUMPAD_4 = 100] = "NUMPAD_4", e3[e3.NUMPAD_5 = 101] = "NUMPAD_5", e3[e3.NUMPAD_6 = 102] = "NUMPAD_6", e3[e3.NUMPAD_7 = 103] = "NUMPAD_7", e3[e3.NUMPAD_8 = 104] = "NUMPAD_8", e3[e3.NUMPAD_9 = 105] = "NUMPAD_9", e3[e3.NUMPAD_ASTERISK = 106] = "NUMPAD_ASTERISK", e3[e3.NUMPAD_PLUS = 107] = "NUMPAD_PLUS", e3[e3.NUMPAD_MINUS = 109] = "NUMPAD_MINUS", e3[e3.NUMPAD_COMMA = 110] = "NUMPAD_COMMA", e3[e3.NUMPAD_SLASH = 111] = "NUMPAD_SLASH", e3[e3.F1 = 112] = "F1", e3[e3.F2 = 113] = "F2", e3[e3.F3 = 114] = "F3", e3[e3.F4 = 115] = "F4", e3[e3.F5 = 116] = "F5", e3[e3.F6 = 117] = "F6", e3[e3.F7 = 118] = "F7", e3[e3.F8 = 119] = "F8", e3[e3.F9 = 120] = "F9", e3[e3.F10 = 121] = "F10", e3[e3.F11 = 122] = "F11", e3[e3.F12 = 123] = "F12", e3[e3.NUM_LOCK = 144] = "NUM_LOCK", e3[e3.SCROLL_LOCK = 145] = "SCROLL_LOCK", e3[e3.OPEN_BRACKET = 186] = "OPEN_BRACKET", e3[e3.PLUS = 187] = "PLUS", e3[e3.COMMA = 188] = "COMMA", e3[e3.SLASH = 189] = "SLASH", e3[e3.DOT = 190] = "DOT", e3[e3.PIPE = 191] = "PIPE", e3[e3.SEMICOLON = 192] = "SEMICOLON", e3[e3.MINUS = 219] = "MINUS", e3[e3.GREAT_ACCENT = 220] = "GREAT_ACCENT", e3[e3.EQUALS = 221] = "EQUALS", e3[e3.SINGLE_QUOTE = 222] = "SINGLE_QUOTE", e3[e3.BACKSLASH = 226] = "BACKSLASH";
}(oS || (oS = {}));
const rS = (e3) => (e3.key ? "Enter" === e3.key : e3.keyCode === oS.ENTER) && !BS(e3), sS = (e3) => (e3.key ? "Spacebar" === e3.key || " " === e3.key : e3.keyCode === oS.SPACE) && !BS(e3), aS = (e3) => (e3.key ? "ArrowLeft" === e3.key || "Left" === e3.key : e3.keyCode === oS.ARROW_LEFT) && !BS(e3), lS = (e3) => (e3.key ? "ArrowRight" === e3.key || "Right" === e3.key : e3.keyCode === oS.ARROW_RIGHT) && !BS(e3), cS = (e3) => (e3.key ? "ArrowUp" === e3.key || "Up" === e3.key : e3.keyCode === oS.ARROW_UP) && !BS(e3), hS = (e3) => (e3.key ? "ArrowDown" === e3.key || "Down" === e3.key : e3.keyCode === oS.ARROW_DOWN) && !BS(e3), uS = (e3) => (e3.key ? "ArrowLeft" === e3.key || "Left" === e3.key : e3.keyCode === oS.ARROW_LEFT) && kS(e3, true, false, false), dS = (e3) => (e3.key ? "ArrowRight" === e3.key || "Right" === e3.key : e3.keyCode === oS.ARROW_RIGHT) && kS(e3, true, false, false), pS = (e3) => (e3.key ? "ArrowUp" === e3.key || "Up" === e3.key : e3.keyCode === oS.ARROW_UP) && kS(e3, true, false, false), _S = (e3) => (e3.key ? "ArrowDown" === e3.key || "Down" === e3.key : e3.keyCode === oS.ARROW_DOWN) && kS(e3, true, false, false), gS = (e3) => (e3.key ? "ArrowUp" === e3.key || "Up" === e3.key : e3.keyCode === oS.ARROW_UP) && kS(e3, false, false, true), mS = (e3) => (e3.key ? "ArrowDown" === e3.key || "Down" === e3.key : e3.keyCode === oS.ARROW_DOWN) && kS(e3, false, false, true), fS = (e3) => (e3.key ? "ArrowLeft" === e3.key || "Left" === e3.key : e3.keyCode === oS.ARROW_LEFT) && kS(e3, false, false, true), vS = (e3) => (e3.key ? "ArrowRight" === e3.key || "Right" === e3.key : e3.keyCode === oS.ARROW_RIGHT) && kS(e3, false, false, true), AS = (e3) => (e3.key ? "Home" === e3.key : e3.keyCode === oS.HOME) && !BS(e3), bS = (e3) => (e3.key ? "End" === e3.key : e3.keyCode === oS.END) && !BS(e3), yS = (e3) => (e3.key ? "Escape" === e3.key || "Esc" === e3.key : e3.keyCode === oS.ESCAPE) && !BS(e3), wS = (e3) => (e3.key ? "Tab" === e3.key : e3.keyCode === oS.TAB) && !BS(e3), xS = (e3) => (e3.key ? "Tab" === e3.key : e3.keyCode === oS.TAB) && kS(e3, false, false, true), CS = (e3) => (e3.key ? "Delete" === e3.key : e3.keyCode === oS.DELETE) && !BS(e3), SS = (e3) => (e3.key ? "PageUp" === e3.key : e3.keyCode === oS.PAGE_UP) && !BS(e3), ES = (e3) => (e3.key ? "PageDown" === e3.key : e3.keyCode === oS.PAGE_DOWN) && !BS(e3), IS = (e3) => (e3.key ? "+" === e3.key : e3.keyCode === oS.PLUS) || e3.keyCode === oS.NUMPAD_PLUS && !BS(e3), TS = (e3) => (e3.key ? "-" === e3.key : e3.keyCode === oS.MINUS) || e3.keyCode === oS.NUMPAD_MINUS && !BS(e3), BS = (e3) => e3.shiftKey || e3.altKey || MS(e3), MS = (e3) => !(!e3.metaKey && !e3.ctrlKey), kS = (e3, t2, i2, n2) => e3.shiftKey === n2 && e3.altKey === i2 && MS(e3) === t2, RS = () => {
  let e3 = document.activeElement;
  for (; e3 && e3.shadowRoot && e3.shadowRoot.activeElement; )
    e3 = e3.shadowRoot.activeElement;
  return e3;
};
var PS;
!function(e3) {
  e3.Auto = "Auto", e3.Vertical = "Vertical", e3.Horizontal = "Horizontal", e3.Paging = "Paging";
}(PS || (PS = {}));
const DS = PS;
var LS;
!function(e3) {
  e3.Static = "Static", e3.Cyclic = "Cyclic";
}(LS || (LS = {}));
const FS = LS;
class NS {
  constructor(e3, t2) {
    if (!e3.isUI5Element)
      throw new Error("The root web component must be a UI5 Element instance");
    if (this.rootWebComponent = e3, this.rootWebComponent.addEventListener("keydown", this._onkeydown.bind(this)), this.rootWebComponent._onComponentStateFinalized = () => {
      this._init();
    }, "function" != typeof t2.getItemsCallback)
      throw new Error("getItemsCallback is required");
    this._getItems = t2.getItemsCallback, this._currentIndex = t2.currentIndex || 0, this._rowSize = t2.rowSize || 1, this._behavior = t2.behavior || FS.Static, this._navigationMode = t2.navigationMode || DS.Auto, this._affectedPropertiesNames = t2.affectedPropertiesNames || [], this._skipItemsSize = t2.skipItemsSize || null;
  }
  setCurrentItem(e3) {
    const t2 = this._getItems().indexOf(e3);
    -1 !== t2 ? (this._currentIndex = t2, this._applyTabIndex()) : console.warn("The provided item is not managed by ItemNavigation", e3);
  }
  setRowSize(e3) {
    this._rowSize = e3;
  }
  _init() {
    this._getItems().forEach((e3, t2) => {
      e3._tabIndex = t2 === this._currentIndex ? "0" : "-1";
    });
  }
  _onkeydown(e3) {
    if (!this._canNavigate())
      return;
    const t2 = this._navigationMode === DS.Horizontal || this._navigationMode === DS.Auto, i2 = this._navigationMode === DS.Vertical || this._navigationMode === DS.Auto, n2 = "rtl" === this.rootWebComponent.effectiveDir;
    if (n2 && aS(e3) && t2)
      this._handleRight();
    else if (n2 && lS(e3) && t2)
      this._handleLeft();
    else if (aS(e3) && t2)
      this._handleLeft();
    else if (lS(e3) && t2)
      this._handleRight();
    else if (cS(e3) && i2)
      this._handleUp();
    else if (hS(e3) && i2)
      this._handleDown();
    else if (AS(e3))
      this._handleHome();
    else if (bS(e3))
      this._handleEnd();
    else if (SS(e3))
      this._handlePageUp();
    else {
      if (!ES(e3))
        return;
      this._handlePageDown();
    }
    e3.preventDefault(), this._applyTabIndex(), this._focusCurrentItem();
  }
  _handleUp() {
    const e3 = this._getItems().length;
    if (this._currentIndex - this._rowSize >= 0)
      this._currentIndex -= this._rowSize;
    else if (this._behavior === FS.Cyclic) {
      const t2 = this._currentIndex % this._rowSize;
      let i2 = (0 === t2 ? this._rowSize - 1 : t2 - 1) + (Math.ceil(e3 / this._rowSize) - 1) * this._rowSize;
      i2 > e3 - 1 && (i2 -= this._rowSize), this._currentIndex = i2;
    } else
      this._currentIndex = 0;
  }
  _handleDown() {
    const e3 = this._getItems().length;
    if (this._currentIndex + this._rowSize < e3)
      this._currentIndex += this._rowSize;
    else if (this._behavior === FS.Cyclic) {
      const e4 = (this._currentIndex % this._rowSize + 1) % this._rowSize;
      this._currentIndex = e4;
    } else
      this._currentIndex = e3 - 1;
  }
  _handleLeft() {
    const e3 = this._getItems().length;
    this._currentIndex > 0 ? this._currentIndex -= 1 : this._behavior === FS.Cyclic && (this._currentIndex = e3 - 1);
  }
  _handleRight() {
    const e3 = this._getItems().length;
    this._currentIndex < e3 - 1 ? this._currentIndex += 1 : this._behavior === FS.Cyclic && (this._currentIndex = 0);
  }
  _handleHome() {
    const e3 = this._rowSize > 1 ? this._rowSize : this._getItems().length;
    this._currentIndex -= this._currentIndex % e3;
  }
  _handleEnd() {
    const e3 = this._rowSize > 1 ? this._rowSize : this._getItems().length;
    this._currentIndex += e3 - 1 - this._currentIndex % e3;
  }
  _handlePageUp() {
    this._rowSize > 1 || this._handlePageUpFlat();
  }
  _handlePageDown() {
    this._rowSize > 1 || this._handlePageDownFlat();
  }
  _handlePageUpFlat() {
    null !== this._skipItemsSize && this._currentIndex + 1 > this._skipItemsSize ? this._currentIndex -= this._skipItemsSize : this._currentIndex -= this._currentIndex;
  }
  _handlePageDownFlat() {
    if (null === this._skipItemsSize)
      return void (this._currentIndex = this._getItems().length - 1);
    this._getItems().length - this._currentIndex - 1 > this._skipItemsSize ? this._currentIndex += this._skipItemsSize : this._currentIndex = this._getItems().length - 1;
  }
  _applyTabIndex() {
    const e3 = this._getItems();
    for (let t2 = 0; t2 < e3.length; t2++)
      e3[t2]._tabIndex = t2 === this._currentIndex ? "0" : "-1";
    this._affectedPropertiesNames.forEach((e4) => {
      const t2 = this.rootWebComponent[e4];
      this.rootWebComponent[e4] = Array.isArray(t2) ? [...t2] : { ...t2 };
    });
  }
  _focusCurrentItem() {
    const e3 = this._getCurrentItem();
    e3 && e3.focus({ focusVisible: true });
  }
  _canNavigate() {
    const e3 = this._getCurrentItem(), t2 = RS();
    return e3 && e3 === t2;
  }
  _getCurrentItem() {
    const e3 = this._getItems();
    if (!e3.length)
      return;
    for (; this._currentIndex >= e3.length; )
      this._currentIndex -= this._rowSize;
    this._currentIndex < 0 && (this._currentIndex = 0);
    const t2 = e3[this._currentIndex];
    if (!t2)
      return;
    if (JC(t2))
      return t2.getFocusDomRef();
    const i2 = this.rootWebComponent.getDomRef();
    return i2 && t2.id ? i2.querySelector(`#${t2.id}`) : void 0;
  }
}
const { I: OS } = ie, zS = () => document.createComment(""), US = (e3, t2, i2) => {
  var n2;
  const o2 = e3._$AA.parentNode, r2 = void 0 === t2 ? e3._$AB : t2._$AA;
  if (void 0 === i2) {
    const t3 = o2.insertBefore(zS(), r2), n3 = o2.insertBefore(zS(), r2);
    i2 = new OS(t3, n3, e3, e3.options);
  } else {
    const t3 = i2._$AB.nextSibling, s2 = i2._$AM, a2 = s2 !== e3;
    if (a2) {
      let t4;
      null === (n2 = i2._$AQ) || void 0 === n2 || n2.call(i2, e3), i2._$AM = e3, void 0 !== i2._$AP && (t4 = e3._$AU) !== s2._$AU && i2._$AP(t4);
    }
    if (t3 !== r2 || a2) {
      let e4 = i2._$AA;
      for (; e4 !== t3; ) {
        const t4 = e4.nextSibling;
        o2.insertBefore(e4, r2), e4 = t4;
      }
    }
  }
  return i2;
}, HS = (e3, t2, i2 = e3) => (e3._$AI(t2, i2), e3), QS = {}, VS = (e3) => {
  var t2;
  null === (t2 = e3._$AP) || void 0 === t2 || t2.call(e3, false, true);
  let i2 = e3._$AA;
  const n2 = e3._$AB.nextSibling;
  for (; i2 !== n2; ) {
    const e4 = i2.nextSibling;
    i2.remove(), i2 = e4;
  }
}, GS = (e3, t2, i2) => {
  const n2 = /* @__PURE__ */ new Map();
  for (let o2 = t2; o2 <= i2; o2++)
    n2.set(e3[o2], o2);
  return n2;
}, $S = My(class extends ky {
  constructor(e3) {
    if (super(e3), e3.type !== By)
      throw Error("repeat() can only be used in text expressions");
  }
  dt(e3, t2, i2) {
    let n2;
    void 0 === i2 ? i2 = t2 : void 0 !== t2 && (n2 = t2);
    const o2 = [], r2 = [];
    let s2 = 0;
    for (const t3 of e3)
      o2[s2] = n2 ? n2(t3, s2) : s2, r2[s2] = i2(t3, s2), s2++;
    return { values: r2, keys: o2 };
  }
  render(e3, t2, i2) {
    return this.dt(e3, t2, i2).values;
  }
  update(e3, [t2, i2, n2]) {
    var o2;
    const r2 = ((e4) => e4._$AH)(e3), { values: s2, keys: a2 } = this.dt(t2, i2, n2);
    if (!Array.isArray(r2))
      return this.ht = a2, s2;
    const l2 = null !== (o2 = this.ht) && void 0 !== o2 ? o2 : this.ht = [], c2 = [];
    let h2, u2, d2 = 0, p2 = r2.length - 1, _2 = 0, g2 = s2.length - 1;
    for (; d2 <= p2 && _2 <= g2; )
      if (null === r2[d2])
        d2++;
      else if (null === r2[p2])
        p2--;
      else if (l2[d2] === a2[_2])
        c2[_2] = HS(r2[d2], s2[_2]), d2++, _2++;
      else if (l2[p2] === a2[g2])
        c2[g2] = HS(r2[p2], s2[g2]), p2--, g2--;
      else if (l2[d2] === a2[g2])
        c2[g2] = HS(r2[d2], s2[g2]), US(e3, c2[g2 + 1], r2[d2]), d2++, g2--;
      else if (l2[p2] === a2[_2])
        c2[_2] = HS(r2[p2], s2[_2]), US(e3, r2[d2], r2[p2]), p2--, _2++;
      else if (void 0 === h2 && (h2 = GS(a2, _2, g2), u2 = GS(l2, d2, p2)), h2.has(l2[d2]))
        if (h2.has(l2[p2])) {
          const t3 = u2.get(a2[_2]), i3 = void 0 !== t3 ? r2[t3] : null;
          if (null === i3) {
            const t4 = US(e3, r2[d2]);
            HS(t4, s2[_2]), c2[_2] = t4;
          } else
            c2[_2] = HS(i3, s2[_2]), US(e3, r2[d2], i3), r2[t3] = null;
          _2++;
        } else
          VS(r2[p2]), p2--;
      else
        VS(r2[d2]), d2++;
    for (; _2 <= g2; ) {
      const t3 = US(e3, c2[g2 + 1]);
      HS(t3, s2[_2]), c2[_2++] = t3;
    }
    for (; d2 <= p2; ) {
      const e4 = r2[d2++];
      null !== e4 && VS(e4);
    }
    return this.ht = a2, ((e4, t3 = QS) => {
      e4._$AH = t3;
    })(e3, c2), H;
  }
}), WS = My(class extends ky {
  constructor(e3) {
    var t2;
    if (super(e3), e3.type !== Ty || "class" !== e3.name || (null === (t2 = e3.strings) || void 0 === t2 ? void 0 : t2.length) > 2)
      throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(e3) {
    return " " + Object.keys(e3).filter((t2) => e3[t2]).join(" ") + " ";
  }
  update(e3, [t2]) {
    var i2, n2;
    if (void 0 === this.it) {
      this.it = /* @__PURE__ */ new Set(), void 0 !== e3.strings && (this.nt = new Set(e3.strings.join(" ").split(/\s/).filter((e4) => "" !== e4)));
      for (const e4 in t2)
        t2[e4] && !(null === (i2 = this.nt) || void 0 === i2 ? void 0 : i2.has(e4)) && this.it.add(e4);
      return this.render(t2);
    }
    const o2 = e3.element.classList;
    this.it.forEach((e4) => {
      e4 in t2 || (o2.remove(e4), this.it.delete(e4));
    });
    for (const e4 in t2) {
      const i3 = !!t2[e4];
      i3 === this.it.has(e4) || (null === (n2 = this.nt) || void 0 === n2 ? void 0 : n2.has(e4)) || (i3 ? (o2.add(e4), this.it.add(e4)) : (o2.remove(e4), this.it.delete(e4)));
    }
    return H;
  }
});
const qS = My(class extends ky {
  constructor(e3) {
    var t2;
    if (super(e3), e3.type !== Ty || "style" !== e3.name || (null === (t2 = e3.strings) || void 0 === t2 ? void 0 : t2.length) > 2)
      throw new Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
  }
  render(e3) {
    return "";
  }
  update(e3, [t2]) {
    const { style: i2 } = e3.element;
    if (void 0 === this._previousStyleProperties) {
      this._previousStyleProperties = /* @__PURE__ */ new Set();
      for (const e4 in t2)
        this._previousStyleProperties.add(e4);
    }
    this._previousStyleProperties.forEach((e4) => {
      null == t2[e4] && (this._previousStyleProperties.delete(e4), e4.includes("-") ? i2.removeProperty(e4) : i2[e4] = "");
    });
    for (const e4 in t2) {
      const n2 = t2[e4];
      null != n2 && (this._previousStyleProperties.add(e4), e4.includes("-") ? i2.setProperty(e4, n2) : i2[e4] = n2);
    }
    return H;
  }
}), jS = (e3) => null != e3 ? e3 : Q, XS = (e3, ...t2) => {
  const i2 = Ky("LitStatic");
  return (i2 ? i2.html : z)(e3, ...t2);
}, YS = (e3, ...t2) => {
  const i2 = Ky("LitStatic");
  return (i2 ? i2.svg : U)(e3, ...t2);
}, KS = (e3, t2, i2, n2, o2) => {
  const r2 = Ky("OpenUI5Enablement");
  r2 && !n2 && (e3 = r2.wrapTemplateResultInBusyMarkup(XS, o2.host, e3)), "string" == typeof i2 ? e3 = XS`<style>${i2}</style>${e3}` : Array.isArray(i2) && i2.length && (e3 = XS`${i2.map((e4) => XS`<link type="text/css" rel="stylesheet" href="${e4}">`)}${e3}`), oe(e3, t2, o2);
}, ZS = (e3, t2, i2) => {
  const n2 = Ky("LitStatic");
  if (n2)
    return n2.unsafeStatic((t2 || []).includes(e3) ? `${e3}-${i2}` : e3);
};
let JS;
const eE = /* @__PURE__ */ new Map(), tE = () => (JS || (JS = new window.ResizeObserver((e3) => {
  window.requestAnimationFrame(() => {
    e3.forEach((e4) => {
      const t2 = eE.get(e4.target);
      t2 && Promise.all(t2.map((e5) => e5()));
    });
  });
})), JS);
class iE {
  static register(e3, t2) {
    let i2 = e3;
    JC(i2) && (i2 = i2.getDomRef()), i2 instanceof HTMLElement ? ((e4, t3) => {
      const i3 = eE.get(e4) || [];
      i3.length || tE().observe(e4), eE.set(e4, [...i3, t3]);
    })(i2, t2) : console.warn("Cannot register ResizeHandler for element", e3);
  }
  static deregister(e3, t2) {
    let i2 = e3;
    JC(i2) && (i2 = i2.getDomRef()), i2 instanceof HTMLElement ? ((e4, t3) => {
      const i3 = eE.get(e4) || [];
      if (0 === i3.length)
        return;
      const n2 = i3.filter((e5) => e5 !== t3);
      0 === n2.length ? (tE().unobserve(e4), eE.delete(e4)) : eE.set(e4, n2);
    })(i2, t2) : console.warn("Cannot deregister ResizeHandler for element", e3);
  }
}
const nE = { key: "ARIA_LABEL_CARD_CONTENT", defaultText: "Card Content" }, oE = { key: "ARIA_ROLEDESCRIPTION_CARD", defaultText: "Card" }, rE = { key: "ARIA_ROLEDESCRIPTION_CARD_HEADER", defaultText: "Card Header" }, sE = { key: "ARIA_ROLEDESCRIPTION_INTERACTIVE_CARD_HEADER", defaultText: "Interactive Card Header" }, aE = { key: "AVATAR_TOOLTIP", defaultText: "Avatar" }, lE = { key: "BUSY_INDICATOR_TITLE", defaultText: "Please wait" }, cE = { key: "BUTTON_ARIA_TYPE_ACCEPT", defaultText: "Positive Action" }, hE = { key: "BUTTON_ARIA_TYPE_REJECT", defaultText: "Negative Action" }, uE = { key: "BUTTON_ARIA_TYPE_EMPHASIZED", defaultText: "Emphasized" }, dE = { key: "COLORPALETTE_CONTAINER_LABEL", defaultText: "Color palette - Predefined colors" }, pE = { key: "COLORPALETTE_POPOVER_TITLE", defaultText: "Color Palette" }, _E = { key: "COLORPALETTE_COLOR_LABEL", defaultText: "Color" }, gE = { key: "COLOR_PALETTE_DIALOG_CANCEL_BUTTON", defaultText: "Cancel" }, mE = { key: "COLOR_PALETTE_DIALOG_OK_BUTTON", defaultText: "OK" }, fE = { key: "COLOR_PALETTE_DIALOG_TITLE", defaultText: "Change Color" }, vE = { key: "COLOR_PALETTE_MORE_COLORS_TEXT", defaultText: "More Colors..." }, AE = { key: "COLORPICKER_ALPHA_SLIDER", defaultText: "Alpha control" }, bE = { key: "COLORPICKER_HUE_SLIDER", defaultText: "Hue control" }, yE = { key: "COLORPICKER_HEX", defaultText: "Hexadecimal" }, wE = { key: "COLORPICKER_RED", defaultText: "Red" }, xE = { key: "COLORPICKER_GREEN", defaultText: "Green" }, CE = { key: "COLORPICKER_BLUE", defaultText: "Blue" }, SE = { key: "COLORPICKER_ALPHA", defaultText: "Alpha" }, EE = { key: "DELETE", defaultText: "Delete" }, IE = { key: "INPUT_SUGGESTIONS", defaultText: "Suggestions available" }, TE = { key: "INPUT_SUGGESTIONS_TITLE", defaultText: "Select" }, BE = { key: "INPUT_SUGGESTIONS_ONE_HIT", defaultText: "1 result available" }, ME = { key: "INPUT_SUGGESTIONS_MORE_HITS", defaultText: "{0} results are available" }, kE = { key: "INPUT_SUGGESTIONS_NO_HIT", defaultText: "No results" }, RE = { key: "LIST_ITEM_SELECTED", defaultText: "Selected" }, PE = { key: "LIST_ITEM_NOT_SELECTED", defaultText: "Not Selected" }, DE = { key: "ARIA_LABEL_LIST_ITEM_CHECKBOX", defaultText: "Multiple Selection mode." }, LE = { key: "ARIA_LABEL_LIST_ITEM_RADIO_BUTTON", defaultText: "Item Selection." }, FE = { key: "ARIA_LABEL_LIST_SELECTABLE", defaultText: "Contains Selectable Items" }, NE = { key: "ARIA_LABEL_LIST_MULTISELECTABLE", defaultText: "Contains Multi-Selectable Items" }, OE = { key: "ARIA_LABEL_LIST_DELETABLE", defaultText: "Contains Deletable Items" }, zE = { key: "PANEL_ICON", defaultText: "Expand/Collapse" }, UE = { key: "RESPONSIVE_POPOVER_CLOSE_DIALOG_BUTTON", defaultText: "Decline" }, HE = { key: "SEGMENTEDBUTTON_ARIA_DESCRIPTION", defaultText: "Segmented button group" }, QE = { key: "SEGMENTEDBUTTON_ARIA_DESCRIBEDBY", defaultText: "Press SPACE or ENTER to select an item" }, VE = { key: "SEGMENTEDBUTTONITEM_ARIA_DESCRIPTION", defaultText: "Segmented button" }, GE = { key: "SLIDER_ARIA_DESCRIPTION", defaultText: "Slider handle" }, $E = { key: "LOAD_MORE_TEXT", defaultText: "More" }, WE = { key: "VALUE_STATE_TYPE_ERROR", defaultText: "Value State Error" }, qE = { key: "VALUE_STATE_TYPE_WARNING", defaultText: "Value State Warning" }, jE = { key: "VALUE_STATE_TYPE_SUCCESS", defaultText: "Value State Success" }, XE = { key: "VALUE_STATE_TYPE_INFORMATION", defaultText: "Value State Information" }, YE = { key: "VALUE_STATE_ERROR", defaultText: "Invalid entry" }, KE = { key: "VALUE_STATE_WARNING", defaultText: "Warning issued" }, ZE = { key: "VALUE_STATE_INFORMATION", defaultText: "Informative entry" }, JE = { key: "VALUE_STATE_SUCCESS", defaultText: "Entry successfully validated" }, eI = { key: "STEPINPUT_DEC_ICON_TITLE", defaultText: "Decrease" }, tI = { key: "STEPINPUT_INC_ICON_TITLE", defaultText: "Increase" };
class iI {
  static isValid(e3) {
    return false;
  }
  static attributeToProperty(e3) {
    return e3;
  }
  static propertyToAttribute(e3) {
    return null === e3 ? null : String(e3);
  }
  static valuesAreEqual(e3, t2) {
    return e3 === t2;
  }
  static generateTypeAccessors(e3) {
    Object.keys(e3).forEach((t2) => {
      Object.defineProperty(this, t2, { get: () => e3[t2] });
    });
  }
  static get isDataTypeClass() {
    return true;
  }
}
class nI extends iI {
  static isValid(e3) {
    return Number.isInteger(e3);
  }
  static attributeToProperty(e3) {
    return parseInt(e3);
  }
}
function oI(e3, t2, i2) {
  return i2 ? XS`<${ZS("ui5-icon", t2, i2)} class="ui5-button-icon" name="${jS(this.icon)}" part="icon" ?show-tooltip=${this.showIconTooltip}></${ZS("ui5-icon", t2, i2)}>` : XS`<ui5-icon class="ui5-button-icon" name="${jS(this.icon)}" part="icon" ?show-tooltip=${this.showIconTooltip}></ui5-icon>`;
}
const rI = "undefined" == typeof document, sI = { get userAgent() {
  return rI ? "" : navigator.userAgent;
}, get touch() {
  return !rI && ("ontouchstart" in window || navigator.maxTouchPoints > 0);
}, get ie() {
  return !rI && /(msie|trident)/i.test(sI.userAgent);
}, get chrome() {
  return !rI && (!sI.ie && /(Chrome|CriOS)/.test(sI.userAgent));
}, get firefox() {
  return !rI && /Firefox/.test(sI.userAgent);
}, get safari() {
  return !rI && (!sI.ie && !sI.chrome && /(Version|PhantomJS)\/(\d+\.\d+).*Safari/.test(sI.userAgent));
}, get webkit() {
  return !rI && (!sI.ie && /webkit/.test(sI.userAgent));
}, get windows() {
  return !rI && -1 !== navigator.platform.indexOf("Win");
}, get iOS() {
  return !rI && (!!navigator.platform.match(/iPhone|iPad|iPod/) || !(!sI.userAgent.match(/Mac/) || !("ontouchend" in document)));
}, get android() {
  return !rI && (!sI.windows && /Android/.test(sI.userAgent));
}, get androidPhone() {
  return !rI && (sI.android && /(?=android)(?=.*mobile)/i.test(sI.userAgent));
}, get ipad() {
  return !rI && (/ipad/i.test(sI.userAgent) || /Macintosh/i.test(sI.userAgent) && "ontouchend" in document);
} };
let aI, lI, cI;
const hI = () => {
  if (rI)
    return false;
  if (!sI.windows)
    return false;
  if (void 0 === aI) {
    const e3 = sI.userAgent.match(/Windows NT (\d+).(\d)/);
    aI = e3 ? parseFloat(e3[1]) : 0;
  }
  return aI >= 8;
}, uI = () => {
  if (rI)
    return false;
  if (void 0 === cI)
    if (sI.ipad)
      cI = true;
    else {
      if (sI.touch) {
        if (hI())
          return void (cI = true);
        if (sI.chrome && sI.android)
          return void (cI = !/Mobile Safari\/[.0-9]+/.test(sI.userAgent));
        let e3 = window.devicePixelRatio ? window.devicePixelRatio : 1;
        return sI.android && (() => {
          if (rI)
            return false;
          if (!sI.webkit)
            return false;
          if (void 0 === lI) {
            const e4 = sI.userAgent.match(/(webkit)[ /]([\w.]+)/);
            lI = e4 ? parseFloat(e4[1]) : 0;
          }
          return lI >= 537.1;
        })() && (e3 = 1), void (cI = Math.min(window.screen.width / e3, window.screen.height / e3) >= 600);
      }
      cI = sI.ie && -1 !== sI.userAgent.indexOf("Touch") || sI.android && !sI.androidPhone;
    }
}, dI = () => sI.touch, pI = () => sI.safari, _I = () => (uI(), (sI.touch || hI()) && cI), gI = () => (uI(), sI.touch && !cI), mI = () => !rI && (!_I() && !gI() || hI()), fI = /* @__PURE__ */ new WeakMap(), vI = /* @__PURE__ */ new WeakMap(), AI = { attributes: true, childList: true, characterData: true, subtree: true }, bI = (e3) => {
  const t2 = e3;
  return t2.accessibleNameRef ? yI(e3) : t2.accessibleName ? t2.accessibleName : void 0;
}, yI = (e3) => {
  var _a2;
  const t2 = ((_a2 = e3.accessibleNameRef) == null ? void 0 : _a2.split(" ")) ?? [], i2 = e3.getRootNode();
  let n2 = "";
  return t2.forEach((e4, o2) => {
    const r2 = i2.querySelector(`[id='${e4}']`), s2 = `${r2 && r2.textContent ? r2.textContent : ""}`;
    s2 && (n2 += s2, o2 < t2.length - 1 && (n2 += " "));
  }), n2;
}, wI = (e3) => {
  const t2 = /* @__PURE__ */ new Set();
  xI(e3).forEach((e4) => {
    t2.add(e4);
  });
  const i2 = e3.accessibleNameRef;
  return ((i2 == null ? void 0 : i2.split(" ")) ?? []).forEach((i3) => {
    const n2 = CI(e3, i3);
    n2 && t2.add(n2);
  }), Array.from(t2);
}, xI = (e3) => {
  const t2 = e3.getRootNode().querySelectorAll(`[for="${e3.id}"]`);
  return Array.from(t2);
}, CI = (e3, t2) => e3.getRootNode().querySelector(`[id='${t2}']`), SI = (e3, t2) => {
  if (vI.has(e3))
    return;
  const i2 = wI(e3), n2 = ((e4) => (t3) => {
    if (!t3 || "property" !== t3.type || "accessibleNameRef" !== t3.name)
      return;
    const i3 = vI.get(e4);
    if (!i3)
      return;
    const n3 = i3.observedElements, o3 = wI(e4);
    n3.forEach((e5) => {
      o3.includes(e5) || II(i3, e5);
    }), o3.forEach((e5) => {
      n3.includes(e5) || (EI(i3, e5), i3.observedElements.push(e5));
    }), i3 == null ? void 0 : i3.callback();
  })(e3), o2 = { host: e3, observedElements: i2, callback: t2, invalidationCallback: n2 };
  vI.set(e3, o2), e3.attachInvalidate(n2), i2.forEach((e4) => {
    EI(o2, e4);
  }), t2();
}, EI = (e3, t2) => {
  let i2 = fI.get(t2);
  if (!i2) {
    i2 = { observer: null, callbacks: [] };
    const n2 = new MutationObserver(() => {
      i2.callbacks.forEach((e4) => {
        e4();
      });
      const n3 = document.getElementById(t2.id);
      e3.host.id === t2.getAttribute("for") || n3 || II(e3, t2);
    });
    i2.observer = n2, n2.observe(t2, AI), fI.set(t2, i2);
  }
  i2.callbacks.includes(e3.callback) || i2.callbacks.push(e3.callback);
}, II = (e3, t2) => {
  var _a2;
  const i2 = fI.get(t2);
  i2 && (i2.callbacks = i2.callbacks.filter((t3) => t3 !== e3.callback), i2.callbacks.length || ((_a2 = i2.observer) == null ? void 0 : _a2.disconnect(), fI.delete(t2))), e3.observedElements = e3.observedElements.filter((e4) => e4 !== t2);
}, TI = /* @__PURE__ */ new WeakMap(), BI = (e3, t2) => {
  TI.set(e3, t2);
}, MI = (e3) => TI.get(e3);
var kI;
!function(e3) {
  e3.Default = "Default", e3.Positive = "Positive", e3.Negative = "Negative", e3.Transparent = "Transparent", e3.Emphasized = "Emphasized", e3.Attention = "Attention";
}(kI || (kI = {}));
const RI = kI;
function PI(e3, t2, i2) {
  return i2 ? XS`<${ZS("ui5-icon", t2, i2)} class="ui5-button-icon" name="${jS(this.icon)}" accessible-role="${jS(this.iconRole)}" part="icon" ?show-tooltip=${this.showIconTooltip}></${ZS("ui5-icon", t2, i2)}>` : XS`<ui5-icon class="ui5-button-icon" name="${jS(this.icon)}" accessible-role="${jS(this.iconRole)}" part="icon" ?show-tooltip=${this.showIconTooltip}></ui5-icon>`;
}
function DI(e3, t2, i2) {
  return XS`<span class="ui5-hidden-text">${jS(this.buttonTypeText)}</span>`;
}
function LI(e3, t2, i2) {
  return YS`<title id="${jS(this._id)}-tooltip">${jS(this.effectiveAccessibleName)}</title>`;
}
function FI(e3, t2, i2) {
  return YS`${jS(this.customSvg)}`;
}
function NI(e3, t2, i2, n2, o2) {
  return YS`<path d="${jS(n2)}"></path>`;
}
function OI(e3, t2, i2) {
  return YS`${this.hasIconTooltip ? LI.call(this, e3, t2, i2) : void 0}<g role="presentation">${this.customSvg ? FI.call(this, e3, t2, i2) : void 0}${$S(this.pathData, (e4, t3) => e4._id || t3, (n2, o2) => NI.call(this, e3, t2, i2, n2, o2))}</g>`;
}
var zI;
!function(e3) {
  e3.Contrast = "Contrast", e3.Critical = "Critical", e3.Default = "Default", e3.Information = "Information", e3.Negative = "Negative", e3.Neutral = "Neutral", e3.NonInteractive = "NonInteractive", e3.Positive = "Positive";
}(zI || (zI = {}));
const UI = zI, HI = { packageName: "@ui5/webcomponents-theming", fileName: "themes/sap_fiori_3/parameters-bundle.css", content: ':root{--sapThemeMetaData-Base-baseLib:{"Path":"Base.baseLib.sap_fiori_3.css_variables","PathPattern":"/%frameworkId%/%libId%/%themeId%/%fileId%.css","Extends":["sap_base_fiori","baseTheme"],"Tags":["Fiori_3","LightColorScheme"],"FallbackThemeId":"sap_belize","Engine":{"Name":"theming-engine","Version":"1.23030.0-20230404052500+08ab7f203f968a8915a46326f198b28734934650"},"Version":{ "Build":"11.3.2.20230406131255","Source":"11.3.2"}};--sapBrandColor:#0a6ed1;--sapHighlightColor:#0854a0;--sapBaseColor:#fff;--sapShellColor:#354a5f;--sapBackgroundColor:#f7f7f7;--sapFontFamily:"72","72full",Arial,Helvetica,sans-serif;--sapFontSize:.875rem;--sapTextColor:#32363a;--sapLinkColor:#0a6ed1;--sapCompanyLogo:none;--sapBackgroundImage:none;--sapBackgroundImageOpacity:1.0;--sapBackgroundImageRepeat:false;--sapSelectedColor:#0854a0;--sapHoverColor:#ededed;--sapActiveColor:#0854a0;--sapHighlightTextColor:#fff;--sapTitleColor:#32363a;--sapNegativeColor:#b00;--sapCriticalColor:#df6e0c;--sapPositiveColor:#107e3e;--sapInformativeColor:#0a6ed1;--sapNeutralColor:#6a6d70;--sapNegativeElementColor:#b00;--sapCriticalElementColor:#df6e0c;--sapPositiveElementColor:#107e3e;--sapInformativeElementColor:#0a6ed1;--sapNeutralElementColor:#6a6d70;--sapNegativeTextColor:#b00;--sapCriticalTextColor:#b3590a;--sapPositiveTextColor:#107e3e;--sapInformativeTextColor:#0a6ed1;--sapNeutralTextColor:#6a6d70;--sapErrorColor:#b00;--sapWarningColor:#df6e0c;--sapSuccessColor:#107e3e;--sapInformationColor:#0a6ed1;--sapErrorBackground:#ffebeb;--sapWarningBackground:#fef7f1;--sapSuccessBackground:#f1fdf6;--sapInformationBackground:#f5faff;--sapNeutralBackground:#f4f4f4;--sapErrorBorderColor:#b00;--sapWarningBorderColor:#df6e0c;--sapSuccessBorderColor:#107e3e;--sapInformationBorderColor:#0a6ed1;--sapNeutralBorderColor:#6a6d70;--sapElement_LineHeight:2.75rem;--sapElement_Height:2.25rem;--sapElement_BorderWidth:.0625rem;--sapElement_BorderCornerRadius:.25rem;--sapElement_Compact_LineHeight:2rem;--sapElement_Compact_Height:1.625rem;--sapElement_Condensed_LineHeight:1.5rem;--sapElement_Condensed_Height:1.375rem;--sapContent_LineHeight:1.4;--sapContent_IconHeight:1rem;--sapContent_IconColor:#0854a0;--sapContent_ContrastIconColor:#fff;--sapContent_NonInteractiveIconColor:#6a6d70;--sapContent_MarkerIconColor:#286eb4;--sapContent_MarkerTextColor:#0e7581;--sapContent_MeasureIndicatorColor:#89919a;--sapContent_Selected_MeasureIndicatorColor:#89919a;--sapContent_Placeholderloading_Background:#ccc;--sapContent_Placeholderloading_Gradient:linear-gradient(90deg,#ccc 0%,#ccc 20%,#999 50%,#ccc 80%,#ccc);--sapContent_ImagePlaceholderBackground:#ccc;--sapContent_ImagePlaceholderForegroundColor:#fff;--sapContent_RatedColor:#d08014;--sapContent_UnratedColor:#89919a;--sapContent_BusyColor:#0854a0;--sapContent_FocusColor:#000;--sapContent_FocusStyle:dotted;--sapContent_FocusWidth:.0625rem;--sapContent_ContrastFocusColor:#fff;--sapContent_ShadowColor:#000;--sapContent_ContrastShadowColor:#fff;--sapContent_Shadow0:0 0 0 0.0625rem rgba(0,0,0,0.1),0 0.125rem 0.5rem 0 rgba(0,0,0,0.1);--sapContent_Shadow1:0 0 0 0.0625rem rgba(0,0,0,0.42),0 0.125rem 0.5rem 0 rgba(0,0,0,0.3);--sapContent_Shadow2:0 0 0 0.0625rem rgba(0,0,0,0.42),0 0.625rem 1.875rem 0 rgba(0,0,0,0.3);--sapContent_Shadow3:0 0 0 0.0625rem rgba(0,0,0,0.42),0 1.25rem 5rem 0 rgba(0,0,0,0.3);--sapContent_TextShadow:0 0 0.125rem #fff;--sapContent_ContrastTextShadow:0 0 0.0625rem rgba(0,0,0,0.7);--sapContent_HeaderShadow:0 0.125rem 0.125rem 0 rgba(0,0,0,0.05),inset 0 -0.0625rem 0 0 #d9d9d9;--sapContent_Interaction_Shadow:none;--sapContent_Selected_Shadow:none;--sapContent_Negative_Shadow:none;--sapContent_Critical_Shadow:none;--sapContent_Positive_Shadow:none;--sapContent_Informative_Shadow:none;--sapContent_Neutral_Shadow:none;--sapContent_SearchHighlightColor:#d4f7db;--sapContent_HelpColor:#3f8600;--sapContent_LabelColor:#6a6d70;--sapContent_MonospaceFontFamily:"72Mono","72Monofull",lucida console,monospace;--sapContent_MonospaceBoldFontFamily:"72Mono-Bold","72Mono-Boldfull",lucida console,monospace;--sapContent_IconFontFamily:"SAP-icons";--sapContent_DisabledTextColor:rgba(50,54,58,0.6);--sapContent_DisabledOpacity:0.4;--sapContent_ContrastTextThreshold:0.65;--sapContent_ContrastTextColor:#fff;--sapContent_ForegroundColor:#efefef;--sapContent_ForegroundBorderColor:#89919a;--sapContent_ForegroundTextColor:#32363a;--sapContent_BadgeBackground:#d04343;--sapContent_BadgeTextColor:#fff;--sapContent_DragAndDropActiveColor:#0854a0;--sapContent_Selected_TextColor:#fff;--sapContent_Selected_Background:#0854a0;--sapContent_Selected_Hover_Background:#095caf;--sapContent_Selected_ForegroundColor:#0854a0;--sapContent_ForcedColorAdjust:none;--sapContent_Illustrative_Color1:#0a6ed1;--sapContent_Illustrative_Color2:#72b5f8;--sapContent_Illustrative_Color3:#ffba10;--sapContent_Illustrative_Color4:#4a5055;--sapContent_Illustrative_Color5:#9da4aa;--sapContent_Illustrative_Color6:#c6cace;--sapContent_Illustrative_Color7:#e7e9ea;--sapContent_Illustrative_Color8:#fff;--sapContent_Illustrative_Color9:#64edd2;--sapContent_Illustrative_Color10:#e7e9ea;--sapContent_Illustrative_Color11:#f31ded;--sapContent_Illustrative_Color12:#5dc122;--sapContent_Illustrative_Color13:#4ba1f6;--sapContent_Illustrative_Color14:#298ff4;--sapContent_Illustrative_Color15:#e6a400;--sapContent_Illustrative_Color16:#085aaa;--sapContent_Illustrative_Color17:#00a5a8;--sapContent_Illustrative_Color18:#d9ddde;--sapContent_Illustrative_Color19:#ccd0d2;--sapContent_Illustrative_Color20:#bec4c6;--sapFontLightFamily:"72-Light","72-Lightfull","72","72full",Arial,Helvetica,sans-serif;--sapFontBoldFamily:"72-Bold","72-Boldfull","72","72full",Arial,Helvetica,sans-serif;--sapFontSemiboldFamily:"72-Semibold","72-Semiboldfull","72","72full",Arial,Helvetica,sans-serif;--sapFontSemiboldDuplexFamily:"72-SemiboldDuplex","72-SemiboldDuplexfull","72","72full",Arial,Helvetica,sans-serif;--sapFontBlackFamily:"72Black","72Blackfull","72","72full",Arial,Helvetica,sans-serif;--sapFontHeaderFamily:"72","72full",Arial,Helvetica,sans-serif;--sapFontSmallSize:.75rem;--sapFontLargeSize:1rem;--sapFontHeader1Size:2.25rem;--sapFontHeader2Size:1.5rem;--sapFontHeader3Size:1.25rem;--sapFontHeader4Size:1.125rem;--sapFontHeader5Size:1rem;--sapFontHeader6Size:.875rem;--sapLink_TextDecoration:none;--sapLink_Hover_Color:#0854a0;--sapLink_Hover_TextDecoration:underline;--sapLink_Active_Color:#0a6ed1;--sapLink_Active_TextDecoration:underline;--sapLink_Visited_Color:#0a6ed1;--sapLink_InvertedColor:#d3e8fd;--sapLink_SubtleColor:#074888;--sapShell_Background:#edeff0;--sapShell_BackgroundImage:linear-gradient(180deg,#dfe3e4,#f3f4f5);--sapShell_BackgroundImageOpacity:1.0;--sapShell_BackgroundImageRepeat:false;--sapShell_BorderColor:#354a5f;--sapShell_TextColor:#fff;--sapShell_InteractiveBackground:#354a5f;--sapShell_InteractiveTextColor:#d1e8ff;--sapShell_InteractiveBorderColor:#7996b4;--sapShell_GroupTitleTextColor:#32363a;--sapShell_GroupTitleTextShadow:0 0 0.125rem #fff;--sapShell_Hover_Background:#283848;--sapShell_Active_Background:#23303e;--sapShell_Active_TextColor:#fff;--sapShell_Selected_Background:#23303e;--sapShell_Selected_TextColor:#fff;--sapShell_Selected_Hover_Background:#23303e;--sapShell_Favicon:none;--sapShell_Navigation_Background:#354a5f;--sapShell_Navigation_Hover_Background:#283848;--sapShell_Navigation_SelectedColor:#d1e8ff;--sapShell_Navigation_Selected_TextColor:#d1e8ff;--sapShell_Navigation_TextColor:#fff;--sapShell_Navigation_Active_TextColor:#fff;--sapShell_Navigation_Active_Background:#23303e;--sapShell_Shadow:0 0.125rem 0.125rem 0 rgba(0,0,0,0.08),inset 0 -0.0625rem 0 0 rgba(0,0,0,0.18);--sapShell_NegativeColor:#f88;--sapShell_CriticalColor:#f8b67d;--sapShell_PositiveColor:#abe2c2;--sapShell_InformativeColor:#b1d6fb;--sapShell_NeutralColor:#d4d6d7;--sapShell_Category_1_Background:#286eb4;--sapShell_Category_1_BorderColor:#286eb4;--sapShell_Category_1_TextColor:#fff;--sapShell_Category_1_TextShadow:0 0 .0625rem rgba(0,0,0,0.7);--sapShell_Category_2_Background:#db1f77;--sapShell_Category_2_BorderColor:#db1f77;--sapShell_Category_2_TextColor:#fff;--sapShell_Category_2_TextShadow:0 0 .0625rem rgba(0,0,0,0.7);--sapShell_Category_3_Background:#d58215;--sapShell_Category_3_BorderColor:#d58215;--sapShell_Category_3_TextColor:#fff;--sapShell_Category_3_TextShadow:0 0 .0625rem rgba(0,0,0,0.7);--sapShell_Category_4_Background:#892971;--sapShell_Category_4_BorderColor:#892971;--sapShell_Category_4_TextColor:#fff;--sapShell_Category_4_TextShadow:0 0 .0625rem rgba(0,0,0,0.7);--sapShell_Category_5_Background:#bb2f2f;--sapShell_Category_5_BorderColor:#bb2f2f;--sapShell_Category_5_TextColor:#fff;--sapShell_Category_5_TextShadow:0 0 .0625rem rgba(0,0,0,0.7);--sapShell_Category_6_Background:#1193a2;--sapShell_Category_6_BorderColor:#1193a2;--sapShell_Category_6_TextColor:#fff;--sapShell_Category_6_TextShadow:0 0 .0625rem rgba(0,0,0,0.7);--sapShell_Category_7_Background:#cf5db3;--sapShell_Category_7_BorderColor:#cf5db3;--sapShell_Category_7_TextColor:#fff;--sapShell_Category_7_TextShadow:0 0 .0625rem rgba(0,0,0,0.7);--sapShell_Category_8_Background:#8b9668;--sapShell_Category_8_BorderColor:#8b9668;--sapShell_Category_8_TextColor:#fff;--sapShell_Category_8_TextShadow:0 0 .0625rem rgba(0,0,0,0.7);--sapShell_Category_9_Background:#597da1;--sapShell_Category_9_BorderColor:#597da1;--sapShell_Category_9_TextColor:#fff;--sapShell_Category_9_TextShadow:0 0 .0625rem rgba(0,0,0,0.7);--sapShell_Category_10_Background:#647987;--sapShell_Category_10_BorderColor:#647987;--sapShell_Category_10_TextColor:#fff;--sapShell_Category_10_TextShadow:0 0 .0625rem rgba(0,0,0,0.7);--sapShell_Category_11_Background:#dc5b5b;--sapShell_Category_11_BorderColor:#dc5b5b;--sapShell_Category_11_TextColor:#fff;--sapShell_Category_11_TextShadow:0 0 .0625rem rgba(0,0,0,0.7);--sapShell_Category_12_Background:#5154bd;--sapShell_Category_12_BorderColor:#5154bd;--sapShell_Category_12_TextColor:#fff;--sapShell_Category_12_TextShadow:0 0 .0625rem rgba(0,0,0,0.7);--sapShell_Category_13_Background:#bc1b66;--sapShell_Category_13_BorderColor:#bc1b66;--sapShell_Category_13_TextColor:#fff;--sapShell_Category_13_TextShadow:0 0 .0625rem rgba(0,0,0,0.7);--sapShell_Category_14_Background:#49797e;--sapShell_Category_14_BorderColor:#49797e;--sapShell_Category_14_TextColor:#fff;--sapShell_Category_14_TextShadow:0 0 .0625rem rgba(0,0,0,0.7);--sapShell_Category_15_Background:#476380;--sapShell_Category_15_BorderColor:#476380;--sapShell_Category_15_TextColor:#fff;--sapShell_Category_15_TextShadow:0 0 .0625rem rgba(0,0,0,0.7);--sapShell_Category_16_Background:#687a33;--sapShell_Category_16_BorderColor:#687a33;--sapShell_Category_16_TextColor:#fff;--sapShell_Category_16_TextShadow:0 0 .0625rem rgba(0,0,0,0.7);--sapAvatar_1_Background:#d08014;--sapAvatar_1_BorderColor:#d08014;--sapAvatar_1_TextColor:#fff;--sapAvatar_2_Background:#d04343;--sapAvatar_2_BorderColor:#d04343;--sapAvatar_2_TextColor:#fff;--sapAvatar_3_Background:#db1f77;--sapAvatar_3_BorderColor:#db1f77;--sapAvatar_3_TextColor:#fff;--sapAvatar_4_Background:#c0399f;--sapAvatar_4_BorderColor:#c0399f;--sapAvatar_4_TextColor:#fff;--sapAvatar_5_Background:#6367de;--sapAvatar_5_BorderColor:#6367de;--sapAvatar_5_TextColor:#fff;--sapAvatar_6_Background:#286eb4;--sapAvatar_6_BorderColor:#286eb4;--sapAvatar_6_TextColor:#fff;--sapAvatar_7_Background:#0f828f;--sapAvatar_7_BorderColor:#0f828f;--sapAvatar_7_TextColor:#fff;--sapAvatar_8_Background:#7ca10c;--sapAvatar_8_BorderColor:#7ca10c;--sapAvatar_8_TextColor:#fff;--sapAvatar_9_Background:#925ace;--sapAvatar_9_BorderColor:#925ace;--sapAvatar_9_TextColor:#fff;--sapAvatar_10_Background:#647987;--sapAvatar_10_BorderColor:#647987;--sapAvatar_10_TextColor:#fff;--sapButton_Background:#fff;--sapButton_BorderColor:#0854a0;--sapButton_BorderWidth:.0625rem;--sapButton_BorderCornerRadius:.25rem;--sapButton_TextColor:#0854a0;--sapButton_Hover_Background:#ebf5fe;--sapButton_Hover_BorderColor:#0854a0;--sapButton_Hover_TextColor:#0854a0;--sapButton_IconColor:#0854a0;--sapButton_Active_Background:#0854a0;--sapButton_Active_BorderColor:#0854a0;--sapButton_Active_TextColor:#fff;--sapButton_Emphasized_Background:#0a6ed1;--sapButton_Emphasized_BorderColor:#0a6ed1;--sapButton_Emphasized_TextColor:#fff;--sapButton_Emphasized_Hover_Background:#085caf;--sapButton_Emphasized_Hover_BorderColor:#085caf;--sapButton_Emphasized_Hover_TextColor:#fff;--sapButton_Emphasized_Active_Background:#0854a0;--sapButton_Emphasized_Active_BorderColor:#0854a0;--sapButton_Emphasized_Active_TextColor:#fff;--sapButton_Emphasized_TextShadow:transparent;--sapButton_Emphasized_FontWeight:bold;--sapButton_Reject_Background:#fff;--sapButton_Reject_BorderColor:#b00;--sapButton_Reject_TextColor:#b00;--sapButton_Reject_Hover_Background:#ffebeb;--sapButton_Reject_Hover_BorderColor:#b00;--sapButton_Reject_Hover_TextColor:#b00;--sapButton_Reject_Active_Background:#a20000;--sapButton_Reject_Active_BorderColor:#a20000;--sapButton_Reject_Active_TextColor:#fff;--sapButton_Reject_Selected_Background:#a20000;--sapButton_Reject_Selected_BorderColor:#a20000;--sapButton_Reject_Selected_TextColor:#fff;--sapButton_Reject_Selected_Hover_Background:#b00;--sapButton_Reject_Selected_Hover_BorderColor:#b00;--sapButton_Accept_Background:#fff;--sapButton_Accept_BorderColor:#107e3e;--sapButton_Accept_TextColor:#107e3e;--sapButton_Accept_Hover_Background:#f1fdf6;--sapButton_Accept_Hover_BorderColor:#107e3e;--sapButton_Accept_Hover_TextColor:#107e3e;--sapButton_Accept_Active_Background:#0d6733;--sapButton_Accept_Active_BorderColor:#0d6733;--sapButton_Accept_Active_TextColor:#fff;--sapButton_Accept_Selected_Background:#0d6733;--sapButton_Accept_Selected_BorderColor:#0d6733;--sapButton_Accept_Selected_TextColor:#fff;--sapButton_Accept_Selected_Hover_Background:#107e3e;--sapButton_Accept_Selected_Hover_BorderColor:#107e3e;--sapButton_Lite_Background:transparent;--sapButton_Lite_BorderColor:transparent;--sapButton_Lite_TextColor:#0854a0;--sapButton_Lite_Hover_Background:#ebf5fe;--sapButton_Lite_Hover_BorderColor:#0854a0;--sapButton_Lite_Hover_TextColor:#0854a0;--sapButton_Lite_Active_Background:#0854a0;--sapButton_Lite_Active_BorderColor:#0854a0;--sapButton_Selected_Background:#0854a0;--sapButton_Selected_BorderColor:#0854a0;--sapButton_Selected_TextColor:#fff;--sapButton_Selected_Hover_Background:#095caf;--sapButton_Selected_Hover_BorderColor:#095caf;--sapButton_Attention_Background:#fff;--sapButton_Attention_BorderColor:#df6e0c;--sapButton_Attention_TextColor:#32363a;--sapButton_Attention_Hover_Background:#fef7f1;--sapButton_Attention_Hover_BorderColor:#df6e0c;--sapButton_Attention_Hover_TextColor:#32363a;--sapButton_Attention_Active_Background:#f3801c;--sapButton_Attention_Active_BorderColor:#f3801c;--sapButton_Attention_Active_TextColor:#fff;--sapButton_Attention_Selected_Background:#f3801c;--sapButton_Attention_Selected_BorderColor:#f3801c;--sapButton_Attention_Selected_TextColor:#fff;--sapButton_Attention_Selected_Hover_Background:#f48e34;--sapButton_Attention_Selected_Hover_BorderColor:#f48e34;--sapButton_Negative_Background:#b00;--sapButton_Negative_BorderColor:#b00;--sapButton_Negative_TextColor:#fff;--sapButton_Negative_Hover_Background:#970000;--sapButton_Negative_Hover_BorderColor:#970000;--sapButton_Negative_Hover_TextColor:#fff;--sapButton_Negative_Active_Background:#800;--sapButton_Negative_Active_BorderColor:#800;--sapButton_Negative_Active_TextColor:#fff;--sapButton_Critical_Background:#df6e0c;--sapButton_Critical_BorderColor:#df6e0c;--sapButton_Critical_TextColor:#fff;--sapButton_Critical_Hover_Background:#f3801c;--sapButton_Critical_Hover_BorderColor:#f3801c;--sapButton_Critical_Hover_TextColor:#fff;--sapButton_Critical_Active_Background:#f5933e;--sapButton_Critical_Active_BorderColor:#f5933e;--sapButton_Critical_Active_TextColor:#fff;--sapButton_Success_Background:#107e3e;--sapButton_Success_BorderColor:#107e3e;--sapButton_Success_TextColor:#fff;--sapButton_Success_Hover_Background:#0c5e2e;--sapButton_Success_Hover_BorderColor:#0c5e2e;--sapButton_Success_Hover_TextColor:#fff;--sapButton_Success_Active_Background:#0a5128;--sapButton_Success_Active_BorderColor:#0a5128;--sapButton_Success_Active_TextColor:#fff;--sapButton_Information_Background:#0a6ed1;--sapButton_Information_BorderColor:#0a6ed1;--sapButton_Information_TextColor:#fff;--sapButton_Information_Hover_Background:#0961b9;--sapButton_Information_Hover_BorderColor:#0961b9;--sapButton_Information_Hover_TextColor:#fff;--sapButton_Information_Active_Background:#0854a0;--sapButton_Information_Active_BorderColor:#0854a0;--sapButton_Information_Active_TextColor:#fff;--sapButton_Neutral_Background:#6a6d70;--sapButton_Neutral_BorderColor:#6a6d70;--sapButton_Neutral_TextColor:#fff;--sapButton_Neutral_Hover_Background:#595b5e;--sapButton_Neutral_Hover_BorderColor:#595b5e;--sapButton_Neutral_Hover_TextColor:#fff;--sapButton_Neutral_Active_Background:#515456;--sapButton_Neutral_Active_BorderColor:#515456;--sapButton_Neutral_Active_TextColor:#fff;--sapButton_Track_Background:#ededed;--sapButton_Track_BorderColor:#89919a;--sapButton_Track_TextColor:#32363a;--sapButton_Track_Hover_Background:#ededed;--sapButton_Track_Hover_BorderColor:#0854a0;--sapButton_Track_Selected_Background:#ebf5fe;--sapButton_Track_Selected_BorderColor:#0854a0;--sapButton_Track_Selected_TextColor:#32363a;--sapButton_Track_Selected_Hover_Background:#ebf5fe;--sapButton_Track_Selected_Hover_BorderColor:#095caf;--sapButton_Handle_Background:#fff;--sapButton_Handle_BorderColor:#89919a;--sapButton_Handle_TextColor:#32363a;--sapButton_Handle_Hover_Background:#ebf5fe;--sapButton_Handle_Hover_BorderColor:#0854a0;--sapButton_Handle_Selected_Background:#0854a0;--sapButton_Handle_Selected_BorderColor:#0854a0;--sapButton_Handle_Selected_TextColor:#fff;--sapButton_Handle_Selected_Hover_Background:#095caf;--sapButton_Handle_Selected_Hover_BorderColor:#095caf;--sapButton_Track_Negative_Background:#ffebeb;--sapButton_Track_Negative_BorderColor:#b00;--sapButton_Track_Negative_TextColor:#b00;--sapButton_Track_Negative_Hover_Background:#ffebeb;--sapButton_Track_Negative_Hover_BorderColor:#b00;--sapButton_Handle_Negative_Background:#fff;--sapButton_Handle_Negative_BorderColor:#b00;--sapButton_Handle_Negative_TextColor:#b00;--sapButton_Handle_Negative_Hover_Background:#ffebeb;--sapButton_Handle_Negative_Hover_BorderColor:#b00;--sapButton_Track_Positive_Background:#f1fdf6;--sapButton_Track_Positive_BorderColor:#107e3e;--sapButton_Track_Positive_TextColor:#107e3e;--sapButton_Track_Positive_Hover_Background:#f1fdf6;--sapButton_Track_Positive_Hover_BorderColor:#107e3e;--sapButton_Handle_Positive_Background:#fff;--sapButton_Handle_Positive_BorderColor:#107e3e;--sapButton_Handle_Positive_TextColor:#107e3e;--sapButton_Handle_Positive_Hover_Background:#f1fdf6;--sapButton_Handle_Positive_Hover_BorderColor:#107e3e;--sapButton_TokenBackground:#fafafa;--sapButton_TokenBorderColor:#c2c2c2;--sapField_Background:#fff;--sapField_BackgroundStyle:none;--sapField_TextColor:#32363a;--sapField_PlaceholderTextColor:#74777a;--sapField_BorderColor:#89919a;--sapField_HelpBackground:#fff;--sapField_BorderWidth:.0625rem;--sapField_BorderStyle:solid;--sapField_BorderCornerRadius:.125rem;--sapField_Shadow:none;--sapField_Hover_Background:#fff;--sapField_Hover_BackgroundStyle:none;--sapField_Hover_BorderColor:#0854a0;--sapField_Hover_HelpBackground:#ebf5fe;--sapField_Hover_Shadow:none;--sapField_Hover_InvalidShadow:none;--sapField_Hover_WarningShadow:none;--sapField_Hover_SuccessShadow:none;--sapField_Hover_InformationShadow:none;--sapField_Active_BorderColor:#0854a0;--sapField_Focus_Background:#fff;--sapField_Focus_BorderColor:#89919a;--sapField_Focus_HelpBackground:#fff;--sapField_ReadOnly_Background:hsla(0,0%,94.9%,0.5);--sapField_ReadOnly_BackgroundStyle:none;--sapField_ReadOnly_BorderColor:#89919a;--sapField_ReadOnly_BorderStyle:solid;--sapField_ReadOnly_HelpBackground:hsla(0,0%,94.9%,0.5);--sapField_RequiredColor:#ce3b3b;--sapField_InvalidColor:#b00;--sapField_InvalidBackground:#fff;--sapField_InvalidBackgroundStyle:none;--sapField_InvalidBorderWidth:.125rem;--sapField_InvalidBorderStyle:solid;--sapField_InvalidShadow:none;--sapField_WarningColor:#df6e0c;--sapField_WarningBackground:#fff;--sapField_WarningBackgroundStyle:none;--sapField_WarningBorderWidth:.125rem;--sapField_WarningBorderStyle:solid;--sapField_WarningShadow:none;--sapField_SuccessColor:#107e3e;--sapField_SuccessBackground:#fff;--sapField_SuccessBackgroundStyle:none;--sapField_SuccessBorderWidth:.0625rem;--sapField_SuccessBorderStyle:solid;--sapField_SuccessShadow:none;--sapField_InformationColor:#0a6ed1;--sapField_InformationBackground:#fff;--sapField_InformationBackgroundStyle:none;--sapField_InformationBorderWidth:.125rem;--sapField_InformationBorderStyle:solid;--sapField_InformationShadow:none;--sapGroup_TitleBackground:transparent;--sapGroup_TitleBorderColor:#d9d9d9;--sapGroup_TitleTextColor:#32363a;--sapGroup_Title_FontSize:1.125rem;--sapGroup_ContentBackground:#fff;--sapGroup_ContentBorderColor:#d9d9d9;--sapGroup_BorderWidth:.0625rem;--sapGroup_BorderCornerRadius:0;--sapGroup_FooterBackground:transparent;--sapToolbar_Background:transparent;--sapToolbar_SeparatorColor:#d9d9d9;--sapList_HeaderBackground:#f2f2f2;--sapList_HeaderBorderColor:#e5e5e5;--sapList_HeaderTextColor:#32363a;--sapList_BorderColor:#e5e5e5;--sapList_BorderWidth:.0625rem;--sapList_TextColor:#32363a;--sapList_Active_TextColor:#fff;--sapList_Active_Background:#0854a0;--sapList_SelectionBackgroundColor:#e5f0fa;--sapList_SelectionBorderColor:#0854a0;--sapList_Hover_SelectionBackground:#d8e9f8;--sapList_Background:#fff;--sapList_Hover_Background:#f5f5f5;--sapList_AlternatingBackground:#f2f2f2;--sapList_GroupHeaderBackground:#fff;--sapList_GroupHeaderBorderColor:#d9d9d9;--sapList_GroupHeaderTextColor:#32363a;--sapList_TableGroupHeaderBackground:#efefef;--sapList_TableGroupHeaderBorderColor:#d9d9d9;--sapList_TableGroupHeaderTextColor:#32363a;--sapList_FooterBackground:#fafafa;--sapList_FooterTextColor:#32363a;--sapList_TableFooterBorder:#d9d9d9;--sapList_TableFixedBorderColor:#8c8c8c;--sapMessage_ErrorBorderColor:#b00;--sapMessage_WarningBorderColor:#df6e0c;--sapMessage_SuccessBorderColor:#107e3e;--sapMessage_InformationBorderColor:#0a6ed1;--sapPopover_BorderCornerRadius:.25rem;--sapProgress_Background:#fff;--sapProgress_BorderColor:#89919a;--sapProgress_TextColor:#32363a;--sapProgress_FontSize:.75rem;--sapProgress_NegativeBackground:#fff;--sapProgress_NegativeBorderColor:#89919a;--sapProgress_NegativeTextColor:#32363a;--sapProgress_CriticalBackground:#fff;--sapProgress_CriticalBorderColor:#89919a;--sapProgress_CriticalTextColor:#32363a;--sapProgress_PositiveBackground:#fff;--sapProgress_PositiveBorderColor:#89919a;--sapProgress_PositiveTextColor:#32363a;--sapProgress_InformationBackground:#fff;--sapProgress_InformationBorderColor:#89919a;--sapProgress_InformationTextColor:#32363a;--sapProgress_Value_Background:#6a6d70;--sapProgress_Value_BorderColor:#89919a;--sapProgress_Value_TextColor:#32363a;--sapProgress_Value_NegativeBackground:#b00;--sapProgress_Value_NegativeBorderColor:#fff;--sapProgress_Value_NegativeTextColor:#32363a;--sapProgress_Value_CriticalBackground:#df6e0c;--sapProgress_Value_CriticalBorderColor:#fff;--sapProgress_Value_CriticalTextColor:#32363a;--sapProgress_Value_PositiveBackground:#107e3e;--sapProgress_Value_PositiveBorderColor:#fff;--sapProgress_Value_PositiveTextColor:#32363a;--sapProgress_Value_InformationBackground:#0a6ed1;--sapProgress_Value_InformationBorderColor:#fff;--sapProgress_Value_InformationTextColor:#32363a;--sapScrollBar_FaceColor:#949494;--sapScrollBar_TrackColor:#fff;--sapScrollBar_BorderColor:#949494;--sapScrollBar_SymbolColor:#0854a0;--sapScrollBar_Dimension:.75rem;--sapScrollBar_Hover_FaceColor:#8c8c8c;--sapSlider_Background:#89919a;--sapSlider_BorderColor:#89919a;--sapSlider_Selected_Background:#0854a0;--sapSlider_Selected_BorderColor:#0854a0;--sapSlider_HandleBackground:#fff;--sapSlider_HandleBorderColor:#89919a;--sapSlider_RangeHandleBackground:transparent;--sapSlider_Hover_HandleBackground:#ebf5fe;--sapSlider_Hover_HandleBorderColor:#0854a0;--sapSlider_Hover_RangeHandleBackground:#ebf5fe;--sapSlider_Active_HandleBackground:#0854a0;--sapSlider_Active_HandleBorderColor:#0854a0;--sapSlider_Active_RangeHandleBackground:transparent;--sapPageHeader_Background:#fff;--sapPageHeader_BorderColor:#d9d9d9;--sapPageHeader_TextColor:#32363a;--sapPageFooter_Background:#fff;--sapPageFooter_BorderColor:#d9d9d9;--sapPageFooter_TextColor:#32363a;--sapInfobar_Background:#0f828f;--sapInfobar_Hover_Background:#0e7581;--sapInfobar_Active_Background:#0a545c;--sapInfobar_NonInteractive_Background:#e6e6e6;--sapInfobar_TextColor:#fff;--sapObjectHeader_Background:#fff;--sapObjectHeader_Hover_Background:#f5f5f5;--sapObjectHeader_BorderColor:#d9d9d9;--sapObjectHeader_Title_TextColor:#32363a;--sapObjectHeader_Title_FontSize:1.25rem;--sapObjectHeader_Title_SnappedFontSize:1.25rem;--sapObjectHeader_Title_FontFamily:"72","72full",Arial,Helvetica,sans-serif;--sapObjectHeader_Subtitle_TextColor:#6a6d70;--sapBlockLayer_Background:#000;--sapTile_Background:#fff;--sapTile_Hover_Background:#f5f5f5;--sapTile_Active_Background:#f5f5f5;--sapTile_BorderColor:transparent;--sapTile_BorderCornerRadius:.25rem;--sapTile_TitleTextColor:#32363a;--sapTile_TextColor:#6a6d70;--sapTile_IconColor:#5a7da0;--sapTile_SeparatorColor:#ccc;--sapTile_Interactive_BorderColor:#b3b3b3;--sapTile_OverlayBackground:rgba(0,0,0,0.8);--sapTile_OverlayForegroundColor:#fff;--sapAccentColor1:#d08014;--sapAccentColor2:#d04343;--sapAccentColor3:#db1f77;--sapAccentColor4:#c0399f;--sapAccentColor5:#6367de;--sapAccentColor6:#286eb4;--sapAccentColor7:#0f828f;--sapAccentColor8:#7ca10c;--sapAccentColor9:#925ace;--sapAccentColor10:#647987;--sapAccentBackgroundColor1:#fff3b8;--sapAccentBackgroundColor2:#ffd0e7;--sapAccentBackgroundColor3:#fff0fa;--sapAccentBackgroundColor4:#ffdcf3;--sapAccentBackgroundColor5:#ded3ff;--sapAccentBackgroundColor6:#d1efff;--sapAccentBackgroundColor7:#c2fcee;--sapAccentBackgroundColor8:#ebf5cb;--sapAccentBackgroundColor9:#dafdf5;--sapAccentBackgroundColor10:#eaecee;--sapIndicationColor_1:#800;--sapIndicationColor_1_Background:#800;--sapIndicationColor_1_BorderColor:#800;--sapIndicationColor_1_TextColor:#fff;--sapIndicationColor_1_Hover_Background:#6f0000;--sapIndicationColor_1_Active_Background:#500;--sapIndicationColor_1_Active_BorderColor:#800;--sapIndicationColor_1_Active_TextColor:#fff;--sapIndicationColor_1_Selected_Background:#500;--sapIndicationColor_1_Selected_BorderColor:#800;--sapIndicationColor_1_Selected_TextColor:#fff;--sapIndicationColor_1b:#fb9d9d;--sapIndicationColor_1b_BorderColor:#fb9d9d;--sapIndicationColor_1b_Hover_Background:#fa8585;--sapIndicationColor_2:#b00;--sapIndicationColor_2_Background:#b00;--sapIndicationColor_2_BorderColor:#b00;--sapIndicationColor_2_TextColor:#fff;--sapIndicationColor_2_Hover_Background:#a20000;--sapIndicationColor_2_Active_Background:#800;--sapIndicationColor_2_Active_BorderColor:#b00;--sapIndicationColor_2_Active_TextColor:#fff;--sapIndicationColor_2_Selected_Background:#800;--sapIndicationColor_2_Selected_BorderColor:#b00;--sapIndicationColor_2_Selected_TextColor:#fff;--sapIndicationColor_2b:#fcc4c4;--sapIndicationColor_2b_BorderColor:#fcc4c4;--sapIndicationColor_2b_Hover_Background:#fbacac;--sapIndicationColor_3:#df6e0c;--sapIndicationColor_3_Background:#df6e0c;--sapIndicationColor_3_BorderColor:#df6e0c;--sapIndicationColor_3_TextColor:#fff;--sapIndicationColor_3_Hover_Background:#d0670b;--sapIndicationColor_3_Active_Background:#c2600a;--sapIndicationColor_3_Active_BorderColor:#df6e0c;--sapIndicationColor_3_Active_TextColor:#fff;--sapIndicationColor_3_Selected_Background:#c2600a;--sapIndicationColor_3_Selected_BorderColor:#df6e0c;--sapIndicationColor_3_Selected_TextColor:#fff;--sapIndicationColor_3b:#fff2c0;--sapIndicationColor_3b_BorderColor:#fff2c0;--sapIndicationColor_3b_Hover_Background:#ffeda6;--sapIndicationColor_4:#107e3e;--sapIndicationColor_4_Background:#107e3e;--sapIndicationColor_4_BorderColor:#107e3e;--sapIndicationColor_4_TextColor:#fff;--sapIndicationColor_4_Hover_Background:#0d6733;--sapIndicationColor_4_Active_Background:#0a5128;--sapIndicationColor_4_Active_BorderColor:#107e3e;--sapIndicationColor_4_Active_TextColor:#fff;--sapIndicationColor_4_Selected_Background:#0a5128;--sapIndicationColor_4_Selected_BorderColor:#107e3e;--sapIndicationColor_4_Selected_TextColor:#fff;--sapIndicationColor_4b:#bae8bc;--sapIndicationColor_4b_BorderColor:#bae8bc;--sapIndicationColor_4b_Hover_Background:#a7e2a9;--sapIndicationColor_5:#0a6ed1;--sapIndicationColor_5_Background:#0a6ed1;--sapIndicationColor_5_BorderColor:#0a6ed1;--sapIndicationColor_5_TextColor:#fff;--sapIndicationColor_5_Hover_Background:#0961b9;--sapIndicationColor_5_Active_Background:#0854a0;--sapIndicationColor_5_Active_BorderColor:#0a6ed1;--sapIndicationColor_5_Active_TextColor:#fff;--sapIndicationColor_5_Selected_Background:#0854a0;--sapIndicationColor_5_Selected_BorderColor:#0a6ed1;--sapIndicationColor_5_Selected_TextColor:#fff;--sapIndicationColor_5b:#d3effd;--sapIndicationColor_5b_BorderColor:#d3effd;--sapIndicationColor_5b_Hover_Background:#bbe6fc;--sapIndicationColor_6:#0f828f;--sapIndicationColor_6_Background:#0f828f;--sapIndicationColor_6_BorderColor:#0f828f;--sapIndicationColor_6_TextColor:#fff;--sapIndicationColor_6_Hover_Background:#0d6d78;--sapIndicationColor_6_Active_Background:#0a5861;--sapIndicationColor_6_Active_BorderColor:#0f828f;--sapIndicationColor_6_Active_TextColor:#fff;--sapIndicationColor_6_Selected_Background:#0a5861;--sapIndicationColor_6_Selected_BorderColor:#0f828f;--sapIndicationColor_6_Selected_TextColor:#fff;--sapIndicationColor_6b:#cdf5ec;--sapIndicationColor_6b_BorderColor:#cdf5ec;--sapIndicationColor_6b_Hover_Background:#b8f1e4;--sapIndicationColor_7:#925ace;--sapIndicationColor_7_Background:#925ace;--sapIndicationColor_7_BorderColor:#925ace;--sapIndicationColor_7_TextColor:#fff;--sapIndicationColor_7_Hover_Background:#8546c8;--sapIndicationColor_7_Active_Background:#7838bd;--sapIndicationColor_7_Active_BorderColor:#925ace;--sapIndicationColor_7_Active_TextColor:#fff;--sapIndicationColor_7_Selected_Background:#7838bd;--sapIndicationColor_7_Selected_BorderColor:#925ace;--sapIndicationColor_7_Selected_TextColor:#fff;--sapIndicationColor_7b:#e2dbff;--sapIndicationColor_7b_BorderColor:#e2dbff;--sapIndicationColor_7b_Hover_Background:#cdc2ff;--sapIndicationColor_8:#c0399f;--sapIndicationColor_8_Background:#c0399f;--sapIndicationColor_8_BorderColor:#c0399f;--sapIndicationColor_8_TextColor:#fff;--sapIndicationColor_8_Hover_Background:#ac338f;--sapIndicationColor_8_Active_Background:#992d7e;--sapIndicationColor_8_Active_BorderColor:#c0399f;--sapIndicationColor_8_Active_TextColor:#fff;--sapIndicationColor_8_Selected_Background:#992d7e;--sapIndicationColor_8_Selected_BorderColor:#c0399f;--sapIndicationColor_8_Selected_TextColor:#fff;--sapIndicationColor_8b:#f8d6ff;--sapIndicationColor_8b_BorderColor:#f8d6ff;--sapIndicationColor_8b_Hover_Background:#f4bdff;--sapIndicationColor_9:#1d2d3e;--sapIndicationColor_9_Background:#1d2d3e;--sapIndicationColor_9_BorderColor:#1d2d3e;--sapIndicationColor_9_TextColor:#fff;--sapIndicationColor_9_Hover_Background:#15202d;--sapIndicationColor_9_Active_Background:#0d141b;--sapIndicationColor_9_Active_BorderColor:#1d2d3e;--sapIndicationColor_9_Active_TextColor:#fff;--sapIndicationColor_9_Selected_Background:#0d141b;--sapIndicationColor_9_Selected_BorderColor:#1d2d3e;--sapIndicationColor_9_Selected_TextColor:#fff;--sapIndicationColor_9b:#fff;--sapIndicationColor_9b_BorderColor:#d9d9d9;--sapIndicationColor_9b_Hover_Background:#f2f2f2;--sapIndicationColor_10:#45484a;--sapIndicationColor_10_Background:#45484a;--sapIndicationColor_10_BorderColor:#45484a;--sapIndicationColor_10_TextColor:#fff;--sapIndicationColor_10_Hover_Background:#393b3d;--sapIndicationColor_10_Active_Background:#2c2e30;--sapIndicationColor_10_Active_BorderColor:#45484a;--sapIndicationColor_10_Active_TextColor:#fff;--sapIndicationColor_10_Selected_Background:#2c2e30;--sapIndicationColor_10_Selected_BorderColor:#45484a;--sapIndicationColor_10_Selected_TextColor:#fff;--sapIndicationColor_10b:#eaecee;--sapIndicationColor_10b_BorderColor:#eaecee;--sapIndicationColor_10b_Hover_Background:#dcdfe3;--sapLegend_WorkingBackground:#fafafa;--sapLegend_NonWorkingBackground:#dedede;--sapLegend_CurrentDateTime:#c0399f;--sapLegendColor1:#d58215;--sapLegendColor2:#dc5b5b;--sapLegendColor3:#db1f77;--sapLegendColor4:#9b3b3b;--sapLegendColor5:#cf5db3;--sapLegendColor6:#286eb4;--sapLegendColor7:#1193a2;--sapLegendColor8:#8b9668;--sapLegendColor9:#647987;--sapLegendColor10:#892971;--sapLegendColor11:#725a3a;--sapLegendColor12:#bb2f2f;--sapLegendColor13:#bc1b66;--sapLegendColor14:#8b714f;--sapLegendColor15:#606190;--sapLegendColor16:#597da1;--sapLegendColor17:#49797e;--sapLegendColor18:#687a33;--sapLegendColor19:#295989;--sapLegendColor20:#5154bd;--sapLegendBackgroundColor1:#fdf3e7;--sapLegendBackgroundColor2:#faeaea;--sapLegendBackgroundColor3:#fce9f2;--sapLegendBackgroundColor4:#f8ecec;--sapLegendBackgroundColor5:#f9ebf5;--sapLegendBackgroundColor6:#ebf3fa;--sapLegendBackgroundColor7:#e8fbfd;--sapLegendBackgroundColor8:#f3f4ef;--sapLegendBackgroundColor9:#f1f3f4;--sapLegendBackgroundColor10:#f9ebf6;--sapLegendBackgroundColor11:#f6f2ed;--sapLegendBackgroundColor12:#faeaea;--sapLegendBackgroundColor13:#fce9f2;--sapLegendBackgroundColor14:#f5f2ee;--sapLegendBackgroundColor15:#f0f0f5;--sapLegendBackgroundColor16:#eff2f6;--sapLegendBackgroundColor17:#eff5f6;--sapLegendBackgroundColor18:#f5f7ed;--sapLegendBackgroundColor19:#ebf2f9;--sapLegendBackgroundColor20:#ecedf8;--sapChart_OrderedColor_1:#438cd5;--sapChart_OrderedColor_2:#e66729;--sapChart_OrderedColor_3:#16976c;--sapChart_OrderedColor_4:#ed4a7b;--sapChart_OrderedColor_5:#945ecf;--sapChart_OrderedColor_6:#1193a2;--sapChart_OrderedColor_7:#525df4;--sapChart_OrderedColor_8:#bf399e;--sapChart_OrderedColor_9:#6c8893;--sapChart_OrderedColor_10:#ed5f5f;--sapChart_OrderedColor_11:#2f6497;--sapChart_Bad:#dc0d0e;--sapChart_Critical:#cb7d0c;--sapChart_Good:#3c9d57;--sapChart_Neutral:#848f94;--sapChart_Sequence_1:#438cd5;--sapChart_Sequence_2:#e66729;--sapChart_Sequence_3:#16976c;--sapChart_Sequence_4:#ed4a7b;--sapChart_Sequence_5:#945ecf;--sapChart_Sequence_6:#1193a2;--sapChart_Sequence_7:#525df4;--sapChart_Sequence_8:#bf399e;--sapChart_Sequence_9:#6c8893;--sapChart_Sequence_10:#ed5f5f;--sapChart_Sequence_11:#2f6497;--sapChart_Sequence_Neutral:#848f94;}' }, QI = { packageName: "@ui5/webcomponents", fileName: "themes/sap_fiori_3/parameters-bundle.css", content: ':root{--_ui5_calendar_height:24.5rem;--_ui5_calendar_width:20rem;--_ui5_calendar_padding:1rem;--_ui5_calendar_left_right_padding:0.5rem;--_ui5_calendar_top_bottom_padding:1rem;--_ui5_calendar_header_height:3rem;--_ui5_calendar_header_arrow_button_width:2.5rem;--_ui5_calendar_header_padding:0.25rem 0;--_ui5_checkbox_root_side_padding:.6875rem;--_ui5_checkbox_icon_size:1rem;--_ui5_checkbox_partially_icon_size:.75rem;--_ui5_custom_list_item_rb_min_width:2.75rem;--_ui5_day_picker_item_width:2.25rem;--_ui5_day_picker_item_height:2.875rem;--_ui5_day_picker_empty_height:3rem;--_ui5_day_picker_item_justify_content:space-between;--_ui5_color-palette-item-height:1.75rem;--_ui5_color-palette-item-hover-height:2.375rem;--_ui5_color-palette-item-margin:calc(var(--_ui5_color-palette-item-hover-height)/2 - var(--_ui5_color-palette-item-height)/2);--_ui5_color-palette-row-width:12rem;--_ui5_color-palette-swatch-container-padding:0.3125rem 0.6875rem;--_ui5_datetime_picker_width:40.0625rem;--_ui5_datetime_picker_height:25rem;--_ui5_datetime_timeview_phonemode_width:19.5rem;--_ui5_datetime_timeview_padding:1rem;--_ui5_dialog_content_min_height:2.75rem;--_ui5_dialog_footer_height:2.75rem;--_ui5_input_inner_padding:0 0.625rem;--_ui5_input_inner_padding_with_icon:0 0.25rem 0 0.625rem;--_ui5_input_inner_space_to_n_more_text:0.1875rem;--_ui5_input_value_state_icon_padding:var(--_ui5-input-icon-padding);--_ui5_list_no_data_height:3rem;--_ui5_list_item_cb_margin_right:0;--_ui5_list_item_title_size:var(--sapFontLargeSize);--_ui5_list_no_data_font_size:var(--sapFontLargeSize);--_ui5_list_item_img_size:3rem;--_ui5_list_item_img_top_margin:0.5rem;--_ui5_list_item_img_bottom_margin:0.5rem;--_ui5_list_item_img_hn_margin:0.75rem;--_ui5_list_item_dropdown_base_height:2.5rem;--_ui5_list_item_base_height:2.75rem;--_ui5_list_item_icon_size:1.125rem;--_ui5_list_item_icon_padding-inline-end:0.5rem;--_ui5_group_header_list_item_height:2.75rem;--_ui5_list_busy_row_height:3rem;--_ui5_month_picker_item_height:3rem;--_ui5_popup_default_header_height:2.75rem;--_ui5-notification-overflow-popover-padding:0.25rem 0.5rem;--_ui5_year_picker_item_height:3rem;--_ui5_tokenizer_padding:0.25rem;--_ui5_token_height:1.625rem;--_ui5_token_icon_padding:0.25rem 0.5rem;--_ui5_token_wrapper_right_padding:0.3125rem;--_ui5_tl_bubble_padding:1rem;--_ui5_tl_indicator_before_bottom:-1.625rem;--_ui5_tl_padding:1rem 1rem 1rem .5rem;--_ui5_tl_li_margin_bottom:1.625rem;--_ui5_switch_height:var(--_ui5_switch_height);--_ui5_switch_width:var(--_ui5_switch_width);--_ui5_switch_with_label_width:var(--_ui5_switch_with_label_width);--_ui5_switch_root_outline_top:var(--_ui5_switch_root_outline_top);--_ui5_switch_root_outline_bottom:var(--_ui5_switch_root_outline_bottom);--_ui5_switch_track_width:var(--_ui5_switch_track_width);--_ui5_switch_track_height:var(--_ui5_switch_track_height);--_ui5_switch_track_with_label_width:var(--_ui5_switch_track_with_label_width);--_ui5_switch_track_with_label_height:var(--_ui5_switch_track_with_label_height);--_ui5_switch_min_width:var(--_ui5_switch_min_width);--_ui5_switch_handle_height:var(--_ui5_switch_handle_height);--_ui5_switch_handle_with_label_width:var(--_ui5_switch_handle_with_label_width);--_ui5_switch_handle_width:var(--_ui5_switch_handle_width);--_ui5_switch_handle_with_label_height:var(--_ui5_switch_handle_with_label_height);--_ui5_switch_text_active_left:var(--_ui5_switch_text_active_left);--_ui5_switch_text_font_size:var(--_ui5_switch_text_font_size);--_ui5_switch_text_width:var(--_ui5_switch_text_width);--_ui5_switch_focus_width_size_horizon_exp:calc(100% + 4px);--_ui5_switch_focus_height_size_horizon_exp:calc(100% + 4px);--_ui5_switch_transform:var(--_ui5_switch_transform);--_ui5_switch_transform_with_label:var(--_ui5_switch_transform_with_label);--_ui5_switch_rtl_transform:var(--_ui5_switch_rtl_transform);--_ui5_switch_rtl_transform_with_label:var(--_ui5_switch_rtl_transform_with_label);--_ui5_tc_item_text:3rem;--_ui5_tc_item_height:4.75rem;--_ui5_tc_item_text_only_height:2.75rem;--_ui5_tc_item_text_only_with_additional_text_height:3.75rem;--_ui5_tc_item_icon_circle_size:2.75rem;--_ui5_tc_item_icon_size:1.25rem;--_ui5_tc_item_add_text_margin_top:0.375rem;--_ui5_textarea_margin:.25rem 0;--_ui5_panel_header_height:2.75rem;--_ui5_radio_button_height:2.75rem;--_ui5_radio_button_label_side_padding:.875rem;--_ui5_radio_button_focus_dist:.5rem;--_ui5_radio_button_inner_size:2.75rem;--_ui5_radio_button_svg_size:1.375rem;--_ui5_radio_button_label_width:calc(100% - 2.75rem);--_ui5_radio_button_outer_ring_padding_with_label:0 0.6875rem;--_ui5-responsive_popover_header_height:2.75rem;--ui5_side_navigation_item_height:2.75rem;--_ui5_load_more_text_height:2.75rem;--_ui5_load_more_text_font_size:var(--sapFontMediumSize);--_ui5_load_more_desc_padding:0.375rem 2rem 0.875rem 2rem;--ui5_table_header_row_height:2.75rem;--ui5_table_row_height:2.75rem;--ui5_table_focus_outline_offset:-0.125rem;--ui5_table_group_row_height:2rem;--_ui5-tree-indent-step:1.5rem;--_ui5-tree-toggle-box-width:2.75rem;--_ui5-tree-toggle-box-height:2.25rem;--_ui5-tree-toggle-icon-size:1.0625rem;--_ui5_timeline_tli_indicator_before_bottom:-1.625rem;--_ui5_timeline_tli_indicator_before_right:-1.625rem;--_ui5_timeline_tli_indicator_before_without_icon_bottom:-1.875rem;--_ui5_timeline_tli_indicator_before_without_icon_right:-1.9375rem;--_ui5_split_button_middle_separator_height:2.25rem}.sapUiSizeCompact,.ui5-content-density-compact,:root,[data-ui5-compact-size]{--_ui5_datetime_timeview_width:17rem;--_ui5_input_inner_space_to_tokenizer:0.125rem;--_ui5_list_item_selection_btn_margin_top:calc(var(--_ui5_checkbox_wrapper_padding)*-1);--_ui5_list_item_content_vertical_offset:calc(var(--_ui5_list_item_base_height)/2 - var(--_ui5_list_item_title_size)/2);--_ui5_list_buttons_left_space:0.125rem;--_ui5_token_icon_size:.75rem;--_ui5_token_wrapper_left_padding:0;--_ui5_tc_item_text_line_height:1.325rem;--_ui5_split_button_middle_separator_top:0}.sapUiSizeCompact,.ui5-content-density-compact,[data-ui5-compact-size]{--_ui5_button_base_height:1.625rem;--_ui5_button_base_padding:0.4375rem;--_ui5_button_base_min_width:2rem;--_ui5_button_icon_font_size:1rem;--_ui5_calendar_height:18rem;--_ui5_calendar_width:17.75rem;--_ui5_calendar_left_right_padding:0.25rem;--_ui5_calendar_top_bottom_padding:0.5rem;--_ui5_calendar_header_height:2rem;--_ui5_calendar_header_arrow_button_width:2rem;--_ui5_calendar_header_padding:0;--_ui5_checkbox_root_side_padding:var(--_ui5_checkbox_wrapped_focus_padding);--_ui5_checkbox_wrapped_content_margin_top:var(--_ui5_checkbox_compact_wrapped_label_margin_top);--_ui5_checkbox_wrapped_focus_left_top_bottom_position:var(--_ui5_checkbox_compact_focus_position);--_ui5_checkbox_width_height:var(--_ui5_checkbox_compact_width_height);--_ui5_checkbox_wrapper_padding:var(--_ui5_checkbox_compact_wrapper_padding);--_ui5_checkbox_focus_position:var(--_ui5_checkbox_compact_focus_position);--_ui5_checkbox_inner_width_height:var(--_ui5_checkbox_compact_inner_size);--_ui5_checkbox_icon_size:.75rem;--_ui5_checkbox_partially_icon_size:.5rem;--_ui5_color-palette-item-height:1.25rem;--_ui5_color-palette-item-focus-height:1rem;--_ui5_color-palette-item-container-sides-padding:0.1875rem;--_ui5_color-palette-item-container-rows-padding:0.8125rem;--_ui5_color-palette-item-hover-height:1.625rem;--_ui5_color-palette-item-margin:calc(var(--_ui5_color-palette-item-hover-height)/2 - var(--_ui5_color-palette-item-height)/2);--_ui5_color-palette-row-width:8.125rem;--_ui5_color-palette-swatch-container-padding:0.1875rem 0.8125rem;--_ui5_color-palette-item-hover-margin:0;--_ui5_color-palette-row-height:7.5rem;--_ui5_color-palette-button-height:2rem;--_ui5_color_picker_slider_container_margin_top:-4px;--_ui5_custom_list_item_rb_min_width:2rem;--_ui5_daypicker_weeknumbers_container_padding_top:2rem;--_ui5_day_picker_item_width:2rem;--_ui5_day_picker_item_height:2rem;--_ui5_day_picker_empty_height:2.125rem;--_ui5_day_picker_item_justify_content:flex-end;--_ui5_datetime_picker_height:17rem;--_ui5_datetime_picker_width:34.0625rem;--_ui5_datetime_timeview_phonemode_width:18.5rem;--_ui5_datetime_timeview_padding:0.5rem;--_ui5_dialog_content_min_height:2.5rem;--_ui5_dialog_footer_height:2.5rem;--_ui5_input_height:var(--sapElement_Compact_Height);--_ui5_input_inner_padding:0 0.5rem;--_ui5_input_inner_padding_with_icon:0 0.2rem 0 0.5rem;--_ui5_input_inner_space_to_n_more_text:0.125rem;--_ui5_input_icon_min_width:var(--_ui5_input_compact_min_width);--_ui5_input_icon_padding:.25rem .4375rem;--_ui5_input_error_warning_icon_padding:.1875rem .375rem .1875rem .4375rem;--_ui5_input_information_icon_padding:.1875rem .375rem .1875rem .4375rem;--_ui5_input_custom_icon_padding:.25rem .5rem;--_ui5_input_error_warning_custom_icon_padding:.1875rem .5rem;--_ui5_input_information_custom_icon_padding:.1875rem .5rem;--_ui5_input_value_state_icon_padding:.1875rem .5rem;--_ui5_menu_item_padding:0 0.75rem 0 0.5rem;--_ui5_menu_item_submenu_icon_right:0.75rem;--_ui5-notification-overflow-popover-padding:0.25rem 0.5rem;--_ui5_popup_default_header_height:2.5rem;--_ui5_textarea_margin:.1875rem 0;--_ui5_list_no_data_height:2rem;--_ui5_list_item_cb_margin_right:.5rem;--_ui5_list_item_title_size:var(--sapFontSize);--_ui5_list_item_img_top_margin:0.55rem;--_ui5_list_no_data_font_size:var(--sapFontSize);--_ui5_list_item_dropdown_base_height:2rem;--_ui5_list_item_base_height:2rem;--_ui5_list_item_icon_size:1rem;--_ui5_list_busy_row_height:2rem;--_ui5_month_picker_item_height:2rem;--_ui5_year_picker_item_height:2rem;--_ui5_panel_header_height:2.5rem;--_ui5_token_height:1.25rem;--_ui5_token_top_margin:0.125rem;--_ui5_token_bottom_margin:0.125rem;--_ui5_token_right_margin:0.25rem;--_ui5_token_left_padding:0.25rem;--_ui5_token_readonly_padding:0.25rem;--_ui5_token_focus_offset:-0.125rem;--_ui5_token_icon_padding:0.125rem 0.25rem;--_ui5_token_wrapper_right_padding:0.25rem;--_ui5_token_outline_offset:-0.125rem;--_ui5_tl_bubble_padding:.5rem;--_ui5_tl_indicator_before_bottom:-.5rem;--_ui5_tl_padding:.5rem;--_ui5_tl_li_margin_bottom:.5rem;--_ui5_wheelslider_item_width:64px;--_ui5_wheelslider_item_height:32px;--_ui5_wheelslider_height:224px;--_ui5_wheelslider_selection_frame_margin_top:calc(var(--_ui5_wheelslider_item_height)*2);--_ui5_wheelslider_arrows_visibility:visible;--_ui5_wheelslider_mobile_selection_frame_margin_top:128px;--_ui5_switch_height:var(--_ui5_switch_compact_height);--_ui5_switch_width:var(--_ui5_switch_compact_width);--_ui5_switch_with_label_width:var(--_ui5_switch_compact_with_label_width);--_ui5_switch_root_outline_top:var(--_ui5_switch_root_compact_outline_top);--_ui5_switch_root_outline_bottom:var(--_ui5_switch_root_compact_outline_bottom);--_ui5_switch_track_width:var(--_ui5_switch_track_compact_width);--_ui5_switch_track_height:var(--_ui5_switch_track_compact_height);--_ui5_switch_track_with_label_width:var(--_ui5_switch_track_with_label_compact_width);--_ui5_switch_track_with_label_height:var(--_ui5_switch_track_with_label_compact_height);--_ui5_switch_min_width:var(--_ui5_switch_compact_min_width);--_ui5_switch_handle_height:var(--_ui5_switch_handle_compact_height);--_ui5_switch_handle_with_label_width:var(--_ui5_switch_handle_with_label_compact_width);--_ui5_switch_handle_width:var(--_ui5_switch_handle_compact_width);--_ui5_switch_handle_with_label_height:var(--_ui5_switch_handle_with_label_compact_height);--_ui5_switch_text_active_left:var(--_ui5_switch_text_compact_active_left);--_ui5_switch_text_font_size:var(--_ui5_switch_text_compact_font_size);--_ui5_switch_text_width:var(--_ui5_switch_text_compact_width);--_ui5_switch_transform:var(--_ui5_switch_compact_transform);--_ui5_switch_transform_with_label:var(--_ui5_switch_compact_transform_with_label);--_ui5_switch_rtl_transform:var(--_ui5_switch_compact_rtl_transform);--_ui5_switch_rtl_transform_with_label:var(--_ui5_switch_compact_rtl_transform_with_label);--_ui5_tc_item_text:2rem;--_ui5_tc_item_add_text_margin_top:0.3125rem;--_ui5_tc_header_height:var(--_ui5_tc_header_height_compact);--_ui5_tc_item_height:4rem;--_ui5_tc_item_icon_circle_size:2rem;--_ui5_tc_item_icon_size:1rem;--_ui5_radio_button_min_width:var(--_ui5_radio_button_min_width_compact);--_ui5_radio_button_height:2rem;--_ui5_radio_button_label_side_padding:.5rem;--_ui5_radio_button_focus_dist:.375rem;--_ui5_radio_button_inner_size:2rem;--_ui5_radio_button_svg_size:1rem;--_ui5_radio_button_label_width:calc(100% - 2rem + 1px);--_ui5_radio_button_outer_ring_padding_with_label:0 0.5rem;--_ui5-responsive_popover_header_height:2.5rem;--ui5_side_navigation_item_height:2rem;--_ui5_slider_handle_height:1.25rem;--_ui5_slider_handle_width:1.25rem;--_ui5_slider_handle_top:-.5rem;--_ui5_slider_tooltip_height:1rem;--_ui5_slider_tooltip_padding:0.25rem;--_ui5_slider_progress_outline_offset:-0.625rem;--_ui5_slider_outer_height:1.3125rem;--_ui5_split_button_middle_separator_height:1.625rem;--_ui5_load_more_text_height:2.625rem;--_ui5_load_more_text_font_size:var(--sapFontSize);--_ui5_load_more_desc_padding:0 2rem 0.875rem 2rem;--ui5_table_header_row_height:2rem;--ui5_table_row_height:2rem;--_ui5-tree-indent-step:0.5rem;--_ui5-tree-toggle-box-width:2rem;--_ui5-tree-toggle-box-height:1.5rem;--_ui5-tree-toggle-icon-size:0.8125rem;--_ui5_timeline_tli_indicator_before_bottom:-0.5rem;--_ui5_timeline_tli_indicator_before_right:-0.5rem;--_ui5_timeline_tli_indicator_before_without_icon_bottom:-0.75rem;--_ui5_timeline_tli_indicator_before_without_icon_right:-0.8125rem;--_ui5_vsd_header_container:2.5rem;--_ui5_vsd_sub_header_container_height:2rem;--_ui5_vsd_header_height:4rem;--_ui5_vsd_expand_content_height:25.4375rem}:root,[dir=ltr]{--_ui5_rotation_90deg:rotate(90deg);--_ui5_rotation_minus_90deg:rotate(-90deg);--_ui5_icon_transform_scale:none;--_ui5_panel_toggle_btn_rotation:var(--_ui5_rotation_90deg);--_ui5_li_notification_group_toggle_btn_rotation:var(--_ui5_rotation_90deg);--_ui5_timeline_scroll_container_offset:0.5rem;--_ui5_popover_upward_arrow_margin:0.1875rem 0 0 0.1875rem;--_ui5_popover_right_arrow_margin:0.1875rem 0 0 -0.375rem;--_ui5_popover_downward_arrow_margin:-0.375rem 0 0 0.125rem;--_ui5_popover_left_arrow_margin:0.125rem 0 0 0.25rem;--_ui5_dialog_resize_cursor:se-resize;--_ui5_shellbar_overflow_container_float:none;--_ui5_progress_indicator_bar_border_radius:0.5rem 0 0 0.5rem;--_ui5_progress_indicator_remaining_bar_border_radius:0 0.5rem 0.5rem 0;--_ui5_menu_submenu_margin_offset:-0.25rem 0;--_ui5_menu_submenu_placement_type_left_margin_offset:0.25rem 0;--_ui5-menu_item_icon_float:right}[dir=rtl]{--_ui5_icon_transform_scale:scale(-1,1);--_ui5_panel_toggle_btn_rotation:var(--_ui5_rotation_minus_90deg);--_ui5_li_notification_group_toggle_btn_rotation:var(--_ui5_rotation_minus_90deg);--_ui5_timeline_scroll_container_offset:-0.5rem;--_ui5_popover_upward_arrow_margin:.1875rem .125rem 0 0;--_ui5_popover_right_arrow_margin:.1875rem .25rem 0 0;--_ui5_popover_downward_arrow_margin:-0.4375rem .125rem 0 0;--_ui5_popover_left_arrow_margin:.1875rem -.375rem 0 0;--_ui5_dialog_resize_cursor:sw-resize;--_ui5_shellbar_overflow_container_float:left;--_ui5_progress_indicator_bar_border_radius:0 0.5rem 0.5rem 0;--_ui5_progress_indicator_remaining_bar_border_radius:0.5rem 0 0 0.5rem;--_ui5_menu_submenu_margin_offset:0 -0.25rem;--_ui5_menu_submenu_placement_type_left_margin_offset:0 0.25rem;--_ui5-menu_item_icon_float:left}:root{--ui5-avatar-initials-color:var(--sapContent_ImagePlaceholderForegroundColor);--ui5-avatar-border-radius:.25rem;--ui5-avatar-border-radius-img-deduction:0.0625rem;--ui5-avatar-initials-border:none;--ui5-avatar-accent1:var(--sapAccentColor1);--ui5-avatar-accent2:var(--sapAccentColor2);--ui5-avatar-accent3:var(--sapAccentColor3);--ui5-avatar-accent4:var(--sapAccentColor4);--ui5-avatar-accent5:var(--sapAccentColor5);--ui5-avatar-accent6:var(--sapAccentColor6);--ui5-avatar-accent7:var(--sapAccentColor7);--ui5-avatar-accent8:var(--sapAccentColor8);--ui5-avatar-accent9:var(--sapAccentColor9);--ui5-avatar-accent10:var(--sapAccentColor10);--ui5-avatar-placeholder:var(--sapContent_ImagePlaceholderBackground);--ui5-avatar-accent1-color:var(--ui5-avatar-initials-color);--ui5-avatar-accent2-color:var(--ui5-avatar-initials-color);--ui5-avatar-accent3-color:var(--ui5-avatar-initials-color);--ui5-avatar-accent4-color:var(--ui5-avatar-initials-color);--ui5-avatar-accent5-color:var(--ui5-avatar-initials-color);--ui5-avatar-accent6-color:var(--ui5-avatar-initials-color);--ui5-avatar-accent7-color:var(--ui5-avatar-initials-color);--ui5-avatar-accent8-color:var(--ui5-avatar-initials-color);--ui5-avatar-accent9-color:var(--ui5-avatar-initials-color);--ui5-avatar-accent10-color:var(--ui5-avatar-initials-color);--ui5-avatar-placeholder-color:var(--ui5-avatar-initials-color);--ui5-avatar-accent1-border-color:var(--sapField_BorderColor);--ui5-avatar-accent2-border-color:var(--sapField_BorderColor);--ui5-avatar-accent3-border-color:var(--sapField_BorderColor);--ui5-avatar-accent4-border-color:var(--sapField_BorderColor);--ui5-avatar-accent5-border-color:var(--sapField_BorderColor);--ui5-avatar-accent6-border-color:var(--sapField_BorderColor);--ui5-avatar-accent7-border-color:var(--sapField_BorderColor);--ui5-avatar-accent8-border-color:var(--sapField_BorderColor);--ui5-avatar-accent9-border-color:var(--sapField_BorderColor);--ui5-avatar-accent10-border-color:var(--sapField_BorderColor);--ui5-avatar-placeholder-border-color:var(--sapField_BorderColor);--_ui5_avatar_outline:var(--sapContent_FocusWidth) var(--sapContent_FocusStyle) var(--sapContent_FocusColor);--_ui5_avatar_focus_offset:1px;--_ui5_avatar_focus_width:1px;--_ui5_avatar_focus_color:var(--sapContent_FocusColor);--_ui5_avatar_fontsize_XS:0.75rem;--_ui5_avatar_fontsize_M:1.625rem;--_ui5_avatar_fontsize_L:2rem;--_ui5_avatar_fontsize_XL:2.75rem;--_ui5_avatar_icon_XS:1rem;--_ui5_avatar_icon_S:1.5rem;--_ui5_avatar_icon_M:2rem;--_ui5_avatar_icon_L:2.5rem;--_ui5_avatar_icon_XL:3rem;--_ui5_avatar_fontsize_XS:1rem;--_ui5_avatar_fontsize_S:1.125rem;--_ui5_avatar_fontsize_M:1.5rem;--_ui5_avatar_fontsize_L:2.25rem;--_ui5_avatar_fontsize_XL:3rem}[ui5-avatar-group]{--_ui5_button_focused_border:none }:root{--_ui5-badge-cursor:default;--ui5-badge-color-scheme-1-background:var(--sapLegendBackgroundColor1);--ui5-badge-color-scheme-1-border:var(--sapAccentColor1);--ui5-badge-color-scheme-1-color:var(--sapTextColor);--ui5-badge-color-scheme-2-background:var(--sapLegendBackgroundColor2);--ui5-badge-color-scheme-2-border:var(--sapAccentColor2);--ui5-badge-color-scheme-2-color:var(--sapTextColor);--ui5-badge-color-scheme-3-background:var(--sapLegendBackgroundColor3);--ui5-badge-color-scheme-3-border:var(--sapAccentColor3);--ui5-badge-color-scheme-3-color:var(--sapTextColor);--ui5-badge-color-scheme-4-background:var(--sapLegendBackgroundColor5);--ui5-badge-color-scheme-4-border:var(--sapAccentColor4);--ui5-badge-color-scheme-4-color:var(--sapTextColor);--ui5-badge-color-scheme-5-background:var(--sapLegendBackgroundColor20);--ui5-badge-color-scheme-5-border:var(--sapAccentColor5);--ui5-badge-color-scheme-5-color:var(--sapTextColor);--ui5-badge-color-scheme-6-background:var(--sapLegendBackgroundColor6);--ui5-badge-color-scheme-6-border:var(--sapAccentColor6);--ui5-badge-color-scheme-6-color:var(--sapTextColor);--ui5-badge-color-scheme-7-background:var(--sapLegendBackgroundColor7);--ui5-badge-color-scheme-7-border:var(--sapAccentColor7);--ui5-badge-color-scheme-7-color:var(--sapTextColor);--ui5-badge-color-scheme-8-background:var(--sapLegendBackgroundColor18);--ui5-badge-color-scheme-8-border:var(--sapLegendColor18);--ui5-badge-color-scheme-8-color:var(--sapTextColor);--ui5-badge-color-scheme-9-background:var(--sapLegendBackgroundColor10);--ui5-badge-color-scheme-9-border:var(--sapAccentColor10);--ui5-badge-color-scheme-9-color:var(--sapTextColor);--ui5-badge-color-scheme-10-background:var(--sapLegendBackgroundColor9);--ui5-badge-color-scheme-10-border:var(--sapAccentColor9);--ui5-badge-color-scheme-10-color:var(--sapTextColor);--browser_scrollbar_border_radius:var(--sapElement_BorderCornerRadius);--browser_scrollbar_border:none;--_ui5_busy_indicator_color:var(--sapContent_IconColor);--_ui5_busy_indicator_focus_outline:var(--sapContent_FocusWidth) var(--sapContent_FocusStyle) var(--sapContent_FocusColor);--_ui5_busy_indicator_focus_border_radius:0px;--_ui5_button_focused_border:0.0625rem dotted var(--sapContent_FocusColor);--_ui5_button_focused_border_radius:0.25rem;--_ui5_button_focused_inner_border_radius:0;--_ui5_button_base_min_width:2.5rem;--_ui5_button_base_min_compact_width:2rem;--_ui5_button_base_height:2.5rem;--_ui5_button_compact_height:1.625rem;--_ui5_button_border_radius:var(--sapButton_BorderCornerRadius);--_ui5_button_base_padding:0.6875rem;--_ui5_button_compact_padding:0.4375rem;--_ui5_button_base_icon_margin:0.563rem;--_ui5_button_icon_font_size:1.375rem;--_ui5_button_outline:1px dotted var(--sapContent_FocusColor);--_ui5_button_emphasized_outline:1px dotted var(--sapContent_FocusColor);--_ui5_button_outline_offset:-0.1875rem;--_ui5_button_emphasized_font_weight:normal;--_ui5_button_text_shadow:var(--sapContent_TextShadow);--_ui5_button_focus_offset:1px;--_ui5_button_focus_width:1px;--_ui5_button_focus_color:var(--sapContent_FocusColor);--_ui5_button_focus_outline_focus_color:var(--sapContent_ContrastFocusColor);--_ui5_button_pressed_focused_border_color:var(--sapContent_ContrastFocusColor);--_ui5_button_positive_border_focus_hover_color:var(--sapContent_FocusColor);--_ui5_button_positive_focus_border_color:var(--sapButton_Accept_BorderColor);--_ui5_button_negative_focus_border_color:var(--sapButton_Reject_BorderColor);--_ui5_button_attention_focus_border_color:var(--sapButton_Negative_BorderColor);--_ui5_button_emphasized_focused_border_color:var(--sapButton_Emphasized_BorderColor);--_ui5_button_fontFamily:"72override",var(--sapFontFamily);--_ui5_button_emphasized_focused_border_before:none;--_ui5_button_emphasized_focused_border_radius:0;--_ui5_button_transparent_hover:transparent;--_ui5_button_base_min_width:2.25rem;--_ui5_button_base_height:2.25rem;--_ui5_button_base_padding:0.5625rem;--_ui5_button_base_icon_only_padding:0.5625rem;--_ui5_button_base_icon_margin:0.375rem;--_ui5_button_icon_font_size:1rem;--_ui5_button_emphasized_font_weight:bold;--_ui5_button_text_shadow:none;--_ui5_button_emphasized_focused_border:0.0625rem dotted var(--sapContent_ContrastFocusColor);--_ui5_button_emphasized_focused_border_before:0.0625rem solid var(--sapContent_FocusColor);--_ui5_button_emphasized_outline:1px solid var(--sapContent_FocusColor);--_ui5_card_box_shadow:var(--sapContent_Shadow0);--_ui5_card_hover_box_shadow:var(--_ui5_card_box_shadow);--_ui5_card_border:1px solid var(--sapTile_BorderColor);--_ui5_card_border-radius:var(--sapElement_BorderCornerRadius);--_ui5_card_header_padding:1rem;--_ui5_card_header_hover_bg:var(--sapList_Hover_Background);--_ui5_card_header_active_bg:var(--_ui5_card_header_hover_bg);--_ui5_card_header_border:1px solid var(--_ui5_card_header_border_color);--_ui5_card_header_border_color:var(--sapTile_SeparatorColor);--_ui5_card_header_focus_border:var(--sapContent_FocusWidth) var(--sapContent_FocusStyle) var(--sapContent_FocusColor);--_ui5_card_header_focus_radius:0px;--_ui5_card_header_focus_bottom_radius:0px;--_ui5_card_header_focus_offset:1px;--_ui5_card_header_title_font_family:"72override",var(--sapFontFamily);--_ui5_card_header_title_font_size:var(--sapFontHeader5Size);--_ui5_card_header_title_font_weight:normal;--_ui5_card_header_subtitle_margin_top:.25rem;--ui5_carousel_background_color:var(--sapBackgroundColor);--ui5_carousel_button_size:2.5rem;--ui5_carousel_inactive_dot_size:0.25rem;--ui5_carousel_inactive_dot_margin:0 0.375rem;--ui5_carousel_inactive_dot_border:none;--ui5_carousel_inactive_dot_background:var(--sapContent_NonInteractiveIconColor);--ui5_carousel_active_dot_border:var(--ui5_carousel_inactive_dot_border);--ui5_carousel_active_dot_background:var(--sapSelectedColor);--_ui5_checkbox_wrapper_padding:.8125rem;--_ui5_checkbox_width_height:3rem;--_ui5_checkbox_box_shadow:none;--_ui5_checkbox_transition:unset;--_ui5_checkbox_focus_border:none;--_ui5_checkbox_disabled_opacity:.5;--_ui5_checkbox_border_radius:0;--_ui5_checkbox_hover_background:var(--sapField_Hover_Background);--_ui5_checkbox_active_background:var(--sapField_Hover_Background);--_ui5_checkbox_checkmark_warning_color:var(--sapField_TextColor);--_ui5_checkbox_inner_warning_color:var(--sapField_WarningColor);--_ui5_checkbox_inner_information_color:currentColor;--_ui5_checkbox_checkmark_color:var(--sapSelectedColor);--_ui5_checkbox_focus_position:.6875rem;--_ui5_checkbox_focus_outline:var(--sapContent_FocusWidth) var(--sapContent_FocusStyle) var(--sapContent_FocusColor);--_ui5_checkbox_focus_border_radius:0;--_ui5_checkbox_outer_hover_background:transparent;--_ui5_checkbox_inner_width_height:1.375rem;--_ui5_checkbox_inner_border:solid .125rem var(--sapField_BorderColor);--_ui5_checkbox_inner_hover_border_color:var(--sapField_HoverBorderColor);--_ui5_checkbox_inner_hover_checked_border_color:var(--sapField_HoverBorderColor);--_ui5_checkbox_inner_selected_border_color:var(--sapField_BorderColor);--_ui5_checkbox_inner_disabled_border_color:var(--sapField_BorderColor);--_ui5_checkbox_inner_active_border_color:var(--sapField_BorderColor);--_ui5_checkbox_inner_border_radius:0;--_ui5_checkbox_inner_error_border:0.125rem solid var(--sapField_InvalidColor);--_ui5_checkbox_inner_warning_border:0.125rem solid var(--sapField_WarningColor);--_ui5_checkbox_inner_information_border:0.125rem solid var(--sapField_InformationColor);--_ui5_checkbox_inner_information_box_shadow:none;--_ui5_checkbox_inner_warning_box_shadow:none;--_ui5_checkbox_inner_error_box_shadow:none;--_ui5_checkbox_inner_success_box_shadow:none;--_ui5_checkbox_inner_default_box_shadow:none;--_ui5_checkbox_inner_warning_background_hover:var(--sapField_WarningBackground);--_ui5_checkbox_inner_error_background_hover:var(--sapField_InvalidBackground);--_ui5_checkbox_inner_success_background_hover:var(--sapField_SuccessBackground);--_ui5_checkbox_inner_information_background_hover:var(--sapField_InformationBackground);--_ui5_checkbox_inner_success_border:var(--sapField_BorderWidth) solid var(--sapField_SuccessColor);--_ui5_checkbox_inner_readonly_border:0.125rem solid var(--sapField_ReadOnly_BorderColor);--_ui5_checkbox_inner_background:var(--sapField_Background);--_ui5_checkbox_wrapped_focus_padding:.375rem;--_ui5_checkbox_wrapped_content_margin_top:.125rem;--_ui5_checkbox_wrapped_focus_left_top_bottom_position:.5625rem;--_ui5_checkbox_compact_wrapper_padding:.5rem;--_ui5_checkbox_compact_width_height:2rem;--_ui5_checkbox_compact_inner_size:1rem;--_ui5_checkbox_compact_focus_position:.375rem;--_ui5_checkbox_compact_wrapped_label_margin_top:-1px;--_ui5_checkbox_label_color:var(--sapContent_LabelColor);--_ui5_checkbox_label_offset:var(--_ui5_checkbox_wrapper_padding);--_ui5_checkbox_disabled_label_color:var(--sapContent_LabelColor);--_ui5_checkbox_default_focus_border:none;--_ui5_checkbox_focus_outline_display:block;--_ui5_checkbox_right_focus_distance:0;--_ui5_checkbox_wrapper_padding:.6875rem;--_ui5_checkbox_width_height:2.75rem;--_ui5_checkbox_inner_border:.0625rem solid var(--sapField_BorderColor);--_ui5_checkbox_focus_position:0.5625rem;--_ui5_checkbox_inner_border_radius:.125rem;--_ui5_checkbox_wrapped_content_margin_top:0;--_ui5_checkbox_wrapped_focus_padding:.5rem;--_ui5_checkbox_inner_readonly_border:1px solid var(--sapField_ReadOnly_BorderColor);--_ui5_checkbox_compact_wrapped_label_margin_top:-0.125rem;--_ui5_color-palette-item-container-sides-padding:0.3125rem;--_ui5_color-palette-item-container-rows-padding:0.6875rem;--_ui5_color-palette-item-focus-height:1.5rem;--_ui5_color-palette-item-container-padding:var(--_ui5_color-palette-item-container-sides-padding) var(--_ui5_color-palette-item-container-rows-padding);--_ui5_color-palette-item-hover-margin:0;--_ui5_color-palette-row-height:9.5rem;--_ui5_color-palette-button-height:3rem;--_ui5_color-palette-item-before-focus-color:0.0625rem solid #fff;--_ui5_color-palette-item-before-focus-offset:0.0625rem;--_ui5_color-palette-item-before-focus-hover-offset:0.0625rem;--_ui5_color-palette-item-after-focus-color:0.0625rem dotted #000;--_ui5_color-palette-item-after-focus-offset:0.0625rem;--_ui5_color-palette-item-after-focus-hover-offset:0.0625rem;--_ui5_color-palette-item-before-focus-border-radius:0;--_ui5_color-palette-item-outer-border-radius:0.25rem;--_ui5_color-palette-item-inner-border-radius:0.1875rem;--_ui5_color-palette-item-hover-outer-border-radius:0.25rem;--_ui5_color-palette-item-hover-inner-border-radius:0.1875rem;--_ui5_color_picker_slider_handle_box_shadow:0.0625rem solid var(--sapField_BorderColor);--_ui5_color_picker_slider_handle_border:0.125rem solid var(--sapField_BorderColor);--_ui5_color_picker_slider_handle_outline_hover:0.125rem solid var(--sapButton_Hover_BorderColor);--_ui5_color_picker_slider_handle_outline_focus:0.0625rem dotted var(--sapContent_FocusColor);--_ui5_color_picker_slider_handle_margin_top:0.125rem;--_ui5_color_picker_slider_handle_focus_margin_top:0.125rem;--_ui5_color_picker_circle_outer_border:0.0625rem solid var(--sapContent_ContrastShadowColor);--_ui5_color_picker_circle_inner_border:0.0625rem solid var(--sapField_BorderColor);--_ui5_color_picker_circle_inner_circle_size:0.5625rem;--_ui5_color_picker_slider_container_margin_top:-10px;--_ui5_color_picker_slider_handle_inline_focus:none;--_ui5_datepicker_icon_border:none;--_ui5-datepicker_border_radius:0;--_ui5-datepicker-hover-background:var(--sapField_Hover_Background);--_ui5-datepicker_icon_border_radius:0;--_ui5_daypicker_item_box_shadow:inset 0 0 0 0.0625rem var(--sapContent_Selected_ForegroundColor);--_ui5_daypicker_item_margin:2px;--_ui5_daypicker_item_border:none;--_ui5_daypicker_item_selected_border_color:var(--sapList_Background);--_ui5_daypicker_daynames_container_height:2rem;--_ui5_daypicker_weeknumbers_container_padding_top:2rem;--_ui5_daypicker_item_othermonth_background_color:var(--sapList_Background);--_ui5_daypicker_item_othermonth_color:var(--sapContent_LabelColor);--_ui5_daypicker_item_othermonth_hover_color:var(--sapContent_LabelColor);--_ui5_daypicker_item_border_radius:0;--_ui5_daypicker_item_now_inner_border_radius:0;--_ui5_daypicker_dayname_color:var(--sapTextColor);--_ui5_daypicker_weekname_color:var(--sapTextColor);--_ui5_daypicker_item_outline_width:1px;--_ui5_daypicker_item_outline_offset:1px;--_ui5_daypicker_item_now_selected_outline_offset:2px;--_ui5_daypicker_item_now_focus_after_width:calc(100% - 0.25rem);--_ui5_daypicker_item_now_focus_after_height:calc(100% - 0.25rem);--_ui5_daypicker_item_now_selected_focus_after_width:calc(100% - 0.375rem);--_ui5_daypicker_item_now_selected_focus_after_height:calc(100% - 0.375rem);--_ui5_daypicker_item_selected_background:transparent;--_ui5_daypicker_item_selected_box_shadow:var(--_ui5_daypicker_item_box_shadow),var(--_ui5_daypicker_item_box_shadow);--_ui5_daypicker_item_selected_daytext_hover_background:transparent;--_ui5_daypicker_item_outline_focus_after:none;--_ui5_daypicker_item_border_radius_focus_after:none;--_ui5_daypicker_item_border_focus_after:var(--_ui5_daypicker_item_outline_width) dotted var(--sapContent_FocusColor);--_ui5_daypicker_item_width_focus_after:calc(100% - 0.25rem);--_ui5_daypicker_item_height_focus_after:calc(100% - 0.25rem);--_ui5_daypicker_item_now_border:0.125rem solid var(--sapLegend_CurrentDateTime);--_ui5_daypicker_item_now_outline:none;--_ui5_daypicker_item_now_outline_offset:none;--_ui5_daypicker_item_now_outline_offset_focus_after:var(--_ui5_daypicker_item_now_outline_offset);--_ui5_daypicker_item_selected_between_border:5%;--_ui5_daypicker_item_selected_between_background:transparent;--_ui5_daypicker_item_selected_between_text_background:var(--sapList_SelectionBackgroundColor);--_ui5_daypicker_item_selected_between_text_font:inherit;--_ui5_daypicker_item_selected_between_hover_background:inherit;--_ui5_daypicker_item_now_box_shadow:inset 0 0 0 0.0625rem var(--_ui5_daypicker_item_selected_border_color);--_ui5_daypicker_item_selected_text_outline:none;--_ui5_daypicker_item_now_not_selected_inset:0;--_ui5_daypicker_item_now_inset:0.1875rem;--_ui5_daypicker_item_now_border_color:var(--sapLegend_CurrentDateTime);--_ui5_daypicker_item_selected_background:var(--sapContent_Selected_Background);--_ui5_daypicker_dayname_color:var(--sapContent_LabelColor);--_ui5_daypicker_weekname_color:var(--sapContent_LabelColor);--_ui5_daypicker_item_border_radius_focus_after:0.0625rem;--_ui5_daypicker_item_selected_border:none;--_ui5_daypicker_item_not_selected_focus_border:0.0625rem dotted var(--sapContent_FocusColor);--_ui5_daypicker_item_selected_focus_color:var(--sapContent_ContrastFocusColor);--_ui5_daypicker_item_selected_focus_width:0.0625rem;--_ui5_daypicker_item_no_selected_inset:0.125rem;--_ui5_daypicker_item_now_border_focus_after:0.0625rem dotted var(--sapList_SelectionBorderColor);--_ui5_daypicker_item_now_border_radius_focus_after:0.0625rem;--_ui5_day_picker_item_selected_now_border:0.1875rem solid var(--sapList_Background);--_ui5_day_picker_item_selected_now_border_foucs:0.0625rem dotted var(--sapContent_ContrastFocusColor);--_ui5_day_picker_item_selected_now_border_radios_foucs:0.0625rem;--_ui5-dp-item_withsecondtype_border:0.1875rem;--_ui5_daypicker_item_border_radius:0.25rem;--_ui5_daypicker_item_selected_text_border:none;--_ui5_daypicker_item_selected_between_text_border_radios:0.25rem;--_ui5_daypicker_item_select_between_border:1px solid var(--sapContent_Selected_ForegroundColor);--_ui5_file_uploader_hover_border:1px solid var(--sapField_Hover_BorderColor);--_ui5_file_uploader_value_state_error_hover_background_color:var(--sapField_Hover_Background);--_ui5_dialog_resize_handle_color:var(--sapButton_Lite_TextColor);--_ui5_dialog_resize_handle_right:-0.25rem;--_ui5_dialog_resize_handle_bottom:-0.0625rem;--_ui5_dialog_header_focus_bottom_offset:3px;--_ui5_dialog_header_focus_top_offset:2px;--_ui5_dialog_header_focus_left_offset:2px;--_ui5_dialog_header_focus_right_offset:2px;--_ui5_dialog_header_border_radius:0px;--_ui5_dialog_header_error_state_box_shadow:inset 0 -0.0625rem var(--sapErrorBorderColor),var(--sapContent_HeaderShadow);--_ui5_dialog_header_information_state_box_shadow:inset 0 -0.0625rem var(--sapInformationBorderColor),var(--sapContent_HeaderShadow);--_ui5_dialog_header_success_state_box_shadow:inset 0 -0.0625rem var(--sapSuccessBorderColor),var(--sapContent_HeaderShadow);--_ui5_dialog_header_warning_state_box_shadow:inset 0 -0.0625rem var(--sapWarningBorderColor),var(--sapContent_HeaderShadow);--_ui5_dialog_header_error_state_icon_color:var(--sapNegativeElementColor);--_ui5_dialog_header_information_state_icon_color:var(--sapInformativeElementColor);--_ui5_dialog_header_success_state_icon_color:var(--sapPositiveElementColor);--_ui5_dialog_header_warning_state_icon_color:var(--sapCriticalElementColor);--ui5-group-header-listitem-background-color:var(--sapList_GroupHeaderBackground);--_ui5_input_width:13.125rem;--_ui5_input_min_width:2.75rem;--_ui5_input_height:var(--sapElement_Height);--_ui5_input_compact_height:1.625rem;--_ui5_input_margin_top_bottom:0.25rem;--_ui5_input_hover_border:var(--sapField_BorderWidth) var(--sapField_BorderStyle) var(--sapField_Hover_BorderColor);--_ui5_input_value_state_error_hover_background:var(--sapField_Hover_Background);--_ui5_input_background_color:var(--sapField_Background);--_ui5_input_border_radius:var(--sapField_BorderCornerRadius);--_ui5_input_focus_border_radius:0;--_ui5-input-border:2px solid transparent;--_ui5_input_placeholder_style:italic;--_ui5_input_placeholder_color:var(--sapField_PlaceholderTextColor);--_ui5_input_bottom_border_height:0;--_ui5_input_bottom_border_color:transparent;--_ui5_input_focused_border_color:var(--sapField_Hover_BorderColor);--_ui5_input_state_border_width:0.125rem;--_ui5_input_information_border_width:0.125rem;--_ui5_input_error_font_weight:normal;--_ui5_input_warning_font_weight:normal;--_ui5_input_focus_border_width:1px;--_ui5_input_error_warning_border_style:solid;--_ui5_input_error_warning_font_style:inherit;--_ui5_input_error_warning_text_indent:0;--_ui5_input_disabled_color:var(--sapContent_DisabledTextColor);--_ui5_input_disabled_font_weight:normal;--_ui5_input_disabled_border_color:var(--sapField_BorderColor);--_ui5-input_disabled_background:var(--sapField_Background);--_ui5_input_readonly_border_color:var(--sapField_ReadOnly_BorderColor);--_ui5_input_readonly_background:var(--sapField_ReadOnly_Background);--_ui5_input_custom_icon_padding:.5625rem .625rem;--_ui5_input_error_warning_custom_icon_padding:.5rem .625rem;--_ui5_input_information_custom_icon_padding:.5rem .625rem;--_ui5_input_error_warning_icon_padding:.5rem .5rem .5rem .5625rem;--_ui5_input_information_icon_padding:.5rem .5rem .5rem .5625rem;--_ui5_input_disabled_opacity:var(--sapContent_DisabledOpacity);--_ui5_input_icon_min_width:2.25rem;--_ui5_input_compact_min_width:2rem;--_ui5_input_transition:none;--_ui5-input-value-state-icon-display:none;--_ui5_input_focused_value_state_error_background:var(--sapField_InvalidBackground);--_ui5_input_focused_value_state_warning_background:var(--sapField_WarningBackground);--_ui5_input_focused_value_state_success_background:var(--sapField_SuccessBackground);--_ui5_input_focused_value_state_information_background:var(--sapField_InformationBackground);--_ui5_input_value_state_error_border_color:var(--sapField_InvalidColor);--_ui5_input_focused_value_state_error_border_color:var(--sapField_InvalidColor);--_ui5_input_focused_value_state_error_focus_outline_color:var(--sapContent_FocusColor);--_ui5_input_focused_value_state_warning_focus_outline_color:var(--sapContent_FocusColor);--_ui5_input_focused_value_state_success_focus_outline_color:var(--sapContent_FocusColor);--_ui5_input_value_state_warning_border_color:var(--sapField_WarningColor);--_ui5_input_focused_value_state_warning_border_color:var(--sapField_WarningColor);--_ui5_input_value_state_success_border_color:var(--sapField_SuccessColor);--_ui5_input_focused_value_state_success_border_color:var(--sapField_SuccessColor);--_ui5_input_value_state_success_border_width:1px;--_ui5_input_value_state_information_border_color:var(--sapField_InformationColor);--_ui5_input_focused_value_state_information_border_color:var(--sapField_InformationColor);--_ui5-input-value-state-information-border-width:1px;--_ui5-input-background-image:none;--_ui5_input_focus_offset:1px;--ui5_input_focus_pseudo_element_content:"";--_ui5_input_value_state_error_warning_placeholder_font_weight:normal;--_ui5_input_focus_outline_color:var(--sapContent_FocusColor);--_ui5-input_error_placeholder_color:var(--sapField_PlaceholderTextColor);--_ui5_input_icon_width:2.25rem;--_ui5_input_icon_wrapper_height:100%;--_ui5_input_icon_wrapper_state_height:100%;--_ui5_input_icon_wrapper_success_state_height:100%;--_ui5-input-icons-count:0;--_ui5_input_margin_top_bottom:0.1875rem;--_ui5_input_tokenizer_min_width:3.25rem}.sapUiSizeCompact,.ui5-content-density-compact,[data-ui5-compact-size]{--_ui5_input_min_width:2rem;--_ui5_input_icon_width:2rem}:root{--_ui5-input-border:1px solid var(--sapField_BorderColor);--_ui5_input_icon_padding:.5625rem;--_ui5_input_icon_color:var(--sapContent_IconColor);--_ui5_input_icon_pressed_color:var(--sapButton_Active_TextColor);--_ui5_input_icon_pressed_bg:var(--sapButton_Selected_Background);--_ui5_input_icon_hover_bg:var(--sapButton_Lite_Hover_Background);--_ui5_input_icon_border_radius:0;--_ui5_input_icon_box_shadow:none;--_ui5_input_icon_border:1px solid transparent;--_ui5_input_error_icon_box_shadow:var(--_ui5_input_icon_box_shadow);--_ui5_input_warning_icon_box_shadow:var(--_ui5_input_icon_box_shadow);--_ui5_input_information_icon_box_shadow:var(--_ui5_input_icon_box_shadow);--_ui5_input_success_icon_box_shadow:var(--_ui5_input_icon_box_shadow);--_ui5_input_icon_error_pressed_color:var(--sapButton_Active_TextColor);--_ui5_input_icon_warning_pressed_color:var(--sapButton_Active_TextColor);--_ui5_input_icon_information_pressed_color:var(--sapButton_Active_TextColor);--_ui5_input_icon_success_pressed_color:var(--sapButton_Active_TextColor);--_ui5_link_focused_hover_text_decoration:underline;--_ui5_link_focused_hover_text_color:var(--sapLinkColor);--_ui5_link_active_text_decoration:underline;--_ui5_link_border:0.0625rem dotted transparent;--_ui5_link_border_focus:0.0625rem dotted var(--sapContent_FocusColor);--_ui5_link_focus_border-radius:0;--_ui5_link_focus_background_color:transparent;--_ui5_link_focus_color:inherit;--_ui5_link_focus_text_decoration:underline;--_ui5_link_subtle_text_decoration:none;--_ui5_link_subtle_text_decoration_hover:underline;--_ui5_link_text_decoration:none;--_ui5_link_hover_text_decoration:underline;--ui5_list_footer_text_color:var(--sapPageFooter_TextColor);--ui5_list_footer_text_color:var(--sapTextColor);--ui5-listitem-background-color:var(--sapList_Background);--ui5-listitem-border-bottom:1px solid var(--sapList_BorderColor);--ui5-listitem-selected-border-bottom:1px solid var(--sapList_SelectionBorderColor);--ui5-listitem-focused-selected-border-bottom:1px solid var(--sapList_SelectionBorderColor);--ui5-listitem-active-border-color:var(--sapContent_ContrastFocusColor);--_ui5_listitembase_focus_width:1px;--_ui5-listitembase_disabled_opacity:0.5;--_ui5_product_switch_item_border:none;--_ui5_menu_popover_border_radius:var(--sapElement_BorderCornerRadius);--_ui5_menu_item_padding:0 1rem 0 0.75rem;--_ui5_menu_item_submenu_icon_right:1rem;--_ui5_menu_item_additional_text_start_margin:1rem;--_ui5_monthpicker_item_border_radius:0;--_ui5_monthpicker_item_border:none;--_ui5_monthpicker_item_margin:1px;--_ui5_monthpicker_item_focus_after_width:calc(100% - 0.375rem);--_ui5_monthpicker_item_focus_after_height:calc(100% - 0.375rem);--_ui5_monthpicker_item_focus_after_border:1px dotted var(--sapContent_FocusColor);--_ui5_monthpicker_item_focus_after_offset:2px;--_ui5_monthpicker_item_focus_after_border_radius:0;--_ui5_monthpicker_item_selected_text_color:var(--sapContent_ContrastTextColor);--_ui5_monthpicker_item_selected_background_color:var(--sapSelectedColor);--_ui5_monthpicker_item_selected_hover_color:var(--sapContent_Selected_Background);--_ui5_monthpicker_item_selected_box_shadow:none;--_ui5_monthpicker_item_focus_after_outline:none;--_ui5_monthpicker_item_selected_font_wieght:inherit;--_ui5_monthpicker_item_border_radius:0.25rem;--_ui5_message_strip_icon_width:2.5rem;--_ui5_message_strip_button_border_width:0;--_ui5_message_strip_button_border_style:none;--_ui5_message_strip_button_border_color:transparent;--_ui5_message_strip_button_border_radius:0;--_ui5_message_strip_padding:0.4375rem 2.5rem 0.4375rem 2.5rem;--_ui5_message_strip_padding_block_no_icon:0.4375rem 0.4375rem;--_ui5_message_strip_padding_inline_no_icon:1rem 2.5rem;--_ui5_message_strip_button_height:1.625rem;--_ui5_message_strip_border_width:1px;--_ui5_message_strip_close_button_border:none;--_ui5_message_strip_icon_top:0.4375rem;--_ui5_message_strip_focus_width:1px;--_ui5_message_strip_focus_offset:-2px;--_ui5_message_strip_close_button_top:0.125rem;--_ui5_message_strip_close_button_right:0.125rem;--_ui5_panel_focus_border:var(--sapContent_FocusWidth) var(--sapContent_FocusStyle) var(--sapContent_FocusColor);--_ui5_panel_button_root_width:3rem;--_ui5_panel_border_radius:0px;--_ui5_panel_border_radius_expanded:0;--_ui5_panel_default_header_border:none;--_ui5_panel_border_bottom:0.0625rem solid var(--sapGroup_TitleBorderColor);--_ui5_panel_outline_offset:-3px;--_ui5_panel_icon_color:var(--sapContent_IconColor);--_ui5_panel_header_padding_right:0.5rem;--_ui5_panel_header_button_wrapper_padding:.25rem;--_ui5_panel_focus_offset:1px;--_ui5_panel_content_padding:0.625rem 1rem 1.375rem 1rem }.sapUiSizeCompact,.ui5-content-density-compact,[data-ui5-compact-size]{--_ui5_panel_header_button_wrapper_padding:.5625rem .375rem}:root{--_ui5_panel_button_root_width:2.75rem;--_ui5_popup_content_padding_s:1rem;--_ui5_popup_content_padding_m_l:2rem;--_ui5_popup_content_padding_xl:3rem;--_ui5_popup_header_footer_padding_s:1rem;--_ui5_popup_header_footer_padding_m_l:2rem;--_ui5_popup_header_footer_padding_xl:3rem;--_ui5_popup_viewport_margin:10px;--_ui5_popup_header_font_weight:400;--_ui5_popup_header_font_family:var(--sapFontFamily);--_ui5_popup_header_prop_header_text_alignment:flex-start;--_ui5_popup_border_radius:var(--sapElement_BorderCornerRadius);--_ui5_progress_indicator_background_none:var(--sapField_Background);--_ui5_progress_indicator_background_error:var(--sapField_Background);--_ui5_progress_indicator_background_warning:var(--sapField_Background);--_ui5_progress_indicator_background_success:var(--sapField_Background);--_ui5_progress_indicator_background_information:var(--sapField_Background);--_ui5_progress_indicator_value_state_none:var(--sapNeutralElementColor);--_ui5_progress_indicator_value_state_error:var(--sapNegativeElementColor);--_ui5_progress_indicator_value_state_warning:var(--sapCriticalElementColor);--_ui5_progress_indicator_value_state_success:var(--sapPositiveElementColor);--_ui5_progress_indicator_value_state_information:var(--sapInformativeElementColor);--_ui5_progress_indicator_border_color_error:var(--sapField_BorderColor);--_ui5_progress_indicator_border_color_warning:var(--sapField_BorderColor);--_ui5_progress_indicator_border_color_success:var(--sapField_BorderColor);--_ui5_progress_indicator_border_color_information:var(--sapField_BorderColor);--_ui5_progress_indicator_color:var(--sapTextColor);--_ui5_progress_indicator_bar_color:var(--sapContent_ContrastTextColor);--_ui5_progress_indicator_border:0.0625rem solid var(--sapField_BorderColor);--_ui5_progress_indicator_bar_border_max:none;--_ui5_progress_indicator_icon_visibility:none;--_ui5_progress_indicator_side_points_visibility:none;--_ui5_progress_indicator_host_height:1rem;--_ui5_progress_indicator_host_min_height:1rem;--_ui5_progress_indicator_root_border_radius:0.5rem;--_ui5_progress_indicator_root_height:100%;--_ui5_progress_indicator_root_overflow:hidden;--_ui5_progress_indicator_bar_height:100%;--_ui5_progress_indicator_bar_border_radius:0.5rem 0 0 0.5rem;--_ui5_progress_indicator_remaining_bar_overflow:hidden;--_ui5_progress_indicator_icon_size:var(--sapFontSmallSize);--_ui5_progress_indicator_value_margin:0 0.375rem;--_ui5_radio_button_min_width:2.75rem;--_ui5_radio_button_min_width_compact:2rem;--_ui5_radio_button_hover_fill:var(--sapField_Hover_Background);--_ui5_radio_button_hover_fill_error:var(--sapField_Hover_Background);--_ui5_radio_button_hover_fill_warning:var(--sapField_Hover_Background);--_ui5_radio_button_hover_fill_success:var(--sapField_Hover_Background);--_ui5_radio_button_hover_fill_information:var(--sapField_Hover_Background);--_ui5_radio_button_border_width:1px;--_ui5_radio_button_checked_fill:var(--sapSelectedColor);--_ui5_radio_button_checked_error_fill:var(--sapField_InvalidColor);--_ui5_radio_button_checked_warning_fill:var(--sapField_TextColor);--_ui5_radio_button_checked_success_fill:var(--sapField_SuccessColor);--_ui5_radio_button_checked_information_fill:var(--sapField_InformationColor);--_ui5_radio_button_warning_error_border_dash:0;--_ui5_radio_button_outer_ring_color:var(--sapField_BorderColor);--_ui5_radio_button_outer_ring_width:var(--sapField_BorderWidth);--_ui5_radio_button_outer_ring_bg:var(--sapField_Background);--_ui5_radio_button_outer_ring_hover_color:var(--sapField_Hover_BorderColor);--_ui5_radio_button_outer_ring_active_color:var(--sapField_Hover_BorderColor);--_ui5_radio_button_outer_ring_checked_hover_color:var(--sapField_Hover_BorderColor);--_ui5_radio_button_outer_ring_padding:0 0.625rem;--_ui5_radio_button_border_radius:0;--_ui5_radio_button_border:none;--_ui5_radio_button_focus_border:none;--_ui5_radio_button_focus_outline:block;--_ui5_radio_button_hover_shadow:none;--_ui5_radio_button_transition:none;--_ui5_radio_button_hover_background:inherit;--_ui5_radio_button_color:var(--sapField_BorderColor);--_ui5_radio_button_label_offset:1px;--_ui5_radio_button_label_color:var(--sapContent_LabelColor);--_ui5_radio_button_items_align:unset;--_ui5_radio_button_inner_width:initial;--_ui5_radio_button_border_readonly_focus_style:var(--sapContent_FocusStyle);--_ui5_radio_button_inner_ring_radius:22%;--_ui5_radio_button_outer_ring_hover_shadow:none;--_ui5_radio_button_outer_ring_hover_shadow_error:none;--_ui5_radio_button_outer_ring_hover_shadow_warning:none;--_ui5_radio_button_outer_ring_hover_shadow_success:none;--_ui5_radio_button_outer_ring_hover_shadow_information:none;--_ui5_radio_button_read_only_border_type:none;--_ui5_radio_button_inner_ring_color:var(--sapSelectedColor);--_ui5_radio_button_information_border_width:var(--sapField_InformationBorderWidth);--_ui5_radio_button_read_only_border_width:var(--sapField_BorderWidth);--_ui5_rating_indicator_border_radius:0px;--_ui5_rating_indicator_outline_offset:0px;--_ui5_rating_indicator_item_height:1em;--_ui5_rating_indicator_item_width:1em;--_ui5_rating_indicator_readonly_item_height:1em;--_ui5_rating_indicator_readonly_item_width:1em;--_ui5_rating_indicator_readonly_item_spacing:0px;--_ui5_rating_indicator_component_spacing:0.5rem 0px}.sapUiSizeCompact,.ui5-content-density-compact,[data-ui5-compact-size]{--_ui5_rating_indicator_item_height:0.67em;--_ui5_rating_indicator_item_width:0.67em;--_ui5_rating_indicator_readonly_item_height:0.67em;--_ui5_rating_indicator_readonly_item_width:0.67em;--_ui5_rating_indicator_component_spacing:0.8125rem 0px}:root{--_ui5_segmented_btn_inner_border:0.0625rem solid var(--sapButton_BorderColor);--_ui5_segmented_btn_inner_border_odd_child:0;--_ui5_segmented_btn_inner_pressed_border_odd_child:0;--_ui5_segmented_btn_border_radius:0.375rem;--_ui5_segmented_btn_inner_border_radius:0;--_ui5_segmented_btn_outer_border_radius:0.375rem;--_ui5_segmented_btn_background_color:transparent;--_ui5_select_disabled_background:var(--sapField_Background);--_ui5_select_disabled_border_color:var(--sapField_BorderColor);--_ui5_select_state_error_warning_border_style:solid;--_ui5_select_state_error_warning_border_width:0.125rem;--_ui5_select_hover_icon_left_border:1px solid transparent;--_ui5_select_focus_width:1px;--_ui5_select_label_color:var(--sapField_TextColor);--_ui5_split_button_focused_border:0.0625rem dotted var(--sapContent_FocusColor);--_ui5_split_button_focused_border_radius:0.125rem;--_ui5_split_button_hover_border_radius:0;--_ui5_split_button_attention_separator_color:var(--sapButton_Attention_BorderColor);--_ui5_split_button_middle_separator_width:0;--_ui5_split_button_middle_separator_left:0;--_ui5_split_button_middle_separator_hover_display:block;--_ui5_split_button_text_button_width:2.25rem;--_ui5_split_button_text_button_right_border_width:0;--_ui5_split_button_transparent_hover_background:var(--sapButton_Lite_Background);--_ui5_split_button_transparent_hover_color:var(--sapButton_Lite_TextColor);--_ui5_split_button_transparent_disabled_background:transparent;--_ui5_split_button_inner_focused_border_radius_outer:0.25rem;--_ui5_split_button_inner_focused_border_radius_inner:0;--_ui5_switch_height:2.75rem;--_ui5_switch_width:3.25rem;--_ui5_switch_compact_height:2rem;--_ui5_switch_compact_width:2.5rem;--_ui5_switch_min_width:3.875rem;--_ui5_switch_compact_min_width:3.5rem;--_ui5_switch_with_label_width:100%;--_ui5_switch_compact_with_label_width:100%;--_ui5_switch_focus_outline:var(--_ui5_switch_foucs_border_size) dotted var(--sapContent_FocusColor);--_ui5_switch_root_outline_top:0.25rem;--_ui5_switch_root_outline_bottom:0.25rem;--_ui5_switch_root_outline_left:0;--_ui5_switch_root_outline_right:0;--_ui5_switch_root_compact_outline_top:0;--_ui5_switch_root_compact_outline_bottom:0;--_ui5_switch_foucs_border_size:1px;--_ui5-switch-root-border-radius:0;--_ui5-switch-root-box-shadow:none;--_ui5_switch_root_after_outline:none;--_ui5-switch-focus:"";--_ui5_switch_disabled_opacity:.4;--_ui5_switch_transform:translateX(100%) translateX(-1.875rem);--_ui5_switch_compact_transform:translateX(100%) translateX(-1.5rem);--_ui5_switch_transform_with_label:translateX(100%) translateX(-1.875rem);--_ui5_switch_compact_transform_with_label:translateX(100%) translateX(-1.5rem);--_ui5_switch_rtl_transform:translateX(-100%) translateX(1.875rem);--_ui5_switch_compact_rtl_transform:translateX(1.5rem) translateX(-100%);--_ui5_switch_rtl_transform_with_label:translateX(-100%) translateX(1.875rem);--_ui5_switch_compact_rtl_transform_with_label:translateX(1.5rem) translateX(-100%);--_ui5_switch_track_with_label_width:100%;--_ui5_switch_track_with_label_compact_width:100%;--_ui5_switch_track_with_label_height:1.375rem;--_ui5_switch_track_with_label_compact_height:1.375rem;--_ui5_switch_track_width:100%;--_ui5_switch_track_compact_width:100%;--_ui5_switch_track_height:1.375rem;--_ui5_switch_track_compact_height:1.375rem;--_ui5_switch_track_border_radius:0.75rem;--_ui5-switch-track-border:1px solid;--_ui5_switch_track_active_background_color:var(--sapButton_Track_Selected_Background);--_ui5_switch_track_inactive_background_color:var(--sapButton_Track_Background);--_ui5_switch_track_hover_active_background_color:var(--sapButton_Track_Selected_Background);--_ui5_switch_track_hover_inactive_background_color:var(--sapButton_Track_Background);--_ui5_switch_track_active_border_color:var(--sapContent_ForegroundBorderColor);--_ui5_switch_track_inactive_border_color:var(--sapContent_ForegroundBorderColor);--_ui5_switch_track_hover_active_border_color:var(--sapButton_Hover_BorderColor);--_ui5_switch_track_hover_inactive_border_color:var(--sapButton_Hover_BorderColor);--_ui5_switch_track_semantic_accept_background_color:var(--sapSuccessBackground);--_ui5_switch_track_semantic_reject_background_color:var(--sapErrorBackground);--_ui5_switch_track_semantic_hover_accept_background_color:var(--sapSuccessBackground);--_ui5_switch_track_semantic_hover_reject_background_color:var(--sapErrorBackground);--_ui5_switch_track_semantic_accept_border_color:var(--sapSuccessBorderColor);--_ui5_switch_track_semantic_reject_border_color:var(--sapErrorBorderColor);--_ui5_switch_track_semantic_hover_accept_border_color:var(--sapSuccessBorderColor);--_ui5_switch_track_semantic_hover_reject_border_color:var(--sapErrorBorderColor);--_ui5_switch_track_transition:none;--_ui5_switch_track_icon_display:none;--_ui5_switch_handle_width:2rem;--_ui5_switch_handle_compact_width:1.625rem;--_ui5_switch_handle_height:2rem;--_ui5_switch_handle_compact_height:1.625rem;--_ui5_switch_handle_with_label_width:2rem;--_ui5_switch_handle_with_label_compact_width:1.625rem;--_ui5_switch_handle_with_label_height:2rem;--_ui5_switch_handle_with_label_compact_height:1.625rem;--_ui5_switch_handle_border:var(--_ui5_switch_handle_border_width) solid var(--sapButton_Handle_BorderColor);--_ui5_switch_handle_border_width:0.0625rem;--_ui5_switch_handle_border_radius:1rem;--_ui5_switch_handle_active_background_color:var(--sapButton_Selected_Background);--_ui5_switch_handle_inactive_background_color:var(--sapButton_TokenBackground);--_ui5_switch_handle_hover_active_background_color:var(--sapButton_Selected_Hover_Background);--_ui5_switch_handle_hover_inactive_background_color:var(--sapButton_Handle_Hover_Background);--_ui5_switch_handle_active_border_color:var(--sapButton_Selected_BorderColor);--_ui5_switch_handle_inactive_border_color:var(--sapContent_ForegroundBorderColor);--_ui5_switch_handle_hover_active_border_color:var(--sapButton_Selected_BorderColor);--_ui5_switch_handle_hover_inactive_border_color:var(--sapButton_Hover_BorderColor);--_ui5_switch_handle_semantic_accept_background_color:var(--sapButton_Background);--_ui5_switch_handle_semantic_reject_background_color:var(--sapButton_Background);--_ui5_switch_handle_semantic_hover_accept_background_color:var(--sapSuccessBackground);--_ui5_switch_handle_semantic_hover_reject_background_color:var(--sapErrorBackground);--_ui5_switch_handle_semantic_accept_border_color:var(--sapSuccessBorderColor);--_ui5_switch_handle_semantic_reject_border_color:var(--sapErrorBorderColor);--_ui5_switch_handle_semantic_hover_accept_border_color:var(--sapSuccessBorderColor);--_ui5_switch_handle_semantic_hover_reject_border_color:var(--sapErrorBorderColor);--_ui5_switch_handle_on_hover_box_shadow:none;--_ui5_switch_handle_off_hover_box_shadow:none;--_ui5_switch_handle_semantic_on_hover_box_shadow:var(--sapContent_Informative_Shadow);--_ui5_switch_handle_semantic_off_hover_box_shadow:var(--sapContent_Negative_Shadow);--_ui5-switch-handle-icon-display:none;--_ui5_switch_handle_left:-0.0625rem;--_ui5-switch-slider-texts-display:inline;--_ui5_switch_text_font_family:"72override",var(--sapFontFamily);--_ui5_switch_text_font_size:var(--sapFontSmallSize);--_ui5_switch_text_compact_font_size:var(--sapFontSmallSize);--_ui5_switch_text_with_label_font_family:"72override",var(--sapFontFamily);--_ui5_switch_text_with_label_font_size:var(--sapFontSmallSize);--_ui5_switch_text_with_label_width:none;--_ui5_switch_text_width:none;--_ui5_switch_text_compact_width:none;--_ui5_switch_text_inactive_left:auto;--_ui5_switch_text_inactive_right:0.125rem;--_ui5_switch_text_active_left:calc(-100% + 2rem);--_ui5_switch_text_compact_active_left:calc(-100% + 1.625rem);--_ui5_switch_text_active_right:auto;--_ui5_switch_text_active_color:var(--sapButton_Track_Selected_TextColor);--_ui5_switch_text_inactive_color:var(--sapTextColor);--_ui5_switch_text_semantic_accept_color:var(--sapPositiveElementColor);--_ui5_switch_text_semantic_reject_color:var(--sapNegativeElementColor);--_ui5_switch_text_overflow:none;--_ui5_switch_text_z_index:inherit;--_ui5_switch_text_hidden:hidden;--_ui5_switch_text_min_width:1.625rem;--_ui5_switch_icon_width:0.75rem;--_ui5_switch_icon_height:0.75rem;--_ui5_tc_header_height_text_only:var(--_ui5_tc_item_text_only_height);--_ui5_tc_header_height_text_with_additional_text:var(--_ui5_tc_item_text_only_with_additional_text_height);--_ui5_tc_header_box_shadow:var(--sapContent_HeaderShadow);--_ui5_tc_header_border_bottom:0.125rem solid var(--sapObjectHeader_Background);--_ui5_tc_header_background:var(--sapObjectHeader_Background);--_ui5_tc_header_background_translucent:var(--sapObjectHeader_Background);--_ui5_tc_content_background:var(--sapBackgroundColor);--_ui5_tc_content_background_translucent:var(--sapGroup_ContentBackground);--_ui5_tc_headeritem_padding:0 1rem;--_ui5_tc_headerItem_color:var(--sapContent_LabelColor);--_ui5_tc_headerItem_additional_text_color:var(--sapContent_LabelColor);--_ui5_tc_headerItem_text_hover_color:var(--_ui5_tc_headerItem_color);--_ui5_tc_headerItem_text_selected_color:var(--sapSelectedColor);--_ui5_tc_headerItem_text_selected_hover_color:var(--sapSelectedColor);--_ui5_tc_headeritem_text_font_weight:normal;--_ui5_tc_headerItem_additional_text_font_weight:normal;--_ui5_tc_headerItem_neutral_color:var(--sapNeutralColor);--_ui5_tc_headerItem_positive_color:var(--sapPositiveColor);--_ui5_tc_headerItem_negative_color:var(--sapNegativeColor);--_ui5_tc_headerItem_critical_color:var(--sapCriticalColor);--_ui5_tc_headerItem_neutral_border_color:var(--_ui5_tc_headerItem_neutral_color);--_ui5_tc_headerItem_positive_border_color:var(--_ui5_tc_headerItem_positive_color);--_ui5_tc_headerItem_negative_border_color:var(--_ui5_tc_headerItem_negative_color);--_ui5_tc_headerItem_critical_border_color:var(--_ui5_tc_headerItem_critical_color);--_ui5_tc_headerItem_neutral_selected_border_color:var(--_ui5_tc_headerItem_neutral_color);--_ui5_tc_headerItem_positive_selected_border_color:var(--_ui5_tc_headerItem_positive_color);--_ui5_tc_headerItem_negative_selected_border_color:var(--_ui5_tc_headerItem_negative_color);--_ui5_tc_headerItem_critical_selected_border_color:var(--_ui5_tc_headerItem_critical_color);--_ui5_tc_headerItem_transition:none;--_ui5_tc_headerItem_hover_border_visibility:hidden;--_ui5_tc_headerItem_focus_offset:0px;--_ui5_tc_headerItemContent_border_radius:0.125rem 0.125rem 0 0;--_ui5_tc_headerItemContent_border_bottom:0.125rem solid var(--sapSelectedColor);--_ui5_tc_headerItemContent_border_bg:transparent;--_ui5_tc_headerItem_neutral_border_bg:transparent;--_ui5_tc_headerItem_positive_border_bg:transparent;--_ui5_tc_headerItem_negative_border_bg:transparent;--_ui5_tc_headerItem_critical_border_bg:transparent;--_ui5_tc_headerItem_hover_border_bg:transparent;--_ui5_tc_headerItem_hover_selected_hover_border_bg:transparent;--_ui5_tc_headerItemContent_border_height:0;--_ui5_tc_headerItemContent_offset:1rem;--_ui5_tc_headerItemContent_focus_offset:1rem;--_ui5_tc_headerItem_focus_border:var(--sapContent_FocusWidth) var(--sapContent_FocusStyle) var(--sapContent_FocusColor);--_ui5_tc_headerItem_text_focus_border_offset_left:0px;--_ui5_tc_headerItem_text_focus_border_offset_right:0px;--_ui5_tc_headerItem_text_focus_border_offset_top:0px;--_ui5_tc_headerItem_text_focus_border_offset_bottom:0px;--_ui5_tc_headerItem_mixed_mode_focus_border_offset_left:0.75rem;--_ui5_tc_headerItem_mixed_mode_focus_border_offset_right:0.625rem;--_ui5_tc_headerItem_mixed_mode_focus_border_offset_top:0.75rem;--_ui5_tc_headerItem_mixed_mode_focus_border_offset_bottom:0.75rem;--_ui5_tc_headerItemContent_padding:0;--_ui5_tc_headerItemContent_focus_border:none;--_ui5_tc_headerItemContent_default_focus_border:none;--_ui5_tc_headerItemContent_focus_border_radius:0;--_ui5_tc_headerItemSemanticIcon_display:none;--_ui5_tc_headerItemSemanticIcon_size:0.75rem;--_ui5_tc_headerItem_focus_border_radius:0px;--_ui5_tc_mixedMode_itemText_color:var(--sapContent_LabelColor);--_ui5_tc_mixedMode_itemText_font_family:var(--sapFontFamily);--_ui5_tc_mixedMode_itemText_font_size:var(--sapFontSmallSize);--_ui5_tc_mixedMode_itemText_font_weight:normal;--_ui5_tc_overflowItem_neutral_color:var(--sapNeutralColor);--_ui5_tc_overflowItem_positive_color:var(--sapPositiveColor);--_ui5_tc_overflowItem_negative_color:var(--sapNegativeColor);--_ui5_tc_overflowItem_critical_color:var(--sapCriticalColor);--_ui5_tc_overflowItem_focus_offset:0.125rem;--_ui5_tc_overflowItem_extraIndent:0rem;--_ui5_tc_headerItemIcon_border:1px solid var(--sapHighlightColor);--_ui5_tc_headerItemIcon_color:var(--sapHighlightColor);--_ui5_tc_headerItemIcon_selected_background:var(--sapHighlightColor);--_ui5_tc_headerItemIcon_selected_color:var(--sapGroup_ContentBackground);--_ui5_tc_headerItemIcon_positive_selected_background:var(--sapPositiveColor);--_ui5_tc_headerItemIcon_negative_selected_background:var(--sapNegativeColor);--_ui5_tc_headerItemIcon_critical_selected_background:var(--sapCriticalColor);--_ui5_tc_headerItemIcon_neutral_selected_background:var(--sapNeutralColor);--_ui5_tc_headerItemIcon_semantic_selected_color:var(--sapGroup_ContentBackground);--_ui5_tc_headerItemIcon_background_color:transparent;--_ui5_tc_content_border_bottom:0.125rem solid var(--sapObjectHeader_BorderColor);--_ui5_tc_headerItem_focus_border_offset:-2px;--_ui5_tc_headerItemIcon_focus_border_radius:0}.sapUiSizeCompact,.ui5-content-density-compact,:root,[data-ui5-compact-size]{--_ui5_tc_header_height:var(--_ui5_tc_item_height)}:root{--_ui5_tc_header_border_bottom:0.0625rem solid var(--sapObjectHeader_Background);--_ui5_tc_headerItemContent_border_bottom:0.1875rem solid var(--sapSelectedColor);--_ui5_tc_overflowItem_default_color:var(--sapNeutralTextColor);--_ui5_tc_overflowItem_current_color:CurrentColor;--_ui5_tc_content_border_bottom:0.0625rem solid var(--sapObjectHeader_BorderColor);--_ui5_tc_headerItem_text_hover_color:#1a1c1f;--_ui5_textarea_state_border_width:0.125rem;--_ui5_textarea_information_border_width:0.125rem;--_ui5_textarea_placeholder_font_style:italic;--_ui5_textarea_value_state_error_warning_placeholder_font_weight:normal;--_ui5_textarea_error_placeholder_font_style:italic;--_ui5_textarea_error_placeholder_color:var(--sapField_PlaceholderTextColor);--_ui5_textarea_error_hover_background_color:var(--sapField_Hover_Background);--_ui5_textarea_hover_border:var(--sapField_BorderWidth) var(--sapField_BorderStyle) var(--sapField_Hover_BorderColor);--_ui5_textarea_hover_box_shadow:none;--_ui5_textarea_error_warning_border_style:solid;--_ui5_textarea_disabled_opacity:0.4;--_ui5_textarea_line_height:1.4;--_ui5_textarea_focus_pseudo_element_content:"";--_ui5_textarea_focused_value_state_error_background:var(--sapField_InvalidBackground);--_ui5_textarea_focused_value_state_warning_background:var(--sapField_WarningBackground);--_ui5_textarea_focused_value_state_success_background:var(--sapField_SuccessBackground);--_ui5_textarea_focused_value_state_information_background:var(--sapField_InformationBackground);--_ui5_textarea_focused_value_state_error_focus_outline_color:var(--sapContent_FocusColor);--_ui5_textarea_focused_value_state_warning_focus_outline_color:var(--sapContent_FocusColor);--_ui5_textarea_focused_value_state_success_focus_outline_color:var(--sapContent_FocusColor);--_ui5_textarea_focus_offset:1px;--_ui5_textarea_readonly_focus_offset:1px;--_ui5_textarea_value_state_focus_offset:1px;--_ui5_textarea_focus_outline_color:var(--sapContent_FocusColor);--__ui5_textarea_min_height:2.25rem;--_ui5_textarea_padding_right_and_left:0.5625rem;--_ui5_textarea_padding_right_and_left_error_warning:0.5rem;--_ui5_textarea_padding_right_and_left_information:0.5rem;--_ui5_textarea_padding_right_and_left_readonly:0.5625rem;--_ui5_textarea_padding_top:0.4375rem;--_ui5_textarea_padding_bottom:0.4375rem;--_ui5_textarea_padding_top_readonly:0.4375rem;--_ui5_textarea_padding_bottom_readonly:0.4375rem;--_ui5_textarea_padding_top_error_warning:0.375rem;--_ui5_textarea_padding_bottom_error_warning:0.375rem;--_ui5_textarea_padding_top_information:0.375rem;--_ui5_textarea_padding_bottom_information:0.375rem;--_ui5_textarea_margin:0.25rem 0;--_ui5_textarea_exceeded_text_height:1rem;--_ui5_textarea_readonly_border_style:var(--sapField_BorderStyle)}.sapUiSizeCompact,.ui5-content-density-compact,[data-ui5-compact-size]{--_ui5_textarea_padding_right_and_left:0.4375rem;--_ui5_textarea_padding_right_and_left_error_warning:0.375rem;--_ui5_textarea_padding_right_and_left_information:0.375rem;--_ui5_textarea_padding_right_and_left_readonly:0.4375rem;--_ui5_textarea_padding_top:0.125rem;--_ui5_textarea_padding_bottom:0.125rem;--_ui5_textarea_padding_top_readonly:0.125rem;--_ui5_textarea_padding_bottom_readonly:0.125rem;--_ui5_textarea_padding_top_error_warning:0.0625rem;--_ui5_textarea_padding_bottom_error_warning:0.0625rem;--_ui5_textarea_padding_top_information:0.0625rem;--_ui5_textarea_padding_bottom_information:0.0625rem;--_ui5_textarea_exceeded_text_height:0.375rem;--_ui5_textarea_margin:0.1875rem 0;--__ui5_textarea_min_height:1.625rem}:root{--_ui5-time_picker_border_radius:0;--_ui5_time_picker_border:0.0625rem solid transparent;--_ui5_toast_vertical_offset:3rem;--_ui5_toast_horizontal_offset:2rem;--_ui5_toast_background:var(--sapList_Background);--_ui5_toast_shadow:var(--sapContent_Shadow2);--_ui5_wheelslider_item_text_size:var(--sapFontSize);--_ui5_wheelslider_selected_item_hover_background_color:var(--sapList_BorderColor);--_ui5_wheelslider_label_text_size:var(--sapFontSmallSize);--_ui5_wheelslider_selection_frame_margin_top:calc(var(--_ui5_wheelslider_item_height)*2);--_ui5_wheelslider_mobile_selection_frame_margin_top:calc(var(--_ui5_wheelslider_item_height)*4);--_ui5_wheelslider_label_text_color:var(--sapContent_LabelColor);--_ui5_wheelslider_height:240px;--_ui5_wheelslider_mobile_height:432px;--_ui5_wheelslider_item_width:48px;--_ui5_wheelslider_item_height:46px;--_ui5_wheelslider_arrows_visibility:hidden;--_ui_wheelslider_item_expanded_hover_color:var(--sapList_Hover_Background);--_ui5_wheelslider_item_background_color:var(--sapLegend_WorkingBackground);--_ui5_wheelslider_item_text_color:var(--sapTextColor);--_ui_wheelslider_item_hover_color:var(--sapButton_Emphasized_Hover_BorderColor);--_ui5_wheelslider_item_border_color:var(--sapList_Background);--_ui5_wheelslider_item_hovered_border_color:var(--sapList_Background);--_ui5_wheelslider_collapsed_item_text_color:var(--_ui5_wheelslider_item_border_color);--_ui5_wheelslider_selected_item_background_color:var(--sapContent_Selected_Background);--_ui5_wheelslider_selected_item_hover_background_color:var(--sapButton_Emphasized_Hover_BorderColor);--_ui5_wheelslider_active_item_background_color:var(--sapContent_Selected_Background);--_ui5_wheelslider_active_item_text_color:var(--sapContent_Selected_TextColor);--_ui5_wheelslider_selection_frame_color:var(--sapList_SelectionBorderColor);--_ui_wheelslider_item_border_radius:var(--_ui5_button_border_radius);--_ui5_toggle_button_pressed_focussed:var(--sapButton_Selected_BorderColor);--_ui5_toggle_button_pressed_focussed_hovered:var(--sapButton_Selected_BorderColor);--_ui5_toggle_button_selected_positive_text_color:var(--sapButton_Selected_TextColor);--_ui5_toggle_button_selected_negative_text_color:var(--sapButton_Selected_TextColor);--_ui5_toggle_button_selected_attention_text_color:var(--sapButton_Selected_TextColor);--_ui5_toggle_button_emphasized_pressed_focussed_hovered:var(--sapContent_FocusColor);--_ui5_toggle_button_emphasized_text_shadow:none;--_ui5_yearpicker_item_selected_focus:var(--sapContent_Selected_Background);--_ui5_yearpicker_item_selected_hover_color:var(--sapContent_Selected_Background);--_ui5_yearpicker_item_border:none;--_ui5_yearpicker_item_border_radius:0;--_ui5_yearpicker_item_margin:1px;--_ui5_yearpicker_item_focus_after_width:calc(100% - 0.375rem);--_ui5_yearpicker_item_focus_after_height:calc(100% - 0.375rem);--_ui5_yearpicker_item_focus_after_border:1px dotted var(--sapContent_FocusColor);--_ui5_yearpicker_item_focus_after_offset:2px;--_ui5_yearpicker_item_focus_after_border_radius:0;--_ui5_yearpicker_item_selected_background_color:var(--sapSelectedColor);--_ui5_yearpicker_item_selected_text_color:var(--sapContent_ContrastTextColor);--_ui5_yearpicker_item_selected_box_shadow:none;--_ui5_yearpicker_item_focus_after_outline:none;--_ui5_yearpicker_item_border_radius:0.25rem;--_ui5_calendar_header_arrow_button_border:none;--_ui5_calendar_header_arrow_button_border_radius:0.25rem;--_ui5_calendar_header_middle_button_width:6.25rem;--_ui5_calendar_header_middle_button_flex:1 1 auto;--_ui5_calendar_header_middle_button_focus_border_radius:0.25rem;--_ui5_calendar_header_middle_button_focus_border:none;--_ui5_calendar_header_middle_button_focus_after_display:block;--_ui5_calendar_header_middle_button_focus_after_width:calc(100% - 0.25rem);--_ui5_calendar_header_middle_button_focus_after_height:calc(100% - 0.25rem);--_ui5_calendar_header_middle_button_focus_after_top_offset:1px;--_ui5_calendar_header_middle_button_focus_after_left_offset:1px;--_ui5_calendar_header_button_background_color:none;--_ui5_calendar_header_arrow_button_box_shadow:none;--_ui5_calendar_header_middle_button_focus_background:transparent;--_ui5_calendar_header_middle_button_focus_outline:none;--_ui5_calendar_header_middle_button_focus_active_outline:none;--_ui5_calendar_header_middle_button_focus_active_background:var(--sapButton_Active_Background);--_ui5_calendar_header_middle_button_focus_after_border:1px dotted var(--sapContent_FocusColor);--_ui5_calendar_header_middle_button_focus_after_width:calc(100% - 0.375rem);--_ui5_calendar_header_middle_button_focus_after_height:calc(100% - 0.375rem);--_ui5_calendar_header_middle_button_focus_after_top_offset:0.125rem;--_ui5_calendar_header_middle_button_focus_after_left_offset:0.125rem;--ui5_table_bottom_border:1px solid var(--sapList_BorderColor);--ui5_table_header_row_outline_width:1px;--ui5_table_multiselect_column_width:2.75rem;--ui5_table_header_row_border_bottom_color:var(--sapList_BorderColor);--ui5_table_header_row_border_width:1px;--_ui5_table_load_more_border-bottom:none;--ui5_table_header_row_font_weight:normal;--ui5_table_row_outline_width:1px;--ui5_table_group_row_font-weight:normal;--ui5_table_border_width:0 0 1px 0;--_ui5_load_more_padding:0;--_ui5_load_more_border:1px top solid transparent;--_ui5_load_more_border_radius:none;--_ui5_load_more_outline_width:1px;--_ui5_token_background:var(--sapButton_TokenBackground);--_ui5_token_readonly_background:var(--sapButton_TokenBackground);--_ui5_token_readonly_color:var(--sapContent_LabelColor);--_ui5_token_border_radius:var(--sapButton_BorderCornerRadius);--_ui5_token_outline_offset:-0.125rem;--_ui5_token_text_color:var(--sapButton_TextColor);--_ui5_token_hover_background:var(--sapButton_Hover_Background);--_ui5_token_hover_border_color:var(--sapButton_Hover_BorderColor);--_ui5_token_top_margin:0.25rem;--_ui5_token_bottom_margin:0.25rem;--_ui5_token_right_margin:0.3125rem;--_ui5_token_padding:0.25rem 0;--_ui5_token_left_padding:0.3125rem;--_ui5_token_readonly_padding:0.375rem;--_ui5_token_selected_focus_outline:var(--_ui5_token_focus_outline_width) dotted var(--sapContent_ContrastFocusColor);--_ui5_token_focus_outline:var(--_ui5_token_focus_outline_width) dotted var(--sapContent_FocusColor);--_ui5_token_selected_hover_background:var(--sapButton_Selected_Hover_Background);--_ui5_token_selected_hover_border_color:var(--sapButton_Selected_Hover_BorderColor);--_ui5_token_focused_selected_border:1px solid var(--sapButton_Selected_BorderColor);--ui5_token_focus_pseudo_element_content:none;--_ui5_token_focus_offset:-0.25rem;--_ui5_token_focus_outline_width:0.0625rem;--_ui5_token_text_color:var(--sapTextColor);--_ui5_tokenizer_padding:0.3125rem;--_ui5_tokenizer_n_more_text_color:var(--sapField_TextColor);--_ui5_value_state_message_border:none;--_ui5_value_state_header_border:none;--_ui5_input_value_state_icon_display:none;--_ui5_value_state_message_padding:0.5rem;--_ui5_value_state_header_padding:.5625rem 1rem;--_ui5_value_state_message_popover_box_shadow:none;--_ui5_value_state_message_icon_width:.875rem;--_ui5_value_state_message_icon_height:.875rem;--_ui5_input_value_state_icon_offset:.5rem;--_ui5_value_state_header_offset:-0.125rem;--_ui5_value_state_message_popover_border_radius:0;--_ui5-multi_combobox_token_margin_top:3px;--_ui5-multi_combobox_token_margin_top:1px;--_ui5_slider_progress_container_background:var(--sapField_BorderColor);--_ui5_slider_progress_container_dot_display:none;--_ui5_slider_progress_container_dot_background:var(--sapField_BorderColor);--_ui5_slider_progress_border:none;--_ui5_slider_padding:1.406rem 1.0625rem;--_ui5_slider_inner_height:0.25rem;--_ui5_slider_outer_height:1.6875rem;--_ui5_slider_progress_border_radius:0.25rem;--_ui5_slider_progress_background:var(--sapActiveColor);--_ui5_slider_handle_icon_display:none;--_ui5_slider_handle_height:1.625rem;--_ui5_slider_handle_width:1.625rem;--_ui5_slider_handle_border:solid 0.125rem var(--sapField_BorderColor);--_ui5_slider_handle_border_radius:1rem;--_ui5_slider_handle_box_shadow:none;--_ui5_slider_handle_box_shadow_focus:none;--_ui5_range_slider_handle_background:#fff;--_ui5_slider_handle_top:-0.825rem;--_ui5_slider_tickmark_bg:var(--sapField_BorderColor);--_ui5_slider_tickmark_in_range_bg:var(--sapButton_Active_Background);--_ui5_slider_handle_margin_left:calc(var(--_ui5_slider_handle_width)/2*-1);--_ui5_slider_handle_hover_border:0.125rem solid var(--sapButton_Hover_BorderColor);--_ui5_slider_handle_outline:0.0625rem dotted var(--sapContent_FocusColor);--_ui5_slider_handle_focus_border:var(--_ui5_slider_handle_hover_border);--_ui5_slider_handle_active_border:var(--_ui5_slider_handle_hover_border);--_ui5_slider_handle_focused_top:var(--_ui5_slider_handle_top);--_ui5_slider_handle_focused_margin_left:var(--_ui5_slider_handle_margin_left);--_ui5_slider_handle_outline_offset:0.075rem;--_ui5_slider_icon_left:0.5rem;--_ui5_slider_icon_top:0.125rem;--_ui5_range_slider_handle_hover_background:rgba(var(--sapButton_Background),0.25);--_ui5_range_slider_handle_hover_icon_display:none;--_ui5_slider_progress_outline:0.0625rem dotted var(--sapContent_FocusColor);--_ui5_slider_progress_outline_offset:-0.8125rem;--_ui5_slider_tickmark_top:-0.375rem;--_ui5_slider_disabled_opacity:0.4;--_ui5_slider_tooltip_fontsize:var(--sapFontSmallSize);--_ui5_slider_tooltip_color:var(--sapContent_LabelColor);--_ui5_slider_tooltip_background:var(--sapField_Background);--_ui5_slider_tooltip_border_radius:var(--sapElement_BorderCornerRadius);--_ui5_slider_tooltip_border_color:var(--sapField_BorderColor);--_ui5_slider_tooltip_border:0.0625rem solid var(--_ui5_slider_tooltip_border_color);--_ui5_slider_tooltip_box_shadow:none;--_ui5_slider_tooltip_padding:0.4125rem;--_ui5_slider_tooltip_height:1rem;--_ui5_slider_tooltip_min_width:2rem;--_ui5_slider_tooltip_bottom:2rem;--_ui5_slider_label_fontsize:var(--sapFontSmallSize);--_ui5_slider_label_color:var(--sapContent_LabelColor);--_ui5_range_slider_progress_focus_display:none;--_ui5_range_slider_progress_focus_top:-1.063rem;--_ui5_range_slider_progress_focus_left:-1.438rem;--_ui5_range_slider_progress_focus_padding:0 1.375rem 0 1.438rem;--_ui5_range_slider_progress_focus_height:2rem;--_ui5_range_slider_legacy_progress_focus_display:block;--_ui5_slider_handle_focus_width:0;--_ui5_slider_start_end_point_size:.375rem;--_ui5_slider_start_end_point_left:-0.875rem;--_ui5_slider_start_end_point_top:-.1875rem;--_ui5_slider_handle_hover_box_shadow:none;--_ui5_slider_handle_background_focus:var(--_ui5_slider_handle_background);--_ui5_slider_handle_active_box_shadow:none;--_ui5_slider_handle_focused_tooltip_distance:var(--_ui5_slider_tooltip_bottom);--_ui5_slider_handle_box_sizing:content-box;--_ui5_slider_tooltip_border_box:content-box;--_ui5_range_slider_handle_active_background:var(--_ui5_range_slider_handle_background);--_ui5_range_slider_active_handle_icon_display:none;--_ui5_range_slider_progress_focus_width:100%;--_ui5_slider_tickmark_height:1rem;--_ui5_slider_tickmark_top:-.3125rem;--_ui5_slider_progress_box_sizing:content-box;--_ui5_slider_tickmark_in_range_bg:var(--sapField_BorderColor);--_ui5_range_slider_focus_outline_width:100%;--_ui5_slider_progress_outline_offset_left:0;--_ui5_range_slider_focus_outline_radius:0;--_ui5_slider_progress_container_top:0;--_ui5_slider_progress_height:100%;--_ui5_slider_active_progress_border:none;--_ui5_slider_active_progress_left:0;--_ui5_slider_active_progress_top:0;--_ui5_slider_no_tickmarks_progress_container_top:var(--_ui5_slider_progress_container_top);--_ui5_slider_no_tickmarks_progress_height:var(--_ui5_slider_progress_height);--_ui5_slider_no_tickmarks_active_progress_border:var(--_ui5_slider_active_progress_border);--_ui5_slider_no_tickmarks_active_progress_left:var(--_ui5_slider_active_progress_left);--_ui5_slider_no_tickmarks_active_progress_top:var(--_ui5_slider_active_progress_top);--_ui5_slider_handle_focus_visibility:none;--_ui5_slider_handle_icon_size:1rem}.sapUiSizeCompact,.ui5-content-density-compact,[data-ui5-compact-size]{--_ui5_slider_handle_focused_top:-0.625rem;--_ui5_slider_handle_focused_margin_left:-0.75rem;--_ui5_slider_handle_icon_size:.875rem;--_ui5_slider_padding:1rem 1.0625rem}:root{--_ui5_slider_inner_min_width:4rem;--_ui5_slider_handle_background_focus:var(--sapButton_Background);--_ui5_range_slider_handle_background_focus:transparent;--_ui5_slider_handle_top:-.875rem;--_ui5_range_slider_handle_background:transparent;--_ui5_range_slider_handle_active_background:transparent;--_ui5_slider_handle_background:var(--sapButton_Background);--_ui5_slider_handle_hover_background:var(--sapButton_Hover_Background);--_ui5_range_slider_root_hover_handle_bg:transparent;--_ui5_range_slider_root_hover_handle_icon_display:none;--_ui5_range_slider_root_active_handle_icon_display:none;--_ui5_slider_handle_width:1.875rem;--_ui5_slider_handle_height:1.875rem;--_ui5_slider_handle_box_sizing:border-box;--_ui5_slider_tickmark_top:-.34375rem;--_ui5_step_input_input_error_background_color:var(--sapField_InvalidBackground);--_ui5-step_input_button_state_hover_background_color:var(--sapField_Background);--_ui5_step_input_border_style:1px solid var(--sapField_BorderColor);--_ui5_step_input_border_style_hover:1px solid var(--sapField_Hover_BorderColor);--_ui5_step_input_button_background_color:var(--sapField_Background);--_ui5_step_input_input_border:1px solid transparent;--_ui5_step_input_input_margin_top:-0.0625rem;--_ui5_step_input_button_display:inline-block;--_ui5_step_input_button_left:0;--_ui5_step_input_button_right:0;--_ui5_step_input_input_border_focused_after:var(--_ui5_input_focus_border_width) dotted var(--sapContent_FocusColor);--_ui5_step_input_input_border_top_bottom_focused_after:0.0625rem;--_ui5_step_input_input_border_radius_focused_after:0;--_ui5_step_input_input_information_border_color_focused_after:var(--sapField_BorderColor);--_ui5_step_input_input_warning_border_color_focused_after:var(--sapField_BorderColor);--_ui5_step_input_input_success_border_color_focused_after:var(--sapField_BorderColor);--_ui5_step_input_input_error_border_color_focused_after:var(--sapField_BorderColor);--_ui5_step_input_disabled_button_background:var(--sapField_ReadOnly_Background);--_ui5_step_input_border_color_hover:var(--sapField_Hover_Background);--_ui5_step_input_border_hover:1px solid var(--sapField_Hover_BorderColor);--_ui5_input_input_background_color:var(--sapField_InvalidBackground);--_ui5_step_input_min_width:7.25rem;--_ui5_step_input_padding:2.5rem}.sapUiSizeCompact,.ui5-content-density-compact,[data-ui5-compact-size]{--_ui5_step_input_min_width:6rem;--_ui5_step_input_padding:2rem}' };
Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
var VI = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
const GI = "presentation";
let $I = class extends ZC {
  _onFocusInHandler() {
    this.interactive && (this.focused = true);
  }
  _onFocusOutHandler() {
    this.focused = false;
  }
  _onkeydown(e3) {
    this.interactive && (rS(e3) && this.fireEvent("click"), sS(e3) && e3.preventDefault());
  }
  _onkeyup(e3) {
    this.interactive && sS(e3) && this.fireEvent("click");
  }
  get _dir() {
    return this.ltr ? "ltr" : void 0;
  }
  get effectiveAriaHidden() {
    return "" === this.ariaHidden ? !!this.isDecorative || void 0 : this.ariaHidden;
  }
  get _tabIndex() {
    return this.interactive ? "0" : void 0;
  }
  get isDecorative() {
    return this.effectiveAccessibleRole === GI;
  }
  get effectiveAccessibleRole() {
    return this.accessibleRole ? this.accessibleRole : this.interactive ? "button" : this.effectiveAccessibleName ? "img" : GI;
  }
  async onBeforeRendering() {
    const e3 = this.name;
    if (!e3)
      return console.warn("Icon name property is required", this);
    let t2 = Jx(e3);
    if (t2 || (t2 = await eC(e3)), !t2)
      return this.invalid = true, console.warn(`Required icon is not registered. Invalid icon name: ${this.name}`);
    if ("ICON_NOT_FOUND" === t2)
      return this.invalid = true, console.warn(`Required icon is not registered. You can either import the icon as a module in order to use it e.g. "@ui5/webcomponents-icons/dist/${e3.replace("sap-icon://", "")}.js", or setup a JSON build step and import "@ui5/webcomponents-icons/dist/AllIcons.js".`);
    if (this.viewBox = t2.viewBox || "0 0 512 512", t2.customTemplate && (t2.pathData = [], this.customSvg = WC(t2.customTemplate, this)), this.invalid = false, this.pathData = Array.isArray(t2.pathData) ? t2.pathData : [t2.pathData], this.accData = t2.accData, this.ltr = t2.ltr, this.packageName = t2.packageName, this._onfocusout = this.interactive ? this._onFocusOutHandler.bind(this) : void 0, this._onfocusin = this.interactive ? this._onFocusInHandler.bind(this) : void 0, this.accessibleName)
      this.effectiveAccessibleName = this.accessibleName;
    else if (this.accData) {
      const e4 = await Wx(this.packageName);
      this.effectiveAccessibleName = e4.getText(this.accData) || void 0;
    } else
      this.effectiveAccessibleName = void 0;
  }
  get hasIconTooltip() {
    return this.showTooltip && this.effectiveAccessibleName;
  }
};
VI([tS({ type: UI, defaultValue: UI.Default })], $I.prototype, "design", void 0), VI([tS({ type: Boolean })], $I.prototype, "interactive", void 0), VI([tS()], $I.prototype, "name", void 0), VI([tS()], $I.prototype, "accessibleName", void 0), VI([tS({ type: Boolean })], $I.prototype, "showTooltip", void 0), VI([tS()], $I.prototype, "accessibleRole", void 0), VI([tS()], $I.prototype, "ariaHidden", void 0), VI([tS({ multiple: true })], $I.prototype, "pathData", void 0), VI([tS({ type: Object, defaultValue: void 0, noAttribute: true })], $I.prototype, "accData", void 0), VI([tS({ type: Boolean })], $I.prototype, "focused", void 0), VI([tS({ type: Boolean })], $I.prototype, "invalid", void 0), VI([tS({ noAttribute: true, defaultValue: void 0 })], $I.prototype, "effectiveAccessibleName", void 0), $I = VI([eS({ tag: "ui5-icon", languageAware: true, themeAware: true, renderer: KS, template: function(e3, t2, i2) {
  return XS`<svg class="ui5-icon-root" part="root" tabindex="${jS(this._tabIndex)}" dir="${jS(this._dir)}" viewBox="${jS(this.viewBox)}" role="${jS(this.effectiveAccessibleRole)}" focusable="false" preserveAspectRatio="xMidYMid meet" aria-label="${jS(this.effectiveAccessibleName)}" aria-hidden=${jS(this.effectiveAriaHidden)} xmlns="http://www.w3.org/2000/svg" @focusin=${this._onfocusin} @focusout=${this._onfocusout} @keydown=${this._onkeydown} @keyup=${this._onkeyup}>${OI.call(this, e3, t2, i2)}</svg>`;
}, styles: { packageName: "@ui5/webcomponents", fileName: "themes/Icon.css", content: ":host{-webkit-tap-highlight-color:rgba(0,0,0,0)}:host([hidden]){display:none}:host([invalid]){display:none}:host(:not([hidden]).ui5_hovered){opacity:.7}:host{display:inline-block;width:1rem;height:1rem;color:var(--sapContent_NonInteractiveIconColor);fill:currentColor;outline:none}:host([design=Contrast]){color:var(--sapContent_ContrastIconColor)}:host([design=Critical]){color:var(--sapCriticalElementColor)}:host([design=Default]){color:var(--sapContent_IconColor)}:host([design=Information]){color:var(--sapInformativeElementColor)}:host([design=Negative]){color:var(--sapNegativeElementColor)}:host([design=Neutral]){color:var(--sapNeutralElementColor)}:host([design=NonInteractive]){color:var(--sapContent_NonInteractiveIconColor)}:host([design=Positive]){color:var(--sapPositiveElementColor)}:host([interactive][focused]) .ui5-icon-root{outline:var(--sapContent_FocusWidth) var(--sapContent_FocusStyle) var(--sapContent_FocusColor);border-radius:var(--ui5-icon-focus-border-radius)}.ui5-icon-root{display:flex;height:100%;width:100%;outline:none;vertical-align:top}:host([interactive]){cursor:pointer}.ui5-icon-root:not([dir=ltr]){transform:var(--_ui5_icon_transform_scale);transform-origin:center}" } }), iS("click")], $I), $I.define();
const WI = $I;
Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
var qI, jI = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
let XI = false, YI = null, KI = qI = class extends ZC {
  constructor() {
    super(), this._deactivate = () => {
      YI && (YI.active = false);
    }, XI || (document.addEventListener("mouseup", this._deactivate), XI = true);
    this._ontouchstart = { handleEvent: (e3) => {
      BI(e3, "button"), this.nonInteractive || (this.active = true);
    }, passive: true };
  }
  onEnterDOM() {
    this._isTouch = (gI() || _I()) && !(_I() && mI());
  }
  async onBeforeRendering() {
    const e3 = Ky("FormSupport");
    this.submits && !e3 && console.warn('In order for the "submits" property to have effect, you should also: import "@ui5/webcomponents/dist/features/InputElementsFormSupport.js";'), this.iconOnly = this.isIconOnly, this.hasIcon = !!this.icon, this.buttonTitle = this.tooltip || await (async (e4) => {
      if (!e4)
        return;
      let t2 = Jx(e4);
      if (t2 || (t2 = await eC(e4)), t2 && t2 !== Yx && t2.accData)
        return (await Wx(t2.packageName)).getText(t2.accData);
    })(this.icon);
  }
  _onclick(e3) {
    var _a2;
    if (this.nonInteractive)
      return;
    BI(e3, "button");
    const t2 = Ky("FormSupport");
    t2 && this.submits && t2.triggerFormSubmit(this), pI() && ((_a2 = this.getDomRef()) == null ? void 0 : _a2.focus());
  }
  _onmousedown(e3) {
    this.nonInteractive || this._isTouch || (BI(e3, "button"), this.active = true, YI = this);
  }
  _ontouchend() {
    this.active = false, YI && (YI.active = false);
  }
  _onmouseup(e3) {
    BI(e3, "button");
  }
  _onkeydown(e3) {
    BI(e3, "button"), (sS(e3) || rS(e3)) && (this.active = true);
  }
  _onkeyup(e3) {
    (sS(e3) || rS(e3)) && (this.active = false);
  }
  _onfocusout() {
    this.nonInteractive || (this.active = false, mI() && (this.focused = false));
  }
  _onfocusin(e3) {
    this.nonInteractive || (BI(e3, "button"), mI() && (this.focused = true));
  }
  get hasButtonType() {
    return this.design !== RI.Default && this.design !== RI.Transparent;
  }
  get iconRole() {
    return this.icon ? "presentation" : "";
  }
  get isIconOnly() {
    return e3 = this.text, !(Array.from(e3).filter((e4) => e4.nodeType !== Node.COMMENT_NODE && (e4.nodeType !== Node.TEXT_NODE || 0 !== (e4.nodeValue || "").trim().length)).length > 0);
    var e3;
  }
  static typeTextMappings() {
    return { Positive: cE, Negative: hE, Emphasized: uE };
  }
  get buttonTypeText() {
    return qI.i18nBundle.getText(qI.typeTextMappings()[this.design]);
  }
  get tabIndexValue() {
    const e3 = this.getAttribute("tabindex");
    return e3 || (this.nonInteractive ? "-1" : this._tabIndex);
  }
  get showIconTooltip() {
    return this.iconOnly && !this.tooltip;
  }
  get ariaLabelText() {
    return bI(this);
  }
  static async onDefine() {
    qI.i18nBundle = await Wx("@ui5/webcomponents");
  }
};
jI([tS({ type: RI, defaultValue: RI.Default })], KI.prototype, "design", void 0), jI([tS({ type: Boolean })], KI.prototype, "disabled", void 0), jI([tS()], KI.prototype, "icon", void 0), jI([tS({ type: Boolean })], KI.prototype, "iconEnd", void 0), jI([tS({ type: Boolean })], KI.prototype, "submits", void 0), jI([tS()], KI.prototype, "tooltip", void 0), jI([tS({ defaultValue: void 0 })], KI.prototype, "accessibleName", void 0), jI([tS({ defaultValue: "" })], KI.prototype, "accessibleNameRef", void 0), jI([tS({ type: Object })], KI.prototype, "accessibilityAttributes", void 0), jI([tS({ type: Boolean })], KI.prototype, "active", void 0), jI([tS({ type: Boolean })], KI.prototype, "iconOnly", void 0), jI([tS({ type: Boolean })], KI.prototype, "focused", void 0), jI([tS({ type: Boolean })], KI.prototype, "hasIcon", void 0), jI([tS({ type: Boolean })], KI.prototype, "nonInteractive", void 0), jI([tS({ noAttribute: true })], KI.prototype, "buttonTitle", void 0), jI([tS({ type: Object })], KI.prototype, "_iconSettings", void 0), jI([tS({ defaultValue: "0", noAttribute: true })], KI.prototype, "_tabIndex", void 0), jI([tS({ type: Boolean })], KI.prototype, "_isTouch", void 0), jI([nS({ type: Node, default: true })], KI.prototype, "text", void 0), KI = qI = jI([eS({ tag: "ui5-button", languageAware: true, renderer: KS, template: function(e3, t2, i2) {
  return XS`<button type="button" class="ui5-button-root" ?disabled="${this.disabled}" data-sap-focus-ref  @focusout=${this._onfocusout} @focusin=${this._onfocusin} @click=${this._onclick} @mousedown=${this._onmousedown} @mouseup=${this._onmouseup} @keydown=${this._onkeydown} @keyup=${this._onkeyup} @touchstart="${this._ontouchstart}" @touchend="${this._ontouchend}" tabindex=${jS(this.tabIndexValue)} aria-expanded="${jS(this.accessibilityAttributes.expanded)}" aria-controls="${jS(this.accessibilityAttributes.controls)}" aria-haspopup="${jS(this.accessibilityAttributes.hasPopup)}" aria-label="${jS(this.ariaLabelText)}" title="${jS(this.buttonTitle)}" part="button">${this.icon ? PI.call(this, e3, t2, i2) : void 0}<span id="${jS(this._id)}-content" class="ui5-button-text"><bdi><slot></slot></bdi></span>${this.hasButtonType ? DI.call(this, e3, t2, i2) : void 0}</button> `;
}, styles: { packageName: "@ui5/webcomponents", fileName: "themes/Button.css", content: ':host{vertical-align:middle}.ui5-hidden-text{position:absolute;clip:rect(1px,1px,1px,1px);user-select:none;left:-1000px;top:-1000px;pointer-events:none;font-size:0}:host(:not([hidden])){display:inline-block}:host{min-width:var(--_ui5_button_base_min_width);height:var(--_ui5_button_base_height);line-height:normal;font-family:var(--_ui5_button_fontFamily);font-size:var(--sapFontSize);text-shadow:var(--_ui5_button_text_shadow);border-radius:var(--_ui5_button_border_radius);cursor:pointer;background-color:var(--sapButton_Background);border:var(--sapButton_BorderWidth) solid var(--sapButton_BorderColor);color:var(--sapButton_TextColor);box-sizing:border-box;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.ui5-button-root{min-width:inherit;cursor:inherit;height:100%;width:100%;box-sizing:border-box;display:flex;justify-content:center;align-items:center;outline:none;padding:0 var(--_ui5_button_base_padding);position:relative;background:transparent;border:none;color:inherit;text-shadow:inherit;font:inherit;white-space:inherit;overflow:inherit;text-overflow:inherit;letter-spacing:inherit;word-spacing:inherit;line-height:inherit;-webkit-user-select:none;-moz-user-select:none;user-select:none}:host(:not([active]):not([non-interactive]):not([_is-touch]):not([disabled]):hover),:host(:not([hidden]):not([disabled]).ui5_hovered){background:var(--sapButton_Hover_Background);box-shadow:var(--sapContent_Interaction_Shadow);border:1px solid var(--sapButton_Hover_BorderColor);color:var(--sapButton_Hover_TextColor)}.ui5-button-icon{color:inherit;flex-shrink:0}:host([icon-end]) .ui5-button-root{flex-direction:row-reverse}:host([icon-end]) .ui5-button-icon{margin-inline-start:var(--_ui5_button_base_icon_margin)}:host([icon-only]) .ui5-button-root{min-width:auto;padding:0}:host([icon-only]) .ui5-button-text{display:none}.ui5-button-text{outline:none;position:relative;white-space:inherit;overflow:inherit;text-overflow:inherit}:host([has-icon]:not([icon-end])) .ui5-button-text{margin-inline-start:var(--_ui5_button_base_icon_margin)}:host([has-icon][icon-end]) .ui5-button-text{margin-inline-start:0}:host([disabled]){opacity:var(--sapContent_DisabledOpacity);pointer-events:unset;cursor:default}:host([has-icon]:not([icon-only])) .ui5-button-text{min-width:calc(var(--_ui5_button_base_min_width) - var(--_ui5_button_base_icon_margin) - 1rem)}:host([disabled]:active){pointer-events:none}:host([focused]) .ui5-button-root:after{content:"";position:absolute;box-sizing:border-box;left:.0625rem;top:.0625rem;right:.0625rem;bottom:.0625rem;border:var(--_ui5_button_focused_border);border-radius:var(--_ui5_button_focused_border_radius)}:host([design=Emphasized][focused]) .ui5-button-root:after{border-color:var(--_ui5_button_emphasized_focused_border_color)}:host([design=Emphasized][focused]) .ui5-button-root:before{content:"";position:absolute;box-sizing:border-box;left:.0625rem;top:.0625rem;right:.0625rem;bottom:.0625rem;border:var(--_ui5_button_emphasized_focused_border_before);border-radius:var(--_ui5_button_focused_border_radius)}.ui5-button-root::-moz-focus-inner{border:0}bdi{display:block;white-space:inherit;overflow:inherit;text-overflow:inherit}:host([ui5-button][active]:not([disabled]):not([non-interactive])){background-image:none;background-color:var(--sapButton_Active_Background);border-color:var(--sapButton_Active_BorderColor);color:var(--sapButton_Active_TextColor)}:host([design=Positive]){background-color:var(--sapButton_Accept_Background);border-color:var(--sapButton_Accept_BorderColor);color:var(--sapButton_Accept_TextColor)}:host([design=Positive]:not([active]):not([non-interactive]):not([_is-touch]):not([disabled]).ui5_hovered),:host([design=Positive]:not([active]):not([non-interactive]):not([_is-touch]):not([disabled]):hover){background-color:var(--sapButton_Accept_Hover_Background);border-color:var(--sapButton_Accept_Hover_BorderColor);box-shadow:var(--sapContent_Positive_Shadow);color:var(--sapButton_Accept_Hover_TextColor)}:host([ui5-button][design=Positive][active]:not([non-interactive])){background-color:var(--sapButton_Accept_Active_Background);border-color:var(--sapButton_Accept_Active_BorderColor);color:var(--sapButton_Accept_Active_TextColor)}:host([design=Negative]){background-color:var(--sapButton_Reject_Background);border-color:var(--sapButton_Reject_BorderColor);color:var(--sapButton_Reject_TextColor)}:host([design=Negative]:not([active]):not([non-interactive]):not([_is-touch]):not([disabled]).ui5_hovered),:host([design=Negative]:not([active]):not([non-interactive]):not([_is-touch]):not([disabled]):hover){background-color:var(--sapButton_Reject_Hover_Background);border-color:var(--sapButton_Reject_Hover_BorderColor);box-shadow:var(--sapContent_Negative_Shadow);color:var(--sapButton_Reject_Hover_TextColor)}:host([ui5-button][design=Negative][active]:not([non-interactive])){background-color:var(--sapButton_Reject_Active_Background);border-color:var(--sapButton_Reject_Active_BorderColor);color:var(--sapButton_Reject_Active_TextColor)}:host([design=Attention]){background-color:var(--sapButton_Attention_Background);border-color:var(--sapButton_Attention_BorderColor);color:var(--sapButton_Attention_TextColor)}:host([design=Attention]:not([active]):not([non-interactive]):not([_is-touch]):not([disabled]).ui5_hovered),:host([design=Attention]:not([active]):not([non-interactive]):not([_is-touch]):not([disabled]):hover){background-color:var(--sapButton_Attention_Hover_Background);border-color:var(--sapButton_Attention_Hover_BorderColor);color:var(--sapButton_Attention_Hover_TextColor);box-shadow:var(--sapContent_Critical_Shadow)}:host([ui5-button][design=Attention][active]:not([non-interactive])){background-color:var(--sapButton_Attention_Active_Background);border-color:var(--sapButton_Attention_Active_BorderColor);color:var(--sapButton_Attention_Active_TextColor)}:host([design=Emphasized]){background-color:var(--sapButton_Emphasized_Background);border-color:var(--sapButton_Emphasized_BorderColor);border-width:var(--_ui5_button_emphasized_border_width);color:var(--sapButton_Emphasized_TextColor);font-weight:var(--_ui5_button_emphasized_font_weight)}:host([design=Emphasized]:not([active]):not([non-interactive]):not([_is-touch]):not([disabled]).ui5_hovered),:host([design=Emphasized]:not([active]):not([non-interactive]):not([_is-touch]):not([disabled]):hover){background-color:var(--sapButton_Emphasized_Hover_Background);border-color:var(--sapButton_Emphasized_Hover_BorderColor);border-width:var(--_ui5_button_emphasized_border_width);color:var(--sapButton_Emphasized_Hover_TextColor);box-shadow:none}:host([ui5-button][design=Empasized][active]:not([non-interactive])){background-color:var(--sapButton_Emphasized_Active_Background);border-color:var(--sapButton_Emphasized_Active_BorderColor);color:var(--sapButton_Emphasized_Active_TextColor)}:host([design=Emphasized][focused]) .ui5-button-root:after{border-color:var(--sapContent_ContrastFocusColor);outline:none}:host([design=Transparent]){background-color:var(--sapButton_Lite_Background);color:var(--sapButton_Lite_TextColor);border-color:var(--sapButton_Lite_BorderColor)}:host([design=Transparent]:not([active]):not([non-interactive]):not([_is-touch]):not([disabled]).ui5_hovered),:host([design=Transparent]:not([active]):not([non-interactive]):not([_is-touch]):not([disabled]):hover){background-color:var(--sapButton_Lite_Hover_Background);border-color:var(--sapButton_Lite_Hover_BorderColor);box-shadow:var(--sapContent_Interaction_Shadow);color:var(--sapButton_Lite_Hover_TextColor)}:host([ui5-button][design=Transparent][active]:not([non-interactive])){background-color:var(--sapButton_Lite_Active_Background);border-color:var(--sapButton_Lite_Active_BorderColor);color:var(--sapButton_Active_TextColor)}:host([pressed][focused]) .ui5-button-root:after,:host([ui5-segmented-button-item][active][focused]) .ui5-button-root:after{border-color:var(--_ui5_button_pressed_focused_border_color);outline:none}:host([ui5-segmented-button-item][focused]:not(:last-child)) .ui5-button-root:after{border-top-right-radius:var(--_ui5_button_focused_inner_border_radius);border-bottom-right-radius:var(--_ui5_button_focused_inner_border_radius)}:host([ui5-segmented-button-item][focused]:not(:first-child)) .ui5-button-root:after{border-top-left-radius:var(--_ui5_button_focused_inner_border_radius);border-bottom-left-radius:var(--_ui5_button_focused_inner_border_radius)}' }, dependencies: [WI] }), iS("click")], KI), KI.define();
const ZI = KI;
function JI(e3, t2, i2) {
  return i2 ? XS`<${ZS("ui5-icon", t2, i2)} class="ui5-button-icon" name="${jS(this.icon)}" accessible-role="${jS(this.iconRole)}" part="icon" ?show-tooltip=${this.showIconTooltip}></${ZS("ui5-icon", t2, i2)}>` : XS`<ui5-icon class="ui5-button-icon" name="${jS(this.icon)}" accessible-role="${jS(this.iconRole)}" part="icon" ?show-tooltip=${this.showIconTooltip}></ui5-icon>`;
}
function eT(e3, t2, i2) {
  return XS`<span class="ui5-hidden-text">${jS(this.buttonTypeText)}</span>`;
}
Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
var tT = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
let iT = class extends ZI {
  _onclick() {
    this.pressed = !this.pressed, pI() && this.getDomRef().focus();
  }
  _onkeyup(e3) {
    ((e4) => (e4.key ? "Spacebar" === e4.key || " " === e4.key : e4.keyCode === oS.SPACE) && kS(e4, false, false, true))(e3) ? e3.preventDefault() : super._onkeyup(e3);
  }
};
tT([tS({ type: Boolean })], iT.prototype, "pressed", void 0), iT = tT([eS({ tag: "ui5-toggle-button", template: function(e3, t2, i2) {
  return XS`<button type="button" class="ui5-button-root" ?disabled="${this.disabled}" data-sap-focus-ref  aria-pressed="${jS(this.pressed)}"  @focusout=${this._onfocusout} @focusin=${this._onfocusin} @click=${this._onclick} @mousedown=${this._onmousedown} @mouseup=${this._onmouseup} @keydown=${this._onkeydown} @keyup=${this._onkeyup} @touchstart="${this._ontouchstart}" @touchend="${this._ontouchend}" tabindex=${jS(this.tabIndexValue)} aria-expanded="${jS(this.accessibilityAttributes.expanded)}" aria-controls="${jS(this.accessibilityAttributes.controls)}" aria-haspopup="${jS(this.accessibilityAttributes.hasPopup)}" aria-label="${jS(this.ariaLabelText)}" title="${jS(this.buttonTitle)}" part="button">${this.icon ? JI.call(this, e3, t2, i2) : void 0}<span id="${jS(this._id)}-content" class="ui5-button-text"><bdi><slot></slot></bdi></span>${this.hasButtonType ? eT.call(this, e3, t2, i2) : void 0}</button> `;
}, styles: [ZI.styles, { packageName: "@ui5/webcomponents", fileName: "themes/ToggleButton.css", content: ":host(:not([hidden])){display:inline-block}:host([design=Emphasized]:not([pressed])){text-shadow:var(--_ui5_toggle_button_emphasized_text_shadow)}:host([design=Default][pressed]),:host([design=Emphasized][pressed]),:host([design=Transparent][pressed]),:host([pressed]){background:var(--sapButton_Selected_Background);border-color:var(--sapButton_Selected_BorderColor);color:var(--sapButton_Selected_TextColor);text-shadow:none}:host([design=Default][pressed]:hover),:host([design=Default][pressed]:not([active]):not([non-interactive]):not([_is-touch]):hover),:host([design=Emphasized][pressed]:hover),:host([design=Emphasized][pressed]:not([active]):not([non-interactive]):not([_is-touch]):hover),:host([design=Transparent][pressed]:hover),:host([design=Transparent][pressed]:not([active]):not([non-interactive]):not([_is-touch]):hover),:host([pressed]:hover),:host([pressed]:not([active]):not([non-interactive]):not([_is-touch]):hover){background:var(--sapButton_Selected_Hover_Background);border-color:var(--sapButton_Selected_Hover_BorderColor);color:var(--sapButton_Selected_TextColor);box-shadow:var(--sapContent_Interaction_Shadow)}:host([active][focused]),:host([design=Default][active][focused]),:host([design=Emphasized][active][focused]),:host([design=Transparent][active][focused]){background:var(--sapButton_Active_Background);border-color:var(--sapButton_Active_BorderColor);color:var(--sapButton_Selected_TextColor);box-shadow:var(--sapContent_Interaction_Shadow)}:host([design=Default][pressed]:not([active]):not([non-interactive]):not([_is-touch])),:host([design=Emphasized][pressed]:not([active]):not([non-interactive]):not([_is-touch])),:host([design=Transparent][pressed]:not([active]):not([non-interactive]):not([_is-touch])),:host([pressed]:not([active]):not([non-interactive]):not([_is-touch])){background:var(--sapButton_Selected_Background);border-color:var(--sapButton_Selected_BorderColor);color:var(--sapButton_Selected_TextColor)}:host([design=Negative][pressed]){background:var(--sapButton_Reject_Selected_Background);border-color:var(--sapButton_Reject_Selected_BorderColor);color:var(--sapButton_Reject_Selected_TextColor)}:host([design=Negative][active][focused]){background:var(--sapButton_Reject_Active_Background);border-color:var(--sapButton_Reject_Active_BorderColor);color:var(--sapButton_Reject_Active_TextColor)}:host([design=Negative][pressed]:not([active]):not([non-interactive]):not([_is-touch]):hover),:host([design=Negative][pressed][active]:hover){background:var(--sapButton_Reject_Selected_Hover_Background);border-color:var(--sapButton_Reject_Selected_Hover_BorderColor);color:var(--sapButton_Reject_Selected_TextColor);box-shadow:var(--sapContent_Negative_Shadow)}:host([design=Negative][pressed]:not([active]):not([non-interactive]):not([_is-touch])){background:var(--sapButton_Reject_Selected_Background);border-color:var(--sapButton_Reject_Selected_BorderColor);color:var(--sapButton_Reject_Selected_TextColor)}:host([design=Positive][pressed]){background:var(--sapButton_Accept_Selected_Background);border-color:var(--sapButton_Accept_Selected_BorderColor);color:var(--sapButton_Accept_Selected_TextColor)}:host([design=Positive][active][focused]){background:var(--sapButton_Accept_Active_Background);border-color:var(--sapButton_Accept_Active_BorderColor);color:var(--sapButton_Accept_Selected_TextColor)}:host([design=Positive][pressed]:not([active]):not([non-interactive]):not([_is-touch]):hover),:host([design=Positive][pressed][active]:hover){background:var(--sapButton_Accept_Selected_Hover_Background);border-color:var(--sapButton_Accept_Selected_Hover_BorderColor);color:var(--sapButton_Accept_Selected_TextColor);box-shadow:var(--sapContent_Positive_Shadow)}:host([design=Positive][pressed]:not([active]):not([non-interactive]):not([_is-touch])){background:var(--sapButton_Accept_Selected_Background);border-color:var(--sapButton_Accept_Selected_BorderColor);color:var(--sapButton_Accept_Selected_TextColor)}:host([design=Attention][pressed]){background:var(--sapButton_Attention_Selected_Background);border-color:var(--sapButton_Attention_Selected_BorderColor);color:var(--sapButton_Attention_Selected_TextColor)}:host([design=Attention][active][focused]){background:var(--sapButton_Attention_Active_Background);border-color:var(--sapButton_Attention_Active_BorderColor);color:var(--sapButton_Attention_Active_TextColor)}:host([design=Attention][pressed]:not([active]):not([non-interactive]):not([_is-touch]):hover),:host([design=Attention][pressed][active]:hover){background:var(--sapButton_Attention_Selected_Hover_Background);border-color:var(--sapButton_Attention_Selected_Hover_BorderColor);color:var(--sapButton_Attention_Selected_TextColor);box-shadow:var(--sapContent_Critical_Shadow)}:host([design=Attention][pressed]:not([active]):not([non-interactive]):not([_is-touch])){background:var(--sapButton_Attention_Selected_Background);border-color:var(--sapButton_Attention_Selected_BorderColor);color:var(--sapButton_Attention_Selected_TextColor)}" }] })], iT), iT.define();
const nT = iT;
var oT, rT = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
let sT = oT = class extends nT {
  get ariaDescription() {
    return oT.i18nBundle.getText(VE);
  }
};
rT([tS({ type: RI, defaultValue: RI.Default })], sT.prototype, "design", void 0), rT([tS({ type: Boolean })], sT.prototype, "iconEnd", void 0), rT([tS({ type: Boolean })], sT.prototype, "submits", void 0), rT([tS({ validator: nI, defaultValue: 0 })], sT.prototype, "posInSet", void 0), rT([tS({ validator: nI, defaultValue: 0 })], sT.prototype, "sizeOfSet", void 0), sT = oT = rT([eS({ tag: "ui5-segmented-button-item", template: function(e3, t2, i2) {
  return XS`<li role="option" aria-roledescription="${jS(this.ariaDescription)}" aria-posinset="${jS(this.posInSet)}" aria-setsize="${jS(this.sizeOfSet)}" aria-selected="${jS(this.pressed)}" class="ui5-button-root" aria-disabled="${jS(this.disabled)}" data-sap-focus-ref  @focusout=${this._onfocusout} @focusin=${this._onfocusin} @click=${this._onclick} @mousedown=${this._onmousedown} @mouseup=${this._onmouseup} @keydown=${this._onkeydown} @keyup=${this._onkeyup} @touchstart="${this._ontouchstart}" @touchend="${this._ontouchend}" tabindex=${jS(this.tabIndexValue)} aria-label="${jS(this.ariaLabelText)}" title="${jS(this.tooltip)}">${this.icon ? oI.call(this, e3, t2, i2) : void 0}<span id="${jS(this._id)}-content" class="ui5-button-text"><bdi><slot></slot></bdi></span></li> `;
}, dependencies: [WI] })], sT), sT.define();
const aT = sT;
Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
var lT, cT = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
let hT = lT = class extends ZC {
  static async onDefine() {
    lT.i18nBundle = await Wx("@ui5/webcomponents");
  }
  constructor() {
    super(), this._itemNavigation = new NS(this, { getItemsCallback: () => this.getSlottedNodes("items") }), this.absoluteWidthSet = false, this.percentageWidthSet = false, this.hasPreviouslyFocusedItem = false, this._handleResizeBound = this._doLayout.bind(this);
  }
  onEnterDOM() {
    iE.register(this.parentNode, this._handleResizeBound);
  }
  onExitDOM() {
    this.parentNode && iE.deregister(this.parentNode, this._handleResizeBound);
  }
  onBeforeRendering() {
    this.getSlottedNodes("items").forEach((e3, t2, i2) => {
      e3.posInSet = t2 + 1, e3.sizeOfSet = i2.length;
    }), this.normalizeSelection();
  }
  async onAfterRendering() {
    await this._doLayout();
  }
  prepareToMeasureItems() {
    this.style.width = "", this.items.forEach((e3) => {
      e3.style.width = "";
    });
  }
  async measureItemsWidth() {
    await Nw(), this.prepareToMeasureItems(), this.widths = this.items.map((e3) => e3.offsetWidth + 1);
  }
  normalizeSelection() {
    const e3 = this.items.filter((e4) => e4.pressed), t2 = this._selectedItem ? e3.indexOf(this._selectedItem) : -1;
    this._selectedItem && e3.length > 1 && e3.splice(t2, 1), this._selectedItem = e3.pop(), this._selectedItem && (this.items.forEach((e4) => {
      e4.pressed = false;
    }), this._selectedItem.pressed = true);
  }
  _selectItem(e3) {
    const t2 = e3.target, i2 = t2.hasAttribute("ui5-segmented-button-item");
    if (!t2.disabled && t2 !== this.getDomRef() && i2)
      return t2 !== this._selectedItem && (this._selectedItem && (this._selectedItem.pressed = false), this._selectedItem = t2, this.fireEvent("selection-change", { selectedItem: this._selectedItem })), this._selectedItem.pressed = true, this._itemNavigation.setCurrentItem(this._selectedItem), this.selectedItem.focus(), this;
  }
  _onclick(e3) {
    this._selectItem(e3);
  }
  _onkeydown(e3) {
    rS(e3) ? this._selectItem(e3) : sS(e3) && e3.preventDefault();
  }
  _onkeyup(e3) {
    sS(e3) && this._selectItem(e3);
  }
  _onmousedown(e3) {
    const t2 = e3.target;
    t2.hasAttribute("ui5-segmented-button-item") && (t2.focus(), this._itemNavigation.setCurrentItem(t2), this.hasPreviouslyFocusedItem = true);
  }
  _onfocusin(e3) {
    this.hasPreviouslyFocusedItem ? this._itemNavigation.setCurrentItem(e3.target) : this.selectedItem && (this.selectedItem.focus(), this._itemNavigation.setCurrentItem(this._selectedItem), this.hasPreviouslyFocusedItem = true);
  }
  async _doLayout() {
    this.widths && this.widths.some((e4) => e4 > 2) || await this.measureItemsWidth();
    const e3 = this.parentNode ? this.parentNode.offsetWidth : 0;
    this.style.width && !this.percentageWidthSet || (this.style.width = Math.max(...this.widths) * this.items.length + "px", this.absoluteWidthSet = true), this.items.forEach((e4) => {
      e4.style.width = "100%";
    }), e3 <= this.offsetWidth && this.absoluteWidthSet && (this.style.width = "100%", this.percentageWidthSet = true);
  }
  get selectedItem() {
    return this._selectedItem;
  }
  get ariaDescribedBy() {
    return lT.i18nBundle.getText(QE);
  }
  get ariaDescription() {
    return lT.i18nBundle.getText(HE);
  }
};
cT([tS({ defaultValue: void 0 })], hT.prototype, "accessibleName", void 0), cT([nS({ type: HTMLElement, invalidateOnChildChange: true, default: true })], hT.prototype, "items", void 0), hT = lT = cT([eS({ tag: "ui5-segmented-button", languageAware: true, renderer: KS, template: function(e3, t2, i2) {
  return XS`<ul @click="${this._onclick}" @mousedown="${this._onmousedown}" @keydown="${this._onkeydown}" @keyup="${this._onkeyup}" @focusin="${this._onfocusin}" class="ui5-segmented-button-root" role="listbox" aria-multiselectable="true" aria-describedby="${jS(this._id)}-invisibleText" aria-roledescription=${jS(this.ariaDescription)} aria-label=${jS(this.accessibleName)}><slot></slot><span id="${jS(this._id)}-invisibleText" class="ui5-hidden-text">${jS(this.ariaDescribedBy)}</span></ul>`;
}, styles: { packageName: "@ui5/webcomponents", fileName: "themes/SegmentedButton.css", content: ":host{vertical-align:middle}.ui5-hidden-text{position:absolute;clip:rect(1px,1px,1px,1px);user-select:none;left:-1000px;top:-1000px;pointer-events:none;font-size:0}:host(:not([hidden])){display:inline-block}.ui5-segmented-button-root{display:flex;margin:0;padding:0;background-color:var(--sapButton_Background);border-radius:var(--_ui5_segmented_btn_outer_border_radius)}::slotted([ui5-segmented-button-item]){border-radius:var(--_ui5_segmented_btn_inner_border_radius);height:var(--_ui5_button_base_height);min-width:2.5rem;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;z-index:auto}::slotted([ui5-segmented-button-item]:hover){z-index:2}::slotted([ui5-segmented-button-item][active]),::slotted([ui5-segmented-button-item][pressed]){border:.0625rem solid var(--sapButton_Selected_BorderColor);background-color:var(--sapButton_Selected_Background);color:var(--sapButton_Selected_TextColor)}::slotted([ui5-segmented-button-item][pressed]:hover){border:.0625rem solid var(--sapButton_Selected_Hover_BorderColor);background-color:var(--sapButton_Selected_Hover_Background);color:var(--sapButton_Selected_TextColor)}::slotted([ui5-segmented-button-item]:nth-child(odd)){border-inline-end:var(--_ui5_segmented_btn_inner_border_odd_child);border-inline-start:var(--_ui5_segmented_btn_inner_border_odd_child)}::slotted([ui5-segmented-button-item][active]:nth-child(odd)),::slotted([ui5-segmented-button-item][pressed]:nth-child(odd)){border-inline-end:var(--_ui5_segmented_btn_inner_pressed_border_odd_child);border-inline-start:var(--_ui5_segmented_btn_inner_pressed_border_odd_child)}::slotted([ui5-segmented-button-item]:last-child){border-start-end-radius:var(--_ui5_segmented_btn_border_radius);border-end-end-radius:var(--_ui5_segmented_btn_border_radius);border-inline-end:var(--_ui5_segmented_btn_inner_border)}::slotted([ui5-segmented-button-item][active]:last-child),::slotted([ui5-segmented-button-item][pressed]:last-child){border-inline-end:.0625rem solid var(--sapButton_Selected_BorderColor)}::slotted([ui5-segmented-button-item]:first-child){border-start-start-radius:var(--_ui5_segmented_btn_border_radius);border-end-start-radius:var(--_ui5_segmented_btn_border_radius);border-inline-start:var(--_ui5_segmented_btn_inner_border)}::slotted([ui5-segmented-button-item][active]:first-child),::slotted([ui5-segmented-button-item][pressed]:first-child){border-inline-start:.0625rem solid var(--sapButton_Selected_BorderColor)}::slotted([ui5-segmented-button-item][active]:not([active]):hover){border-color:var(--sapButton_BorderColor)}::slotted([ui5-segmented-button-item][active]:hover){border-color:var(--sapButton_Selected_BorderColor)}" }, dependencies: [aT] }), iS("selection-change", { detail: { selectedItem: { type: HTMLElement } } })], hT), hT.define();
const uT = { key: "ICON_ADD", defaultText: "Add" }, dT = { key: "ICON_DECLINE", defaultText: "Decline" }, pT = { key: "ICON_ERROR", defaultText: "Error" }, _T = "M86 109l22-23q5-5 12-5 6 0 11 5l124 125L380 86q5-5 11-5 7 0 12 5l22 23q12 11 0 23L301 256l124 125q11 11 0 22l-22 23q-8 5-12 5-3 0-11-5L255 301 131 426q-5 5-11 5-4 0-12-5l-22-23q-11-11 0-22l124-125L86 132q-12-12 0-23z";
Kx("decline", { pathData: _T, ltr: false, accData: dT, collection: "SAP-icons-v4", packageName: "@ui5/webcomponents-icons" });
const gT = "M292 256l117 117q7 7 7 18t-7.5 18-18.5 7-18-7L256 293 140 409q-7 7-18 7t-18.5-7-7.5-18 7-18l117-117-117-116q-7-7-7-18t7.5-18.5T122 96q10 0 18 8l116 116 116-116q8-8 18-8 11 0 18.5 7.5T416 122t-7 18z";
Kx("decline", { pathData: gT, ltr: false, accData: dT, collection: "SAP-icons-v5", packageName: "@ui5/webcomponents-icons" }), dx();
const mT = "M0 512L512 0v512H0zm77-32h403V77l-77 77 45 45-23 23-45-45-22 22 45 45-23 23-45-45-22 23 44 45-22 22-45-45-23 23 45 45-22 22-45-44-23 22 45 45-23 23-45-45-22 22 45 45-23 23-45-45zm204-32l167-167v167H281zm135-32v-58l-58 58h58z";
Kx("unit", { pathData: mT, ltr: false, collection: "tnt-v2", packageName: "@ui5/webcomponents-icons-tnt" });
const fT = "M485 509H29q-11 0-18-7t-7-18 7-18 18-7h456q11 0 18 7t7 18-7 18-18 7zm-75-101H302l108-109v109zm75 101q-11 0-18-7t-7-18V28q0-11 7-18.5T485 2t18 7.5 7 18.5v456q0 11-7 18t-18 7zm-456 0q-11 0-18-7-7-8-7-18.5t7-17.5L467 10q8-8 18.5-8t17.5 8q8 8 8 18t-8 17L47 502q-7 7-18 7zm188-119q-11 0-18-7l-26-25q-8-8-7.5-18.5T173 322q8-8 18.5-8t18.5 8l25 25q8 8 7.5 18t-7.5 18q-7 7-18 7zm76-76q-11 0-18-7l-26-26q-7-7-7-17t7-18q8-8 18.5-8t17.5 8l26 25q8 8 8 18t-8 18q-7 7-18 7zm76-76q-11 0-18-8l-25-25q-8-8-8-17.5t8-17.5 17.5-8 17.5 8l26 25q8 8 8 18t-8 17q-7 8-18 8z";
Kx("unit", { pathData: fT, ltr: false, collection: "tnt-v3", packageName: "@ui5/webcomponents-icons-tnt" }), dx();
var vT = Object.defineProperty, AT = Object.getOwnPropertyDescriptor, bT = (e3, t2, i2, n2) => {
  for (var o2, r2 = n2 > 1 ? void 0 : n2 ? AT(t2, i2) : t2, s2 = e3.length - 1; s2 >= 0; s2--)
    (o2 = e3[s2]) && (r2 = (n2 ? o2(t2, i2, r2) : o2(r2)) || r2);
  return n2 && r2 && vT(t2, i2, r2), r2;
};
let yT = class extends ae {
  constructor() {
    super(...arguments), this.title = "", this.icon = "", this.isSelected = false;
  }
  render() {
    return z`
        	<slot></slot>
        `;
  }
  updated(e3) {
    super.updated(e3), e3.has("isSelected") && (this.hidden = !this.isSelected);
  }
};
function wT(e3, t2, i2) {
  return XS`<div class="ui5-card-header-root"><slot name="header"></slot></div>`;
}
yT.styles = r`
  :host {
    max-height: 100%;
    max-width: 100%;
  }
`, bT([ue()], yT.prototype, "title", 2), bT([ue()], yT.prototype, "icon", 2), bT([ue({ type: Boolean, reflect: true })], yT.prototype, "isSelected", 2), yT = bT([ce("pv-menu-item")], yT), Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
var xT, CT = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
let ST = xT = class extends ZC {
  get classes() {
    return { root: { "ui5-card-root": true, "ui5-card--interactive": this._hasHeader && this.header[0].interactive, "ui5-card--nocontent": !this.content.length } };
  }
  get _hasHeader() {
    return !!this.header.length;
  }
  get _getAriaLabel() {
    const e3 = bI(this), t2 = e3 ? ` ${e3}` : "";
    return xT.i18nBundle.getText(oE) + t2;
  }
  get _ariaCardContentLabel() {
    return xT.i18nBundle.getText(nE);
  }
  static async onDefine() {
    xT.i18nBundle = await Wx("@ui5/webcomponents");
  }
};
function ET(e3, t2, i2) {
  return XS`<div id="${jS(this._id)}-avatar" class="ui5-card-header-avatar" aria-label="${jS(this.ariaCardAvatarLabel)}"><slot name="avatar"></slot></div>`;
}
function IT(e3, t2, i2) {
  return XS`<div id="${jS(this._id)}-title" class="ui5-card-header-title" part="title" role="heading" aria-level="3">${jS(this.titleText)}</div>`;
}
function TT(e3, t2, i2) {
  return XS`<div class="ui5-card-header-status"><span id="${jS(this._id)}-status" part="status" dir="auto">${jS(this.status)}</span></div>`;
}
function BT(e3, t2, i2) {
  return XS`<div id="${jS(this._id)}-subtitle" class="ui5-card-header-subtitle" part="subtitle">${jS(this.subtitleText)}</div>`;
}
function MT(e3, t2, i2) {
  return XS`<div class="ui5-card-header-action" @focusin="${this._actionsFocusin}" @focusout="${this._actionsFocusout}"><slot name="action"></slot></div>`;
}
CT([tS()], ST.prototype, "accessibleName", void 0), CT([tS()], ST.prototype, "accessibleNameRef", void 0), CT([nS({ type: HTMLElement, default: true })], ST.prototype, "content", void 0), CT([nS({ type: HTMLElement, invalidateOnChildChange: true })], ST.prototype, "header", void 0), ST = xT = CT([eS({ tag: "ui5-card", languageAware: true, renderer: KS, template: function(e3, t2, i2) {
  return XS`<div class="${WS(this.classes.root)}" role="region" aria-label="${jS(this._getAriaLabel)}">${this._hasHeader ? wT.call(this, e3, t2, i2) : void 0}<div role="group" aria-label="${jS(this._ariaCardContentLabel)}"><slot></slot></div></div>`;
}, styles: { packageName: "@ui5/webcomponents", fileName: "themes/Card.css", content: '.ui5-hidden-text{position:absolute;clip:rect(1px,1px,1px,1px);user-select:none;left:-1000px;top:-1000px;pointer-events:none;font-size:0}:host(:not([hidden])){display:inline-block;width:100%}.ui5-card-root{width:100%;height:100%;color:var(--sapGroup_TitleTextColor);background:var(--sapTile_Background);box-shadow:var(--_ui5_card_box_shadow);border-radius:var(--_ui5_card_border-radius);border:var(--_ui5_card_border);overflow:hidden;font-family:"72override",var(--sapFontFamily);font-size:var(--sapFontSize);box-sizing:border-box}.ui5-card-root.ui5-card--interactive:hover{box-shadow:var(--_ui5_card_hover_box_shadow)}.ui5-card-root.ui5-card--interactive:active{box-shadow:var(--_ui5_card_box_shadow)}.ui5-card-root.ui5-card--nocontent{height:auto}.ui5-card-root.ui5-card--nocontent .ui5-card-header-root{border-bottom:none}.ui5-card--nocontent ::slotted([ui5-card-header]){--_ui5_card_header_focus_bottom_radius:var(--_ui5_card_header_focus_radius)}.ui5-card-root .ui5-card-header-root{border-bottom:var(--_ui5_card_header_border)}' }, dependencies: [WI] })], ST), ST.define(), Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
var kT, RT = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
let PT = kT = class extends ZC {
  get classes() {
    return { root: { "ui5-card-header": true, "ui5-card-header--interactive": this.interactive, "ui5-card-header--active": this.interactive && this._headerActive, "ui5-card-header-ff": sI.firefox } };
  }
  get _root() {
    return this.shadowRoot.querySelector(".ui5-card-header");
  }
  get ariaRoleDescription() {
    return this.interactive ? kT.i18nBundle.getText(sE) : kT.i18nBundle.getText(rE);
  }
  get ariaRoleFocusableElement() {
    return this.interactive ? "button" : null;
  }
  get ariaCardAvatarLabel() {
    return kT.i18nBundle.getText(aE);
  }
  get ariaLabelledBy() {
    const e3 = [];
    return this.titleText && e3.push(`${this._id}-title`), this.subtitleText && e3.push(`${this._id}-subtitle`), this.status && e3.push(`${this._id}-status`), this.hasAvatar && e3.push(`${this._id}-avatar`), 0 !== e3.length ? e3.join(" ") : void 0;
  }
  get hasAvatar() {
    return !!this.avatar.length;
  }
  get hasAction() {
    return !!this.action.length;
  }
  static async onDefine() {
    kT.i18nBundle = await Wx("@ui5/webcomponents");
  }
  _actionsFocusin() {
    this._root.classList.add("ui5-card-header-hide-focus");
  }
  _actionsFocusout() {
    this._root.classList.remove("ui5-card-header-hide-focus");
  }
  _click(e3) {
    e3.stopImmediatePropagation(), this.interactive && this._root.contains(e3.target) && this.fireEvent("click");
  }
  _keydown(e3) {
    if (!this.interactive || !this._root.contains(e3.target))
      return;
    const t2 = rS(e3), i2 = sS(e3);
    this._headerActive = t2 || i2, t2 ? this.fireEvent("click") : i2 && e3.preventDefault();
  }
  _keyup(e3) {
    if (!this.interactive || !this._root.contains(e3.target))
      return;
    const t2 = sS(e3);
    this._headerActive = false, t2 && this.fireEvent("click");
  }
};
var DT;
RT([tS()], PT.prototype, "titleText", void 0), RT([tS()], PT.prototype, "subtitleText", void 0), RT([tS()], PT.prototype, "status", void 0), RT([tS({ type: Boolean })], PT.prototype, "interactive", void 0), RT([tS({ validator: nI, defaultValue: 3 })], PT.prototype, "_ariaLevel", void 0), RT([tS({ type: Boolean, noAttribute: true })], PT.prototype, "_headerActive", void 0), RT([nS()], PT.prototype, "avatar", void 0), RT([nS()], PT.prototype, "action", void 0), PT = kT = RT([eS({ tag: "ui5-card-header", languageAware: true, renderer: KS, template: function(e3, t2, i2) {
  return XS`<div id="${jS(this._id)}--header" class="${WS(this.classes.root)}" role="group" aria-roledescription="${jS(this.ariaRoleDescription)}" @click="${this._click}" @keydown="${this._keydown}" @keyup="${this._keyup}" part="root"><div class="ui5-card-header-focusable-element" aria-labelledby="${jS(this.ariaLabelledBy)}" role="${jS(this.ariaRoleFocusableElement)}" data-sap-focus-ref tabindex="0">${this.hasAvatar ? ET.call(this, e3, t2, i2) : void 0}<div class="ui5-card-header-text"><div class="ui5-card-header-first-line">${this.titleText ? IT.call(this, e3, t2, i2) : void 0}${this.status ? TT.call(this, e3, t2, i2) : void 0}</div>${this.subtitleText ? BT.call(this, e3, t2, i2) : void 0}</div></div>${this.hasAction ? MT.call(this, e3, t2, i2) : void 0}</div></div>`;
}, styles: { packageName: "@ui5/webcomponents", fileName: "themes/CardHeader.css", content: '.ui5-hidden-text{position:absolute;clip:rect(1px,1px,1px,1px);user-select:none;left:-1000px;top:-1000px;pointer-events:none;font-size:0}.ui5-card-header{position:relative;display:flex;align-items:center;padding:var(--_ui5_card_header_padding);outline:none}:host([subtitleText]) .ui5-card-header{align-items:flex-start}.ui5-card-header.ui5-card-header-ff:not(.ui5-card-header-hide-focus):focus-within:before{outline:none;content:"";position:absolute;border:var(--_ui5_card_header_focus_border);pointer-events:none;top:var(--_ui5_card_header_focus_offset);left:var(--_ui5_card_header_focus_offset);right:var(--_ui5_card_header_focus_offset);bottom:var(--_ui5_card_header_focus_offset);border-top-left-radius:var(--_ui5_card_header_focus_radius);border-top-right-radius:var(--_ui5_card_header_focus_radius);border-bottom-left-radius:var(--_ui5_card_header_focus_bottom_radius);border-bottom-right-radius:var(--_ui5_card_header_focus_bottom_radius)}.ui5-card-header:not(.ui5-card-header-ff):not(.ui5-card-header-hide-focus):has(.ui5-card-header-focusable-element:focus-visible):before{outline:none;content:"";position:absolute;border:var(--_ui5_card_header_focus_border);pointer-events:none;top:var(--_ui5_card_header_focus_offset);left:var(--_ui5_card_header_focus_offset);right:var(--_ui5_card_header_focus_offset);bottom:var(--_ui5_card_header_focus_offset);border-top-left-radius:var(--_ui5_card_header_focus_radius);border-top-right-radius:var(--_ui5_card_header_focus_radius);border-bottom-left-radius:var(--_ui5_card_header_focus_bottom_radius);border-bottom-right-radius:var(--_ui5_card_header_focus_bottom_radius)}.ui5-card-header-focusable-element{outline:none}.ui5-card-header-focusable-element{display:inherit;align-items:inherit;flex:1}.ui5-card-header.ui5-card-header--interactive:hover{cursor:pointer;background:var(--_ui5_card_header_hover_bg)}.ui5-card-header.ui5-card-header--active,.ui5-card-header.ui5-card-header--interactive:active{background:var(--_ui5_card_header_active_bg)}.ui5-card-header .ui5-card-header-text{flex:1;pointer-events:none}.ui5-card-header-first-line{display:flex;flex-flow:row;justify-content:space-between}.ui5-card-header-status{flex:none}.ui5-card-header .ui5-card-header-avatar{height:3rem;width:3rem;display:flex;align-items:center;justify-content:center;margin-inline-end:.75rem;pointer-events:none;align-self:flex-start}::slotted([ui5-icon]){width:1.5rem;height:1.5rem;color:var(--sapTile_IconColor)}::slotted(img[slot=avatar]){width:100%;height:100%;border-radius:50%}.ui5-card-header .ui5-card-header-status{display:inline-block;font-family:"72override",var(--sapFontFamily);font-size:var(--sapFontSmallSize);color:var(--sapTile_TextColor);text-align:left;text-overflow:ellipsis;overflow:hidden;white-space:nowrap;vertical-align:middle;margin-inline-start:1rem;margin-block-start:.125rem}.ui5-card-header .ui5-card-header-text .ui5-card-header-title{font-family:var(--_ui5_card_header_title_font_family);font-size:var(--_ui5_card_header_title_font_size);font-weight:var(--_ui5_card_header_title_font_weight);color:var(--sapTile_TitleTextColor);max-height:3.5rem;align-self:flex-end}.ui5-card-header .ui5-card-header-text .ui5-card-header-subtitle{font-family:"72override",var(--sapFontFamily);font-size:var(--sapFontSize);font-weight:400;color:var(--sapTile_TextColor);margin-top:var(--_ui5_card_header_subtitle_margin_top);max-height:2.1rem}.ui5-card-header .ui5-card-header-text .ui5-card-header-subtitle,.ui5-card-header .ui5-card-header-text .ui5-card-header-title{text-align:start;text-overflow:ellipsis;white-space:normal;word-wrap:break-word;overflow:hidden;-webkit-line-clamp:2;-webkit-box-orient:vertical;display:-webkit-box;max-width:100%}.ui5-card-header .ui5-card-header-text .ui5-card-header-title{-webkit-line-clamp:3}.ui5-card-header-action{display:flex;padding-inline-start:1rem;align-self:flex-start}' } }), iS("click")], PT), PT.define(), function(e3) {
  e3.H1 = "H1", e3.H2 = "H2", e3.H3 = "H3", e3.H4 = "H4", e3.H5 = "H5", e3.H6 = "H6";
}(DT || (DT = {}));
const LT = DT;
var FT;
!function(e3) {
  e3.None = "None", e3.Normal = "Normal";
}(FT || (FT = {}));
const NT = FT;
function OT(e3, t2, i2) {
  return XS`<h1 class="ui5-title-root"><span id="${jS(this._id)}-inner"><slot></slot></span></h1>`;
}
function zT(e3, t2, i2) {
  return XS`<h2 class="ui5-title-root"><span id="${jS(this._id)}-inner"><slot></slot></span></h2>`;
}
function UT(e3, t2, i2) {
  return XS`<h3 class="ui5-title-root"><span id="${jS(this._id)}-inner"><slot></slot></span></h3>`;
}
function HT(e3, t2, i2) {
  return XS`<h4 class="ui5-title-root"><span id="${jS(this._id)}-inner"><slot></slot></span></h4>`;
}
function QT(e3, t2, i2) {
  return XS`<h5 class="ui5-title-root"><span id="${jS(this._id)}-inner"><slot></slot></span></h5>`;
}
function VT(e3, t2, i2) {
  return XS`<h6 class="ui5-title-root"><span id="${jS(this._id)}-inner"><slot></slot></span></h6>`;
}
Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
var GT = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
let $T = class extends ZC {
  get normalizedLevel() {
    return this.level.toLowerCase();
  }
  get h1() {
    return "h1" === this.normalizedLevel;
  }
  get h2() {
    return "h2" === this.normalizedLevel;
  }
  get h3() {
    return "h3" === this.normalizedLevel;
  }
  get h4() {
    return "h4" === this.normalizedLevel;
  }
  get h5() {
    return "h5" === this.normalizedLevel;
  }
  get h6() {
    return "h6" === this.normalizedLevel;
  }
};
GT([tS({ type: NT, defaultValue: NT.None })], $T.prototype, "wrappingType", void 0), GT([tS({ type: LT, defaultValue: LT.H2 })], $T.prototype, "level", void 0), $T = GT([eS({ tag: "ui5-title", renderer: KS, template: function(e3, t2, i2) {
  return XS`${this.h1 ? OT.call(this, e3, t2, i2) : void 0}${this.h2 ? zT.call(this, e3, t2, i2) : void 0}${this.h3 ? UT.call(this, e3, t2, i2) : void 0}${this.h4 ? HT.call(this, e3, t2, i2) : void 0}${this.h5 ? QT.call(this, e3, t2, i2) : void 0}${this.h6 ? VT.call(this, e3, t2, i2) : void 0}`;
}, styles: { packageName: "@ui5/webcomponents", fileName: "themes/Title.css", content: ':host(:not([hidden])){display:block;cursor:text}:host{max-width:100%;color:var(--sapGroup_TitleTextColor);font-size:var(--sapFontHeader2Size);font-family:"72override",var(--sapFontHeaderFamily);text-shadow:var(--sapContent_TextShadow)}.ui5-title-root{display:inline-block;position:relative;font-weight:400;font-size:inherit;box-sizing:border-box;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:100%;vertical-align:bottom;-webkit-margin-before:0;-webkit-margin-after:0;-webkit-margin-start:0;-webkit-margin-end:0;margin:0;cursor:inherit}:host([wrapping-type=Normal]) .ui5-title-root,:host([wrapping-type=Normal]) ::slotted(*){white-space:pre-line}::slotted(*){font-size:inherit;font-family:inherit;text-shadow:inherit}:host([level=H1]){font-size:var(--sapFontHeader1Size)}:host([level=H2]){font-size:var(--sapFontHeader2Size)}:host([level=H3]){font-size:var(--sapFontHeader3Size)}:host([level=H4]){font-size:var(--sapFontHeader4Size)}:host([level=H5]){font-size:var(--sapFontHeader5Size)}:host([level=H6]){font-size:var(--sapFontHeader6Size)}' } })], $T), $T.define();
const WT = $T;
var qT;
!function(e3) {
  e3.Header = "Header", e3.Subheader = "Subheader", e3.Footer = "Footer", e3.FloatingFooter = "FloatingFooter";
}(qT || (qT = {}));
const jT = qT;
const XT = { packageName: "@ui5/webcomponents-fiori", fileName: "themes/sap_fiori_3/parameters-bundle.css", content: ":root{--_ui5_bar_base_height:2.75rem;--_ui5_bar_subheader_height:3rem}.sapUiSizeCompact,.ui5-content-density-compact,[data-ui5-compact-size]{--_ui5_bar_base_height:2.5rem;--_ui5_bar_subheader_height:2.25rem}:root{--_ui5_fcl_solid_bg:var(--sapShell_Background);--_ui5_fcl_column_border:none;--_ui5_fcl_decoration_top:linear-gradient(0deg,var(--sapHighlightColor),transparent);--_ui5_fcl_decoration_bottom:linear-gradient(180deg,var(--sapHighlightColor),transparent);--sapIllus_BrandColorPrimary:var(--sapContent_Illustrative_Color1);--sapIllus_BrandColorSecondary:var(--sapContent_Illustrative_Color2);--sapIllus_StrokeDetailColor:var(--sapContent_Illustrative_Color4);--sapIllus_Layering1:var(--sapContent_Illustrative_Color5);--sapIllus_Layering2:var(--sapContent_Illustrative_Color6);--sapIllus_BackgroundColor:var(--sapContent_Illustrative_Color7);--sapIllus_ObjectFillColor:var(--sapContent_Illustrative_Color8);--sapIllus_AccentColor:var(--sapContent_Illustrative_Color3);--sapIllus_NoColor:none;--sapIllus_PatternShadow:url(#sapIllus_PatternShadow);--sapIllus_PatternHighlight:url(#sapIllus_PatternHighlight);--_ui5_media_gallery_overflow_btn_background:var(--sapButton_Neutral_Background);--_ui5_media_gallery_overflow_btn_color:var(--sapBaseColor);--_ui5_media_gallery_overflow_btn_border:none;--_ui5_media_gallery_thumbnail_border:1px solid var(--sapContent_ForegroundColor);--_ui5_media_gallery_thumbnail_selected_border:2px solid var(--sapSelectedColor);--_ui5_media_gallery_thumbnail_focus_outline:var(--sapContent_FocusWidth) var(--sapContent_FocusStyle) var(--sapContent_FocusColor);--_ui5_media_gallery_item_overlay_box_shadow:inset 0px 0px 80px rgba(0,0,0,0.2);--_ui5_page_list_bg:var(--sapGroup_ContentBackground);--_ui5_page_transparent_bg:transparent;--_ui5_product_switch_item_width:11.25rem;--_ui5_product_switch_item_height:7rem;--_ui5_product_switch_item_outline_width:.0625rem;--_ui5_product_switch_item_outline_color:var(--sapContent_FocusColor);--_ui5_product_switch_item_outline:var(--_ui5_product_switch_item_outline_width) var(--_ui5_product_switch_item_outline_color) dotted;--_ui5_product_switch_item_active_outline_color:var(--sapContent_ContrastFocusColor);--_ui5_product_switch_item_outline_offset:-.1875rem;--_ui5_product_switch_item_outline_offset_positive:.1875rem;--_ui5_shellbar_root_height:2.75rem;--_ui5_shellbar_logo_outline_color:var(--sapContent_ContrastFocusColor);--_ui5_shellbar_logo_outline:var(--sapContent_FocusWidth) var(--sapContent_FocusStyle) var(--_ui5_shellbar_logo_outline_color);--_ui5_shellbar_outline_offset:-0.0625rem;--_ui5_shellbar_logo_outline_offset:var(--_ui5_shellbar_outline_offset);--_ui5_shellbar_button_box_shadow:none;--_ui5_shellbar_button_border:none;--_ui5_shellbar_button_border_radius:0.25rem;--_ui5_shellbar_button_active_color:var(--sapShell_Active_TextColor);--_ui5_shellbar_logo_outline_border_radius:0;--_ui5_shellbar_copilot_stop_color1:#c0d9f2;--_ui5_shellbar_copilot_stop_color2:#fff;--_ui5_shellbar_copilot_focus_offset:0;--_ui5_shellbar_search_button_size:2.25rem;--_ui5_shellbar_search_field_height:2.25rem;--_ui5_shellbar_search_button_border_radius:0.25rem;--_ui5_shellbar_search_field_background:var(--sapShellColor);--_ui5_shellbar_search_field_border:1px solid var(--sapShell_InteractiveBorderColor);--_ui5_shellbar_search_field_color:var(--sapShell_TextColor);--_ui5_shellbar_search_field_outline_focused:1px dotted var(--sapContent_ContrastFocusColor);--_ui5_shellbar_overflow_container_middle_height:2.5rem;--_ui5_shellbar_menu_button_title_font_size:0.75rem}[ui5-shellbar]{--_ui5_button_focused_border:0.0625rem dotted var(--sapContent_ContrastFocusColor)}:root{--_ui5_side_navigation_separator_backgound:var(--sapList_GroupHeaderBorderColor);--_ui5_side_navigation_icon_color:var(--sapContent_IconColor);--_ui5_side_navigation_icon_size:1rem;--_ui5_side_navigation_toggle_icon_size:1rem;--_ui5_side_navigation_collapsed_state_width:3.25rem;--_ui5_side_navigation_indent_step:2.25rem;--_ui5_side_navigation_icon_padding:1.125rem;--_ui5_TimelineItem_arrow_size:1.625rem;--_ui5_TimelineItem_bubble_border_width:0.0625rem;--_ui5_TimelineItem_bubble_border_style:dotted;--_ui5_TimelineItem_bubble_border_radius:0.25rem;--_ui5_TimelineItem_bubble_border_color:var(--sapList_BorderColor);--_ui5_TimelineItem_bubble_border_top:-0.125rem;--_ui5_TimelineItem_bubble_border_right:-0.125rem;--_ui5_TimelineItem_bubble_border_bottom:-0.125rem;--_ui5_TimelineItem_bubble_border_left:-0.625rem;--_ui5_TimelineItem_bubble_rtl_left_offset:-0.125rem;--_ui5_TimelineItem_bubble_rtl_right_offset:-0.625rem;--_ui5_TimelineItem_bubble_focus_border_radius:0;--_ui5_TimelineItem_horizontal_bubble_focus_top_offset:-0.625rem;--_ui5_TimelineItem_horizontal_bubble_focus_left_offset:-0.125rem;--_ui5_TimelineItem_bubble_content_padding:var(--_ui5_tl_bubble_padding);--_ui5_TimelineItem_bubble_content_subtitle_padding_top:0.375rem;--_ui5_TimelineItem_bubble_content_description_padding_top:0.75rem;--ui5_upload_collection_drag_overlay_border:0.125rem dashed var(--sapContent_ForegroundBorderColor);--ui5_upload_collection_drop_overlay_border:0.125rem solid var(--sapContent_DragAndDropActiveColor);--ui5_upload_collection_drop_overlay_background:transparent;--ui5_upload_collection_button_margin_block_end:0;--ui5_upload_collection_last_button_inline_end:0;--ui5_upload_collection_small_size_buttons_margin_block_start:0.75rem;--_ui5_vsd_header_container:2.75rem;--_ui5_vsd_sub_header_container_height:2.75rem;--_ui5_vsd_content_li_padding:0.375rem;--_ui5_vsd_content_height:23.4375rem;--_ui5_vsd_expand_content_height:26.1875rem;--_ui5_wiz_content_item_wrapper_padding:0rem;--_ui5_wiz_content_item_wrapper_bg:var(--sapBackgroundColor);--_ui5_wiz_tab_focus_outline:1px dotted var(--sapContent_FocusColor);--_ui5_wiz_tab_selected_bg:var(--sapSelectedColor);--_ui5_wiz_tab_border:1px solid var(--sapSelectedColor);--_ui5_wiz_tab_selection_line:var(--sapSelectedColor);--_ui5_wiz_tab_icon_color:var(--sapSelectedColor);--_ui5_wiz_tab_active_separator_color:var(--sapSelectedColor);--_ui5_wiz_tab_title_color:var(--sapContent_LabelColor);--_ui5_wiz_tab_title_font_family:var(--sapFontFamily);--_ui5_wiz_tab_focus_border_radius:0}" };
Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents-fiori", "sap_fiori_3", async () => XT);
var YT = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
let KT = class extends ZC {
  get accInfo() {
    return { label: this.design };
  }
  constructor() {
    super(), this._handleResizeBound = this.handleResize.bind(this);
  }
  handleResize() {
    const e3 = this.getDomRef(), t2 = e3.offsetWidth, i2 = Array.from(e3.children).some((e4) => e4.offsetWidth > t2 / 3);
    e3.classList.toggle("ui5-bar-root-shrinked", i2);
  }
  get classes() {
    return { root: { "ui5-bar-root": true } };
  }
  onBeforeRendering() {
    [...this.startContent, ...this.middleContent, ...this.endContent].forEach((e3) => e3.classList.add("ui5-bar-content"));
  }
  onEnterDOM() {
    iE.register(this, this._handleResizeBound), this.getDomRef().querySelectorAll(".ui5-bar-content-container").forEach((e3) => {
      iE.register(e3, this._handleResizeBound);
    }, this);
  }
  onExitDOM() {
    iE.deregister(this, this._handleResizeBound), this.getDomRef().querySelectorAll(".ui5-bar-content-container").forEach((e3) => {
      iE.deregister(e3, this._handleResizeBound);
    }, this);
  }
};
YT([tS({ type: jT, defaultValue: jT.Header })], KT.prototype, "design", void 0), YT([nS({ type: HTMLElement })], KT.prototype, "startContent", void 0), YT([nS({ type: HTMLElement, default: true })], KT.prototype, "middleContent", void 0), YT([nS({ type: HTMLElement })], KT.prototype, "endContent", void 0), KT = YT([eS({ tag: "ui5-bar", fastNavigation: true, renderer: KS, styles: { packageName: "@ui5/webcomponents-fiori", fileName: "themes/Bar.css", content: ":host{background-color:var(--sapPageHeader_Background);height:var(--_ui5_bar_base_height);width:100%;box-shadow:inset 0 -.0625rem var(--sapPageHeader_BorderColor);display:block}.ui5-bar-root{display:flex;align-items:center;justify-content:space-between;height:inherit;width:inherit;background-color:inherit;box-shadow:inherit;border-radius:inherit}.ui5-bar-root .ui5-bar-startcontent-container{padding-inline-start:.5rem;display:flex;flex-direction:row;align-items:center;justify-content:flex-start}.ui5-bar-root .ui5-bar-content-container{min-width:30%}.ui5-bar-root.ui5-bar-root-shrinked .ui5-bar-content-container{min-width:0;overflow:hidden;height:100%}.ui5-bar-root .ui5-bar-endcontent-container{padding-inline-end:.5rem;display:flex;flex-direction:row;align-items:center;justify-content:flex-end}.ui5-bar-root .ui5-bar-midcontent-container{padding-left:.5rem;padding-right:.5rem;display:flex;flex-direction:row;align-items:center;justify-content:center}:host([design=Footer]){background-color:var(--sapPageFooter_Background);border-top:.0625rem solid var(--sapPageFooter_BorderColor);box-shadow:none}:host([design=Subheader]){height:var(--_ui5_bar_subheader_height)}:host([design=FloatingFooter]){border-radius:var(--sapElement_BorderCornerRadius);background-color:var(--sapPageFooter_Background);box-shadow:var(--sapContent_Shadow1);border:none}::slotted(*){margin:0 .25rem}" }, template: function(e3, t2, i2) {
  return XS`<div class="${WS(this.classes.root)}" aria-label="${jS(this.accInfo.label)}" role="toolbar" part="bar"><div class="ui5-bar-content-container ui5-bar-startcontent-container"><slot name="startContent"></slot></div><div class="ui5-bar-content-container ui5-bar-midcontent-container"><slot></slot></div><div class="ui5-bar-content-container ui5-bar-endcontent-container"><slot name="endContent"></slot></div></div>`;
} })], KT), KT.define();
const ZT = (e3, t2, i2) => Math.min(Math.max(e3, t2), i2);
var JT;
!function(e3) {
  e3.None = "None", e3.Success = "Success", e3.Warning = "Warning", e3.Error = "Error", e3.Information = "Information";
}(JT || (JT = {}));
const eB = JT, tB = (e3) => "SLOT" !== e3.nodeName && (e3.offsetWidth <= 0 && e3.offsetHeight <= 0 || e3.style && "hidden" === e3.style.visibility), iB = /^(?:a|area)$/i, nB = /^(?:input|select|textarea|button)$/i, oB = (e3) => {
  if (e3.disabled)
    return false;
  const t2 = e3.getAttribute("tabindex");
  return null != t2 ? parseInt(t2) >= 0 : nB.test(e3.nodeName) || iB.test(e3.nodeName) && !!e3.href;
}, rB = (e3) => e3.hasAttribute("data-ui5-focus-trap"), sB = async (e3, t2) => !e3 || tB(e3) ? null : aB(e3, true, t2), aB = async (e3, t2, i2) => {
  let n2, o2, r2, s2 = -1;
  for (e3.shadowRoot ? n2 = t2 ? e3.shadowRoot.firstChild : e3.shadowRoot.lastChild : e3 instanceof HTMLSlotElement && e3.assignedNodes() ? (o2 = e3.assignedNodes(), s2 = t2 ? 0 : o2.length - 1, n2 = o2[s2]) : n2 = i2 ? e3 : t2 ? e3.firstElementChild : e3.lastElementChild; n2; ) {
    const e4 = n2;
    if (JC(n2) && (n2 = await n2.getFocusDomRefAsync()), !n2)
      return null;
    if (1 === n2.nodeType && ((a2 = n2).hasAttribute("data-ui5-focus-redirect") || !tB(a2)) && !rB(n2)) {
      if (oB(n2))
        return n2 && "function" == typeof n2.focus ? n2 : null;
      if (r2 = await aB(n2, t2), r2)
        return r2 && "function" == typeof r2.focus ? r2 : null;
    }
    n2 = t2 ? e4.nextSibling : e4.previousSibling, o2 && !o2[s2].contains(n2) && (s2 = t2 ? s2 + 1 : s2 - 1, n2 = o2[s2]);
  }
  var a2;
  return null;
}, lB = () => document.body.classList.contains("ui5-content-native-scrollbars"), cB = Oy("PopupUtilsData", { currentZIndex: 100 }), hB = () => {
  const e3 = RS();
  return e3 && "function" == typeof e3.focus ? e3 : null;
}, uB = (e3, t2) => {
  let i2 = e3;
  if (i2.shadowRoot) {
    if (i2 = Array.from(i2.shadowRoot.children).find((e4) => "style" !== e4.localName), !i2)
      return false;
  }
  if (i2 === t2)
    return true;
  const n2 = "slot" === i2.localName ? i2.assignedNodes() : i2.children;
  return !!n2 && Array.from(n2).some((e4) => uB(e4, t2));
}, dB = (e3, t2) => {
  let i2, n2;
  if (e3 instanceof MouseEvent)
    i2 = e3.clientX, n2 = e3.clientY;
  else {
    const t3 = e3.touches[0];
    i2 = t3.clientX, n2 = t3.clientY;
  }
  return ((e4, t3, i3) => e4 >= i3.left && e4 <= i3.right && t3 >= i3.top && t3 <= i3.bottom)(i2, n2, t2);
};
const pB = (e3) => {
  const t2 = e3.parentElement || e3.getRootNode && e3.getRootNode().host;
  return t2 && ("isUI5Element" in (i2 = t2) && "_show" in i2 || t2 === document.documentElement) ? t2 : pB(t2);
  var i2;
}, _B = () => {
  const e3 = Ky("OpenUI5Support");
  return e3 && e3.isLoaded() ? e3.getNextZIndex() : (cB.currentZIndex += 2, cB.currentZIndex);
}, gB = /* @__PURE__ */ new Map(), mB = /* @__PURE__ */ new Map();
var fB;
mB.set("S", [0, 599]), mB.set("M", [600, 1023]), mB.set("L", [1024, 1439]), mB.set("XL", [1440, 1 / 0]), function(e3) {
  e3.RANGE_4STEPS = "4Step";
}(fB || (fB = {}));
const vB = { RANGESETS: fB, initRangeSet: (e3, t2) => {
  gB.set(e3, t2);
}, getCurrentRange: (e3, t2 = window.innerWidth) => {
  let i2, n2 = gB.get(e3);
  n2 || (n2 = gB.get(fB.RANGE_4STEPS));
  const o2 = Math.floor(t2);
  return n2.forEach((e4, t3) => {
    o2 >= e4[0] && o2 <= e4[1] && (i2 = t3);
  }), i2 || [...n2.keys()][0];
} };
var AB;
vB.initRangeSet(vB.RANGESETS.RANGE_4STEPS, mB), function(e3) {
  e3.None = "None", e3.Dialog = "Dialog", e3.AlertDialog = "AlertDialog";
}(AB || (AB = {}));
const bB = AB;
let yB = [];
const wB = (e3, t2 = []) => {
  yB.some((t3) => t3.instance === e3) || yB.push({ instance: e3, parentPopovers: t2 }), IB(), 1 === yB.length && SB();
}, xB = (e3) => {
  yB = yB.filter((t2) => t2.instance !== e3), IB(), yB.length || EB();
}, CB = (e3) => {
  yB.length && yS(e3) && yB[yB.length - 1].instance.close(true);
}, SB = () => {
  document.addEventListener("keydown", CB);
}, EB = () => {
  document.removeEventListener("keydown", CB);
}, IB = () => {
  let e3, t2 = false;
  for (let i2 = yB.length - 1; i2 >= 0; i2--)
    e3 = yB[i2].instance, !t2 && e3.isModal ? (e3.isTopModalPopup = true, t2 = true) : e3.isTopModalPopup = false;
};
Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
const TB = { packageName: "@ui5/webcomponents", fileName: "themes/PopupGlobal.css", content: ".ui5-popup-scroll-blocker{overflow:hidden}" };
var BB, MB = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
Zw("data-ui5-popup-scroll-blocker") || Kw(TB, "data-ui5-popup-scroll-blocker");
const kB = /* @__PURE__ */ new Set();
let RB = BB = class extends ZC {
  constructor() {
    super(), this._resizeHandler = this._resize.bind(this);
  }
  onBeforeRendering() {
    this._blockLayerHidden = !this.isOpen() || !this.isTopModalPopup;
  }
  onEnterDOM() {
    iE.register(this, this._resizeHandler);
  }
  onExitDOM() {
    this.isOpen() && (BB.unblockPageScrolling(this), this._removeOpenedPopup()), iE.deregister(this, this._resizeHandler);
  }
  get _displayProp() {
    return "block";
  }
  _resize() {
    this.mediaRange = vB.getCurrentRange(vB.RANGESETS.RANGE_4STEPS, this.getDomRef().offsetWidth);
  }
  _preventBlockLayerFocus(e3) {
    e3.preventDefault();
  }
  static blockPageScrolling(e3) {
    kB.add(e3), 1 === kB.size && document.documentElement.classList.add("ui5-popup-scroll-blocker");
  }
  static unblockPageScrolling(e3) {
    kB.delete(e3), 0 === kB.size && document.documentElement.classList.remove("ui5-popup-scroll-blocker");
  }
  _scroll(e3) {
    this.fireEvent("scroll", { scrollTop: e3.target.scrollTop, targetRef: e3.target });
  }
  _onkeydown(e3) {
    const t2 = e3.target === this._root && xS(e3), i2 = rS(e3) && !this.isOpen();
    (t2 || i2) && e3.preventDefault();
  }
  _onfocusout(e3) {
    e3.relatedTarget || (this._shouldFocusRoot = true);
  }
  _onmousedown(e3) {
    this._root.removeAttribute("tabindex"), this.shadowRoot.contains(e3.target) ? this._shouldFocusRoot = true : this._shouldFocusRoot = false;
  }
  _onmouseup() {
    this._root.tabIndex = -1, this._shouldFocusRoot && (sI.chrome && this._root.focus(), this._shouldFocusRoot = false);
  }
  async forwardToFirst() {
    const e3 = await sB(this);
    e3 ? e3.focus({ focusVisible: true }) : this._root.focus();
  }
  async forwardToLast() {
    const e3 = await (async (e4, t2) => !e4 || tB(e4) ? null : aB(e4, false, t2))(this);
    e3 ? e3.focus({ focusVisible: true }) : this._root.focus();
  }
  async applyInitialFocus() {
    await this.applyFocus();
  }
  async applyFocus() {
    await this._waitForDomRef();
    const e3 = this.getRootNode().getElementById(this.initialFocus) || document.getElementById(this.initialFocus) || await sB(this) || this._root;
    e3 && (e3 === this._root && (e3.tabIndex = -1), e3.focus({ focusVisible: true }));
  }
  isOpen() {
    return this.opened;
  }
  isFocusWithin() {
    return ((e3) => {
      const t2 = hB();
      return !!t2 && uB(e3, t2);
    })(this._root);
  }
  async _open(e3) {
    var _a2;
    !this.fireEvent("before-open", {}, true, false) || (this.isModal && !this.shouldHideBackdrop && (this.getStaticAreaItemDomRef(), this._blockLayerHidden = false, BB.blockPageScrolling(this)), this._zIndex = _B(), this.style.zIndex = ((_a2 = this._zIndex) == null ? void 0 : _a2.toString()) || "", this._focusedElementBeforeOpen = hB(), this._show(), this._addOpenedPopup(), this.opened = true, this.open = true, await Nw(), this._disableInitialFocus || e3 || await this.applyInitialFocus(), this.fireEvent("after-open", {}, false, false));
  }
  _addOpenedPopup() {
    wB(this);
  }
  close(e3 = false, t2 = false, i2 = false) {
    if (!this.opened)
      return;
    !this.fireEvent("before-close", { escPressed: e3 }, true, false) || (this.isModal && (this._blockLayerHidden = true, BB.unblockPageScrolling(this)), this.hide(), this.opened = false, this.open = false, t2 || this._removeOpenedPopup(), this.preventFocusRestore || i2 || this.resetFocus(), this.fireEvent("after-close", {}, false, false));
  }
  _removeOpenedPopup() {
    xB(this);
  }
  resetFocus() {
    this._focusedElementBeforeOpen && (this._focusedElementBeforeOpen.focus({ focusVisible: true }), this._focusedElementBeforeOpen = null);
  }
  _show() {
    this.style.display = this._displayProp;
  }
  hide() {
    this.style.display = "none";
  }
  get _ariaLabel() {
    return bI(this);
  }
  get _root() {
    return this.shadowRoot.querySelector(".ui5-popup-root");
  }
  get _role() {
    return this.accessibleRole === bB.None ? void 0 : this.accessibleRole.toLowerCase();
  }
  get _ariaModal() {
    return this.accessibleRole === bB.None ? void 0 : "true";
  }
  get contentDOM() {
    return this.shadowRoot.querySelector(".ui5-popup-content");
  }
  get styles() {
    return { root: {}, content: {}, blockLayer: { zIndex: this._zIndex ? this._zIndex - 1 : "" } };
  }
  get classes() {
    return { root: { "ui5-popup-root": true, "ui5-content-native-scrollbars": lB() }, content: { "ui5-popup-content": true } };
  }
};
MB([tS()], RB.prototype, "initialFocus", void 0), MB([tS({ type: Boolean })], RB.prototype, "preventFocusRestore", void 0), MB([tS({ type: Boolean })], RB.prototype, "open", void 0), MB([tS({ type: Boolean, noAttribute: true })], RB.prototype, "opened", void 0), MB([tS({ defaultValue: void 0 })], RB.prototype, "accessibleName", void 0), MB([tS({ defaultValue: "" })], RB.prototype, "accessibleNameRef", void 0), MB([tS({ type: bB, defaultValue: bB.Dialog })], RB.prototype, "accessibleRole", void 0), MB([tS()], RB.prototype, "mediaRange", void 0), MB([tS({ type: Boolean })], RB.prototype, "_disableInitialFocus", void 0), MB([tS({ type: Boolean })], RB.prototype, "_blockLayerHidden", void 0), MB([tS({ type: Boolean, noAttribute: true })], RB.prototype, "isTopModalPopup", void 0), MB([nS({ type: HTMLElement, default: true })], RB.prototype, "content", void 0), RB = BB = MB([eS({ renderer: KS, styles: { packageName: "@ui5/webcomponents", fileName: "themes/Popup.css", content: ":host{min-width:1px;display:none;position:fixed}" }, template: function(e3, t2, i2) {
  return XS`<section style="${qS(this.styles.root)}" class="${WS(this.classes.root)}" role="${jS(this._role)}" aria-modal="${jS(this._ariaModal)}" aria-label="${jS(this._ariaLabel)}" aria-labelledby="${jS(this._ariaLabelledBy)}" @keydown=${this._onkeydown} @focusout=${this._onfocusout} @mouseup=${this._onmouseup} @mousedown=${this._onmousedown}><span class="first-fe" data-ui5-focus-trap tabindex="0" @focusin=${this.forwardToLast}></span><div style="${qS(this.styles.content)}" class="${WS(this.classes.content)}"  @scroll="${this._scroll}" part="content"><slot></slot></div><span class="last-fe" data-ui5-focus-trap tabindex="0" @focusin=${this.forwardToFirst}></span></section> `;
}, staticAreaTemplate: function(e3, t2, i2) {
  return XS`<div class="ui5-block-layer" ?hidden=${this._blockLayerHidden} tabindex="0" style="${qS(this.styles.blockLayer)}" @keydown="${this._preventBlockLayerFocus}" @mousedown="${this._preventBlockLayerFocus}"></div>`;
}, staticAreaStyles: { packageName: "@ui5/webcomponents", fileName: "themes/PopupStaticAreaStyles.css", content: ".ui5-block-layer{display:none;position:fixed;background-color:var(--sapBlockLayer_Background);opacity:.6;top:-500px;left:-500px;right:-500px;bottom:-500px;outline:none;pointer-events:all;z-index:-1}.ui5-block-layer:not([hidden]){display:inline-block}" } }), iS("before-open"), iS("after-open"), iS("before-close", { escPressed: { type: Boolean } }), iS("after-close"), iS("scroll")], RB);
const PB = RB, DB = "M384 224v32q0 12-10 22L182 470q-10 10-22 10h-32zM224 480l160-160v32q0 12-10 22l-96 96q-10 10-22 10h-32zm160-64v32q0 12-10 22t-22 10h-32z";
Kx("resize-corner", { pathData: DB, ltr: false, collection: "SAP-icons-v4", packageName: "@ui5/webcomponents-icons" });
const LB = "M386.5 305q10-8 19-8 11 0 19 8 8 10 8 19t-8 19l-161 161q-10 8-19 8t-19-8q-8-8-8-18t8-20zm38-134q8 8 8 19 0 10-8 18l-296 296q-8 8-18 8-11 0-19-8-8-7-8-19 0-11 8-19l295-295q8-8 19-8 12 0 19 8z";
Kx("resize-corner", { pathData: LB, ltr: false, collection: "SAP-icons-v5", packageName: "@ui5/webcomponents-icons" }), dx();
const FB = "M512 256q0 53-20.5 100t-55 81.5-81 54.5-99.5 20-100-20.5-81.5-55T20 355 0 256q0-54 20-100.5t55-81T156.5 20 256 0t99.5 20T437 75t55 81.5 20 99.5zM399 364q6-6 0-12l-86-86q-6-6 0-12l81-81q6-6 0-12l-37-37q-2-2-6-2t-6 2l-83 82q-1 3-6 3-3 0-6-3l-84-83q-1-2-6-2-4 0-6 2l-37 37q-6 6 0 12l83 82q6 6 0 12l-83 82q-2 2-2.5 6t2.5 6l36 37q4 2 6 2 4 0 6-2l85-84q2-2 6-2t6 2l88 88q4 2 6 2t6-2z";
Kx("error", { pathData: FB, ltr: false, accData: pT, collection: "SAP-icons-v4", packageName: "@ui5/webcomponents-icons" });
const NB = "M375 183q9-11 9-23 0-13-9-23-10-9-23-9-12 0-23 9l-73 74-73-74q-10-9-23-9-12 0-23 9-9 10-9 23 0 12 9 23l74 73-74 73q-9 10-9 23 0 12 9 23 11 9 23 9 13 0 23-9l73-74 73 74q11 9 23 9 13 0 23-9 9-11 9-23 0-13-9-23l-74-73zM256 512q-53 0-99.5-20T75 437t-55-81.5T0 256t20-99.5T75 75t81.5-55T256 0t99.5 20T437 75t55 81.5 20 99.5-20 99.5-55 81.5-81.5 55-99.5 20z";
Kx("error", { pathData: NB, ltr: false, accData: pT, collection: "SAP-icons-v5", packageName: "@ui5/webcomponents-icons" }), dx();
const OB = "M501 374q5 10 7.5 19.5T512 412v5q0 31-23 47.5T439 481H74q-13 0-26-4.5T24.5 464t-17-20T1 417q-1-13 3-22.5t9-20.5L198 38q24-38 61-38t59 38zM257 127q-13 0-23.5 8T223 161q1 7 3 23 2 14 3.5 37t3.5 61q0 11 7.5 16t15.5 5q22 0 24-21l2-36 9-85q0-18-10.5-26t-23.5-8zm0 299q20 0 31.5-12t11.5-32q0-19-11.5-31T257 339t-31.5 12-11.5 31q0 20 11.5 32t31.5 12z";
Kx("alert", { pathData: OB, ltr: false, collection: "SAP-icons-v4", packageName: "@ui5/webcomponents-icons" });
const zB = "M200 34q9-17 24-25.5T256 0t32 8.5T312 34l192 353q8 13 8 30 0 25-18 44.5T448 481H64q-28 0-46-19.5T0 417q0-17 8-30zm88 119q0-13-9-22.5t-23-9.5-23 9.5-9 22.5v128q0 14 9 23.5t23 9.5 23-9.5 9-23.5V153zm6 238q0-16-11-27t-27-11-27 11-11 27q0 17 11 28t27 11 27-11 11-28z";
Kx("alert", { pathData: zB, ltr: false, collection: "SAP-icons-v5", packageName: "@ui5/webcomponents-icons" }), dx();
const UB = "M512 256q0 54-20 100.5t-54.5 81T356 492t-100 20q-54 0-100.5-20t-81-55T20 355.5 0 256t20.5-100 55-81.5T157 20t99-20q53 0 100 20t81.5 54.5T492 156t20 100zm-118-87q4-8-1-13l-36-36q-3-4-8-4t-8 5L237 294q-3 1-4 0l-70-52q-4-3-7-3t-4.5 2-2.5 3l-29 41q-6 8 2 14l113 95q2 2 7 2t8-4z";
Kx("sys-enter-2", { pathData: UB, ltr: true, collection: "SAP-icons-v4", packageName: "@ui5/webcomponents-icons" });
const HB = "M256 0q53 0 99.5 20T437 75t55 81.5 20 99.5-20 99.5-55 81.5-81.5 55-99.5 20-99.5-20T75 437t-55-81.5T0 256t20-99.5T75 75t81.5-55T256 0zM128 256q-14 0-23 9t-9 23q0 12 9 23l64 64q11 9 23 9 13 0 23-9l192-192q9-11 9-23 0-13-9.5-22.5T384 128q-12 0-23 9L192 307l-41-42q-10-9-23-9z";
Kx("sys-enter-2", { pathData: HB, ltr: true, collection: "SAP-icons-v5", packageName: "@ui5/webcomponents-icons" }), dx();
const QB = "M0 256q0-53 20.5-100t55-81.5T157 20t99-20q54 0 100.5 20t81 55 54.5 81.5 20 99.5q0 54-20 100.5t-54.5 81T356 492t-100 20q-54 0-100.5-20t-81-55T20 355.5 0 256zm192 112v33h128v-33h-32V215q0-6-7-6h-88v31h32v128h-33zm34-201q14 11 30 11 17 0 29.5-11.5T298 138q0-19-13-31-12-12-29-12-19 0-30.5 12.5T214 138q0 17 12 29z";
Kx("information", { pathData: QB, ltr: false, collection: "SAP-icons-v4", packageName: "@ui5/webcomponents-icons" });
const VB = "M256 0q53 0 99.5 20T437 75t55 81.5 20 99.5-20 99.5-55 81.5-81.5 55-99.5 20-99.5-20T75 437t-55-81.5T0 256t20-99.5T75 75t81.5-55T256 0zm38 140q0-16-11-27.5T256 101t-27 11.5-11 27.5 11 27 27 11 27-11 11-27zm-6 110q0-14-9-23t-23-9-23 9-9 23v128q0 13 9 22.5t23 9.5 23-9.5 9-22.5V250z";
function GB(e3, t2, i2) {
  return XS`<header class="ui5-popup-header-root" id="ui5-popup-header" tabindex="${jS(this._headerTabIndex)}" @keydown="${this._onDragOrResizeKeyDown}" @mousedown="${this._onDragMouseDown}" part="header" state="${jS(this.state)}">${this.hasValueState ? $B.call(this, e3, t2, i2) : void 0}${this.header.length ? WB.call(this, e3, t2, i2) : qB.call(this, e3, t2, i2)}</header>`;
}
function $B(e3, t2, i2) {
  return i2 ? XS`<${ZS("ui5-icon", t2, i2)} class="ui5-dialog-value-state-icon" name="${jS(this._dialogStateIcon)}"></${ZS("ui5-icon", t2, i2)}>` : XS`<ui5-icon class="ui5-dialog-value-state-icon" name="${jS(this._dialogStateIcon)}"></ui5-icon>`;
}
function WB(e3, t2, i2) {
  return XS`<slot name="header"></slot>`;
}
function qB(e3, t2, i2) {
  return XS`<h1 id="ui5-popup-header-text" class="ui5-popup-header-text">${jS(this.headerText)}</h1>`;
}
function jB(e3, t2, i2) {
  return XS`<footer class="ui5-popup-footer-root" part="footer"><slot name="footer"></slot></footer>`;
}
function XB(e3, t2, i2) {
  return i2 ? XS`<${ZS("ui5-icon", t2, i2)} name="resize-corner" class="ui5-popup-resize-handle" @mousedown="${this._onResizeMouseDown}"></${ZS("ui5-icon", t2, i2)}>` : XS`<ui5-icon name="resize-corner" class="ui5-popup-resize-handle" @mousedown="${this._onResizeMouseDown}"></ui5-icon>`;
}
Kx("information", { pathData: VB, ltr: false, collection: "SAP-icons-v5", packageName: "@ui5/webcomponents-icons" }), dx(), Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
const YB = { packageName: "@ui5/webcomponents", fileName: "themes/BrowserScrollbar.css", content: ":not(.ui5-content-native-scrollbars) ::-webkit-scrollbar:horizontal{height:var(--sapScrollBar_Dimension)}:not(.ui5-content-native-scrollbars) ::-webkit-scrollbar:vertical{width:var(--sapScrollBar_Dimension)}:not(.ui5-content-native-scrollbars) ::-webkit-scrollbar{background-color:var(--sapScrollBar_TrackColor);border-left:var(--browser_scrollbar_border)}:not(.ui5-content-native-scrollbars) ::-webkit-scrollbar-thumb{border-radius:var(--browser_scrollbar_border_radius);background-color:var(--sapScrollBar_FaceColor)}:not(.ui5-content-native-scrollbars) ::-webkit-scrollbar-thumb:hover{background-color:var(--sapScrollBar_Hover_FaceColor)}:not(.ui5-content-native-scrollbars) ::-webkit-scrollbar-corner{background-color:var(--sapScrollBar_TrackColor)}" };
Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
const KB = { packageName: "@ui5/webcomponents", fileName: "themes/PopupsCommon.css", content: ':host{display:none;position:fixed;background:var(--sapGroup_ContentBackground);box-shadow:var(--sapContent_Shadow2);border-radius:var(--_ui5_popup_border_radius);min-height:2rem;box-sizing:border-box}.ui5-popup-root{background:inherit;border-radius:inherit;width:100%;height:100%;box-sizing:border-box;display:flex;flex-direction:column;overflow:hidden;outline:none}.ui5-popup-root .ui5-popup-header-root{color:var(--sapPageHeader_TextColor);box-shadow:var(--sapContent_HeaderShadow);margin-bottom:.125rem}.ui5-popup-content{color:var(--sapTextColor)}.ui5-popup-footer-root{background:var(--sapPageFooter_Background);border-top:1px solid var(--sapPageFooter_BorderColor);color:var(--sapPageFooter_TextColor)}.ui5-popup-footer-root,.ui5-popup-header-root,:host([header-text]) .ui5-popup-header-text{margin:0;font-size:1rem;font-family:"72override",var(--_ui5_popup_header_font_family);display:flex;justify-content:center;align-items:center}.ui5-popup-header-root .ui5-popup-header-text{font-weight:var(--_ui5_popup_header_font_weight)}.ui5-popup-content{overflow:auto;box-sizing:border-box}:host([header-text]) .ui5-popup-header-text{text-align:center;min-height:var(--_ui5_popup_default_header_height);max-height:var(--_ui5_popup_default_header_height);line-height:var(--_ui5_popup_default_header_height);text-overflow:ellipsis;overflow:hidden;white-space:nowrap;max-width:100%;display:inline-block}:host([header-text]) .ui5-popup-header-root{justify-content:var(--_ui5_popup_header_prop_header_text_alignment)}:host(:not([header-text])) .ui5-popup-header-text{display:none}:host([disable-scrolling]) .ui5-popup-content{overflow:hidden}:host([media-range=S]) .ui5-popup-content{padding:1rem var(--_ui5_popup_content_padding_s)}:host([media-range=L]) .ui5-popup-content,:host([media-range=M]) .ui5-popup-content{padding:1rem var(--_ui5_popup_content_padding_m_l)}:host([media-range=XL]) .ui5-popup-content{padding:1rem var(--_ui5_popup_content_padding_xl)}.ui5-popup-header-root{background:var(--sapPageHeader_Background)}:host([media-range=S]) .ui5-popup-footer-root,:host([media-range=S]) .ui5-popup-header-root{padding-left:var(--_ui5_popup_header_footer_padding_s);padding-right:var(--_ui5_popup_header_footer_padding_s)}:host([media-range=L]) .ui5-popup-footer-root,:host([media-range=L]) .ui5-popup-header-root,:host([media-range=M]) .ui5-popup-footer-root,:host([media-range=M]) .ui5-popup-header-root{padding-left:var(--_ui5_popup_header_footer_padding_m_l);padding-right:var(--_ui5_popup_header_footer_padding_m_l)}:host([media-range=XL]) .ui5-popup-footer-root,:host([media-range=XL]) .ui5-popup-header-root{padding-left:var(--_ui5_popup_header_footer_padding_xl);padding-right:var(--_ui5_popup_header_footer_padding_xl)}' };
Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
var ZB, JB = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
const eM = 16, tM = { [eB.Error]: "error", [eB.Warning]: "alert", [eB.Success]: "sys-enter-2", [eB.Information]: "information" };
let iM = ZB = class extends PB {
  constructor() {
    super(), this._revertSize = () => {
      Object.assign(this.style, { top: "", left: "", width: "", height: "" });
    }, this._screenResizeHandler = this._center.bind(this), this._dragMouseMoveHandler = this._onDragMouseMove.bind(this), this._dragMouseUpHandler = this._onDragMouseUp.bind(this), this._resizeMouseMoveHandler = this._onResizeMouseMove.bind(this), this._resizeMouseUpHandler = this._onResizeMouseUp.bind(this), this._dragStartHandler = this._handleDragStart.bind(this);
  }
  static _isHeader(e3) {
    return e3.classList.contains("ui5-popup-header-root") || "header" === e3.getAttribute("slot");
  }
  async show(e3 = false) {
    await super._open(e3);
  }
  get isModal() {
    return true;
  }
  get shouldHideBackdrop() {
    return false;
  }
  get _ariaLabelledBy() {
    let e3;
    return "" === this.headerText || this._ariaLabel || (e3 = "ui5-popup-header-text"), e3;
  }
  get _displayProp() {
    return "flex";
  }
  get _displayHeader() {
    return this.header.length || this.headerText || this.draggable || this.resizable;
  }
  get _movable() {
    return !this.stretch && this.onDesktop && (this.draggable || this.resizable);
  }
  get _headerTabIndex() {
    return this._movable ? "0" : void 0;
  }
  get _showResizeHandle() {
    return this.resizable && this.onDesktop;
  }
  get _minHeight() {
    let e3 = Number.parseInt(window.getComputedStyle(this.contentDOM).minHeight);
    const t2 = this._root.querySelector(".ui5-popup-header-root");
    t2 && (e3 += t2.offsetHeight);
    const i2 = this._root.querySelector(".ui5-popup-footer-root");
    return i2 && (e3 += i2.offsetHeight), e3;
  }
  get hasValueState() {
    return this.state !== eB.None;
  }
  get _dialogStateIcon() {
    return tM[this.state];
  }
  get _role() {
    if (this.accessibleRole !== bB.None)
      return this.state === eB.Error || this.state === eB.Warning ? bB.AlertDialog.toLowerCase() : this.accessibleRole.toLowerCase();
  }
  _show() {
    super._show(), this._center();
  }
  onBeforeRendering() {
    super.onBeforeRendering(), this._isRTL = "rtl" === this.effectiveDir, this.onPhone = gI(), this.onDesktop = mI();
  }
  onAfterRendering() {
    !this.isOpen() && this.open ? this.show() : this.isOpen() && !this.open && this.close();
  }
  onEnterDOM() {
    super.onEnterDOM(), this._attachScreenResizeHandler(), this.addEventListener("dragstart", this._dragStartHandler);
  }
  onExitDOM() {
    super.onExitDOM(), this._detachScreenResizeHandler(), this.removeEventListener("dragstart", this._dragStartHandler);
  }
  _resize() {
    super._resize(), this._screenResizeHandlerAttached && this._center();
  }
  _attachScreenResizeHandler() {
    this._screenResizeHandlerAttached || (window.addEventListener("resize", this._screenResizeHandler), this._screenResizeHandlerAttached = true);
  }
  _detachScreenResizeHandler() {
    this._screenResizeHandlerAttached && (window.removeEventListener("resize", this._screenResizeHandler), this._screenResizeHandlerAttached = false);
  }
  _center() {
    const e3 = window.innerHeight - this.offsetHeight, t2 = window.innerWidth - this.offsetWidth;
    Object.assign(this.style, { top: `${Math.round(e3 / 2)}px`, left: `${Math.round(t2 / 2)}px` });
  }
  _onDragMouseDown(e3) {
    if (!this._movable || !this.draggable || !ZB._isHeader(e3.target))
      return;
    e3.preventDefault();
    const { top: t2, left: i2 } = this.getBoundingClientRect(), { width: n2, height: o2 } = window.getComputedStyle(this);
    Object.assign(this.style, { top: `${t2}px`, left: `${i2}px`, width: Math.round(100 * Number.parseFloat(n2)) / 100 + "px", height: Math.round(100 * Number.parseFloat(o2)) / 100 + "px" }), this._x = e3.clientX, this._y = e3.clientY, this._attachMouseDragHandlers();
  }
  _onDragMouseMove(e3) {
    e3.preventDefault();
    const { clientX: t2, clientY: i2 } = e3, n2 = this._x - t2, o2 = this._y - i2, { left: r2, top: s2 } = this.getBoundingClientRect();
    Object.assign(this.style, { left: `${Math.floor(r2 - n2)}px`, top: `${Math.floor(s2 - o2)}px` }), this._x = t2, this._y = i2;
  }
  _onDragMouseUp() {
    delete this._x, delete this._y, this._detachMouseDragHandlers();
  }
  _onDragOrResizeKeyDown(e3) {
    this._movable && ZB._isHeader(e3.target) && (this.draggable && [cS, hS, aS, lS].some((t2) => t2(e3)) ? this._dragWithEvent(e3) : this.resizable && [gS, mS, fS, vS].some((t2) => t2(e3)) && this._resizeWithEvent(e3));
  }
  _dragWithEvent(e3) {
    const { top: t2, left: i2, width: n2, height: o2 } = this.getBoundingClientRect();
    let r2 = 0, s2 = "top";
    switch (true) {
      case cS(e3):
        r2 = t2 - eM, s2 = "top";
        break;
      case hS(e3):
        r2 = t2 + eM, s2 = "top";
        break;
      case aS(e3):
        r2 = i2 - eM, s2 = "left";
        break;
      case lS(e3):
        r2 = i2 + eM, s2 = "left";
    }
    r2 = ZT(r2, 0, "left" === s2 ? window.innerWidth - n2 : window.innerHeight - o2), this.style[s2] = `${r2}px`;
  }
  _resizeWithEvent(e3) {
    this._detachScreenResizeHandler(), this.addEventListener("ui5-before-close", this._revertSize, { once: true });
    const { top: t2, left: i2 } = this.getBoundingClientRect(), n2 = window.getComputedStyle(this), o2 = Number.parseFloat(n2.minWidth), r2 = window.innerWidth - i2, s2 = window.innerHeight - t2;
    let a2 = Number.parseFloat(n2.width), l2 = Number.parseFloat(n2.height);
    switch (true) {
      case gS(e3):
        l2 -= eM;
        break;
      case mS(e3):
        l2 += eM;
        break;
      case fS(e3):
        a2 -= eM;
        break;
      case vS(e3):
        a2 += eM;
    }
    a2 = ZT(a2, o2, r2), l2 = ZT(l2, this._minHeight, s2), Object.assign(this.style, { width: `${a2}px`, height: `${l2}px` });
  }
  _attachMouseDragHandlers() {
    this._detachScreenResizeHandler(), window.addEventListener("mousemove", this._dragMouseMoveHandler), window.addEventListener("mouseup", this._dragMouseUpHandler);
  }
  _detachMouseDragHandlers() {
    window.removeEventListener("mousemove", this._dragMouseMoveHandler), window.removeEventListener("mouseup", this._dragMouseUpHandler);
  }
  _onResizeMouseDown(e3) {
    if (!this._movable || !this.resizable)
      return;
    e3.preventDefault();
    const { top: t2, left: i2 } = this.getBoundingClientRect(), { width: n2, height: o2, minWidth: r2 } = window.getComputedStyle(this);
    this._initialX = e3.clientX, this._initialY = e3.clientY, this._initialWidth = Number.parseFloat(n2), this._initialHeight = Number.parseFloat(o2), this._initialTop = t2, this._initialLeft = i2, this._minWidth = Number.parseFloat(r2), this._cachedMinHeight = this._minHeight, Object.assign(this.style, { top: `${t2}px`, left: `${i2}px` }), this._attachMouseResizeHandlers();
  }
  _onResizeMouseMove(e3) {
    const { clientX: t2, clientY: i2 } = e3;
    let n2, o2;
    this._isRTL ? (n2 = ZT(this._initialWidth - (t2 - this._initialX), this._minWidth, this._initialLeft + this._initialWidth), o2 = ZT(this._initialLeft + (t2 - this._initialX), 0, this._initialX + this._initialWidth - this._minWidth)) : n2 = ZT(this._initialWidth + (t2 - this._initialX), this._minWidth, window.innerWidth - this._initialLeft);
    const r2 = ZT(this._initialHeight + (i2 - this._initialY), this._cachedMinHeight, window.innerHeight - this._initialTop);
    Object.assign(this.style, { height: `${r2}px`, width: `${n2}px`, left: o2 ? `${o2}px` : void 0 });
  }
  _onResizeMouseUp() {
    delete this._initialX, delete this._initialY, delete this._initialWidth, delete this._initialHeight, delete this._initialTop, delete this._initialLeft, delete this._minWidth, delete this._cachedMinHeight, this._detachMouseResizeHandlers();
  }
  _handleDragStart(e3) {
    this.draggable && e3.preventDefault();
  }
  _attachMouseResizeHandlers() {
    this._detachScreenResizeHandler(), window.addEventListener("mousemove", this._resizeMouseMoveHandler), window.addEventListener("mouseup", this._resizeMouseUpHandler), this.addEventListener("ui5-before-close", this._revertSize, { once: true });
  }
  _detachMouseResizeHandlers() {
    window.removeEventListener("mousemove", this._resizeMouseMoveHandler), window.removeEventListener("mouseup", this._resizeMouseUpHandler);
  }
};
JB([tS()], iM.prototype, "headerText", void 0), JB([tS({ type: Boolean })], iM.prototype, "stretch", void 0), JB([tS({ type: Boolean })], iM.prototype, "draggable", void 0), JB([tS({ type: Boolean })], iM.prototype, "resizable", void 0), JB([tS({ type: eB, defaultValue: eB.None })], iM.prototype, "state", void 0), JB([tS({ type: Boolean })], iM.prototype, "onPhone", void 0), JB([tS({ type: Boolean })], iM.prototype, "onDesktop", void 0), JB([nS()], iM.prototype, "header", void 0), JB([nS()], iM.prototype, "footer", void 0), iM = ZB = JB([eS({ tag: "ui5-dialog", template: function(e3, t2, i2) {
  return XS`<section style="${qS(this.styles.root)}" class="${WS(this.classes.root)}" role="${jS(this._role)}" aria-modal="${jS(this._ariaModal)}" aria-label="${jS(this._ariaLabel)}" aria-labelledby="${jS(this._ariaLabelledBy)}" @keydown=${this._onkeydown} @focusout=${this._onfocusout} @mouseup=${this._onmouseup} @mousedown=${this._onmousedown}><span class="first-fe" data-ui5-focus-trap tabindex="0" @focusin=${this.forwardToLast}></span>${this._displayHeader ? GB.call(this, e3, t2, i2) : void 0}<div style="${qS(this.styles.content)}" class="${WS(this.classes.content)}"  @scroll="${this._scroll}" part="content"><slot></slot></div>${this.footer.length ? jB.call(this, e3, t2, i2) : void 0}${this._showResizeHandle ? XB.call(this, e3, t2, i2) : void 0}<span class="last-fe" data-ui5-focus-trap tabindex="0" @focusin=${this.forwardToFirst}></span></section> `;
}, styles: [YB, KB, { packageName: "@ui5/webcomponents", fileName: "themes/Dialog.css", content: ':host{min-width:20rem;min-height:6rem;max-height:94%;max-width:90%;flex-direction:column;box-shadow:var(--sapContent_Shadow3);border-radius:var(--sapElement_BorderCornerRadius)}:host([stretch]){width:90%;height:94%}:host([stretch][on-phone]){width:100%;height:100%;max-height:100%;max-width:100%;border-radius:0}:host([draggable]) .ui5-popup-header-root,:host([draggable]) ::slotted([slot=header]){cursor:move}:host([draggable]) .ui5-popup-header-root *{cursor:auto}:host([draggable]) .ui5-popup-root{user-select:text}.ui5-popup-root{display:flex;flex-direction:column;max-width:100vw}.ui5-popup-header-root{position:relative}:host([state=Error]) .ui5-popup-header-root{box-shadow:var(--_ui5_dialog_header_error_state_box_shadow)}:host([state=Information]) .ui5-popup-header-root{box-shadow:var(--_ui5_dialog_header_information_state_box_shadow)}:host([state=Success]) .ui5-popup-header-root{box-shadow:var(--_ui5_dialog_header_success_state_box_shadow)}:host([state=Warning]) .ui5-popup-header-root{box-shadow:var(--_ui5_dialog_header_warning_state_box_shadow)}.ui5-dialog-value-state-icon{margin-inline-end:.5rem}:host([state=Error]) .ui5-dialog-value-state-icon{color:var(--_ui5_dialog_header_error_state_icon_color)}:host([state=Information]) .ui5-dialog-value-state-icon{color:var(--_ui5_dialog_header_information_state_icon_color)}:host([state=Success]) .ui5-dialog-value-state-icon{color:var(--_ui5_dialog_header_success_state_icon_color)}:host([state=Warning]) .ui5-dialog-value-state-icon{color:var(--_ui5_dialog_header_warning_state_icon_color)}.ui5-popup-header-root{outline:none}.ui5-popup-header-root:focus-visible:after{content:"";position:absolute;left:var(--_ui5_dialog_header_focus_left_offset);bottom:var(--_ui5_dialog_header_focus_bottom_offset);right:var(--_ui5_dialog_header_focus_right_offset);top:var(--_ui5_dialog_header_focus_top_offset);border:var(--sapContent_FocusWidth) var(--sapContent_FocusStyle) var(--sapContent_FocusColor);border-radius:var(--_ui5_dialog_header_border_radius) var(--_ui5_dialog_header_border_radius) 0 0;pointer-events:none}:host([stretch]) .ui5-popup-content{width:100%;height:100%}.ui5-popup-content{min-height:var(--_ui5_dialog_content_min_height);flex:1 1 auto}.ui5-popup-resize-handle{position:absolute;bottom:var(--_ui5_dialog_resize_handle_bottom);inset-inline-end:var(--_ui5_dialog_resize_handle_right);cursor:var(--_ui5_dialog_resize_cursor);color:var(--_ui5_dialog_resize_handle_color)}:host ::slotted([slot=footer]){height:var(--_ui5_dialog_footer_height)}:host ::slotted([slot=footer][ui5-bar][design=Footer]){border-top:none}' }], dependencies: [WI] })], iM), iM.define();
const nM = iM;
var oM = Object.defineProperty, rM = Object.getOwnPropertyDescriptor, sM = (e3, t2, i2, n2) => {
  for (var o2, r2 = n2 > 1 ? void 0 : n2 ? rM(t2, i2) : t2, s2 = e3.length - 1; s2 >= 0; s2--)
    (o2 = e3[s2]) && (r2 = (n2 ? o2(t2, i2, r2) : o2(r2)) || r2);
  return n2 && r2 && oM(t2, i2, r2), r2;
};
let aM = class extends ae {
  constructor() {
    super(...arguments), this.isColumnMode = false, this.title = "";
  }
  render() {
    return z`
        	<span id="arrow" class="${this.isColumnMode ? "show-up" : "show-left"}" ></span>
            <ui5-dialog id="dialog">
                <ui5-bar slot="header" design="Header"> 
                    <ui5-title level="H6" slot="startContent">
                        ${this.title}
                    </ui5-title>
                    <ui5-button
                        @click="${this._handleExitClicked}" 
                        design="Transparent"
                        id="closeDialogButton"
                        slot="endContent"
                        icon="decline"
                    ></ui5-button>
                </ui5-bar>
                <slot id="content" class="${this.isColumnMode ? "ver-orientation" : "hor-orientation"}" ></slot>
            </ui5-dialog>

           
        `;
  }
  close() {
    this.style.display = "none";
  }
  show(e3) {
    this.style.display = "flex", this.style.setProperty("--arrowOffset", e3 + "px");
  }
  _handleExitClicked() {
    this.style.display = "none", this.dispatchEvent(new Event("tool-area-closed"));
  }
};
aM.styles = r`
    :host {
      max-height: 100%;
      max-width: 100%;
      display:none;
      position: relative;
      pointer-events: auto;
      --arrowOffset: 0;
      --_ui5_popup_content_padding_s: 1rem;
      --_ui5_popup_content_padding_m_l: 1rem;
      --_ui5_popup_content_padding_xl: 1rem;
      --_ui5_popup_header_footer_padding_s: 0rem;
      --_ui5_popup_header_footer_padding_m_l: 0rem;
      --_ui5_popup_header_footer_padding_xl: 0rem;
    }

    ui5-title{
        font-family: var(--sapFontBoldFamily);
        width: 100%;
    }

    ui5-dialog{
        display: flex;
        position: static;
        width: 100%;
        max-width: 100%;
        max-height: 100%;
        min-width: 0px;
    }

    #content.ver-orientation{
        width: 100%;
    }
    #content.hor-orientation{
        height: 100%;
    }

    #arrow{
        pointer-events: none;
        display: block;
        width: 1rem;
        height: 1rem;
        position: absolute;
        overflow: hidden;
    }

    #arrow:after {
        content: "";
        display: block;
        width: 0.7rem;
        height: 0.7rem;
        background-color: var(--sapGroup_ContentBackground);
        box-shadow: var(--sapContent_Shadow3);
        transform: rotate(-45deg);
    }

    #arrow.show-up{
        height: 0.5625rem;
        top: -0.5rem;
        left: -0.5625rem;
        transform: translate(var(--arrowOffset), 0px);
    }
    #arrow.show-up:after{
        margin: var(--_ui5_popover_upward_arrow_margin);
    }

    #arrow.show-left{
        left: -0.5625rem;
        top: -0.5625rem;
        width: 0.5625rem;
        height: 1rem;
        transform: translate(0px,var(--arrowOffset));
    }

    #arrow.show-left:after {
        margin: var(--_ui5_popover_left_arrow_margin);
    }
  `, sM([ue({ type: Boolean })], aM.prototype, "isColumnMode", 2), sM([ue()], aM.prototype, "title", 2), sM([de("#arrow")], aM.prototype, "arrowElement", 2), aM = sM([ce("pv-tool-area")], aM);
var lM = Object.defineProperty, cM = Object.getOwnPropertyDescriptor, hM = (e3, t2, i2, n2) => {
  for (var o2, r2 = n2 > 1 ? void 0 : n2 ? cM(t2, i2) : t2, s2 = e3.length - 1; s2 >= 0; s2--)
    (o2 = e3[s2]) && (r2 = (n2 ? o2(t2, i2, r2) : o2(r2)) || r2);
  return n2 && r2 && lM(t2, i2, r2), r2;
};
let uM = class extends ae {
  constructor() {
    super(...arguments), this.isColumnMode = false, this.currentTitle = "", this._currentToolBarIndex = -1;
  }
  render() {
    return z`
            <div id="toolBar" class="${this.isColumnMode ? "ver-orientation" : "hor-orientation"}">
                <div id="btnBar" class="${this.isColumnMode ? "hor-orientation" : "ver-orientation"}">
                    ${this.tools.map((e3, t2) => z`
                        <ui5-toggle-button data-index = ${t2} @click="${this._handleToolBtnClicked}" ?pressed=${this._currentToolBarIndex == t2} tooltip=${e3.title}>
                            <ui5-icon name= ${e3.icon}></ui5-icon>
                        </ui5-toggle-button> `)}
                </div>
                <pv-tool-area id="toolArea" ?isColumnMode=${this.isColumnMode} title="${this.currentTitle}" @tool-area-closed="${this._handleToolAreaClosed}">
                    <slot  @slotchange = ${() => this.requestUpdate()}></slot>
                </pv-tool-area>
            </div>
        `;
  }
  get tools() {
    var _a2;
    const e3 = (_a2 = this.shadowRoot) == null ? void 0 : _a2.querySelector("slot"), t2 = e3 ? e3.assignedElements() : [];
    return Array.from(t2).filter((e4) => e4 instanceof yT);
  }
  _handleToolBtnClicked(e3) {
    const t2 = e3.target;
    if (void 0 === t2.dataset.index)
      return;
    if (!t2.pressed)
      return this.toolArea.close(), void this._handleToolAreaClosed();
    if (this._handleToolAreaClosed(), this._currentToolBarIndex = Number(t2.dataset.index), this._currentToolBarIndex < 0 || this._currentToolBarIndex >= this.tools.length)
      return;
    let i2 = this.tools[this._currentToolBarIndex];
    i2.isSelected = true, this.currentTitle = i2.title;
    const n2 = Math.max(t2.offsetLeft, t2.offsetTop), o2 = Math.max(t2.offsetWidth, t2.offsetHeight);
    this.toolArea.show(n2 + 0.5 * o2);
  }
  _handleToolAreaClosed() {
    this._currentToolBarIndex > -1 && this._currentToolBarIndex < this.tools.length && (this.tools[this._currentToolBarIndex].isSelected = false), this._currentToolBarIndex = -1;
  }
};
uM.styles = r`
    :host {
      max-height: 100%;
      max-width: 100%;
      --size: 13.5rem;
    }

    #btnBar.hor-orientation{
      width: 100%;
      flex-direction: row;
    }

    #btnBar.ver-orientation{
      height: 100%;
      flex-direction: column;
    }

    #btnBar
    {
      display: flex;
      gap: 0.25rem;
      pointer-events: auto;
    }

    #toolBar.hor-orientation{
      width: calc(100% - 1rem);
      height: var(--size);
      flex-direction: row;
    }

    #toolBar.ver-orientation{
      height: calc(100% - 1rem);
      width: var(--size);
      flex-direction: column;
    }

    #toolBar{
      display: flex;
      gap: 0.5625rem;
      left: 0.5rem;
      top: 0.5rem;
      position: absolute;
      pointer-events: none;
    }

    #toolBar.hor-orientation pv-tool-area{
      height: 100%;
    }

    #toolBar.ver-orientation pv-tool-area{
      width: 100%;
    }

    ui5-toggle-button{
      height: 2.5rem;
      width: 2.5rem;
    }

    ui5-toggle-button ui5-icon{
      height: 85%;
      width: 85%;
    }

    ui5-icon {
      stroke:black;
      fill: black;
      pointer-events: none;
      transform: translateY(2.5%)
    }

    [pressed] ui5-icon {
      color:white;
      stroke:white;
      fill: white;
    }
  `, hM([ue({ type: Boolean })], uM.prototype, "isColumnMode", 2), hM([ue()], uM.prototype, "currentTitle", 2), hM([ue({ type: Number })], uM.prototype, "_currentToolBarIndex", 2), hM([de("#toolArea")], uM.prototype, "toolArea", 2), uM = hM([ce("pv-menu")], uM), Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
var dM = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
let pM = class extends ZC {
  get classes() {
    return { textWrapper: { "ui5-label-text-wrapper": true, "ui5-label-text-wrapper-safari": pI() } };
  }
  _onclick() {
    if (!this.for)
      return;
    const e3 = this.getRootNode().querySelector(`#${this.for}`);
    e3 && e3.focus();
  }
};
dM([tS()], pM.prototype, "for", void 0), dM([tS({ type: Boolean })], pM.prototype, "showColon", void 0), dM([tS({ type: Boolean })], pM.prototype, "required", void 0), dM([tS({ type: NT, defaultValue: NT.None })], pM.prototype, "wrappingType", void 0), pM = dM([eS({ tag: "ui5-label", renderer: KS, template: function(e3, t2, i2) {
  return XS`<label class="ui5-label-root" @click=${this._onclick}><span class="${WS(this.classes.textWrapper)}"><bdi id="${jS(this._id)}-bdi"><slot></slot></bdi></span><span aria-hidden="true" class="ui5-label-required-colon"></span></label>`;
}, styles: { packageName: "@ui5/webcomponents", fileName: "themes/Label.css", content: ':host(:not([hidden])){display:inline-flex}:host{max-width:100%;color:var(--sapContent_LabelColor);font-family:"72override",var(--sapFontFamily);font-size:var(--sapFontSize);font-weight:400;cursor:text}.ui5-label-root{width:100%;cursor:inherit}:host([wrapping-type=Normal]) .ui5-label-root{white-space:normal}:host(:not([wrapping-type=Normal])) .ui5-label-root{display:inline-block;white-space:nowrap}bdi{content:"";padding-right:.075rem}:host(:not([wrapping-type=Normal])) .ui5-label-text-wrapper{text-overflow:ellipsis;overflow:hidden;display:inline-block;vertical-align:top;max-width:100%}:host(:not([wrapping-type=Normal])[required][show-colon]) .ui5-label-text-wrapper,:host(:not([wrapping-type=Normal])[required][show-colon]) .ui5-label-text-wrapper.ui5-label-text-wrapper-safari{max-width:calc(100% - .8rem)}:host(:not([wrapping-type=Normal])[required]) .ui5-label-text-wrapper{max-width:calc(100% - .475rem)}:host(:not([wrapping-type=Normal])[required]) .ui5-label-text-wrapper.ui5-label-text-wrapper-safari{max-width:calc(100% - .425rem)}:host(:not([wrapping-type=Normal])[show-colon]) .ui5-label-text-wrapper{max-width:calc(100% - .125rem)}:host([show-colon]) .ui5-label-required-colon{margin-inline-start:-.05rem}:host([show-colon]) .ui5-label-required-colon:before{content:":"}:host([required]) .ui5-label-required-colon:after{content:"*";color:var(--sapField_RequiredColor);font-size:1.25rem;font-weight:700;position:relative;font-style:normal;vertical-align:middle;line-height:0}:host([required][show-colon]) .ui5-label-required-colon:after{margin-inline-start:.125rem}' } })], pM), pM.define();
const _M = pM, gM = "M455.8 94q9 9 3 19l-222 326q-4 8-12 9t-14-5l-151-167q-5-5-4.5-11t5.5-11l25-25q12-12 23 0l96 96q5 5 13 4.5t12-8.5l175-249q4-7 11.5-8t13.5 4z";
Kx("accept", { pathData: gM, ltr: true, collection: "SAP-icons-v4", packageName: "@ui5/webcomponents-icons" });
const mM = "M186 384q-10 0-17-7l-97-93q-8-8-8-18 0-11 7-18 8-8 19-8 8 0 17 7l79 76 218-219q8-8 18-8t18 8 8 18q0 11-7 18L205 377q-7 7-19 7z";
Kx("accept", { pathData: mM, ltr: true, collection: "SAP-icons-v5", packageName: "@ui5/webcomponents-icons" }), dx(), Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
function fM(e3, t2, i2) {
  return i2 ? XS`<${ZS("ui5-icon", t2, i2)} aria-hidden="true" name="accept" class="ui5-checkbox-icon"></${ZS("ui5-icon", t2, i2)}>` : XS`<ui5-icon aria-hidden="true" name="accept" class="ui5-checkbox-icon"></ui5-icon>`;
}
function vM(e3, t2, i2) {
  return i2 ? XS`<${ZS("ui5-label", t2, i2)} id="${jS(this._id)}-label" class="ui5-checkbox-label" wrapping-type="${jS(this.wrappingType)}">${jS(this.text)}</${ZS("ui5-label", t2, i2)}>` : XS`<ui5-label id="${jS(this._id)}-label" class="ui5-checkbox-label" wrapping-type="${jS(this.wrappingType)}">${jS(this.text)}</ui5-label>`;
}
function AM(e3, t2, i2) {
  return XS`<span id="${jS(this._id)}-descr" class="ui5-hidden-text">${jS(this.valueStateText)}</span>`;
}
var bM, yM = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
let wM, xM = false, CM = bM = class extends ZC {
  constructor() {
    super(), this._deactivate = () => {
      wM && (wM.active = false);
    }, xM || (document.addEventListener("mouseup", this._deactivate), xM = true);
  }
  onBeforeRendering() {
    this._enableFormSupport();
  }
  _enableFormSupport() {
    const e3 = Ky("FormSupport");
    e3 ? e3.syncNativeHiddenInput(this, (e4, t2) => {
      t2.disabled = e4.disabled || !e4.checked, t2.value = e4.checked ? "on" : "";
    }) : this.name && console.warn('In order for the "name" property to have effect, you should also: import "@ui5/webcomponents/dist/features/InputElementsFormSupport.js";');
  }
  _onclick() {
    this.toggle();
  }
  _onmousedown() {
    this.readonly || this.disabled || (this.active = true, wM = this);
  }
  _onmouseup() {
    this.active = false;
  }
  _onfocusout() {
    this.active = false;
  }
  _onkeydown(e3) {
    sS(e3) && (e3.preventDefault(), this.active = true), rS(e3) && (this.toggle(), this.active = true);
  }
  _onkeyup(e3) {
    sS(e3) && this.toggle(), this.active = false;
  }
  toggle() {
    if (this.canToggle()) {
      const e3 = { checked: this.checked, indeterminate: this.indeterminate };
      this.indeterminate ? (this.indeterminate = false, this.checked = true) : this.checked = !this.checked;
      const t2 = !this.fireEvent("change", null, true), i2 = !this.fireEvent("value-changed", null, true);
      (t2 || i2) && (this.checked = e3.checked, this.indeterminate = e3.indeterminate);
    }
    return this;
  }
  canToggle() {
    return !(this.disabled || this.readonly);
  }
  valueStateTextMappings() {
    return { Error: bM.i18nBundle.getText(YE), Warning: bM.i18nBundle.getText(KE), Success: bM.i18nBundle.getText(JE) };
  }
  get ariaLabelText() {
    return bI(this);
  }
  get classes() {
    return { main: { "ui5-checkbox--hoverable": !this.disabled && !this.readonly && mI() } };
  }
  get ariaReadonly() {
    return this.readonly ? "true" : void 0;
  }
  get effectiveAriaDisabled() {
    return this.disabled ? "true" : void 0;
  }
  get effectiveAriaChecked() {
    return this.indeterminate && this.checked ? "mixed" : this.checked;
  }
  get ariaLabelledBy() {
    if (!this.ariaLabelText)
      return this.text ? `${this._id}-label` : void 0;
  }
  get ariaDescribedBy() {
    return this.hasValueState ? `${this._id}-descr` : void 0;
  }
  get hasValueState() {
    return this.valueState !== eB.None;
  }
  get valueStateText() {
    if (this.valueState !== eB.None && this.valueState !== eB.Information)
      return this.valueStateTextMappings()[this.valueState];
  }
  get effectiveTabIndex() {
    const e3 = this.getAttribute("tabindex");
    return this.disabled ? void 0 : e3 || "0";
  }
  get isCompletelyChecked() {
    return this.checked && !this.indeterminate;
  }
  static async onDefine() {
    bM.i18nBundle = await Wx("@ui5/webcomponents");
  }
};
yM([tS()], CM.prototype, "accessibleNameRef", void 0), yM([tS()], CM.prototype, "accessibleName", void 0), yM([tS({ type: Boolean })], CM.prototype, "disabled", void 0), yM([tS({ type: Boolean })], CM.prototype, "readonly", void 0), yM([tS({ type: Boolean })], CM.prototype, "required", void 0), yM([tS({ type: Boolean })], CM.prototype, "indeterminate", void 0), yM([tS({ type: Boolean })], CM.prototype, "checked", void 0), yM([tS()], CM.prototype, "text", void 0), yM([tS({ type: eB, defaultValue: eB.None })], CM.prototype, "valueState", void 0), yM([tS({ type: NT, defaultValue: NT.None })], CM.prototype, "wrappingType", void 0), yM([tS()], CM.prototype, "name", void 0), yM([tS({ type: Boolean })], CM.prototype, "active", void 0), yM([nS()], CM.prototype, "formSupport", void 0), CM = bM = yM([eS({ tag: "ui5-checkbox", languageAware: true, renderer: KS, template: function(e3, t2, i2) {
  return XS`<div class="ui5-checkbox-root ${WS(this.classes.main)}" role="checkbox" part="root" aria-checked="${jS(this.effectiveAriaChecked)}" aria-readonly="${jS(this.ariaReadonly)}" aria-disabled="${jS(this.effectiveAriaDisabled)}" aria-label="${jS(this.ariaLabelText)}" aria-labelledby="${jS(this.ariaLabelledBy)}" aria-describedby="${jS(this.ariaDescribedBy)}" aria-required="${jS(this.required)}" tabindex="${jS(this.effectiveTabIndex)}" @mousedown="${this._onmousedown}" @mouseup="${this._onmouseup}" @keydown="${this._onkeydown}" @keyup="${this._onkeyup}" @click="${this._onclick}" @focusout="${this._onfocusout}"><div id="${jS(this._id)}-CbBg" class="ui5-checkbox-inner">${this.isCompletelyChecked ? fM.call(this, e3, t2, i2) : void 0}<input id="${jS(this._id)}-CB" type='checkbox' ?checked="${this.checked}" ?readonly="${this.readonly}" ?disabled="${this.disabled}" tabindex="-1" aria-hidden="true" data-sap-no-tab-ref /></div>${this.text ? vM.call(this, e3, t2, i2) : void 0}${this.hasValueState ? AM.call(this, e3, t2, i2) : void 0}<slot name="formSupport"></slot></div>`;
}, styles: { packageName: "@ui5/webcomponents", fileName: "themes/CheckBox.css", content: '.ui5-hidden-text{position:absolute;clip:rect(1px,1px,1px,1px);user-select:none;left:-1000px;top:-1000px;pointer-events:none;font-size:0}:host{-webkit-tap-highlight-color:rgba(0,0,0,0)}:host(:not([hidden])){display:inline-block}:host{overflow:hidden;max-width:100%;outline:none;border-radius:var(--_ui5_checkbox_border_radius);transition:var(--_ui5_checkbox_transition);cursor:pointer}:host([disabled]){cursor:default}:host([disabled]) .ui5-checkbox-root{opacity:var(--_ui5_checkbox_disabled_opacity)}:host([disabled]) .ui5-checkbox-inner{border-color:var(--_ui5_checkbox_inner_disabled_border_color)}:host([disabled]) .ui5-checkbox-label{color:var(--_ui5_checkbox_disabled_label_color)}:host([readonly]:not([value-state=Warning]):not([value-state=Error])) .ui5-checkbox-inner{background:var(--sapField_ReadOnly_Background);border:var(--_ui5_checkbox_inner_readonly_border);color:var(--sapField_TextColor)}:host([wrapping-type=Normal][text]) .ui5-checkbox-root{min-height:auto;box-sizing:border-box;align-items:flex-start;padding-top:var(--_ui5_checkbox_root_side_padding);padding-bottom:var(--_ui5_checkbox_root_side_padding)}:host([wrapping-type=Normal][text]) .ui5-checkbox-root .ui5-checkbox-inner,:host([wrapping-type=Normal][text]) .ui5-checkbox-root .ui5-checkbox-label{margin-top:var(--_ui5_checkbox_wrapped_content_margin_top)}:host([wrapping-type=Normal][text]) .ui5-checkbox-root .ui5-checkbox-label{overflow-wrap:break-word;align-self:center}:host([wrapping-type=Normal]) .ui5-checkbox-root:focus:before{bottom:var(--_ui5_checkbox_wrapped_focus_left_top_bottom_position)}:host([value-state=Error]) .ui5-checkbox--hoverable:hover .ui5-checkbox-inner,:host([value-state=Error]) .ui5-checkbox-inner{background:var(--sapField_InvalidBackground);border:var(--_ui5_checkbox_inner_error_border);color:var(--sapField_InvalidColor)}:host([value-state=Error]) .ui5-checkbox--hoverable:hover .ui5-checkbox-inner{background:var(--_ui5_checkbox_inner_error_background_hover)}:host([value-state=Warning]) .ui5-checkbox--hoverable:hover .ui5-checkbox-inner,:host([value-state=Warning]) .ui5-checkbox-inner{background:var(--sapField_WarningBackground);border:var(--_ui5_checkbox_inner_warning_border);color:var(--_ui5_checkbox_inner_warning_color)}:host([value-state=Warning]) .ui5-checkbox--hoverable:hover .ui5-checkbox-inner{background:var(--_ui5_checkbox_inner_warning_background_hover)}:host([value-state=Information]) .ui5-checkbox--hoverable:hover .ui5-checkbox-inner,:host([value-state=Information]) .ui5-checkbox-inner{background:var(--sapField_InformationBackground);border:var(--_ui5_checkbox_inner_information_border);color:var(--_ui5_checkbox_inner_information_color)}:host([value-state=Information]) .ui5-checkbox--hoverable:hover .ui5-checkbox-inner{background:var(--_ui5_checkbox_inner_information_background_hover)}:host([value-state=Success]) .ui5-checkbox--hoverable:hover .ui5-checkbox-inner,:host([value-state=Success]) .ui5-checkbox-inner{background:var(--sapField_SuccessBackground);border:var(--_ui5_checkbox_inner_success_border);color:var(--sapField_SuccessColor)}:host([value-state=Success]) .ui5-checkbox--hoverable:hover .ui5-checkbox-inner{background:var(--_ui5_checkbox_inner_success_background_hover)}:host([value-state=Warning]) .ui5-checkbox-icon,:host([value-state=Warning][indeterminate]) .ui5-checkbox-inner:after{color:var(--_ui5_checkbox_checkmark_warning_color)}:host([text]) .ui5-checkbox-root{padding-inline-end:var(--_ui5_checkbox_right_focus_distance)}:host([text]) .ui5-checkbox-root:focus:before{inset-inline-end:0}.ui5-checkbox-root{position:relative;display:inline-flex;align-items:center;width:100%;min-height:var(--_ui5_checkbox_width_height);min-width:var(--_ui5_checkbox_width_height);padding:0 var(--_ui5_checkbox_wrapper_padding);outline:none;transition:var(--_ui5_checkbox_transition);border:var(--_ui5_checkbox_default_focus_border);border-radius:var(--_ui5_checkbox_border_radius);box-sizing:border-box}.ui5-checkbox-root:focus:before{display:var(--_ui5_checkbox_focus_outline_display);content:"";position:absolute;inset-inline:var(--_ui5_checkbox_focus_position);inset-block:var(--_ui5_checkbox_focus_position);border:var(--_ui5_checkbox_focus_outline);border-radius:var(--_ui5_checkbox_focus_border_radius)}:host .ui5-checkbox-root:focus{border:var(--_ui5_checkbox_focus_border);border-radius:.5rem}:host(:hover:not([disabled])){background:var(--_ui5_checkbox_outer_hover_background)}.ui5-checkbox--hoverable .ui5-checkbox-label:hover{color:var(--_ui5_checkbox_label_color)}:host(:not([active]):not([checked]):not([value-state])) .ui5-checkbox--hoverable:hover .ui5-checkbox-inner,:host(:not([active]):not([checked])[value-state=None]) .ui5-checkbox--hoverable:hover .ui5-checkbox-inner{background:var(--_ui5_checkbox_hover_background);border-color:var(--_ui5_checkbox_inner_hover_border_color)}:host(:not([active])[checked]:not([value-state])) .ui5-checkbox--hoverable:hover .ui5-checkbox-inner,:host(:not([active])[checked][value-state=None]) .ui5-checkbox--hoverable:hover .ui5-checkbox-inner{background:var(--_ui5_checkbox_hover_background);border-color:var(--_ui5_checkbox_inner_hover_checked_border_color)}:host([checked]:not([value-state])) .ui5-checkbox-inner,:host([checked][value-state=None]) .ui5-checkbox-inner{border-color:var(--_ui5_checkbox_inner_selected_border_color)}:host([active]:not([checked]):not([value-state]):not([disabled])) .ui5-checkbox-inner,:host([active]:not([checked])[value-state=None]:not([disabled])) .ui5-checkbox-inner{border-color:var(--_ui5_checkbox_inner_active_border_color);background-color:var(--_ui5_checkbox_active_background)}:host([active][checked]:not([value-state]):not([disabled])) .ui5-checkbox-inner,:host([active][checked][value-state=None]:not([disabled])) .ui5-checkbox-inner{border-color:var(--_ui5_checkbox_inner_selected_border_color);background-color:var(--_ui5_checkbox_active_background)}.ui5-checkbox-inner{min-width:var(--_ui5_checkbox_inner_width_height);max-width:var(--_ui5_checkbox_inner_width_height);height:var(--_ui5_checkbox_inner_width_height);max-height:var(--_ui5_checkbox_inner_width_height);border:var(--_ui5_checkbox_inner_border);border-radius:var(--_ui5_checkbox_inner_border_radius);background:var(--_ui5_checkbox_inner_background);color:var(--_ui5_checkbox_checkmark_color);box-sizing:border-box;position:relative;cursor:inherit}:host([indeterminate][checked]) .ui5-checkbox-inner:after{content:"";background-color:currentColor;position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:var(--_ui5_checkbox_partially_icon_size);height:var(--_ui5_checkbox_partially_icon_size)}.ui5-checkbox-inner input{-webkit-appearance:none;visibility:hidden;width:0;left:0;position:absolute;font-size:inherit}.ui5-checkbox-root .ui5-checkbox-label{margin-inline-start:var(--_ui5_checkbox_label_offset);cursor:inherit;text-overflow:ellipsis;overflow:hidden;pointer-events:none;user-select:none;-webkit-user-select:none;color:var(--_ui5_checkbox_label_color)}.ui5-checkbox-icon{width:var(--_ui5_checkbox_icon_size);height:var(--_ui5_checkbox_icon_size);color:currentColor;cursor:inherit;position:absolute;left:50%;top:50%;transform:translate(-50%,-50%)}' }, dependencies: [_M, WI] }), iS("change")], CM), CM.define();
const SM = CM;
class EM extends iI {
  static isValid(e3) {
    return /^(#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})|rgb\(\s*((1?[0-9]?[0-9]|2([0-4][0-9]|5[0-5]))|([0-9]?[0-9](\.[0-9]+)?|100(\.0+)?)%)\s*(,\s*((1?[0-9]?[0-9]|2([0-4][0-9]|5[0-5]))|([0-9]?[0-9](\.[0-9]+)?|100(\.0+)?)%)\s*){2}\)|rgba\((\s*((1?[0-9]?[0-9]|2([0-4][0-9]|5[0-5]))|([0-9]?[0-9](\.[0-9]+)?|100(\.0+)?)%)\s*,){3}\s*(0(\.[0-9]+)?|1(\.0+)?)\s*\)|hsl\(\s*([0-2]?[0-9]?[0-9]|3([0-5][0-9]|60))\s*(,\s*(([0-9]?[0-9](\.[0-9]+)?|100(\.0+)?)%)\s*){2}\)|hsla\(\s*([0-2]?[0-9]?[0-9]|3([0-5][0-9]|60))\s*,(\s*(([0-9]?[0-9](\.[0-9]+)?|100(\.0+)?)%)\s*,){2}\s*(0(\.[0-9]+)?|1(\.0+)?)\s*\)|aliceblue|antiquewhite|aqua|aquamarine|azure|beige|bisque|black|blanchedalmond|blue|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgrey|darkgreen|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|fuchsia|gainsboro|ghostwhite|gold|goldenrod|gray|grey|green|greenyellow|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgrey|lightgreen|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|lime|limegreen|linen|magenta|maroon|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|navy|oldlace|olive|olivedrab|orange|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|purple|red|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|silverskyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|teal|thistle|tomato|turquoise|violet|wheat|white|whitesmoke|yellow|yellowgreen|transparent|inherit|)$/.test(e3);
  }
}
function IM(e3, t2, i2) {
  return i2 ? XS`<div class="ui5-cp-default-color-button-wrapper"><${ZS("ui5-button", t2, i2)} class="ui5-cp-default-color-button" design="Transparent" @click=${this._onDefaultColorClick} @keydown=${this._onDefaultColorKeyDown}>Default color</${ZS("ui5-button", t2, i2)}><div class="ui5-cp-separator"></div></div>` : XS`<div class="ui5-cp-default-color-button-wrapper"><ui5-button class="ui5-cp-default-color-button" design="Transparent" @click=${this._onDefaultColorClick} @keydown=${this._onDefaultColorKeyDown}>Default color</ui5-button><div class="ui5-cp-separator"></div></div>`;
}
function TM(e3, t2, i2, n2, o2) {
  return XS`<slot name="${jS(n2._individualSlot)}"></slot>`;
}
function BM(e3, t2, i2) {
  return i2 ? XS`<div class="ui5-cp-more-colors-wrapper"><div class="ui5-cp-separator"></div><${ZS("ui5-button", t2, i2)} design="Transparent" class="ui5-cp-more-colors" @click="${this._openMoreColorsDialog}" @keydown=${this._onMoreColorsKeyDown}>${jS(this.colorPaleteMoreColorsText)}</${ZS("ui5-button", t2, i2)}></div>` : XS`<div class="ui5-cp-more-colors-wrapper"><div class="ui5-cp-separator"></div><ui5-button design="Transparent" class="ui5-cp-more-colors" @click="${this._openMoreColorsDialog}" @keydown=${this._onMoreColorsKeyDown}>${jS(this.colorPaleteMoreColorsText)}</ui5-button></div>`;
}
function MM(e3, t2, i2) {
  return XS`<div class="ui5-cp-recent-colors-wrapper"><div class="ui5-cp-separator"></div><div class="ui5-cp-recent-colors-container" @keydown="${this._onRecentColorsContainerKeyDown}">${$S(this.recentColors, (e4, t3) => e4._id || t3, (n2, o2) => kM.call(this, e3, t2, i2, n2, o2))}</div></div>`;
}
function kM(e3, t2, i2, n2, o2) {
  return i2 ? XS`<${ZS("ui5-color-palette-item", t2, i2)} value="${jS(n2)}"></${ZS("ui5-color-palette-item", t2, i2)}>` : XS`<ui5-color-palette-item value="${jS(n2)}"></ui5-color-palette-item>`;
}
Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
var RM, PM = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
let DM = RM = class extends ZC {
  static async onDefine() {
    RM.i18nBundle = await Wx("@ui5/webcomponents");
  }
  constructor() {
    super();
  }
  onBeforeRendering() {
    this._disabled = !this.value, this.phone = gI();
  }
  get colorLabel() {
    return RM.i18nBundle.getText(_E);
  }
  get styles() {
    return { root: { "background-color": this.value } };
  }
};
PM([tS({ validator: EM })], DM.prototype, "value", void 0), PM([tS({ defaultValue: "-1", noAttribute: true })], DM.prototype, "_tabIndex", void 0), PM([tS({ validator: nI })], DM.prototype, "index", void 0), PM([tS({ type: Boolean })], DM.prototype, "phone", void 0), PM([tS({ type: Boolean })], DM.prototype, "_disabled", void 0), DM = RM = PM([eS({ tag: "ui5-color-palette-item", renderer: KS, styles: { packageName: "@ui5/webcomponents", fileName: "themes/ColorPaletteItem.css", content: ':host(:not([hidden])){height:var(--_ui5_color-palette-item-height);width:var(--_ui5_color-palette-item-height);border:1px solid var(--sapContent_ForegroundBorderColor);border-radius:var(--_ui5_color-palette-item-outer-border-radius);display:inline-block;margin:var(--_ui5_color-palette-item-margin);box-sizing:border-box}:host(:not([_disabled]):hover){height:var(--_ui5_color-palette-item-hover-height);width:var(--_ui5_color-palette-item-hover-height);margin:var(--_ui5_color-palette-item-hover-margin);border-radius:var(--_ui5_color-palette-item-hover-outer-border-radius)}:host(:not([hidden])[phone]){height:2.75rem;width:2.75rem;border:1px solid var(--sapContent_ForegroundBorderColor);border-radius:.25rem;display:inline-block;margin:.375rem}.ui5-cp-item{position:relative;box-sizing:border-box;border-radius:var(--_ui5_color-palette-item-inner-border-radius);width:100%;height:100%}:host(:not([_disabled]):not([phone]):hover) .ui5-cp-item{border-radius:var(--_ui5_color-palette-item-hover-inner-border-radius)}:host(:not([_disabled])[phone]) .ui5-cp-item{border-radius:.1875rem}.ui5-cp-item:hover:not(:focus){border:1px solid var(--sapGroup_ContentBackground);border-radius:var(--_ui5_color-palette-item-hover-inner-border-radius);box-sizing:border-box}:host(:not([_disabled]):not([phone])) .ui5-cp-item:focus{outline:none}:host(:not([_disabled]):not([phone]):focus) .ui5-cp-item{pointer-events:none}:host(:not([_disabled]):not([phone])) .ui5-cp-item:focus:not(:hover):before{content:"";box-sizing:border-box;position:absolute;left:var(--_ui5_color-palette-item-before-focus-offset);top:var(--_ui5_color-palette-item-before-focus-offset);right:var(--_ui5_color-palette-item-before-focus-offset);bottom:var(--_ui5_color-palette-item-before-focus-offset);border:var(--_ui5_color-palette-item-before-focus-color);border-radius:var(--_ui5_color-palette-item-before-focus-border-radius);pointer-events:none}:host(:not([_disabled])) .ui5-cp-item:focus:not(:hover):after{content:"";box-sizing:border-box;position:absolute;left:var(--_ui5_color-palette-item-after-focus-offset);top:var(--_ui5_color-palette-item-after-focus-offset);right:var(--_ui5_color-palette-item-after-focus-offset);bottom:var(--_ui5_color-palette-item-after-focus-offset);border:var(--_ui5_color-palette-item-after-focus-color);border-radius:var(--_ui5_color-palette-item-after-focus-border-radius);pointer-events:none}:host(:not([_disabled]):not([phone]):hover:focus) .ui5-cp-item:focus:not(:hover):before{content:"";box-sizing:border-box;position:absolute;left:var(--_ui5_color-palette-item-before-focus-hover-offset);top:var(--_ui5_color-palette-item-before-focus-hover-offset);right:var(--_ui5_color-palette-item-before-focus-hover-offset);bottom:var(--_ui5_color-palette-item-before-focus-hover-offset);border:var(--_ui5_color-palette-item-before-focus-color);border-radius:var(--_ui5_color-palette-item-before-focus-border-radius);pointer-events:none}:host(:not([_disabled]):not([phone]):hover:focus) .ui5-cp-item:focus:not(:hover):after{content:"";box-sizing:border-box;position:absolute;left:var(--_ui5_color-palette-item-after-focus-hover-offset);top:var(--_ui5_color-palette-item-after-focus-hover-offset);right:var(--_ui5_color-palette-item-after-focus-hover-offset);bottom:var(--_ui5_color-palette-item-after-focus-hover-offset);border:var(--_ui5_color-palette-item-after-focus-color);border-radius:var(--_ui5_color-palette-item-after-focus-border-radius);pointer-events:none}' }, template: function(e3, t2, i2) {
  return XS`<div class="ui5-cp-item" style="${qS(this.styles.root)}" value="${jS(this.value)}" tabindex="${jS(this._tabIndex)}" role="button" aria-label="${jS(this.colorLabel)} - ${jS(this.index)}: ${jS(this.value)}" title="${jS(this.colorLabel)} - ${jS(this.index)}: ${jS(this.value)}" ?disabled="${this._disabled}"></div>`;
} })], DM), DM.define();
const LM = DM;
Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
var FM, NM = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
let OM = FM = class extends ZC {
  static async onDefine() {
    const e3 = Ky("ColorPaletteMoreColors");
    [FM.i18nBundle] = await Promise.all([Wx("@ui5/webcomponents"), e3 ? e3.init() : Promise.resolve()]);
  }
  constructor() {
    super(), this._itemNavigation = new NS(this, { getItemsCallback: () => this.displayedColors, rowSize: this.rowSize, behavior: FS.Cyclic }), this._itemNavigationRecentColors = new NS(this, { getItemsCallback: () => this.recentColorsElements, rowSize: this.rowSize, behavior: FS.Static }), this._recentColors = [];
  }
  onBeforeRendering() {
    if (this.displayedColors.forEach((e3, t2) => {
      e3.index = t2 + 1;
    }), this.showMoreColors) {
      const e3 = Ky("ColorPaletteMoreColors");
      if (!e3)
        throw new Error('You have to import "@ui5/webcomponents/dist/features/ColorPaletteMoreColors.js" module to use the more-colors functionality.');
      this.moreColorsFeature = new e3();
    }
  }
  selectColor(e3) {
    e3.value && (e3.focus(), this.displayedColors.includes(e3) && this._itemNavigation.setCurrentItem(e3), this._setColor(e3.value));
  }
  _setColor(e3) {
    this._selectedColor = e3, this._recentColors[0] !== this._selectedColor && (this._recentColors.includes(this._selectedColor) ? this._recentColors.unshift(this._recentColors.splice(this._recentColors.indexOf(this._selectedColor), 1)[0]) : this._recentColors.unshift(this._selectedColor)), this.fireEvent("item-click", { color: this._selectedColor });
  }
  _onclick(e3) {
    const t2 = e3.target;
    t2.hasAttribute("ui5-color-palette-item") && this.selectColor(t2);
  }
  _onkeyup(e3) {
    const t2 = e3.target;
    sS(e3) && t2.hasAttribute("ui5-color-palette-item") && (e3.preventDefault(), this.selectColor(t2));
  }
  _onkeydown(e3) {
    const t2 = e3.target;
    rS(e3) && t2.hasAttribute("ui5-color-palette-item") && this.selectColor(t2);
  }
  _onDefaultColorKeyDown(e3) {
    if (wS(e3) && this.popupMode && (e3.preventDefault(), this._onDefaultColorClick()), hS(e3))
      e3.stopPropagation(), this.focusColorElement(this.colorPaletteNavigationElements[1], this._itemNavigation);
    else if (cS(e3)) {
      e3.stopPropagation();
      const t2 = this.colorPaletteNavigationElements[this.colorPaletteNavigationElements.length - 1];
      if (this.hasRecentColors)
        this.focusColorElement(t2, this._itemNavigationRecentColors);
      else if (this.showMoreColors)
        t2.focus();
      else {
        const e4 = this.displayedColors.length % this.rowSize * this.rowSize;
        this.focusColorElement(this.displayedColors[e4], this._itemNavigation);
      }
    }
  }
  _onMoreColorsKeyDown(e3) {
    const t2 = e3.target, i2 = this.colorPaletteNavigationElements.indexOf(t2), n2 = this.displayedColors.length % this.rowSize * this.rowSize;
    cS(e3) ? (e3.stopPropagation(), this.focusColorElement(this.displayedColors[n2], this._itemNavigation)) : hS(e3) && (e3.stopPropagation(), this.hasRecentColors ? this.focusColorElement(this.colorPaletteNavigationElements[i2 + 1], this._itemNavigationRecentColors) : this.showDefaultColor ? this.colorPaletteNavigationElements[0].focus() : this.focusColorElement(this.displayedColors[0], this._itemNavigation));
  }
  _onColorContainerKeyDown(e3) {
    const t2 = e3.target, i2 = this.colorPaletteNavigationElements[this.colorPaletteNavigationElements.length - 1];
    if (wS(e3) && this.popupMode && (e3.preventDefault(), this.selectColor(t2)), cS(e3) && t2 === this.displayedColors[0] && this.colorPaletteNavigationElements.length > 1)
      e3.stopPropagation(), this.showDefaultColor ? this.colorPaletteNavigationElements[0].focus() : !this.showDefaultColor && this.hasRecentColors ? this.focusColorElement(i2, this._itemNavigationRecentColors) : !this.showDefaultColor && this.showMoreColors && i2.focus();
    else if (hS(e3) && t2 === this.displayedColors[this.displayedColors.length - 1] && this.colorPaletteNavigationElements.length > 1) {
      e3.stopPropagation();
      const t3 = this.showDefaultColor && !this.showMoreColors && this.hasRecentColors || !this.showDefaultColor && !this.showMoreColors && this.hasRecentColors;
      this.showDefaultColor && this.showMoreColors ? this.colorPaletteNavigationElements[2].focus() : !this.showDefaultColor || this.showMoreColors || this.showRecentColors && this.recentColors[0] ? t3 ? this.focusColorElement(i2, this._itemNavigationRecentColors) : !this.showDefaultColor && this.showMoreColors && this.colorPaletteNavigationElements[1].focus() : this.colorPaletteNavigationElements[0].focus();
    }
  }
  _onRecentColorsContainerKeyDown(e3) {
    if (cS(e3)) {
      if (this.showMoreColors) {
        const e4 = this.showDefaultColor ? 2 : 1;
        this.colorPaletteNavigationElements[e4].focus();
      } else if (!this.showMoreColors && this.colorPaletteNavigationElements.length > 1) {
        const t2 = this.displayedColors.length % this.rowSize * this.rowSize;
        e3.stopPropagation(), this.focusColorElement(this.displayedColors[t2], this._itemNavigation);
      }
    } else
      hS(e3) && (this.showDefaultColor ? this.colorPaletteNavigationElements[0].focus() : (e3.stopPropagation(), this.focusColorElement(this.displayedColors[0], this._itemNavigation)));
  }
  focusColorElement(e3, t2) {
    t2.setCurrentItem(e3), t2._focusCurrentItem();
  }
  async _chooseCustomColor() {
    const e3 = await this.getColorPicker();
    this._setColor(e3.color), this._closeDialog();
  }
  async _closeDialog() {
    (await this._getDialog()).close();
  }
  async _openMoreColorsDialog() {
    (await this._getDialog()).show();
  }
  _onDefaultColorClick() {
    this.defaultColor && this._setColor(this.defaultColor);
  }
  get selectedColor() {
    return this._selectedColor;
  }
  get displayedColors() {
    return this.getSlottedNodes("colors").filter((e3) => e3.value).slice(0, 15);
  }
  get colorContainerLabel() {
    return FM.i18nBundle.getText(dE);
  }
  get colorPaleteMoreColorsText() {
    return FM.i18nBundle.getText(vE);
  }
  get _showMoreColors() {
    return this.showMoreColors && this.moreColorsFeature;
  }
  get rowSize() {
    return 5;
  }
  get hasRecentColors() {
    return this.showRecentColors && this.recentColors[0];
  }
  get recentColors() {
    for (this._recentColors.length > this.rowSize && (this._recentColors = this._recentColors.slice(0, this.rowSize)); this._recentColors.length < this.rowSize; )
      this._recentColors.push("");
    return this._recentColors;
  }
  get recentColorsElements() {
    const e3 = this.getDomRef();
    return e3 ? Array.from(e3.querySelectorAll(".ui5-cp-recent-colors-wrapper [ui5-color-palette-item]")).filter((e4) => "" !== e4.value) : [];
  }
  get colorPaletteNavigationElements() {
    const e3 = [], t2 = this.shadowRoot.querySelector(".ui5-cp-root");
    return this.showDefaultColor && e3.push(t2.querySelector(".ui5-cp-default-color-button")), e3.push(this.displayedColors[0]), this.showMoreColors && e3.push(t2.querySelector(".ui5-cp-more-colors")), this.showRecentColors && this.recentColorsElements.length && e3.push(this.recentColorsElements[0]), e3;
  }
  get classes() {
    return { colorPaletteRoot: { "ui5-cp-root": true, "ui5-cp-root-phone": gI() } };
  }
  async _getDialog() {
    return (await this.getStaticAreaItemDomRef()).querySelector("[ui5-dialog]");
  }
  async getColorPicker() {
    return (await this._getDialog()).content[0].querySelector("[ui5-color-picker]");
  }
};
NM([tS({ type: Boolean })], OM.prototype, "showRecentColors", void 0), NM([tS({ type: Boolean })], OM.prototype, "showMoreColors", void 0), NM([tS({ type: Boolean })], OM.prototype, "showDefaultColor", void 0), NM([tS({ validator: EM })], OM.prototype, "defaultColor", void 0), NM([tS({ validator: EM })], OM.prototype, "_selectedColor", void 0), NM([tS({ type: Boolean })], OM.prototype, "popupMode", void 0), NM([nS({ default: true, type: HTMLElement, invalidateOnChildChange: true, individualSlots: true })], OM.prototype, "colors", void 0), OM = FM = NM([eS({ tag: "ui5-color-palette", renderer: KS, template: function(e3, t2, i2) {
  return XS`<div class="${WS(this.classes.colorPaletteRoot)}" @click=${this._onclick} @keyup=${this._onkeyup} @keydown=${this._onkeydown}>${this.showDefaultColor ? IM.call(this, e3, t2, i2) : void 0}<div class="ui5-cp-item-container" role="region" aria-label="${jS(this.colorContainerLabel)}" @keydown="${this._onColorContainerKeyDown}">${$S(this.displayedColors, (e4, t3) => e4._id || t3, (n2, o2) => TM.call(this, e3, t2, i2, n2, o2))}</div>${this._showMoreColors ? BM.call(this, e3, t2, i2) : void 0}${this.showRecentColors ? MM.call(this, e3, t2, i2) : void 0}</div>`;
}, staticAreaTemplate: function(e3, t2, i2) {
  return i2 ? XS`<${ZS("ui5-dialog", t2, i2)} header-text="${jS(this.moreColorsFeature.colorPaletteDialogTitle)}"><div class="ui5-cp-dialog-content"><${ZS("ui5-color-picker", t2, i2)}></${ZS("ui5-color-picker", t2, i2)}></div><div slot="footer" class="ui5-cp-dialog-footer"><${ZS("ui5-button", t2, i2)} design="Emphasized" @click="${this._chooseCustomColor}">${jS(this.moreColorsFeature.colorPaletteDialogOKButton)}</${ZS("ui5-button", t2, i2)}><${ZS("ui5-button", t2, i2)} design="Transparent" @click="${this._closeDialog}">${jS(this.moreColorsFeature.colorPaletteCancelButton)}</${ZS("ui5-button", t2, i2)}></div></${ZS("ui5-dialog", t2, i2)}>` : XS`<ui5-dialog header-text="${jS(this.moreColorsFeature.colorPaletteDialogTitle)}"><div class="ui5-cp-dialog-content"><ui5-color-picker></ui5-color-picker></div><div slot="footer" class="ui5-cp-dialog-footer"><ui5-button design="Emphasized" @click="${this._chooseCustomColor}">${jS(this.moreColorsFeature.colorPaletteDialogOKButton)}</ui5-button><ui5-button design="Transparent" @click="${this._closeDialog}">${jS(this.moreColorsFeature.colorPaletteCancelButton)}</ui5-button></div></ui5-dialog>`;
}, styles: { packageName: "@ui5/webcomponents", fileName: "themes/ColorPalette.css", content: ":host(:not([hidden])){display:inline-block}:host(:not([hidden])[popup-mode]){width:100%}.ui5-cp-root{display:flex;flex-direction:column}.ui5-cp-recent-colors-wrapper,.ui5-cp-root.ui5-cp-root-phone,.ui5-cp-root.ui5-cp-root-phone .ui5-cp-default-color-button-wrapper,.ui5-cp-root.ui5-cp-root-phone .ui5-cp-more-colors-wrapper,.ui5-cp-separator{width:100%}.ui5-cp-root.ui5-cp-root-phone .ui5-cp-item-container{width:18.5rem;max-width:19.5rem;max-height:13rem;padding:.375rem .625rem}.ui5-cp-recent-colors-wrapper{display:flex;align-items:center;flex-direction:column}.ui5-cp-root.ui5-cp-root-phone{display:flex;align-items:center}.ui5-cp-item-container{display:flex;max-width:var(--_ui5_color-palette-row-width);flex-flow:wrap;max-height:var(--_ui5_color-palette-row-height);overflow:hidden;padding:var(--_ui5_color-palette-swatch-container-padding)}.ui5-cp-default-color-button,.ui5-cp-more-colors{width:100%;height:var(--_ui5_color-palette-button-height);text-align:center;border:none}.ui5-cp-default-color-button-wrapper,.ui5-cp-more-colors-wrapper{display:flex;flex-direction:column}.ui5-cp-separator{height:.0625rem;background:var(--sapToolbar_SeparatorColor)}.ui5-cp-default-color-button,.ui5-cp-more-colors{padding:.0625rem}" }, staticAreaStyles: { packageName: "@ui5/webcomponents", fileName: "themes/ColorPaletteStaticArea.css", content: ".ui5-cp-dialog-content{display:flex;justify-content:center;align-items:center;margin:1rem 0}.ui5-cp-dialog-footer{width:100%;display:flex;justify-content:flex-end;margin:.1875rem 1rem}.ui5-cp-dialog-footer [ui5-button]:first-child{margin-right:1rem}" }, get dependencies() {
  const e3 = Ky("ColorPaletteMoreColors");
  return [LM, ZI].concat(e3 ? e3.dependencies : []);
} }), iS("item-click", { detail: { color: { type: String } } })], OM), OM.define();
const zM = OM;
function UM(e3, t2, i2, n2, o2) {
  return XS`<slot name="${jS(n2._individualSlot)}"></slot>`;
}
Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
const HM = { packageName: "@ui5/webcomponents", fileName: "themes/ResponsivePopoverCommon.css", content: '.input-root-phone{flex:1;position:relative;height:var(--_ui5_input_height);color:var(--sapField_TextColor);font-size:var(--sapFontSize);font-family:"72override",var(--sapFontFamily);background:var(--sapField_BackgroundStyle);background-color:var(--_ui5_input_background_color);border:var(--_ui5-input-border);border-radius:var(--_ui5_input_border_radius);box-sizing:border-box}.input-root-phone [inner-input]{padding:0 .5rem;width:100%;height:100%}.input-root-phone [inner-input]:focus{background-color:var(--sapField_Focus_Background)}.input-root-phone:focus-within:before{content:"";position:absolute;pointer-events:none;z-index:2;border:var(--sapContent_FocusWidth) var(--sapContent_FocusStyle) var(--sapContent_FocusColor);border-radius:var(--_ui5_input_focus_border_radius);top:var(--_ui5_input_focus_offset);bottom:var(--_ui5_input_focus_offset);left:var(--_ui5_input_focus_offset);right:var(--_ui5_input_focus_offset)}.input-root-phone [value-state=Error] [input-icon][data-ui5-compact-size],.input-root-phone [value-state=Success] [input-icon][data-ui5-compact-size],.input-root-phone [value-state=Warning] [input-icon][data-ui5-compact-size]{padding:.1875rem .5rem}[inner-input]{background:transparent;color:inherit;border:none;font-style:normal;-webkit-appearance:none;-moz-appearance:textfield;line-height:normal;padding:var(--_ui5_input_inner_padding);box-sizing:border-box;min-width:3rem;text-overflow:ellipsis;flex:1;outline:none;font-size:inherit;font-family:inherit;border-radius:var(--_ui5_input_border_radius)}[inner-input]::-moz-selection,[inner-input]::selection{background:var(--sapSelectedColor);color:var(--sapContent_ContrastTextColor)}[inner-input]::-webkit-input-placeholder{font-style:italic;color:var(--sapField_PlaceholderTextColor)}[inner-input]::-moz-placeholder{font-style:italic;color:var(--sapField_PlaceholderTextColor)}.input-root-phone[value-state]:not([value-state=None]){border-width:var(--_ui5_input_state_border_width)}.input-root-phone[value-state=Error] [inner-input],.input-root-phone[value-state=Warning] [inner-input]{font-style:var(--_ui5_input_error_warning_font_style)}.input-root-phone[value-state=Error] [inner-input]{font-weight:var(--_ui5_input_error_font_weight)}.input-root-phone[value-state=Error]:not([readonly]){background:var(--sapField_InvalidBackgroundStyle);background-color:var(--sapField_InvalidBackground);border-color:var(--_ui5_input_value_state_error_border_color)}.input-root-phone[value-state=Error]:not([readonly]) [inner-input]:focus{background-color:var(--_ui5_input_focused_value_state_error_background);border-color:var(--_ui5_input_focused_value_state_error_border_color)}.input-root-phone[value-state=Error]:not([readonly]):focus-within:before{border-color:var(--_ui5_input_focused_value_state_error_focus_outline_color)}.input-root-phone[value-state=Error]:not([readonly]):not([disabled]),.input-root-phone[value-state=Information]:not([readonly]):not([disabled]),.input-root-phone[value-state=Warning]:not([readonly]):not([disabled]){border-style:var(--_ui5_input_error_warning_border_style)}.input-root-phone[value-state=Warning]:not([readonly]){background:var(--sapField_WarningBackgroundStyle);background-color:var(--sapField_WarningBackground);border-color:var(--_ui5_input_value_state_warning_border_color)}.input-root-phone[value-state=Warning]:not([readonly]) [inner-input]:focus{background-color:var(--_ui5_input_focused_value_state_warning_background);border-color:var(--_ui5_input_focused_value_state_warning_border_color)}.input-root-phone[value-state=Warning]:not([readonly]):focus-within:before{border-color:var(--_ui5_input_focused_value_state_warning_focus_outline_color)}.input-root-phone[value-state=Success]:not([readonly]){background:var(--sapField_SuccessBackgroundStyle);background-color:var(--sapField_SuccessBackground);border-color:var(--_ui5_input_value_state_success_border_color);border-width:var(--_ui5_input_value_state_success_border_width)}.input-root-phone[value-state=Success]:not([readonly]) [inner-input]:focus{background-color:var(--_ui5_input_focused_value_state_success_background);border-color:var(--_ui5_input_focused_value_state_success_border_color)}.input-root-phone[value-state=Success]:not([readonly]):focus-within:before{border-color:var(--_ui5_input_focused_value_state_success_focus_outline_color)}.input-root-phone[value-state=Information]:not([readonly]){background:var(--sapField_InformationBackgroundStyle);background-color:var(--sapField_InformationBackground);border-color:var(--_ui5_input_value_state_information_border_color);border-width:var(--_ui5_input_information_border_width)}.input-root-phone[value-state=Information]:not([readonly]) [inner-input]:focus{background-color:var(--_ui5_input_focused_value_state_information_background);border-color:var(--_ui5_input_focused_value_state_information_border_color)}.ui5-multi-combobox-toggle-button{margin-left:.5rem}.ui5-responsive-popover-header{width:100%;min-height:2.5rem;display:flex;flex-direction:column}.ui5-responsive-popover-header-text{width:calc(100% - var(--_ui5_button_base_min_width))}.ui5-responsive-popover-header .row{box-sizing:border-box;padding:.25rem 1rem;min-height:2.5rem;display:flex;justify-content:center;align-items:center;font-size:var(--sapFontHeader5Size)}.ui5-responsive-popover-footer{display:flex;justify-content:flex-end;padding:.25rem 0;width:100%}.ui5-responsive-popover-close-btn{position:absolute;right:1rem}' };
function QM(e3, t2, i2) {
  return i2 ? XS`<${ZS("ui5-dialog", t2, i2)} accessible-name=${jS(this.accessibleName)} accessible-name-ref=${jS(this.accessibleNameRef)} accessible-role=${jS(this.accessibleRole)} stretch _disable-initial-focus @ui5-before-open="${jS(this._beforeDialogOpen)}" @ui5-after-open="${jS(this._propagateDialogEvent)}" @ui5-before-close="${jS(this._propagateDialogEvent)}" @ui5-after-close="${jS(this._afterDialogClose)}" exportparts="content, header, footer">${this._hideHeader ? void 0 : VM.call(this, e3, t2, i2)}<slot></slot><slot slot="footer" name="footer"></slot></${ZS("ui5-dialog", t2, i2)}>` : XS`<ui5-dialog accessible-name=${jS(this.accessibleName)} accessible-name-ref=${jS(this.accessibleNameRef)} accessible-role=${jS(this.accessibleRole)} stretch _disable-initial-focus @ui5-before-open="${jS(this._beforeDialogOpen)}" @ui5-after-open="${jS(this._propagateDialogEvent)}" @ui5-before-close="${jS(this._propagateDialogEvent)}" @ui5-after-close="${jS(this._afterDialogClose)}" exportparts="content, header, footer">${this._hideHeader ? void 0 : VM.call(this, e3, t2, i2)}<slot></slot><slot slot="footer" name="footer"></slot></ui5-dialog>`;
}
function VM(e3, t2, i2) {
  return XS`${this.header.length ? GM.call(this, e3, t2, i2) : $M.call(this, e3, t2, i2)}`;
}
function GM(e3, t2, i2) {
  return XS`<slot slot="header" name="header"></slot>`;
}
function $M(e3, t2, i2) {
  return XS`<div class="${WS(this.classes.header)}" slot="header">${this.headerText ? WM.call(this, e3, t2, i2) : void 0}${this._hideCloseButton ? void 0 : qM.call(this, e3, t2, i2)}</div>`;
}
function WM(e3, t2, i2) {
  return i2 ? XS`<${ZS("ui5-title", t2, i2)} level="H2" class="ui5-popup-header-text ui5-responsive-popover-header-text">${jS(this.headerText)}</${ZS("ui5-title", t2, i2)}>` : XS`<ui5-title level="H2" class="ui5-popup-header-text ui5-responsive-popover-header-text">${jS(this.headerText)}</ui5-title>`;
}
function qM(e3, t2, i2) {
  return i2 ? XS`<${ZS("ui5-button", t2, i2)} icon="decline" design="Transparent" aria-label="${jS(this._closeDialogAriaLabel)}" @click="${this.close}"></${ZS("ui5-button", t2, i2)}>` : XS`<ui5-button icon="decline" design="Transparent" aria-label="${jS(this._closeDialogAriaLabel)}" @click="${this.close}"></ui5-button>`;
}
function jM(e3, t2, i2) {
  return XS`<section style="${qS(this.styles.root)}" class="${WS(this.classes.root)}" role="${jS(this._role)}" aria-modal="${jS(this._ariaModal)}" aria-label="${jS(this._ariaLabel)}" aria-labelledby="${jS(this._ariaLabelledBy)}" @keydown=${this._onkeydown} @focusout=${this._onfocusout} @mouseup=${this._onmouseup} @mousedown=${this._onmousedown}><span class="first-fe" data-ui5-focus-trap tabindex="0" @focusin=${this.forwardToLast}></span><span class="ui5-popover-arrow" style="${qS(this.styles.arrow)}"></span>${this._displayHeader ? XM.call(this, e3, t2, i2) : void 0}<div style="${qS(this.styles.content)}" class="${WS(this.classes.content)}"  @scroll="${this._scroll}" part="content"><slot></slot></div>${this._displayFooter ? ZM.call(this, e3, t2, i2) : void 0}<span class="last-fe" data-ui5-focus-trap tabindex="0" @focusin=${this.forwardToFirst}></span></section>`;
}
function XM(e3, t2, i2) {
  return XS`<header class="ui5-popup-header-root" id="ui5-popup-header" part="header">${this.header.length ? YM.call(this, e3, t2, i2) : KM.call(this, e3, t2, i2)}</header>`;
}
function YM(e3, t2, i2) {
  return XS`<slot name="header"></slot>`;
}
function KM(e3, t2, i2) {
  return XS`<h1 class="ui5-popup-header-text">${jS(this.headerText)}</h1>`;
}
function ZM(e3, t2, i2) {
  return XS`${this.footer.length ? JM.call(this, e3, t2, i2) : void 0}`;
}
function JM(e3, t2, i2) {
  return XS`<footer class="ui5-popup-footer-root" part="footer"><slot name="footer"></slot></footer>`;
}
var ek;
!function(e3) {
  e3.Left = "Left", e3.Right = "Right", e3.Top = "Top", e3.Bottom = "Bottom";
}(ek || (ek = {}));
const tk = ek;
var ik;
!function(e3) {
  e3.Center = "Center", e3.Top = "Top", e3.Bottom = "Bottom", e3.Stretch = "Stretch";
}(ik || (ik = {}));
const nk = ik;
var ok;
!function(e3) {
  e3.Center = "Center", e3.Left = "Left", e3.Right = "Right", e3.Stretch = "Stretch";
}(ok || (ok = {}));
const rk = ok;
let sk;
const ak = [], lk = () => {
  ak.forEach((e3) => {
    e3.instance.reposition();
  });
}, ck = () => {
  sk = setInterval(() => {
    lk(), "IFRAME" === document.activeElement.tagName && pk().reverse().forEach((e3) => e3.instance.close(false, false, true));
  }, 300);
}, hk = (e3) => {
  const t2 = [...yB];
  if (0 === t2.length)
    return;
  if (xk(t2[t2.length - 1].instance))
    for (let i2 = t2.length - 1; -1 !== i2; i2--) {
      const n2 = t2[i2].instance;
      if (n2.isModal || n2.isOpenerClicked(e3))
        return;
      if (dB(e3, n2.getBoundingClientRect()))
        break;
      n2.close();
    }
}, uk = (e3) => {
  const t2 = _k(e3);
  var i2;
  wB(e3, t2), ak.push({ instance: e3, parentPopovers: t2 }), (i2 = e3) && i2.shadowRoot.addEventListener("scroll", lk, { capture: true }), 1 === ak.length && (document.body.addEventListener("scroll", lk, { capture: true }), document.addEventListener("mousedown", hk), ck());
}, dk = (e3) => {
  const t2 = [e3];
  for (let i3 = 0; i3 < ak.length; i3++) {
    const n2 = ak[i3].parentPopovers.indexOf(e3);
    ak[i3].parentPopovers.length > 0 && n2 > -1 && t2.push(ak[i3].instance);
  }
  for (let e4 = t2.length - 1; e4 >= 0; e4--)
    for (let n2 = 0; n2 < ak.length; n2++) {
      let o2 = -1;
      if (t2[e4] === ak[n2].instance && (o2 = n2), o2 >= 0) {
        xB(ak[o2].instance), (i2 = ak[o2].instance) && i2.shadowRoot.removeEventListener("scroll", lk, { capture: true });
        ak.splice(o2, 1)[0].instance.close(false, true);
      }
    }
  var i2;
  ak.length || (document.body.removeEventListener("scroll", lk, { capture: true }), document.removeEventListener("mousedown", hk), clearInterval(sk));
}, pk = () => ak, _k = (e3) => {
  let t2 = e3.parentNode;
  const i2 = [];
  for (; t2 && t2.parentNode; ) {
    for (let e4 = 0; e4 < ak.length; e4++)
      t2 === ak[e4].instance && i2.push(t2);
    t2 = t2.parentNode;
  }
  return i2;
};
function gk(e3, t2, i2) {
  return XS`<header class="ui5-popup-header-root" id="ui5-popup-header" part="header">${this.header.length ? mk.call(this, e3, t2, i2) : fk.call(this, e3, t2, i2)}</header>`;
}
function mk(e3, t2, i2) {
  return XS`<slot name="header"></slot>`;
}
function fk(e3, t2, i2) {
  return XS`<h1 class="ui5-popup-header-text">${jS(this.headerText)}</h1>`;
}
function vk(e3, t2, i2) {
  return XS`${this.footer.length ? Ak.call(this, e3, t2, i2) : void 0}`;
}
function Ak(e3, t2, i2) {
  return XS`<footer class="ui5-popup-footer-root" part="footer"><slot name="footer"></slot></footer>`;
}
Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
var bk, yk = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
let wk = bk = class extends PB {
  static get VIEWPORT_MARGIN() {
    return 10;
  }
  constructor() {
    super();
  }
  onAfterRendering() {
    if (!this.isOpen() && this.open) {
      let e3;
      if (this.opener instanceof HTMLElement ? e3 = this.opener : "string" == typeof this.opener && (e3 = this.getRootNode().getElementById(this.opener)), !e3)
        return void console.warn("Valid opener id is required.");
      this.showAt(e3);
    } else
      this.isOpen() && !this.open && this.close();
  }
  isOpenerClicked(e3) {
    const t2 = e3.target;
    if (t2 === this._opener)
      return true;
    const i2 = t2;
    return !(!i2.getFocusDomRef || i2.getFocusDomRef() !== this._opener) || e3.composedPath().indexOf(this._opener) > -1;
  }
  async showAt(e3, t2 = false) {
    e3 && !this.opened && (this._opener = e3, this._openerRect = e3.getBoundingClientRect(), await super._open(t2));
  }
  _addOpenedPopup() {
    uk(this);
  }
  _removeOpenedPopup() {
    dk(this);
  }
  shouldCloseDueToOverflow(e3, t2) {
    const i2 = { Right: t2.right, Left: t2.left, Top: t2.top, Bottom: t2.bottom }, n2 = pB(this._opener);
    let o2 = false, r2 = false;
    if (n2.showAt) {
      const e4 = n2.contentDOM.getBoundingClientRect();
      o2 = t2.top > e4.top + e4.height, r2 = t2.top + t2.height < e4.top;
    }
    return i2[e3] < 0 || i2[e3] + 32 > n2.innerHeight || o2 || r2;
  }
  shouldCloseDueToNoOpener(e3) {
    return 0 === e3.top && 0 === e3.bottom && 0 === e3.left && 0 === e3.right;
  }
  isOpenerOutsideViewport(e3) {
    return e3.bottom < 0 || e3.top > window.innerHeight || e3.right < 0 || e3.left > window.innerWidth;
  }
  _resize() {
    super._resize(), this.opened && this.reposition();
  }
  reposition() {
    this._show();
  }
  _show() {
    let e3;
    const t2 = this.getPopoverSize();
    if (0 === t2.width || 0 === t2.height)
      return;
    if (this.isOpen() && (this._openerRect = this._opener.getBoundingClientRect()), e3 = this.shouldCloseDueToNoOpener(this._openerRect) && this.isFocusWithin() ? this._oldPlacement : this.calcPlacement(this._openerRect, t2), this._preventRepositionAndClose || this.isOpenerOutsideViewport(this._openerRect))
      return this.close();
    this._oldPlacement = e3, this.actualPlacementType = e3.placementType;
    let i2 = ZT(this._left, bk.VIEWPORT_MARGIN, document.documentElement.clientWidth - t2.width - bk.VIEWPORT_MARGIN);
    this.actualPlacementType === tk.Right && (i2 = Math.max(i2, this._left));
    let n2 = ZT(this._top, bk.VIEWPORT_MARGIN, document.documentElement.clientHeight - t2.height - bk.VIEWPORT_MARGIN);
    this.actualPlacementType === tk.Bottom && (n2 = Math.max(n2, this._top)), this.arrowTranslateX = e3.arrow.x, this.arrowTranslateY = e3.arrow.y, n2 = this._adjustForIOSKeyboard(n2), Object.assign(this.style, { top: `${n2}px`, left: `${i2}px` }), super._show(), this.horizontalAlign === rk.Stretch && this._width && (this.style.width = this._width);
  }
  _adjustForIOSKeyboard(e3) {
    if (!sI.iOS)
      return e3;
    const t2 = Math.ceil(this.getBoundingClientRect().top);
    return e3 + (Number.parseInt(this.style.top || "0") - t2);
  }
  getPopoverSize() {
    this.opened || Object.assign(this.style, { display: "block", top: "-10000px", left: "-10000px" });
    const e3 = this.getBoundingClientRect();
    return { width: e3.width, height: e3.height };
  }
  get arrowDOM() {
    return this.shadowRoot.querySelector(".ui5-popover-arrow");
  }
  calcPlacement(e3, t2) {
    let i2 = 0, n2 = 0;
    const o2 = this.allowTargetOverlap, r2 = document.documentElement.clientWidth, s2 = document.documentElement.clientHeight;
    let a2 = s2, l2 = r2;
    const c2 = this.getActualPlacementType(e3, t2);
    this._preventRepositionAndClose = this.shouldCloseDueToNoOpener(e3) || this.shouldCloseDueToOverflow(c2, e3);
    const h2 = c2 === tk.Top || c2 === tk.Bottom;
    this.horizontalAlign === rk.Stretch && h2 ? (t2.width = e3.width, this._width = `${e3.width}px`) : this.verticalAlign !== nk.Stretch || h2 || (t2.height = e3.height);
    const u2 = this.hideArrow ? 0 : 8;
    switch (c2) {
      case tk.Top:
        i2 = this.getVerticalLeft(e3, t2), n2 = Math.max(e3.top - t2.height - u2, 0), o2 || (a2 = e3.top - u2);
        break;
      case tk.Bottom:
        i2 = this.getVerticalLeft(e3, t2), n2 = e3.bottom + u2, o2 ? n2 = Math.max(Math.min(n2, s2 - t2.height), 0) : a2 = s2 - e3.bottom - u2;
        break;
      case tk.Left:
        i2 = Math.max(e3.left - t2.width - u2, 0), n2 = this.getHorizontalTop(e3, t2), o2 || (l2 = e3.left - u2);
        break;
      case tk.Right:
        i2 = e3.left + e3.width + u2, n2 = this.getHorizontalTop(e3, t2), o2 ? i2 = Math.max(Math.min(i2, r2 - t2.width), 0) : l2 = r2 - e3.right - u2;
    }
    h2 ? t2.width > r2 || i2 < 0 ? i2 = 0 : i2 + t2.width > r2 && (i2 -= i2 + t2.width - r2) : t2.height > s2 || n2 < 0 ? n2 = 0 : n2 + t2.height > s2 && (n2 -= n2 + t2.height - s2), this._maxHeight = Math.round(a2 - bk.VIEWPORT_MARGIN), this._maxWidth = Math.round(l2 - bk.VIEWPORT_MARGIN), (void 0 === this._left || Math.abs(this._left - i2) > 1.5) && (this._left = Math.round(i2)), (void 0 === this._top || Math.abs(this._top - n2) > 1.5) && (this._top = Math.round(n2));
    const d2 = Number.parseInt(window.getComputedStyle(this).getPropertyValue("border-radius"));
    return { arrow: this.getArrowPosition(e3, t2, i2, n2, h2, d2), top: this._top, left: this._left, placementType: c2 };
  }
  getArrowPosition(e3, t2, i2, n2, o2, r2) {
    const s2 = this._actualHorizontalAlign;
    let a2 = s2 === rk.Center || s2 === rk.Stretch;
    s2 === rk.Right && i2 <= e3.left && (a2 = true), s2 === rk.Left && i2 + t2.width >= e3.left + e3.width && (a2 = true);
    let l2 = 0;
    o2 && a2 && (l2 = e3.left + e3.width / 2 - i2 - t2.width / 2);
    let c2 = 0;
    o2 || (c2 = e3.top + e3.height / 2 - n2 - t2.height / 2);
    const h2 = t2.height / 2 - r2 - 4;
    c2 = ZT(c2, -h2, h2);
    const u2 = t2.width / 2 - r2 - 4;
    return l2 = ZT(l2, -u2, u2), { x: Math.round(l2), y: Math.round(c2) };
  }
  fallbackPlacement(e3, t2, i2, n2) {
    return i2.left > n2.width ? tk.Left : e3 - i2.right > i2.left ? tk.Right : t2 - i2.bottom > n2.height ? tk.Bottom : t2 - i2.bottom < i2.top ? tk.Top : void 0;
  }
  getActualPlacementType(e3, t2) {
    const i2 = this.placementType;
    let n2 = i2;
    const o2 = document.documentElement.clientWidth, r2 = document.documentElement.clientHeight;
    switch (i2) {
      case tk.Top:
        e3.top < t2.height && e3.top < r2 - e3.bottom && (n2 = tk.Bottom);
        break;
      case tk.Bottom:
        r2 - e3.bottom < t2.height && r2 - e3.bottom < e3.top && (n2 = tk.Top);
        break;
      case tk.Left:
        e3.left < t2.width && (n2 = this.fallbackPlacement(o2, r2, e3, t2) || i2);
        break;
      case tk.Right:
        o2 - e3.right < t2.width && (n2 = this.fallbackPlacement(o2, r2, e3, t2) || i2);
    }
    return n2;
  }
  getVerticalLeft(e3, t2) {
    let i2;
    switch (this._actualHorizontalAlign) {
      case rk.Center:
      case rk.Stretch:
        i2 = e3.left - (t2.width - e3.width) / 2;
        break;
      case rk.Left:
        i2 = e3.left;
        break;
      case rk.Right:
        i2 = e3.right - t2.width;
    }
    return i2;
  }
  getHorizontalTop(e3, t2) {
    let i2;
    switch (this.verticalAlign) {
      case nk.Center:
      case nk.Stretch:
        i2 = e3.top - (t2.height - e3.height) / 2;
        break;
      case nk.Top:
        i2 = e3.top;
        break;
      case nk.Bottom:
        i2 = e3.bottom - t2.height;
    }
    return i2;
  }
  get isModal() {
    return this.modal;
  }
  get shouldHideBackdrop() {
    return this.hideBackdrop;
  }
  get _ariaLabelledBy() {
    if (!this._ariaLabel && this._displayHeader)
      return "ui5-popup-header";
  }
  get styles() {
    return { ...super.styles, root: { "max-height": this._maxHeight ? `${this._maxHeight}px` : "", "max-width": this._maxWidth ? `${this._maxWidth}px` : "" }, arrow: { transform: `translate(${this.arrowTranslateX}px, ${this.arrowTranslateY}px)` } };
  }
  get classes() {
    const e3 = super.classes;
    return e3.root["ui5-popover-root"] = true, e3;
  }
  get _displayHeader() {
    return !(!this.header.length && !this.headerText);
  }
  get _displayFooter() {
    return true;
  }
  get _actualHorizontalAlign() {
    if ("rtl" === this.effectiveDir) {
      if (this.horizontalAlign === rk.Left)
        return rk.Right;
      if (this.horizontalAlign === rk.Right)
        return rk.Left;
    }
    return this.horizontalAlign;
  }
};
yk([tS()], wk.prototype, "headerText", void 0), yk([tS({ type: tk, defaultValue: tk.Right })], wk.prototype, "placementType", void 0), yk([tS({ type: rk, defaultValue: rk.Center })], wk.prototype, "horizontalAlign", void 0), yk([tS({ type: nk, defaultValue: nk.Center })], wk.prototype, "verticalAlign", void 0), yk([tS({ type: Boolean })], wk.prototype, "modal", void 0), yk([tS({ type: Boolean })], wk.prototype, "hideBackdrop", void 0), yk([tS({ type: Boolean })], wk.prototype, "hideArrow", void 0), yk([tS({ type: Boolean })], wk.prototype, "allowTargetOverlap", void 0), yk([tS({ validator: class extends iI {
  static isValid(e3) {
    return "string" == typeof e3 || e3 instanceof HTMLElement;
  }
  static propertyToAttribute(e3) {
    return e3 instanceof HTMLElement ? null : e3;
  }
} })], wk.prototype, "opener", void 0), yk([tS({ type: Boolean })], wk.prototype, "disableScrolling", void 0), yk([tS({ validator: nI, defaultValue: 0, noAttribute: true })], wk.prototype, "arrowTranslateX", void 0), yk([tS({ validator: nI, defaultValue: 0, noAttribute: true })], wk.prototype, "arrowTranslateY", void 0), yk([tS({ type: tk, defaultValue: tk.Right })], wk.prototype, "actualPlacementType", void 0), yk([tS({ validator: nI, noAttribute: true })], wk.prototype, "_maxHeight", void 0), yk([tS({ validator: nI, noAttribute: true })], wk.prototype, "_maxWidth", void 0), yk([nS({ type: HTMLElement })], wk.prototype, "header", void 0), yk([nS({ type: HTMLElement })], wk.prototype, "footer", void 0), wk = bk = yk([eS({ tag: "ui5-popover", styles: [YB, KB, { packageName: "@ui5/webcomponents", fileName: "themes/Popover.css", content: '.ui5-popover-arrow{pointer-events:none;display:block;width:1rem;height:1rem;position:absolute;overflow:hidden}.ui5-popover-arrow:after{content:"";display:block;width:.7rem;height:.7rem;background-color:var(--sapGroup_ContentBackground);box-shadow:var(--sapContent_Shadow3);transform:rotate(-45deg)}:host{max-width:calc(100% - var(--_ui5_popup_viewport_margin)*2)}:host([opened][actual-placement-type=Top]){margin-top:var(--_ui5-popover-margin-bottom)}:host([opened][actual-placement-type=Bottom]){margin-top:var(--_ui5-popover-margin-top)}:host([actual-placement-type=Bottom]) .ui5-popover-arrow{left:calc(50% - .5625rem);top:-.5rem;height:.5625rem}:host([actual-placement-type=Bottom]) .ui5-popover-arrow:after{margin:var(--_ui5_popover_upward_arrow_margin)}:host([actual-placement-type=Left]) .ui5-popover-arrow{top:calc(50% - .5625rem);right:-.5625rem;width:.5625rem}:host([actual-placement-type=Left]) .ui5-popover-arrow:after{margin:var(--_ui5_popover_right_arrow_margin)}:host([actual-placement-type=Top]) .ui5-popover-arrow{left:calc(50% - .5625rem);height:.5625rem;top:100%}:host([actual-placement-type=Top]) .ui5-popover-arrow:after{margin:var(--_ui5_popover_downward_arrow_margin)}:host(:not([actual-placement-type])) .ui5-popover-arrow,:host([actual-placement-type=Right]) .ui5-popover-arrow{left:-.5625rem;top:calc(50% - .5625rem);width:.5625rem;height:1rem}:host(:not([actual-placement-type])) .ui5-popover-arrow:after,:host([actual-placement-type=Right]) .ui5-popover-arrow:after{margin:var(--_ui5_popover_left_arrow_margin)}:host([hide-arrow]) .ui5-popover-arrow{display:none}.ui5-popover-root{min-width:6.25rem}' }], template: function(e3, t2, i2) {
  return XS`<section style="${qS(this.styles.root)}" class="${WS(this.classes.root)}" role="${jS(this._role)}" aria-modal="${jS(this._ariaModal)}" aria-label="${jS(this._ariaLabel)}" aria-labelledby="${jS(this._ariaLabelledBy)}" @keydown=${this._onkeydown} @focusout=${this._onfocusout} @mouseup=${this._onmouseup} @mousedown=${this._onmousedown}><span class="first-fe" data-ui5-focus-trap tabindex="0" @focusin=${this.forwardToLast}></span><span class="ui5-popover-arrow" style="${qS(this.styles.arrow)}"></span>${this._displayHeader ? gk.call(this, e3, t2, i2) : void 0}<div style="${qS(this.styles.content)}" class="${WS(this.classes.content)}"  @scroll="${this._scroll}" part="content"><slot></slot></div>${this._displayFooter ? vk.call(this, e3, t2, i2) : void 0}<span class="last-fe" data-ui5-focus-trap tabindex="0" @focusin=${this.forwardToFirst}></span></section> `;
} })], wk);
const xk = (e3) => "showAt" in e3;
wk.define();
const Ck = wk;
Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
var Sk, Ek = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
let Ik = Sk = class extends Ck {
  constructor() {
    super();
  }
  async showAt(e3, t2 = false) {
    if (gI()) {
      this.style.display = "contents";
      const e4 = _B();
      if (!e4)
        return;
      this.style.zIndex = e4.toString(), await this._dialog.show(t2);
    } else
      await super.showAt(e3, t2);
  }
  close(e3 = false, t2 = false, i2 = false) {
    gI() ? this._dialog.close(e3, t2, i2) : super.close(e3, t2, i2);
  }
  toggle(e3) {
    if (this.isOpen())
      return this.close();
    this.showAt(e3);
  }
  isOpen() {
    return gI() && this._dialog ? this._dialog.isOpen() : super.isOpen();
  }
  get classes() {
    const e3 = super.classes;
    return e3.header = { "ui5-responsive-popover-header": true, "ui5-responsive-popover-header-no-title": !this.headerText }, e3;
  }
  get _dialog() {
    return this.shadowRoot.querySelector("[ui5-dialog]");
  }
  get contentDOM() {
    return gI() ? this._dialog.contentDOM : super.contentDOM;
  }
  get _isPhone() {
    return gI();
  }
  get _displayHeader() {
    return (gI() || !this.contentOnlyOnDesktop) && super._displayHeader;
  }
  get _displayFooter() {
    return gI() || !this.contentOnlyOnDesktop;
  }
  get _closeDialogAriaLabel() {
    return Sk.i18nBundle.getText(UE);
  }
  _beforeDialogOpen(e3) {
    this.open = true, this.opened = true, this._propagateDialogEvent(e3);
  }
  _afterDialogClose(e3) {
    this.open = false, this.opened = false, this._propagateDialogEvent(e3);
  }
  _propagateDialogEvent(e3) {
    const t2 = e3.type.replace("ui5-", "");
    this.fireEvent(t2, e3.detail);
  }
  get isModal() {
    return gI() ? this._dialog.isModal : super.isModal;
  }
  static async onDefine() {
    Sk.i18nBundle = await Wx("@ui5/webcomponents");
  }
};
Ek([tS({ type: Boolean })], Ik.prototype, "contentOnlyOnDesktop", void 0), Ek([tS({ type: Boolean })], Ik.prototype, "_hideHeader", void 0), Ek([tS({ type: Boolean })], Ik.prototype, "_hideCloseButton", void 0), Ik = Sk = Ek([eS({ tag: "ui5-responsive-popover", styles: [Ck.styles, { packageName: "@ui5/webcomponents", fileName: "themes/ResponsivePopover.css", content: ":host{--_ui5_input_width:100%;min-width:6.25rem;min-height:2rem}:host([opened]){display:inline-block}.ui5-responsive-popover-header{height:var(--_ui5-responsive_popover_header_height);display:flex;justify-content:space-between;align-items:center;width:100%}.ui5-responsive-popover-header-text{width:calc(100% - var(--_ui5_button_base_min_width))}.ui5-responsive-popover-header-no-title{justify-content:flex-end}" }], template: function(e3, t2, i2) {
  return XS`${this._isPhone ? QM.call(this, e3, t2, i2) : jM.call(this, e3, t2, i2)}`;
}, dependencies: [...Ck.dependencies, ZI, nM, WT] })], Ik), Ik.define();
const Tk = Ik;
var Bk, Mk = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
let kk = Bk = class extends ZC {
  static async onDefine() {
    Bk.i18nBundle = await Wx("@ui5/webcomponents");
  }
  constructor() {
    super();
  }
  _respPopover() {
    return this.responsivePopover = this.shadowRoot.querySelector("[ui5-responsive-popover]"), this.responsivePopover;
  }
  _colorPalette() {
    return this.responsivePopover.content[0].querySelector("[ui5-color-palette]");
  }
  showAt(e3) {
    this._openPopover(e3);
  }
  openPopover(e3) {
    console.warn("The method 'openPopover' is deprecated and will be removed in future, use 'showAt' instead."), this._openPopover(e3);
  }
  _openPopover(e3) {
    this._respPopover(), this.responsivePopover.showAt(e3, true), this.showDefaultColor ? this._colorPalette().colorPaletteNavigationElements[0].focus() : this._colorPalette().focusColorElement(this._colorPalette().colorPaletteNavigationElements[0], this._colorPalette()._itemNavigation);
  }
  closePopover() {
    this.responsivePopover.close();
  }
  onSelectedColor(e3) {
    this.closePopover(), this.fireEvent("item-click", e3.detail);
  }
  isOpen() {
    return this._respPopover(), this.responsivePopover.opened;
  }
  get colorPaletteColors() {
    return this.getSlottedNodes("colors");
  }
  get _colorPaletteTitle() {
    return Bk.i18nBundle.getText(pE);
  }
  get _cancelButtonLabel() {
    return Bk.i18nBundle.getText(gE);
  }
};
Mk([tS({ type: Boolean })], kk.prototype, "showRecentColors", void 0), Mk([tS({ type: Boolean })], kk.prototype, "showMoreColors", void 0), Mk([tS({ type: Boolean })], kk.prototype, "showDefaultColor", void 0), Mk([tS({ validator: EM })], kk.prototype, "defaultColor", void 0), Mk([nS({ default: true, type: HTMLElement, individualSlots: true })], kk.prototype, "colors", void 0), kk = Bk = Mk([eS({ tag: "ui5-color-palette-popover", renderer: KS, styles: [HM, { packageName: "@ui5/webcomponents", fileName: "themes/ColorPalettePopover.css", content: ".ui5-cp-header{width:100%;height:var(--_ui5_color-palette-button-height);display:flex;align-items:center}.ui5-cp-footer{width:100%;display:flex;justify-content:flex-end;margin:.1875rem 0}[ui5-responsive-popover]::part(content){padding:0}.ui5-cp-item-container{padding:.3125rem .6875rem}" }], template: function(e3, t2, i2) {
  return i2 ? XS`<${ZS("ui5-responsive-popover", t2, i2)} hide-arrow content-only-on-desktop placement-type="Bottom"><div slot="header" class="ui5-cp-header"><${ZS("ui5-title", t2, i2)} class="ui5-cp-title">${jS(this._colorPaletteTitle)}</${ZS("ui5-title", t2, i2)}></div><div><${ZS("ui5-color-palette", t2, i2)} ?show-more-colors="${this.showMoreColors}" ?show-recent-colors="${this.showRecentColors}" ?show-default-color="${this.showDefaultColor}" default-color="${jS(this.defaultColor)}" popup-mode @ui5-item-click="${jS(this.onSelectedColor)}">${$S(this.colorPaletteColors, (e4, t3) => e4._id || t3, (n2, o2) => UM.call(this, e3, t2, i2, n2, o2))}</${ZS("ui5-color-palette", t2, i2)}></div><div slot="footer" class="ui5-cp-footer"><${ZS("ui5-button", t2, i2)} design="Transparent" @click="${this.closePopover}">${jS(this._cancelButtonLabel)}</${ZS("ui5-button", t2, i2)}></div></${ZS("ui5-responsive-popover", t2, i2)}>` : XS`<ui5-responsive-popover hide-arrow content-only-on-desktop placement-type="Bottom"><div slot="header" class="ui5-cp-header"><ui5-title class="ui5-cp-title">${jS(this._colorPaletteTitle)}</ui5-title></div><div><ui5-color-palette ?show-more-colors="${this.showMoreColors}" ?show-recent-colors="${this.showRecentColors}" ?show-default-color="${this.showDefaultColor}" default-color="${jS(this.defaultColor)}" popup-mode @ui5-item-click="${jS(this.onSelectedColor)}">${$S(this.colorPaletteColors, (e4, t3) => e4._id || t3, (n2, o2) => UM.call(this, e3, t2, i2, n2, o2))}</ui5-color-palette></div><div slot="footer" class="ui5-cp-footer"><ui5-button design="Transparent" @click="${this.closePopover}">${jS(this._cancelButtonLabel)}</ui5-button></div></ui5-responsive-popover>`;
}, dependencies: [Tk, ZI, WT, zM] }), iS("item-click", { detail: { color: { type: String } } })], kk), kk.define();
class Rk extends iI {
  static isValid(e3) {
    return Number(e3) === e3;
  }
  static attributeToProperty(e3) {
    return parseFloat(e3);
  }
}
var Pk;
!function(e3) {
  e3.aliceblue = "f0f8ff", e3.antiquewhite = "faebd7", e3.aqua = "00ffff", e3.aquamarine = "7fffd4", e3.azure = "f0ffff", e3.beige = "f5f5dc", e3.bisque = "ffe4c4", e3.black = "000000", e3.blanchedalmond = "ffebcd", e3.blue = "0000ff", e3.blueviolet = "8a2be2", e3.brown = "a52a2a", e3.burlywood = "deb887", e3.cadetblue = "5f9ea0", e3.chartreuse = "7fff00", e3.chocolate = "d2691e", e3.coral = "ff7f50", e3.cornflowerblue = "6495ed", e3.cornsilk = "fff8dc", e3.crimson = "dc143c", e3.cyan = "00ffff", e3.darkblue = "00008b", e3.darkcyan = "008b8b", e3.darkgoldenrod = "b8860b", e3.darkgray = "a9a9a9", e3.darkgrey = "a9a9a9", e3.darkgreen = "006400", e3.darkkhaki = "bdb76b", e3.darkmagenta = "8b008b", e3.darkolivegreen = "556b2f", e3.darkorange = "ff8c00", e3.darkorchid = "9932cc", e3.darkred = "8b0000", e3.darksalmon = "e9967a", e3.darkseagreen = "8fbc8f", e3.darkslateblue = "483d8b", e3.darkslategray = "2f4f4f", e3.darkslategrey = "2f4f4f", e3.darkturquoise = "00ced1", e3.darkviolet = "9400d3", e3.deeppink = "ff1493", e3.deepskyblue = "00bfff", e3.dimgray = "696969", e3.dimgrey = "696969", e3.dodgerblue = "1e90ff", e3.firebrick = "b22222", e3.floralwhite = "fffaf0", e3.forestgreen = "228b22", e3.fuchsia = "ff00ff", e3.gainsboro = "dcdcdc", e3.ghostwhite = "f8f8ff", e3.gold = "ffd700", e3.goldenrod = "daa520", e3.gray = "808080", e3.grey = "808080", e3.green = "008000", e3.greenyellow = "adff2f", e3.honeydew = "f0fff0", e3.hotpink = "ff69b4", e3.indianred = "cd5c5c", e3.indigo = "4b0082", e3.ivory = "fffff0", e3.khaki = "f0e68c", e3.lavender = "e6e6fa", e3.lavenderblush = "fff0f5", e3.lawngreen = "7cfc00", e3.lemonchiffon = "fffacd", e3.lightblue = "add8e6", e3.lightcoral = "f08080", e3.lightcyan = "e0ffff", e3.lightgoldenrodyellow = "fafad2", e3.lightgray = "d3d3d3", e3.lightgrey = "d3d3d3", e3.lightgreen = "90ee90", e3.lightpink = "ffb6c1", e3.lightsalmon = "ffa07a", e3.lightseagreen = "20b2aa", e3.lightskyblue = "87cefa", e3.lightslategray = "778899", e3.lightslategrey = "778899", e3.lightsteelblue = "b0c4de", e3.lightyellow = "ffffe0", e3.lime = "00ff00", e3.limegreen = "32cd32", e3.linen = "faf0e6", e3.magenta = "ff00ff", e3.maroon = "800000", e3.mediumaquamarine = "66cdaa", e3.mediumblue = "0000cd", e3.mediumorchid = "ba55d3", e3.mediumpurple = "9370db", e3.mediumseagreen = "3cb371", e3.mediumslateblue = "7b68ee", e3.mediumspringgreen = "00fa9a", e3.mediumturquoise = "48d1cc", e3.mediumvioletred = "c71585", e3.midnightblue = "191970", e3.mintcream = "f5fffa", e3.mistyrose = "ffe4e1", e3.moccasin = "ffe4b5", e3.navajowhite = "ffdead", e3.navy = "000080", e3.oldlace = "fdf5e6", e3.olive = "808000", e3.olivedrab = "6b8e23", e3.orange = "ffa500", e3.orangered = "ff4500", e3.orchid = "da70d6", e3.palegoldenrod = "eee8aa", e3.palegreen = "98fb98", e3.paleturquoise = "afeeee", e3.palevioletred = "db7093", e3.papayawhip = "ffefd5", e3.peachpuff = "ffdab9", e3.peru = "cd853f", e3.pink = "ffc0cb", e3.plum = "dda0dd", e3.powderblue = "b0e0e6", e3.purple = "800080", e3.red = "ff0000", e3.rosybrown = "bc8f8f", e3.royalblue = "4169e1", e3.saddlebrown = "8b4513", e3.salmon = "fa8072", e3.sandybrown = "f4a460", e3.seagreen = "2e8b57", e3.seashell = "fff5ee", e3.sienna = "a0522d", e3.silver = "c0c0c0", e3.skyblue = "87ceeb", e3.slateblue = "6a5acd", e3.slategray = "708090", e3.slategrey = "708090", e3.snow = "fffafa", e3.springgreen = "00ff7f", e3.steelblue = "4682b4", e3.tan = "d2b48c", e3.teal = "008080", e3.thistle = "d8bfd8", e3.tomato = "ff6347", e3.turquoise = "40e0d0", e3.violet = "ee82ee", e3.wheat = "f5deb3", e3.white = "ffffff", e3.whitesmoke = "f5f5f5", e3.yellow = "ffff00", e3.yellowgreen = "9acd32", e3.transparent = "00000000";
}(Pk || (Pk = {}));
const Dk = (e3) => e3.startsWith("rgba") ? Lk(e3) : e3.startsWith("rgb") ? Fk(e3) : (0 === e3.indexOf("#") && (e3 = 4 === e3.length ? `${e3[1]}${e3[1]}${e3[2]}${e3[2]}${e3[3]}${e3[3]}` : e3.slice(1, e3.length)), e3 in Pk && (e3 = Pk[e3]), Ok(e3)), Lk = (e3) => {
  const t2 = e3.indexOf("("), i2 = [];
  for (let t3 = 0; t3 < e3.length; t3++)
    "," === e3[t3] && i2.push(t3);
  return { r: parseInt(e3.slice(t2 + 1, i2[0]).trim()), g: parseInt(e3.slice(i2[0] + 1, i2[1]).trim()), b: parseInt(e3.slice(i2[1] + 1, i2[2]).trim()) };
}, Fk = (e3) => {
  const t2 = e3.indexOf("("), i2 = e3.indexOf(")"), n2 = [];
  for (let t3 = 0; t3 < e3.length; t3++)
    "," === e3[t3] && n2.push(t3);
  return { r: parseInt(e3.slice(t2 + 1, n2[0]).trim()), g: parseInt(e3.slice(n2[0] + 1, n2[1]).trim()), b: parseInt(e3.slice(n2[1] + 1, i2).trim()) };
}, Nk = (e3) => {
  const t2 = (1 - Math.abs(2 * e3.l - 1)) * e3.s, i2 = t2 * (1 - Math.abs(e3.h / 60 % 2 - 1)), n2 = e3.l - t2 / 2;
  let o2;
  switch (Math.round(e3.h / 60)) {
    case 0:
      o2 = { r: t2, g: i2, b: 0 };
      break;
    case 1:
      o2 = { r: i2, g: t2, b: 0 };
      break;
    case 2:
      o2 = { r: 0, g: t2, b: i2 };
      break;
    case 3:
      o2 = { r: 0, g: i2, b: t2 };
      break;
    case 4:
      o2 = { r: i2, g: 0, b: t2 };
      break;
    default:
      o2 = { r: t2, g: 0, b: i2 };
  }
  return { r: Math.floor(255 * (o2.r + n2)), g: Math.floor(255 * (o2.g + n2)), b: Math.floor(255 * (o2.b + n2)) };
}, Ok = (e3) => ({ r: parseInt(e3.substr(0, 2), 16), g: parseInt(e3.substr(2, 2), 16), b: parseInt(e3.substr(4, 2), 16) });
const zk = "M443 104q5 7 5 12 0 6-5 11L118 453q-4 4-8 4L0 480l22-110q0-5 4-9L352 36q4-4 11-4t11 4zm-121 99l-46-45L52 381l46 46zm87-88l-46-44-64 64 45 45zm71 204l-63 64-65-64-33 32 66 63-66 66 33 32 65-66 63 66 32-32-66-66 66-63z";
Kx("not-editable", { pathData: zk, ltr: false, collection: "SAP-icons-v4", packageName: "@ui5/webcomponents-icons" });
const Uk = "M499 88q8 7 8 19 0 10-8 18L126 504q-5 4-9 6t-10 2H27q-12 0-19.5-7.5T0 485v-80q0-10 8-18L382 8q8-8 18-8 11 0 19 8zm-136 99l-43-43L64 405l43 43zm80-80l-43-43-42 43 42 42zm61 331q8 8 8 18 0 8-8 18-7 7-18 7t-18-7l-33-34-33 34q-7 7-18 7t-18-7q-8-10-8-18 0-10 8-18l33-33-33-34q-8-8-8-17 0-10 8-18t18-8 18 8l33 33 33-33q8-8 18-8t18 8 8 18q0 9-8 17l-33 34z";
var Hk;
Kx("not-editable", { pathData: Uk, ltr: false, collection: "SAP-icons-v5", packageName: "@ui5/webcomponents-icons" }), dx(), function(e3) {
  e3.Text = "Text", e3.Email = "Email", e3.Number = "Number", e3.Password = "Password", e3.Tel = "Tel", e3.URL = "URL";
}(Hk || (Hk = {}));
const Qk = Hk;
function Vk(e3, t2, i2) {
  return i2 ? XS`<div @click=${this._clear} @mousedown=${this._iconMouseDown} class="ui5-input-clear-icon-wrapper" input-icon tabindex="-1"><${ZS("ui5-icon", t2, i2)} tabindex="-1" class="ui5-input-clear-icon" name="decline"></${ZS("ui5-icon", t2, i2)}></div>` : XS`<div @click=${this._clear} @mousedown=${this._iconMouseDown} class="ui5-input-clear-icon-wrapper" input-icon tabindex="-1"><ui5-icon tabindex="-1" class="ui5-input-clear-icon" name="decline"></ui5-icon></div>`;
}
function Gk(e3, t2, i2) {
  return XS`<div class="ui5-input-icon-root"><slot name="icon"></slot></div>`;
}
function $k(e3, t2, i2) {
  return XS`<span id="${jS(this._id)}-suggestionsText" class="ui5-hidden-text">${jS(this.suggestionsText)}</span><span id="${jS(this._id)}-selectionText" class="ui5-hidden-text" aria-live="polite" role="status"></span><span id="${jS(this._id)}-suggestionsCount" class="ui5-hidden-text" aria-live="polite">${jS(this.availableSuggestionsCount)}</span>`;
}
function Wk(e3, t2, i2) {
  return XS`<span id="${jS(this._id)}-descr" class="ui5-hidden-text">${jS(this.accInfo.input.ariaDescription)}</span>`;
}
function qk(e3, t2, i2) {
  return XS`<span id="${jS(this._id)}-valueStateDesc" class="ui5-hidden-text">${jS(this.ariaValueStateHiddenText)}</span>`;
}
function jk(e3, t2, i2) {
  return i2 ? XS`<${ZS("ui5-responsive-popover", t2, i2)} class="${WS(this.classes.popover)}" hide-arrow _disable-initial-focus placement-type="Bottom" horizontal-align="Left" style="${qS(this.styles.suggestionsPopover)}" @ui5-after-open="${jS(this._afterOpenPopover)}" @ui5-after-close="${jS(this._afterClosePopover)}" @ui5-scroll="${jS(this._scroll)}">${this._isPhone ? Xk.call(this, e3, t2, i2) : void 0}${this._isPhone ? void 0 : eR.call(this, e3, t2, i2)}<${ZS("ui5-list", t2, i2)} separators="${jS(this.suggestionSeparators)}" @mousedown="${this.onItemMouseDown}" mode="SingleSelect">${$S(this.suggestionsTexts, (e4, t3) => e4._id || t3, (n2, o2) => rR.call(this, e3, t2, i2, n2, o2))}</${ZS("ui5-list", t2, i2)}>${this._isPhone ? cR.call(this, e3, t2, i2) : void 0}</${ZS("ui5-responsive-popover", t2, i2)}>` : XS`<ui5-responsive-popover class="${WS(this.classes.popover)}" hide-arrow _disable-initial-focus placement-type="Bottom" horizontal-align="Left" style="${qS(this.styles.suggestionsPopover)}" @ui5-after-open="${jS(this._afterOpenPopover)}" @ui5-after-close="${jS(this._afterClosePopover)}" @ui5-scroll="${jS(this._scroll)}">${this._isPhone ? Xk.call(this, e3, t2, i2) : void 0}${this._isPhone ? void 0 : eR.call(this, e3, t2, i2)}<ui5-list separators="${jS(this.suggestionSeparators)}" @mousedown="${this.onItemMouseDown}" mode="SingleSelect">${$S(this.suggestionsTexts, (e4, t3) => e4._id || t3, (n2, o2) => rR.call(this, e3, t2, i2, n2, o2))}</ui5-list>${this._isPhone ? cR.call(this, e3, t2, i2) : void 0}</ui5-responsive-popover>`;
}
function Xk(e3, t2, i2) {
  return i2 ? XS`<div slot="header" class="ui5-responsive-popover-header"><div class="row"><span>${jS(this._headerTitleText)}</span><${ZS("ui5-button", t2, i2)} class="ui5-responsive-popover-close-btn" icon="decline" design="Transparent" @click="${this._closeRespPopover}"></${ZS("ui5-button", t2, i2)}></div><div class="row"><div class="input-root-phone native-input-wrapper"><${ZS("ui5-input", t2, i2)} class="ui5-input-inner-phone" type="${jS(this.inputType)}" .value="${jS(this.value)}" ?show-clear-icon=${this.showClearIcon} placeholder="${jS(this.placeholder)}" @ui5-input="${jS(this._handleInput)}" @ui5-change="${jS(this._handleChange)}"></${ZS("ui5-input", t2, i2)}></div></div>${this.hasValueStateMessage ? Yk.call(this, e3, t2, i2) : void 0}</div>` : XS`<div slot="header" class="ui5-responsive-popover-header"><div class="row"><span>${jS(this._headerTitleText)}</span><ui5-button class="ui5-responsive-popover-close-btn" icon="decline" design="Transparent" @click="${this._closeRespPopover}"></ui5-button></div><div class="row"><div class="input-root-phone native-input-wrapper"><ui5-input class="ui5-input-inner-phone" type="${jS(this.inputType)}" .value="${jS(this.value)}" ?show-clear-icon=${this.showClearIcon} placeholder="${jS(this.placeholder)}" @ui5-input="${jS(this._handleInput)}" @ui5-change="${jS(this._handleChange)}"></ui5-input></div></div>${this.hasValueStateMessage ? Yk.call(this, e3, t2, i2) : void 0}</div>`;
}
function Yk(e3, t2, i2) {
  return i2 ? XS`<div class="${WS(this.classes.popoverValueState)}" style="${qS(this.styles.suggestionPopoverHeader)}"><${ZS("ui5-icon", t2, i2)} class="ui5-input-value-state-message-icon" name="${jS(this._valueStateMessageInputIcon)}"></${ZS("ui5-icon", t2, i2)}>${this.shouldDisplayDefaultValueStateMessage ? Kk.call(this, e3, t2, i2) : Zk.call(this, e3, t2, i2)}</div>` : XS`<div class="${WS(this.classes.popoverValueState)}" style="${qS(this.styles.suggestionPopoverHeader)}"><ui5-icon class="ui5-input-value-state-message-icon" name="${jS(this._valueStateMessageInputIcon)}"></ui5-icon>${this.shouldDisplayDefaultValueStateMessage ? Kk.call(this, e3, t2, i2) : Zk.call(this, e3, t2, i2)}</div>`;
}
function Kk(e3, t2, i2) {
  return XS`${jS(this.valueStateText)}`;
}
function Zk(e3, t2, i2) {
  return XS`${$S(this.valueStateMessageText, (e4, t3) => e4._id || t3, (n2, o2) => Jk.call(this, e3, t2, i2, n2, o2))}`;
}
function Jk(e3, t2, i2, n2, o2) {
  return XS`${jS(n2)}`;
}
function eR(e3, t2, i2) {
  return XS`${this.hasValueStateMessage ? tR.call(this, e3, t2, i2) : void 0}`;
}
function tR(e3, t2, i2) {
  return i2 ? XS`<div slot="header" ?focused=${this._isValueStateFocused} class="ui5-responsive-popover-header ${WS(this.classes.popoverValueState)}" style=${qS(this.styles.suggestionPopoverHeader)}><${ZS("ui5-icon", t2, i2)} class="ui5-input-value-state-message-icon" name="${jS(this._valueStateMessageInputIcon)}"></${ZS("ui5-icon", t2, i2)}>${this.shouldDisplayDefaultValueStateMessage ? iR.call(this, e3, t2, i2) : nR.call(this, e3, t2, i2)}</div>` : XS`<div slot="header" ?focused=${this._isValueStateFocused} class="ui5-responsive-popover-header ${WS(this.classes.popoverValueState)}" style=${qS(this.styles.suggestionPopoverHeader)}><ui5-icon class="ui5-input-value-state-message-icon" name="${jS(this._valueStateMessageInputIcon)}"></ui5-icon>${this.shouldDisplayDefaultValueStateMessage ? iR.call(this, e3, t2, i2) : nR.call(this, e3, t2, i2)}</div>`;
}
function iR(e3, t2, i2) {
  return XS`${jS(this.valueStateText)}`;
}
function nR(e3, t2, i2) {
  return XS`${$S(this.valueStateMessageText, (e4, t3) => e4._id || t3, (n2, o2) => oR.call(this, e3, t2, i2, n2, o2))}`;
}
function oR(e3, t2, i2, n2, o2) {
  return XS`${jS(n2)}`;
}
function rR(e3, t2, i2, n2, o2) {
  return XS`${n2.groupItem ? sR.call(this, e3, t2, i2, n2, o2) : aR.call(this, e3, t2, i2, n2, o2)}`;
}
function sR(e3, t2, i2, n2, o2) {
  return i2 ? XS`<${ZS("ui5-li-groupheader", t2, i2)} data-ui5-key="${jS(n2.key)}">${Py(n2.text)}</${ZS("ui5-li-groupheader", t2, i2)}>` : XS`<ui5-li-groupheader data-ui5-key="${jS(n2.key)}">${Py(n2.text)}</ui5-li-groupheader>`;
}
function aR(e3, t2, i2, n2, o2) {
  return i2 ? XS`<${ZS("ui5-li-suggestion-item", t2, i2)} image="${jS(n2.image)}" icon="${jS(n2.icon)}" additional-text="${jS(n2.additionalText)}" type="${jS(n2.type)}" additional-text-state="${jS(n2.additionalTextState)}" data-ui5-key="${jS(n2.key)}">${Py(n2.text)}${n2.description ? lR.call(this, e3, t2, i2, n2, o2) : void 0}</${ZS("ui5-li-suggestion-item", t2, i2)}>` : XS`<ui5-li-suggestion-item image="${jS(n2.image)}" icon="${jS(n2.icon)}" additional-text="${jS(n2.additionalText)}" type="${jS(n2.type)}" additional-text-state="${jS(n2.additionalTextState)}" data-ui5-key="${jS(n2.key)}">${Py(n2.text)}${n2.description ? lR.call(this, e3, t2, i2, n2, o2) : void 0}</ui5-li-suggestion-item>`;
}
function lR(e3, t2, i2, n2, o2) {
  return XS`<span slot="richDescription">${Py(n2.description)}</span>`;
}
function cR(e3, t2, i2) {
  return i2 ? XS`<div slot="footer" class="ui5-responsive-popover-footer"><${ZS("ui5-button", t2, i2)} design="Transparent" @click="${this._closeRespPopover}">OK</${ZS("ui5-button", t2, i2)}></div>` : XS`<div slot="footer" class="ui5-responsive-popover-footer"><ui5-button design="Transparent" @click="${this._closeRespPopover}">OK</ui5-button></div>`;
}
function hR(e3, t2, i2) {
  return i2 ? XS`<${ZS("ui5-popover", t2, i2)} skip-registry-update _disable-initial-focus prevent-focus-restore hide-arrow class="ui5-valuestatemessage-popover" placement-type="Bottom" horizontal-align="${jS(this._valueStatePopoverHorizontalAlign)}"><div slot="header" class="${WS(this.classes.popoverValueState)}" style="${qS(this.styles.popoverHeader)}"><${ZS("ui5-icon", t2, i2)} class="ui5-input-value-state-message-icon" name="${jS(this._valueStateMessageInputIcon)}"></${ZS("ui5-icon", t2, i2)}>${this.shouldDisplayDefaultValueStateMessage ? uR.call(this, e3, t2, i2) : dR.call(this, e3, t2, i2)}</div></${ZS("ui5-popover", t2, i2)}>` : XS`<ui5-popover skip-registry-update _disable-initial-focus prevent-focus-restore hide-arrow class="ui5-valuestatemessage-popover" placement-type="Bottom" horizontal-align="${jS(this._valueStatePopoverHorizontalAlign)}"><div slot="header" class="${WS(this.classes.popoverValueState)}" style="${qS(this.styles.popoverHeader)}"><ui5-icon class="ui5-input-value-state-message-icon" name="${jS(this._valueStateMessageInputIcon)}"></ui5-icon>${this.shouldDisplayDefaultValueStateMessage ? uR.call(this, e3, t2, i2) : dR.call(this, e3, t2, i2)}</div></ui5-popover>`;
}
function uR(e3, t2, i2) {
  return XS`${jS(this.valueStateText)}`;
}
function dR(e3, t2, i2) {
  return XS`${$S(this.valueStateMessageText, (e4, t3) => e4._id || t3, (n2, o2) => pR.call(this, e3, t2, i2, n2, o2))}`;
}
function pR(e3, t2, i2, n2, o2) {
  return XS`${jS(n2)}`;
}
Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
var _R, gR, mR, fR = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
!function(e3) {
  e3.CHANGE = "change", e3.INPUT = "input", e3.SUGGESTION_ITEM_SELECT = "suggestion-item-select";
}(gR || (gR = {})), function(e3) {
  e3.ACTION_ENTER = "enter", e3.ACTION_USER_INPUT = "input";
}(mR || (mR = {}));
let vR = _R = class extends ZC {
  constructor() {
    super(), this.hasSuggestionItemSelected = false, this.valueBeforeItemSelection = "", this.valueBeforeItemPreview = "", this.suggestionSelectionCanceled = false, this.previousValue = "", this.firstRendering = true, this.typedInValue = "", this.lastConfirmedValue = "", this.isTyping = false, this.suggestionsTexts = [], this._handleResizeBound = this._handleResize.bind(this), this._keepInnerValue = false, this._focusedAfterClear = false;
  }
  onEnterDOM() {
    iE.register(this, this._handleResizeBound), SI(this, this._updateAssociatedLabelsTexts.bind(this));
  }
  onExitDOM() {
    iE.deregister(this, this._handleResizeBound), ((e3) => {
      const t2 = vI.get(e3);
      if (!t2)
        return;
      [...t2.observedElements].forEach((e4) => {
        II(t2, e4);
      }), e3.detachInvalidate(t2.invalidationCallback), vI.delete(e3);
    })(this);
  }
  onBeforeRendering() {
    this._keepInnerValue || (this._innerValue = this.value), this.showSuggestions && (this.enableSuggestions(), this.suggestionsTexts = this.Suggestions.defaultSlotProperties(this.typedInValue)), this.effectiveShowClearIcon = this.showClearIcon && !!this.value && !this.readonly && !this.disabled, this.style.setProperty("--_ui5-input-icons-count", `${this.iconsCount}`), this.FormSupport = Ky("FormSupport");
    const e3 = !!this.suggestionItems.length, t2 = !!this.value, i2 = this.shadowRoot.querySelector("input") === RS();
    this._isPhone ? this.open = this.openOnMobile : this._forceOpen ? this.open = true : this.open = t2 && e3 && i2 && this.isTyping, this.FormSupport ? this.FormSupport.syncNativeHiddenInput(this) : this.name && console.warn('In order for the "name" property to have effect, you should also: import "@ui5/webcomponents/dist/features/InputElementsFormSupport.js";');
    const n2 = this.value, o2 = this.getInputDOMRefSync();
    if (!o2 || !n2)
      return;
    const r2 = o2.selectionEnd - o2.selectionStart;
    if (this._shouldAutocomplete && !sI.android && !sI.androidPhone && !r2 && !this._isKeyNavigation) {
      const e4 = this._getFirstMatchingItem(n2);
      e4 && this._handleTypeAhead(e4);
    }
  }
  async onAfterRendering() {
    const e3 = this.getInputDOMRefSync();
    this.Suggestions && this.showSuggestions && (this.Suggestions.toggle(this.open, { preventFocusRestore: true }), this._listWidth = await this.Suggestions._getListWidth()), this.shouldDisplayOnlyValueStateMessage ? this.openPopover() : this.closePopover(), this._performTextSelection && (e3.value !== this._innerValue && (e3.value = this._innerValue), this.typedInValue.length && this.value.length && e3.setSelectionRange(this.typedInValue.length, this.value.length)), this._performTextSelection = false;
  }
  _onkeydown(e3) {
    return this._isKeyNavigation = true, this._shouldAutocomplete = !this.noTypeahead && !(((e4) => (e4.key ? "Backspace" === e4.key : e4.keyCode === oS.BACKSPACE) && !BS(e4))(e3) || CS(e3) || yS(e3)), cS(e3) ? this._handleUp(e3) : hS(e3) ? this._handleDown(e3) : sS(e3) ? this._handleSpace(e3) : wS(e3) ? this._handleTab() : rS(e3) ? this._handleEnter(e3) : SS(e3) ? this._handlePageUp(e3) : ES(e3) ? this._handlePageDown(e3) : AS(e3) ? this._handleHome(e3) : bS(e3) ? this._handleEnd(e3) : yS(e3) ? this._handleEscape() : (this.showSuggestions && this._clearPopoverFocusAndSelection(), this._keyDown = true, void (this._isKeyNavigation = false));
  }
  _onkeyup(e3) {
    CS(e3) && (this.value = e3.target.value), this._keyDown = false;
  }
  _handleUp(e3) {
    this.Suggestions && this.Suggestions.isOpened() && this.Suggestions.onUp(e3);
  }
  _handleDown(e3) {
    this.Suggestions && this.Suggestions.isOpened() && this.Suggestions.onDown(e3);
  }
  _handleSpace(e3) {
    this.Suggestions && this.Suggestions.onSpace(e3);
  }
  _handleTab() {
    this.Suggestions && this.previousValue !== this.value && this.Suggestions.onTab();
  }
  _handleEnter(e3) {
    const t2 = !(!this.Suggestions || !this.Suggestions.onEnter(e3)), i2 = this.getInputDOMRefSync(), n2 = this.suggestionItems.find((e4) => e4.text && e4.text === this.value || e4.textContent === this.value);
    if (n2) {
      const e4 = n2.text ? n2.text : n2.textContent || "";
      i2.setSelectionRange(e4.length, e4.length), t2 || (this.selectSuggestion(n2, true), this.open = false);
    }
    if (!this._isPhone || this.suggestionItems.length || this.isTypeNumber || i2.setSelectionRange(this.value.length, this.value.length), !t2)
      return this.lastConfirmedValue = this.value, void (this.FormSupport && this.FormSupport.triggerFormSubmit(this));
    this.focused = true;
  }
  _handlePageUp(e3) {
    this._isSuggestionsFocused ? this.Suggestions.onPageUp(e3) : e3.preventDefault();
  }
  _handlePageDown(e3) {
    this._isSuggestionsFocused ? this.Suggestions.onPageDown(e3) : e3.preventDefault();
  }
  _handleHome(e3) {
    this._isSuggestionsFocused && this.Suggestions.onHome(e3);
  }
  _handleEnd(e3) {
    this._isSuggestionsFocused && this.Suggestions.onEnd(e3);
  }
  _handleEscape() {
    const e3 = this.showSuggestions && !!this.Suggestions && this.open, t2 = this.getInputDOMRefSync(), i2 = t2.selectionEnd - t2.selectionStart > 0;
    if (this.isTyping = false, e3) {
      if (e3 && this.Suggestions._isItemOnTarget())
        return this.value = this.typedInValue || this.valueBeforeItemPreview, this.suggestionSelectionCanceled = true, void (this.focused = true);
      i2 && (this.value = this.typedInValue), this._isValueStateFocused && (this._isValueStateFocused = false, this.focused = true);
    } else
      this.value = this.lastConfirmedValue ? this.lastConfirmedValue : this.previousValue;
  }
  async _onfocusin(e3) {
    await this.getInputDOMRef(), this.focused = true, this._focusedAfterClear || (this.previousValue = this.value), this.valueBeforeItemPreview = this.value, this._inputIconFocused = !!e3.target && e3.target === this.querySelector("[ui5-icon]"), this._focusedAfterClear = false;
  }
  innerFocusIn() {
  }
  _onfocusout(e3) {
    const t2 = e3.relatedTarget, i2 = this.Suggestions && t2 && t2.shadowRoot && t2.shadowRoot.contains(this.Suggestions.responsivePopover), n2 = t2 && t2.shadowRoot && t2.shadowRoot.querySelector(".ui5-valuestatemessage-root");
    this._keepInnerValue = false, this.showClearIcon && !this.effectiveShowClearIcon && (this._clearIconClicked = false, this._handleChange()), i2 || n2 ? e3.stopImmediatePropagation() : t2 && t2.classList.contains(this._id) || (this.open = false, this._clearPopoverFocusAndSelection(), this._clearIconClicked || (this.previousValue = ""), this.lastConfirmedValue = "", this.focused = false, this.isTyping = false, this._forceOpen = false);
  }
  _clearPopoverFocusAndSelection() {
    this.showSuggestions && this.Suggestions && (this._isValueStateFocused = false, this.hasSuggestionItemSelected = false, this.Suggestions._deselectItems(), this.Suggestions._clearItemFocus());
  }
  _click() {
    gI() && !this.readonly && this.Suggestions && (this.blur(), this.openOnMobile = true);
  }
  _handleChange() {
    this._clearIconClicked ? this._clearIconClicked = false : this.previousValue !== this.getInputDOMRefSync().value && (this.fireEvent(gR.CHANGE), this.previousValue = this.value, this.typedInValue = this.value);
  }
  _clear() {
    this.value = "", this.fireEvent(gR.INPUT), this._isPhone || (this.focus(), this._focusedAfterClear = true);
  }
  _iconMouseDown() {
    this._clearIconClicked = true;
  }
  _scroll(e3) {
    this.fireEvent("suggestion-scroll", { scrollTop: e3.detail.scrollTop, scrollContainer: e3.detail.targetRef });
  }
  _handleInput(e3) {
    const t2 = this.getInputDOMRefSync(), i2 = this.value && this.isTypeNumber && !t2.value, n2 = e3.inputType || e3.detail && e3.detail.inputType || "";
    this._keepInnerValue = false;
    if (this._shouldAutocomplete = !["deleteWordBackward", "deleteWordForward", "deleteSoftLineBackward", "deleteSoftLineForward", "deleteEntireSoftLine", "deleteHardLineBackward", "deleteHardLineForward", "deleteByDrag", "deleteByCut", "deleteContent", "deleteContentBackward", "deleteContentForward", "historyUndo"].includes(n2) && !this.noTypeahead, this.suggestionSelectionCanceled = false, e3 instanceof InputEvent) {
      const t3 = this.isTypeNumber && ("deleteContentForward" === e3.inputType || "deleteContentBackward" === e3.inputType) && !e3.target.value.includes(".") && this.value.includes("."), n3 = i2 && "e" === e3.data, o2 = i2 && this.value.startsWith("-") && 2 === this.value.length && ("deleteContentForward" === e3.inputType || "deleteContentBackward" === e3.inputType);
      (t3 || n3 || o2) && (this.value = e3.target.value, this._keepInnerValue = true);
    }
    e3.target === t2 && (this.focused = true, e3.stopImmediatePropagation()), this.fireEventByAction(mR.ACTION_ENTER, e3), this.hasSuggestionItemSelected = false, this._isValueStateFocused = false, this.Suggestions && this.Suggestions.updateSelectedItemPosition(-1), this.isTyping = true;
  }
  _startsWithMatchingItems(e3) {
    const t2 = this.suggestionItems[0].text ? "text" : "textContent";
    return i2 = e3, n2 = this.suggestionItems, o2 = t2, n2.filter((e4) => e4[o2].toLowerCase().startsWith(i2.toLowerCase()));
    var i2, n2, o2;
  }
  _getFirstMatchingItem(e3) {
    if (!this.suggestionItems.length)
      return;
    const t2 = this._startsWithMatchingItems(e3).filter((e4) => !e4.groupItem);
    return t2.length ? t2[0] : void 0;
  }
  _handleTypeAhead(e3) {
    const t2 = e3.text ? e3.text : e3.textContent || "";
    this._innerValue = t2, this.value = t2, this._performTextSelection = true, this._shouldAutocomplete = false;
  }
  _handleResize() {
    this._inputWidth = this.offsetWidth;
  }
  _updateAssociatedLabelsTexts() {
    this._associatedLabelsTexts = ((e3) => {
      const t2 = [];
      if (xI(e3).forEach((e4) => {
        const i2 = e4.textContent;
        i2 && t2.push(i2);
      }), t2.length)
        return t2.join(" ");
    })(this), this._accessibleLabelsRefTexts = yI(this);
  }
  _closeRespPopover() {
    this.Suggestions.close(true);
  }
  async _afterOpenPopover() {
    gI() && (await this.getInputDOMRef()).focus();
  }
  _afterClosePopover() {
    this.announceSelectedItem(), gI() && (this.blur(), this.focused = false), this.openOnMobile = false, this.open = false, this._forceOpen = false, this.hasSuggestionItemSelected && this.focus();
  }
  isValueStateOpened() {
    return !!this._isPopoverOpen;
  }
  async openPopover() {
    const e3 = await this._getPopover();
    e3 && (this._isPopoverOpen = true, e3.showAt(this));
  }
  async closePopover() {
    const e3 = await this._getPopover();
    e3 && e3.close();
  }
  async _getPopover() {
    return (await this.getStaticAreaItemDomRef()).querySelector("[ui5-popover]");
  }
  openPicker() {
    !this.suggestionItems.length || this.disabled || this.readonly || (this._forceOpen = true);
  }
  enableSuggestions() {
    if (this.Suggestions)
      return;
    const e3 = Ky("InputSuggestions");
    if (!e3)
      throw new Error('You have to import "@ui5/webcomponents/dist/features/InputSuggestions.js" module to use ui5-input suggestions');
    this.Suggestions = new e3(this, "suggestionItems", true, false);
  }
  selectSuggestion(e3, t2) {
    if (e3.groupItem)
      return;
    const i2 = this.typedInValue || this.value, n2 = e3.text || e3.textContent || "", o2 = t2 ? this.valueBeforeItemSelection !== n2 : i2 !== n2;
    this.hasSuggestionItemSelected = true, o2 && (this.value = n2, this.valueBeforeItemSelection = n2, this.lastConfirmedValue = n2, this._performTextSelection = true, this.hasSuggestionItemSelected = true, this.value = n2, this.fireEvent(gR.CHANGE), gI() && this.fireEvent(gR.INPUT), this.typedInValue = this.value, this.previousValue = this.value), this.valueBeforeItemPreview = "", this.suggestionSelectionCanceled = false, this.fireEvent(gR.SUGGESTION_ITEM_SELECT, { item: e3 }), this.isTyping = false, this.openOnMobile = false, this._forceOpen = false;
  }
  previewSuggestion(e3) {
    this.valueBeforeItemSelection = this.value, this.updateValueOnPreview(e3), this.announceSelectedItem(), this._previewItem = e3;
  }
  updateValueOnPreview(e3) {
    const t2 = "Inactive" === e3.type || e3.groupItem ? this.valueBeforeItemPreview : e3.effectiveTitle || e3.textContent || "";
    this.value = t2, this._performTextSelection = true;
  }
  get previewItem() {
    return this._previewItem ? this.getSuggestionByListItem(this._previewItem) : null;
  }
  async fireEventByAction(e3, t2) {
    if (this.disabled || this.readonly)
      return;
    const i2 = await this.getInputValue(), n2 = e3 === mR.ACTION_ENTER;
    this.value = i2, this.typedInValue = i2, this.valueBeforeItemPreview = i2, n2 && (this.fireEvent(gR.INPUT, { inputType: t2.inputType }), this.fireEvent("value-changed"));
  }
  async getInputValue() {
    return this.getDomRef() ? (await this.getInputDOMRef()).value : "";
  }
  async getInputDOMRef() {
    return gI() && this.Suggestions ? (await this.Suggestions._getSuggestionPopover(), this.Suggestions.responsivePopover.querySelector(".ui5-input-inner-phone")) : this.nativeInput;
  }
  getInputDOMRefSync() {
    return gI() && this.Suggestions && this.Suggestions.responsivePopover ? this.Suggestions.responsivePopover.querySelector(".ui5-input-inner-phone").shadowRoot.querySelector("input") : this.nativeInput;
  }
  get nativeInput() {
    const e3 = this.getDomRef();
    return e3 ? e3.querySelector("input") : null;
  }
  get nativeInputWidth() {
    return this.nativeInput ? this.nativeInput.offsetWidth : 0;
  }
  getLabelableElementId() {
    return this.getInputId();
  }
  getSuggestionByListItem(e3) {
    const t2 = parseInt(e3.getAttribute("data-ui5-key"));
    return this.suggestionItems[t2];
  }
  isSuggestionsScrollable() {
    return this.Suggestions ? this.Suggestions._isScrollable() : Promise.resolve(false);
  }
  getInputId() {
    return `${this._id}-inner`;
  }
  onItemMouseOver(e3) {
    const t2 = e3.target, i2 = this.getSuggestionByListItem(t2);
    i2 && i2.fireEvent("mouseover", { item: i2, targetRef: t2 });
  }
  onItemMouseOut(e3) {
    const t2 = e3.target, i2 = this.getSuggestionByListItem(t2);
    i2 && i2.fireEvent("mouseout", { item: i2, targetRef: t2 });
  }
  onItemMouseDown(e3) {
    e3.preventDefault();
  }
  onItemSelected(e3, t2) {
    this.selectSuggestion(e3, t2);
  }
  onItemPreviewed(e3) {
    this.previewSuggestion(e3), this.fireEvent("suggestion-item-preview", { item: this.getSuggestionByListItem(e3), targetRef: e3 });
  }
  get valueStateTypeMappings() {
    return { Success: _R.i18nBundle.getText(jE), Information: _R.i18nBundle.getText(XE), Error: _R.i18nBundle.getText(WE), Warning: _R.i18nBundle.getText(qE) };
  }
  valueStateTextMappings() {
    return { Success: _R.i18nBundle.getText(JE), Information: _R.i18nBundle.getText(ZE), Error: _R.i18nBundle.getText(YE), Warning: _R.i18nBundle.getText(KE) };
  }
  announceSelectedItem() {
    const e3 = this.shadowRoot.querySelector(`#${this._id}-selectionText`);
    this.Suggestions && this.Suggestions._isItemOnTarget() ? e3.textContent = this.itemSelectionAnnounce : e3.textContent = "";
  }
  get _readonly() {
    return this.readonly && !this.disabled;
  }
  get _headerTitleText() {
    return _R.i18nBundle.getText(TE);
  }
  get inputType() {
    return this.type.toLowerCase();
  }
  get isTypeNumber() {
    return this.type === Qk.Number;
  }
  get suggestionsTextId() {
    return this.showSuggestions ? `${this._id}-suggestionsText` : "";
  }
  get valueStateTextId() {
    return this.hasValueState ? `${this._id}-valueStateDesc` : "";
  }
  get accInfo() {
    const e3 = this.showSuggestions ? "true" : void 0, t2 = this.showSuggestions ? "list" : void 0, i2 = this._inputAccInfo.ariaDescribedBy ? `${this.suggestionsTextId} ${this.valueStateTextId} ${this._inputAccInfo.ariaDescribedBy}`.trim() : `${this.suggestionsTextId} ${this.valueStateTextId}`.trim();
    return { input: { ariaRoledescription: this._inputAccInfo && (this._inputAccInfo.ariaRoledescription || void 0), ariaDescribedBy: i2 || void 0, ariaInvalid: this.valueState === eB.Error ? "true" : void 0, ariaHasPopup: this._inputAccInfo.ariaHasPopup ? this._inputAccInfo.ariaHasPopup : e3, ariaAutoComplete: this._inputAccInfo.ariaAutoComplete ? this._inputAccInfo.ariaAutoComplete : t2, role: this._inputAccInfo && this._inputAccInfo.role, ariaControls: this._inputAccInfo && this._inputAccInfo.ariaControls, ariaExpanded: this._inputAccInfo && this._inputAccInfo.ariaExpanded, ariaDescription: this._inputAccInfo && this._inputAccInfo.ariaDescription, ariaLabel: this._inputAccInfo && this._inputAccInfo.ariaLabel || this._accessibleLabelsRefTexts || this.accessibleName || this._associatedLabelsTexts || void 0 } };
  }
  get nativeInputAttributes() {
    return { min: this.isTypeNumber ? this._nativeInputAttributes.min : void 0, max: this.isTypeNumber ? this._nativeInputAttributes.max : void 0, step: this.isTypeNumber ? this._nativeInputAttributes.step || "any" : void 0 };
  }
  get ariaValueStateHiddenText() {
    if (!this.hasValueState)
      return;
    const e3 = this.valueState !== eB.None ? this.valueStateTypeMappings[this.valueState] : "";
    return this.shouldDisplayDefaultValueStateMessage ? this.valueStateText ? `${e3} ${this.valueStateText}` : e3 : `${e3}`.concat(" ", this.valueStateMessageText.map((e4) => e4.textContent).join(" "));
  }
  get itemSelectionAnnounce() {
    return this.Suggestions ? this.Suggestions.itemSelectionAnnounce : "";
  }
  get iconsCount() {
    return (this.icon ? this.icon.length : 0) + (Number(this.effectiveShowClearIcon) ?? 0);
  }
  get classes() {
    return { popover: { "ui5-suggestions-popover": !this._isPhone && this.showSuggestions, "ui5-suggestions-popover-with-value-state-header": !this._isPhone && this.showSuggestions && this.hasValueStateMessage }, popoverValueState: { "ui5-valuestatemessage-root": true, "ui5-valuestatemessage-header": true, "ui5-valuestatemessage--success": this.valueState === eB.Success, "ui5-valuestatemessage--error": this.valueState === eB.Error, "ui5-valuestatemessage--warning": this.valueState === eB.Warning, "ui5-valuestatemessage--information": this.valueState === eB.Information } };
  }
  get styles() {
    const e3 = parseInt(getComputedStyle(document.documentElement).fontSize);
    return { popoverHeader: { "max-width": this._inputWidth ? `${this._inputWidth}px` : "" }, suggestionPopoverHeader: { display: 0 === this._listWidth ? "none" : "inline-block", width: this._listWidth ? `${this._listWidth}px` : "" }, suggestionsPopover: { "min-width": this._inputWidth ? `${this._inputWidth}px` : "", "max-width": this._inputWidth && this._inputWidth / e3 > 40 ? `${this._inputWidth}px` : "40rem" }, innerInput: { padding: "" } };
  }
  get suggestionSeparators() {
    return "None";
  }
  get valueStateMessageText() {
    return this.getSlottedNodes("valueStateMessage").map((e3) => e3.cloneNode(true));
  }
  get shouldDisplayOnlyValueStateMessage() {
    return this.hasValueStateMessage && !this.readonly && !this.open && this.focused;
  }
  get shouldDisplayDefaultValueStateMessage() {
    return !this.valueStateMessage.length && this.hasValueStateMessage;
  }
  get hasValueState() {
    return this.valueState !== eB.None;
  }
  get hasValueStateMessage() {
    return this.hasValueState && this.valueState !== eB.Success && (!this._inputIconFocused || !(!this._isPhone || !this.Suggestions));
  }
  get valueStateText() {
    return this.valueState !== eB.None ? this.valueStateTextMappings()[this.valueState] : void 0;
  }
  get suggestionsText() {
    return _R.i18nBundle.getText(IE);
  }
  get availableSuggestionsCount() {
    if (this.showSuggestions && (this.value || this.Suggestions.isOpened()))
      switch (this.suggestionsTexts.length) {
        case 0:
          return _R.i18nBundle.getText(kE);
        case 1:
          return _R.i18nBundle.getText(BE);
        default:
          return _R.i18nBundle.getText(ME, this.suggestionsTexts.length);
      }
  }
  get step() {
    return this.isTypeNumber ? "any" : void 0;
  }
  get _isPhone() {
    return gI();
  }
  get _isSuggestionsFocused() {
    return !this.focused && this.Suggestions && this.Suggestions.isOpened();
  }
  get _placeholder() {
    return this.placeholder;
  }
  get _valueStateInputIcon() {
    const e3 = { Error: '<path xmlns="http://www.w3.org/2000/svg" fill-rule="evenodd" clip-rule="evenodd" d="M10 20C4.47715 20 0 15.5228 0 10C0 4.47715 4.47715 0 10 0C15.5228 0 20 4.47715 20 10C20 15.5228 15.5228 20 10 20ZM7.70711 13.7071C7.31658 14.0976 6.68342 14.0976 6.29289 13.7071C5.90237 13.3166 5.90237 12.6834 6.29289 12.2929L8.58579 10L6.29289 7.70711C5.90237 7.31658 5.90237 6.68342 6.29289 6.29289C6.68342 5.90237 7.31658 5.90237 7.70711 6.29289L10 8.58579L12.2929 6.29289C12.6834 5.90237 13.3166 5.90237 13.7071 6.29289C14.0976 6.68342 14.0976 7.31658 13.7071 7.70711L11.4142 10L13.7071 12.2929C14.0976 12.6834 14.0976 13.3166 13.7071 13.7071C13.3166 14.0976 12.6834 14.0976 12.2929 13.7071L10 11.4142L7.70711 13.7071Z" fill="#EE3939"/>', Warning: '<path xmlns="http://www.w3.org/2000/svg" fill-rule="evenodd" clip-rule="evenodd" d="M11.8619 0.49298C11.6823 0.187541 11.3544 0 11 0C10.6456 0 10.3177 0.187541 10.1381 0.49298L0.138066 17.493C-0.0438112 17.8022 -0.0461447 18.1851 0.13195 18.4965C0.310046 18.8079 0.641283 19 1 19H21C21.3587 19 21.69 18.8079 21.868 18.4965C22.0461 18.1851 22.0438 17.8022 21.8619 17.493L11.8619 0.49298ZM11 6C11.5523 6 12 6.44772 12 7V10C12 10.5523 11.5523 11 11 11C10.4477 11 10 10.5523 10 10V7C10 6.44772 10.4477 6 11 6ZM11 16C11.8284 16 12.5 15.3284 12.5 14.5C12.5 13.6716 11.8284 13 11 13C10.1716 13 9.5 13.6716 9.5 14.5C9.5 15.3284 10.1716 16 11 16Z" fill="#F58B00"/>', Success: '<path xmlns="http://www.w3.org/2000/svg" fill-rule="evenodd" clip-rule="evenodd" d="M0 10C0 15.5228 4.47715 20 10 20C15.5228 20 20 15.5228 20 10C20 4.47715 15.5228 0 10 0C4.47715 0 0 4.47715 0 10ZM14.7071 6.29289C14.3166 5.90237 13.6834 5.90237 13.2929 6.29289L8 11.5858L6.70711 10.2929C6.31658 9.90237 5.68342 9.90237 5.29289 10.2929C4.90237 10.6834 4.90237 11.3166 5.29289 11.7071L7.29289 13.7071C7.68342 14.0976 8.31658 14.0976 8.70711 13.7071L14.7071 7.70711C15.0976 7.31658 15.0976 6.68342 14.7071 6.29289Z" fill="#36A41D"/>', Information: '<path xmlns="http://www.w3.org/2000/svg" fill-rule="evenodd" clip-rule="evenodd" d="M3 0C1.34315 0 0 1.34315 0 3V15C0 16.6569 1.34315 18 3 18H15C16.6569 18 18 16.6569 18 15V3C18 1.34315 16.6569 0 15 0H3ZM9 6.5C9.82843 6.5 10.5 5.82843 10.5 5C10.5 4.17157 9.82843 3.5 9 3.5C8.17157 3.5 7.5 4.17157 7.5 5C7.5 5.82843 8.17157 6.5 9 6.5ZM9 8.5C9.55228 8.5 10 8.94772 10 9.5V13.5C10 14.0523 9.55228 14.5 9 14.5C8.44771 14.5 8 14.0523 8 13.5V9.5C8 8.94772 8.44771 8.5 9 8.5Z" fill="#1B90FF"/>' };
    return this.valueState !== eB.None ? `
			<svg xmlns="http://www.w3.org/2000/svg" width="24" height="20" viewBox="0 0 20 20" fill="none">
				${e3[this.valueState]};
			</svg>
			` : "";
  }
  get _valueStatePopoverHorizontalAlign() {
    return "rtl" !== this.effectiveDir ? "Left" : "Right";
  }
  get _valueStateMessageInputIcon() {
    return this.valueState !== eB.None ? { Error: "error", Warning: "alert", Success: "sys-enter-2", Information: "information" }[this.valueState] : "";
  }
  getCaretPosition() {
    return ((e3) => {
      let t2 = 0;
      return (e3.selectionStart || 0 === e3.selectionStart) && (t2 = "backward" === e3.selectionDirection ? e3.selectionStart : e3.selectionEnd), t2;
    })(this.nativeInput);
  }
  setCaretPosition(e3) {
    var t2, i2;
    t2 = this.nativeInput, i2 = e3, t2.selectionStart ? (t2.focus(), t2.setSelectionRange(i2, i2)) : t2.focus();
  }
  removeFractionalPart(e3) {
    return e3.includes(".") ? e3.slice(0, e3.indexOf(".")) : e3.includes(",") ? e3.slice(0, e3.indexOf(",")) : e3;
  }
  static async onDefine() {
    const e3 = Ky("InputSuggestions");
    [_R.i18nBundle] = await Promise.all([Wx("@ui5/webcomponents"), e3 ? e3.init() : Promise.resolve()]);
  }
};
fR([tS({ type: Boolean })], vR.prototype, "disabled", void 0), fR([tS({ type: Boolean })], vR.prototype, "highlight", void 0), fR([tS()], vR.prototype, "placeholder", void 0), fR([tS({ type: Boolean })], vR.prototype, "readonly", void 0), fR([tS({ type: Boolean })], vR.prototype, "required", void 0), fR([tS({ type: Boolean })], vR.prototype, "noTypeahead", void 0), fR([tS({ type: Qk, defaultValue: Qk.Text })], vR.prototype, "type", void 0), fR([tS()], vR.prototype, "value", void 0), fR([tS({ noAttribute: true })], vR.prototype, "_innerValue", void 0), fR([tS({ type: eB, defaultValue: eB.None })], vR.prototype, "valueState", void 0), fR([tS()], vR.prototype, "name", void 0), fR([tS({ type: Boolean })], vR.prototype, "showSuggestions", void 0), fR([tS({ validator: nI })], vR.prototype, "maxlength", void 0), fR([tS()], vR.prototype, "accessibleName", void 0), fR([tS({ defaultValue: "" })], vR.prototype, "accessibleNameRef", void 0), fR([tS({ type: Boolean })], vR.prototype, "showClearIcon", void 0), fR([tS({ type: Boolean })], vR.prototype, "effectiveShowClearIcon", void 0), fR([tS({ type: Boolean })], vR.prototype, "focused", void 0), fR([tS({ type: Boolean })], vR.prototype, "openOnMobile", void 0), fR([tS({ type: Boolean })], vR.prototype, "open", void 0), fR([tS({ type: Boolean })], vR.prototype, "_forceOpen", void 0), fR([tS({ type: Boolean })], vR.prototype, "_isValueStateFocused", void 0), fR([tS({ type: Object, noAttribute: true })], vR.prototype, "_inputAccInfo", void 0), fR([tS({ type: Object, noAttribute: true })], vR.prototype, "_nativeInputAttributes", void 0), fR([tS({ validator: nI })], vR.prototype, "_inputWidth", void 0), fR([tS({ validator: nI })], vR.prototype, "_listWidth", void 0), fR([tS({ type: Boolean, noAttribute: true })], vR.prototype, "_isPopoverOpen", void 0), fR([tS({ type: Boolean, noAttribute: true })], vR.prototype, "_inputIconFocused", void 0), fR([tS({ type: String, noAttribute: true, defaultValue: void 0 })], vR.prototype, "_associatedLabelsTexts", void 0), fR([tS({ type: String, noAttribute: true, defaultValue: void 0 })], vR.prototype, "_accessibleLabelsRefTexts", void 0), fR([nS({ type: HTMLElement, default: true })], vR.prototype, "suggestionItems", void 0), fR([nS()], vR.prototype, "icon", void 0), fR([nS()], vR.prototype, "formSupport", void 0), fR([nS()], vR.prototype, "valueStateMessage", void 0), vR = _R = fR([eS({ tag: "ui5-input", languageAware: true, renderer: KS, template: function(e3, t2, i2) {
  return XS`<div class="ui5-input-root ui5-input-focusable-element" @focusin="${this._onfocusin}" @focusout="${this._onfocusout}"><div class="ui5-input-content"><input id="${jS(this._id)}-inner" class="ui5-input-inner" style="${qS(this.styles.innerInput)}" type="${jS(this.inputType)}" inner-input ?inner-input-with-icon="${this.icon.length}" ?disabled="${this.disabled}" ?readonly="${this._readonly}" .value="${jS(this._innerValue)}" placeholder="${jS(this._placeholder)}" maxlength="${jS(this.maxlength)}" role="${jS(this.accInfo.input.role)}" aria-controls="${jS(this.accInfo.input.ariaControls)}" aria-invalid="${jS(this.accInfo.input.ariaInvalid)}" aria-haspopup="${jS(this.accInfo.input.ariaHasPopup)}" aria-describedby="${jS(this.accInfo.input.ariaDescribedBy)}" aria-roledescription="${jS(this.accInfo.input.ariaRoledescription)}" aria-autocomplete="${jS(this.accInfo.input.ariaAutoComplete)}" aria-expanded="${jS(this.accInfo.input.ariaExpanded)}" aria-label="${jS(this.accInfo.input.ariaLabel)}" aria-required="${jS(this.required)}" @input="${this._handleInput}" @change="${this._handleChange}" @keydown="${this._onkeydown}" @keyup="${this._onkeyup}" @click=${this._click} @focusin=${this.innerFocusIn} data-sap-focus-ref step="${jS(this.nativeInputAttributes.step)}" min="${jS(this.nativeInputAttributes.min)}" max="${jS(this.nativeInputAttributes.max)}" />${this.effectiveShowClearIcon ? Vk.call(this, e3, t2, i2) : void 0}${this.icon.length ? Gk.call(this, e3, t2, i2) : void 0}<div class="ui5-input-value-state-icon">${Py(this._valueStateInputIcon)}</div>${this.showSuggestions ? $k.call(this, e3, t2, i2) : void 0}${this.accInfo.input.ariaDescription ? Wk.call(this, e3, t2, i2) : void 0}${this.hasValueState ? qk.call(this, e3, t2, i2) : void 0}</div><slot name="formSupport"></slot></div>`;
}, staticAreaTemplate: function(e3, t2, i2) {
  return XS`${this.showSuggestions ? jk.call(this, e3, t2, i2) : void 0}${this.hasValueStateMessage ? hR.call(this, e3, t2, i2) : void 0} `;
}, styles: { packageName: "@ui5/webcomponents", fileName: "themes/Input.css", content: ':host{vertical-align:middle}.ui5-hidden-text{position:absolute;clip:rect(1px,1px,1px,1px);user-select:none;left:-1000px;top:-1000px;pointer-events:none;font-size:0}[input-icon]{color:var(--_ui5_input_icon_color);cursor:pointer;outline:none;padding:var(--_ui5_input_icon_padding);border-inline-start:var(--_ui5_input_icon_border);min-width:1rem;min-height:1rem;border-radius:var(--_ui5_input_icon_border_radius)}[input-icon][pressed]{background:var(--_ui5_input_icon_pressed_bg);box-shadow:var(--_ui5_input_icon_box_shadow);border-inline-start:var(--_ui5_select_hover_icon_left_border);color:var(--_ui5_input_icon_pressed_color)}[input-icon]:active{background-color:var(--sapButton_Active_Background);box-shadow:var(--_ui5_input_icon_box_shadow);border-inline-start:var(--_ui5_select_hover_icon_left_border);color:var(--_ui5_input_icon_pressed_color)}[input-icon]:not([pressed]):not(:active):hover{background:var(--_ui5_input_icon_hover_bg);box-shadow:var(--_ui5_input_icon_box_shadow)}[input-icon]:hover{border-inline-start:var(--_ui5_select_hover_icon_left_border);box-shadow:var(--_ui5_input_icon_box_shadow)}:host(:not([hidden])){display:inline-block}:host{width:var(--_ui5_input_width);min-width:calc(var(--_ui5_input_min_width) + var(--_ui5-input-icons-count)*var(--_ui5_input_icon_width));margin:var(--_ui5_input_margin_top_bottom) 0;height:var(--_ui5_input_height);color:var(--sapField_TextColor);font-size:var(--sapFontSize);font-family:"72override",var(--sapFontFamily);font-style:normal;border:var(--_ui5-input-border);border-radius:var(--_ui5_input_border_radius);box-sizing:border-box;text-align:start;transition:var(--_ui5_input_transition);background:var(--sapField_BackgroundStyle);background-color:var(--_ui5_input_background_color)}:host(:not([readonly])){box-shadow:var(--sapField_Shadow)}:host([focused]:not([opened])){border-color:var(--_ui5_input_focused_border_color);background-color:var(--sapField_Focus_Background)}.ui5-input-focusable-element{position:relative}:host([focused]:not([opened])) .ui5-input-focusable-element:after{content:var(--ui5_input_focus_pseudo_element_content);position:absolute;pointer-events:none;z-index:2;border:var(--sapContent_FocusWidth) var(--sapContent_FocusStyle) var(--_ui5_input_focus_outline_color);border-radius:var(--_ui5_input_focus_border_radius);top:var(--_ui5_input_focus_offset);bottom:var(--_ui5_input_focus_offset);left:var(--_ui5_input_focus_offset);right:var(--_ui5_input_focus_offset)}.ui5-input-root:before{content:"";position:absolute;width:calc(100% - 2px);left:1px;bottom:-2px;border-bottom-left-radius:8px;border-bottom-right-radius:8px;height:var(--_ui5_input_bottom_border_height);transition:var(--_ui5_input_transition);background-color:var(--_ui5_input_bottom_border_color)}.ui5-input-root{width:100%;height:100%;position:relative;background:transparent;display:inline-block;outline:none;box-sizing:border-box;color:inherit;transition:border-color .2s ease-in-out;border-radius:var(--_ui5_input_border_radius);overflow:hidden}:host([disabled]){opacity:var(--_ui5_input_disabled_opacity);cursor:default;pointer-events:none;background-color:var(--_ui5-input_disabled_background);border-color:var(--_ui5_input_disabled_border_color)}:host([disabled]) .ui5-input-root:before,:host([readonly]) .ui5-input-root:before{content:none}[inner-input]{background:transparent;color:inherit;border:none;font-style:inherit;-webkit-appearance:none;-moz-appearance:textfield;padding:var(--_ui5_input_inner_padding);box-sizing:border-box;min-width:var(--_ui5_input_min_width);width:100%;text-overflow:ellipsis;flex:1;outline:none;font-size:inherit;font-family:inherit;line-height:inherit;letter-spacing:inherit;word-spacing:inherit;text-align:inherit}[inner-input][inner-input-with-icon]{padding:var(--_ui5_input_inner_padding_with_icon)}.ui5-input-value-state-icon{height:100%;display:var(--_ui5-input-value-state-icon-display);align-items:center}.ui5-input-value-state-icon>svg{margin-right:8px}[inner-input]::selection{background:var(--sapSelectedColor);color:var(--sapContent_ContrastTextColor)}:host([disabled]) [inner-input]::-webkit-input-placeholder{visibility:hidden}:host([readonly]) [inner-input]::-webkit-input-placeholder{visibility:hidden}:host([disabled]) [inner-input]::-moz-placeholder{visibility:hidden}:host([readonly]) [inner-input]::-moz-placeholder{visibility:hidden}[inner-input]::-webkit-input-placeholder{font-weight:400;font-style:var(--_ui5_input_placeholder_style);color:var(--_ui5_input_placeholder_color);padding-right:.125rem}[inner-input]::-moz-placeholder{font-weight:400;font-style:var(--_ui5_input_placeholder_style);color:var(--_ui5_input_placeholder_color);padding-right:.125rem}:host([value-state=Error]) [inner-input]::-webkit-input-placeholder{color:var(--_ui5-input_error_placeholder_color);font-weight:var(--_ui5_input_value_state_error_warning_placeholder_font_weight)}:host([value-state=Error]) [inner-input]::-moz-placeholder{color:var(--_ui5-input_error_placeholder_color);font-weight:var(--_ui5_input_value_state_error_warning_placeholder_font_weight)}:host([value-state=Warning]) [inner-input]::-webkit-input-placeholder{font-weight:var(--_ui5_input_value_state_error_warning_placeholder_font_weight)}:host([value-state=Warning]) [inner-input]::-moz-placeholder{font-weight:var(--_ui5_input_value_state_error_warning_placeholder_font_weight)}:host([value-state=Success]) [inner-input]::-webkit-input-placeholder{color:var(--_ui5_input_placeholder_color)}:host([value-state=Success]) [inner-input]::-moz-placeholder{color:var(--_ui5_input_placeholder_color)}:host([value-state=Information]) [inner-input]::-webkit-input-placeholder{color:var(--_ui5_input_placeholder_color)}:host([value-state=Information]) [inner-input]::-moz-placeholder{color:var(--_ui5_input_placeholder_color)}.ui5-input-content{height:100%;box-sizing:border-box;display:flex;flex-direction:row;justify-content:flex-end;overflow:hidden;outline:none;background:transparent;color:inherit;border-radius:var(--_ui5_input_border_radius)}:host([readonly]){border-color:var(--_ui5_input_readonly_border_color);background:var(--sapField_ReadOnly_BackgroundStyle);background-color:var(--_ui5_input_readonly_background)}:host(:not([value-state]):not([readonly]):hover),:host([value-state=None]:not([readonly]):hover){border:var(--_ui5_input_hover_border);border-color:var(--_ui5_input_focused_border_color);box-shadow:var(--sapField_Hover_Shadow);background:var(--sapField_Hover_BackgroundStyle);background-color:var(--sapField_Hover_Background)}:host(:not([value-state]):not([readonly])[focused]:not([opened]):hover),:host([value-state=None]:not([readonly])[focused]:not([opened]):hover){box-shadow:none}:host([focused]):not([opened]) .ui5-input-root:before{content:none}:host(:not([readonly]):not([disabled])[value-state]:not([value-state=None])){border-width:var(--_ui5_input_state_border_width)}:host([value-state=Error]) [inner-input],:host([value-state=Warning]) [inner-input]{font-style:var(--_ui5_input_error_warning_font_style);text-indent:var(--_ui5_input_error_warning_text_indent)}:host([value-state=Error]) [inner-input]{font-weight:var(--_ui5_input_error_font_weight)}:host([value-state=Warning]) [inner-input]{font-weight:var(--_ui5_input_warning_font_weight)}:host([value-state=Error]:not([readonly]):not([disabled])){background:var(--sapField_InvalidBackgroundStyle);background-color:var(--sapField_InvalidBackground);border-color:var(--_ui5_input_value_state_error_border_color);box-shadow:var(--sapField_InvalidShadow)}:host([value-state=Error][focused]:not([opened]):not([readonly])){background-color:var(--_ui5_input_focused_value_state_error_background);border-color:var(--_ui5_input_focused_value_state_error_border_color)}:host([value-state=Error][focused]:not([opened]):not([readonly])) .ui5-input-focusable-element:after{border-color:var(--_ui5_input_focused_value_state_error_focus_outline_color)}:host([value-state=Error]:not([readonly])) .ui5-input-root:before{background-color:var(--_ui5-input-value-state-error-border-botom-color)}:host([value-state=Error]:not([readonly]):not([focused]):hover),:host([value-state=Error]:not([readonly])[focused][opened]:hover){background-color:var(--_ui5_input_value_state_error_hover_background);box-shadow:var(--sapField_Hover_InvalidShadow)}:host([value-state=Error]:not([readonly]):not([disabled])),:host([value-state=Information]:not([readonly]):not([disabled])),:host([value-state=Warning]:not([readonly]):not([disabled])){border-style:var(--_ui5_input_error_warning_border_style)}:host([value-state=Warning]:not([readonly]):not([disabled])){background:var(--sapField_WarningBackgroundStyle);background-color:var(--sapField_WarningBackground);border-color:var(--_ui5_input_value_state_warning_border_color);box-shadow:var(--sapField_WarningShadow)}:host([value-state=Warning][focused]:not([opened]):not([readonly])){background-color:var(--_ui5_input_focused_value_state_warning_background);border-color:var(--_ui5_input_focused_value_state_warning_border_color)}:host([value-state=Warning][focused]:not([opened]):not([readonly])) .ui5-input-focusable-element:after{border-color:var(--_ui5_input_focused_value_state_warning_focus_outline_color)}:host([value-state=Warning]:not([readonly])) .ui5-input-root:before{background-color:var(--_ui5_input_value_state_warning_border_botom_color)}:host([value-state=Warning]:not([readonly]):not([focused]):hover),:host([value-state=Warning]:not([readonly])[focused][opened]:hover){background-color:var(--sapField_Hover_Background);box-shadow:var(--sapField_Hover_WarningShadow)}:host([value-state=Success]:not([readonly]):not([disabled])){background:var(--sapField_SuccessBackgroundStyle);background-color:var(--sapField_SuccessBackground);border-color:var(--_ui5_input_value_state_success_border_color);border-width:var(--_ui5_input_value_state_success_border_width);box-shadow:var(--sapField_SuccessShadow)}:host([value-state=Success][focused]:not([opened]):not([readonly])){background-color:var(--_ui5_input_focused_value_state_success_background);border-color:var(--_ui5_input_focused_value_state_success_border_color)}:host([value-state=Success][focused]:not([opened]):not([readonly])) .ui5-input-focusable-element:after{border-color:var(--_ui5_input_focused_value_state_success_focus_outline_color)}:host([value-state=Success]:not([readonly])) .ui5-input-root:before{background-color:var(--_ui5_input_value_state_success_border_botom_color)}:host([value-state=Success]:not([readonly]):not([focused]):hover),:host([value-state=Success]:not([readonly])[focused][opened]:hover){background-color:var(--sapField_Hover_Background);box-shadow:var(--sapField_Hover_SuccessShadow)}:host([value-state=Information]:not([readonly]):not([disabled])){background:var(--sapField_InformationBackgroundStyle);background-color:var(--sapField_InformationBackground);border-color:var(--_ui5_input_value_state_information_border_color);border-width:var(--_ui5_input_information_border_width);box-shadow:var(--sapField_InformationShadow)}:host([value-state=Information][focused]:not([opened]):not([readonly])){background-color:var(--_ui5_input_focused_value_state_information_background);border-color:var(--_ui5_input_focused_value_state_information_border_color)}:host([value-state=Information]:not([readonly])) .ui5-input-root:before{background-color:var(--_ui5_input_value_success_information_border_botom_color)}:host([value-state=Information]:not([readonly]):not([focused]):hover),:host([value-state=Information]:not([readonly])[focused][opened]:hover){background-color:var(--sapField_Hover_Background);box-shadow:var(--sapField_Hover_InformationShadow)}.ui5-input-icon-root{min-width:var(--_ui5_input_icon_min_width);height:100%;display:flex;justify-content:center;align-items:center}::slotted([ui5-icon][slot=icon]){align-self:start;padding:var(--_ui5_input_custom_icon_padding);box-sizing:content-box!important}:host([value-state=Error]) [input-icon],:host([value-state=Warning]) [input-icon]{padding:var(--_ui5_input_error_warning_icon_padding)}:host([value-state=Information]) [input-icon]{padding:var(--_ui5_input_information_icon_padding)}:host([value-state=Error]) ::slotted([input-icon][ui5-icon]),:host([value-state=Error]) ::slotted([ui5-icon][slot=icon]),:host([value-state=Warning]) ::slotted([ui5-icon][slot=icon]){padding:var(--_ui5_input_error_warning_custom_icon_padding)}:host([value-state=Information]) ::slotted([ui5-icon][slot=icon]){padding:var(--_ui5_input_information_custom_icon_padding)}:host([value-state=Error]) [input-icon]:active,:host([value-state=Error]) [input-icon][pressed]{box-shadow:var(--_ui5_input_error_icon_box_shadow);color:var(--_ui5_input_icon_error_pressed_color)}:host([value-state=Error]) [input-icon]:not([pressed]):not(:active):hover{box-shadow:var(--_ui5_input_error_icon_box_shadow)}:host([value-state=Warning]) [input-icon]:active,:host([value-state=Warning]) [input-icon][pressed]{box-shadow:var(--_ui5_input_warning_icon_box_shadow);color:var(--_ui5_input_icon_warning_pressed_color)}:host([value-state=Warning]) [input-icon]:not([pressed]):not(:active):hover{box-shadow:var(--_ui5_input_warning_icon_box_shadow)}:host([value-state=Information]) [input-icon]:active,:host([value-state=Information]) [input-icon][pressed]{box-shadow:var(--_ui5_input_information_icon_box_shadow);color:var(--_ui5_input_icon_information_pressed_color)}:host([value-state=Information]) [input-icon]:not([pressed]):not(:active):hover{box-shadow:var(--_ui5_input_information_icon_box_shadow)}:host([value-state=Success]) [input-icon]:active,:host([value-state=Success]) [input-icon][pressed]{box-shadow:var(--_ui5_input_success_icon_box_shadow);color:var(--_ui5_input_icon_success_pressed_color)}:host([value-state=Success]) [input-icon]:not([pressed]):not(:active):hover{box-shadow:var(--_ui5_input_success_icon_box_shadow)}.ui5-input-clear-icon-wrapper{height:var(--_ui5_input_icon_wrapper_height);padding:0;width:var(--_ui5_input_icon_width);min-width:var(--_ui5_input_icon_width);display:flex;justify-content:center;align-items:center;box-sizing:border-box}:host([value-state]:not([value-state=None]):not([value-state=Success])) .ui5-input-clear-icon-wrapper{height:var(--_ui5_input_icon_wrapper_state_height);vertical-align:top}:host([value-state=Success]) .ui5-input-clear-icon-wrapper{height:var(--_ui5_input_icon_wrapper_success_state_height)}[ui5-icon].ui5-input-clear-icon{padding:0;color:inherit}[inner-input]::-webkit-inner-spin-button,[inner-input]::-webkit-outer-spin-button{-webkit-appearance:inherit;margin:inherit}' }, staticAreaStyles: [HM, { packageName: "@ui5/webcomponents", fileName: "themes/ValueStateMessage.css", content: '.ui5-valuestatemessage-popover{border-radius:var(--_ui5_value_state_message_popover_border_radius);box-shadow:var(--_ui5_value_state_message_popover_box_shadow)}.ui5-input-value-state-message-icon{width:var(--_ui5_value_state_message_icon_width);height:var(--_ui5_value_state_message_icon_height);display:var(--_ui5_input_value_state_icon_display);position:absolute;padding-right:.375rem}.ui5-valuestatemessage-root .ui5-input-value-state-message-icon{left:var(--_ui5_input_value_state_icon_offset)}.ui5-input-value-state-message-icon[name=error]{color:var(--sapNegativeElementColor)}.ui5-input-value-state-message-icon[name=alert]{color:var(--sapCriticalElementColor)}.ui5-input-value-state-message-icon[name=success]{color:var(--sapPositiveElementColor)}.ui5-input-value-state-message-icon[name=information]{color:var(--sapInformativeElementColor)}.ui5-valuestatemessage-root{box-sizing:border-box;display:inline-block;color:var(--sapTextColor);font-size:var(--sapFontSmallSize);font-family:"72override",var(--sapFontFamily);height:auto;padding:var(--_ui5_value_state_message_padding);overflow:hidden;text-overflow:ellipsis;min-width:6.25rem;border:var(--_ui5_value_state_message_border)}[ui5-popover] .ui5-valuestatemessage-header,[ui5-responsive-popover] .ui5-valuestatemessage-header{min-height:2rem}[ui5-responsive-popover] .ui5-valuestatemessage-header{padding:var(--_ui5_value_state_header_padding);border:var(--_ui5_value_state_header_border);border-bottom:var(--_ui5_value_state_header_border_bottom)}.ui5-valuestatemessage--success{background:var(--sapSuccessBackground)}.ui5-valuestatemessage--warning{background:var(--sapWarningBackground)}.ui5-valuestatemessage--error{background:var(--sapErrorBackground)}.ui5-valuestatemessage--information{background:var(--sapInformationBackground)}.ui5-responsive-popover-header:focus,.ui5-responsive-popover-header[focused]{outline-offset:var(--_ui5_value_state_header_offset);outline:var(--sapContent_FocusWidth) var(--sapContent_FocusStyle) var(--sapContent_FocusColor)}.ui5-valuestatemessage-popover::part(content),.ui5-valuestatemessage-popover::part(header){padding:0}.ui5-valuestatemessage-popover::part(footer),.ui5-valuestatemessage-popover::part(header){min-height:0}.ui5-suggestions-popover-with-value-state-header::part(header),.ui5-valuestatemessage-popover::part(header){margin-bottom:0}' }, { packageName: "@ui5/webcomponents", fileName: "themes/Suggestions.css", content: ".ui5-suggestions-popover{box-shadow:var(--sapContent_Shadow1)}.ui5-suggestions-popover::part(content),.ui5-suggestions-popover::part(header){padding:0}.ui5-suggestions-popover::part(footer){padding:0 1rem}.ui5-suggestions-popover [ui5-li-suggestion-item],.ui5-suggestions-popover [ui5-li]{height:var(--_ui5_list_item_dropdown_base_height)}.ui5-suggestions-popover [ui5-li-suggestion-item]::part(icon),.ui5-suggestions-popover [ui5-li]::part(icon){color:var(--sapList_TextColor)}.input-root-phone.native-input-wrapper{display:contents}.input-root-phone.native-input-wrapper:before{display:none}.native-input-wrapper .ui5-input-inner-phone{margin:0}" }], get dependencies() {
  const e3 = Ky("InputSuggestions");
  return [Ck, WI].concat(e3 ? e3.dependencies : []);
} }), iS("change"), iS("input"), iS("suggestion-item-select", { detail: { item: { type: HTMLElement } } }), iS("suggestion-item-preview", { detail: { item: { type: HTMLElement }, targetRef: { type: HTMLElement } } }), iS("suggestion-scroll", { detail: { scrollTop: { type: nI }, scrollContainer: { type: HTMLElement } } })], vR), vR.define();
const AR = vR, bR = "M507 244q5 5 5 12 0 6-5 11L394 379q-5 5-12 5-6 0-11-5t-5-11V144q0-12 10-15 2-1 6-1 8 0 12 4zM135 129q10 3 10 15v224q0 6-4.5 11t-11.5 5q-6 0-11-5L5 267q-5-5-5-11 0-7 5-12l113-112q4-4 11-4 4 0 6 1z";
Kx("direction-arrows", { pathData: bR, ltr: false, collection: "SAP-icons-v4", packageName: "@ui5/webcomponents-icons" });
const yR = "M504 237q8 8 8 19t-8 19L395 377q-7 7-17 7t-18-7.5-8-18.5V154q0-11 8-18.5t19-7.5q9 0 16 7zM135 128q11 0 18 7.5t7 18.5v204q0 12-8 19t-18 7-17-7L8 275q-8-8-8-19t8-19l109-102q7-7 18-7z";
Kx("direction-arrows", { pathData: yR, ltr: false, collection: "SAP-icons-v5", packageName: "@ui5/webcomponents-icons" }), dx(), Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
var wR, xR = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
let CR = wR = class extends ZC {
  constructor() {
    super(), this.notResized = false, this._isUserInteraction = false, this._isInnerElementFocusing = false, this._labelWidth = 0, this._resizeHandler = this._handleResize.bind(this), this._moveHandler = this._handleMove.bind(this), this._upHandler = this._handleUp.bind(this), this._stateStorage = { step: void 0, min: void 0, max: void 0, labelInterval: void 0 };
    this._ontouchstart = { handleEvent: (e3) => {
      this._onmousedown(e3);
    }, passive: true };
  }
  _handleMove(e3) {
  }
  _handleUp() {
  }
  _onmousedown(e3) {
  }
  _handleActionKeyPress(e3) {
  }
  static get ACTION_KEYS() {
    return [aS, lS, cS, hS, uS, dS, pS, _S, IS, TS, AS, bS, SS, ES, yS];
  }
  static get MIN_SPACE_BETWEEN_TICKMARKS() {
    return 8;
  }
  static get TOOLTIP_VISIBILITY() {
    return { VISIBLE: "visible", HIDDEN: "hidden" };
  }
  get classes() {
    return { root: { "ui5-slider-root-phone": gI() }, labelContainer: { "ui5-slider-hidden-labels": this._labelsOverlapping } };
  }
  onEnterDOM() {
    iE.register(this, this._resizeHandler);
  }
  onExitDOM() {
    iE.deregister(this, this._resizeHandler);
  }
  onAfterRendering() {
    this.notResized && this._resizeHandler();
  }
  _onmouseover() {
    this.showTooltip && (this._tooltipVisibility = wR.TOOLTIP_VISIBILITY.VISIBLE);
  }
  _onmouseout() {
    this.showTooltip && !this.shadowRoot.activeElement && (this._tooltipVisibility = wR.TOOLTIP_VISIBILITY.HIDDEN);
  }
  _onkeydown(e3) {
    this.disabled || 0 === this._effectiveStep || wR._isActionKey(e3) && (e3.preventDefault(), this._isUserInteraction = true, this._handleActionKeyPress(e3));
  }
  _onkeyup() {
    this.disabled || (this._isUserInteraction = false);
  }
  _preserveFocus(e3) {
    this._isInnerElementFocusing = e3;
  }
  _isFocusing() {
    return this._isInnerElementFocusing;
  }
  _preventFocusOut() {
    this.focusInnerElement();
  }
  focusInnerElement() {
    this.focus();
  }
  _handleResize() {
    if (!this.showTickmarks)
      return;
    this.notResized = false;
    if (this._spaceBetweenTickmarks() < wR.MIN_SPACE_BETWEEN_TICKMARKS ? (this._hiddenTickmarks = true, this._labelsOverlapping = true) : this._hiddenTickmarks = false, this.labelInterval <= 0 || this._hiddenTickmarks)
      return;
    const e3 = this.shadowRoot.querySelectorAll(".ui5-slider-labels li");
    this._labelsOverlapping = [...e3].some((e4) => e4.scrollWidth > e4.clientWidth);
  }
  handleDownBase(e3) {
    const t2 = this._effectiveMin, i2 = this._effectiveMax, n2 = this.getBoundingClientRect(), o2 = this.directionStart, r2 = this._effectiveStep, s2 = wR.getValueFromInteraction(e3, r2, t2, i2, n2, o2);
    return this._isUserInteraction = true, window.addEventListener("mouseup", this._upHandler), window.addEventListener("touchend", this._upHandler), dI() && e3 instanceof TouchEvent ? window.addEventListener("touchmove", this._moveHandler) : window.addEventListener("mousemove", this._moveHandler), this._handleFocusOnMouseDown(e3), s2;
  }
  _handleFocusOnMouseDown(e3) {
    const t2 = this.shadowRoot.activeElement;
    t2 && t2 === e3.target || (this._preserveFocus(true), this.focusInnerElement());
  }
  handleUpBase() {
    window.removeEventListener("mouseup", this._upHandler), window.removeEventListener("touchend", this._upHandler), window.removeEventListener("mousemove", this._moveHandler), window.removeEventListener("touchmove", this._moveHandler), this._isUserInteraction = false, this._preserveFocus(false);
  }
  updateStateStorageAndFireInputEvent(e3) {
    this.storePropertyState(e3), this._isUserInteraction && this.fireEvent("input");
  }
  static _isActionKey(e3) {
    return this.ACTION_KEYS.some((t2) => t2(e3));
  }
  static clipValue(e3, t2, i2) {
    return e3 = Math.min(Math.max(e3, t2), i2);
  }
  static getValueFromInteraction(e3, t2, i2, n2, o2, r2) {
    const s2 = this.getPageXValueFromEvent(e3), a2 = this.computedValueFromPageX(s2, i2, n2, o2, r2), l2 = this.getSteppedValue(a2, t2, i2);
    return this.clipValue(l2, i2, n2);
  }
  static getSteppedValue(e3, t2, i2) {
    const n2 = Math.abs((e3 - i2) % t2);
    if (0 === t2 || 0 === n2)
      return e3;
    e3 = 2 * n2 >= t2 ? e3 + t2 - n2 : e3 - n2;
    const o2 = wR._getDecimalPrecisionOfNumber(t2);
    return Number(e3.toFixed(o2));
  }
  static getPageXValueFromEvent(e3) {
    return dI() && e3 instanceof TouchEvent ? e3.targetTouches && e3.targetTouches.length > 0 ? e3.targetTouches[0].pageX : 0 : e3.pageX;
  }
  static computedValueFromPageX(e3, t2, i2, n2, o2) {
    return t2 + ("left" === o2 ? e3 - n2[o2] : n2[o2] - e3) / n2.width * (i2 - t2);
  }
  static _getDecimalPrecisionOfNumber(e3) {
    if (Number.isInteger(e3))
      return 0;
    const t2 = String(e3).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
    return !t2 || t2.length < 2 ? 0 : Math.max(0, (t2[1] ? t2[1].length : 0) - (t2[2] ? Number(t2[2]) : 0));
  }
  isCurrentStateOutdated() {
    return Object.entries(this._stateStorage).some(([e3, t2]) => this[e3] !== t2);
  }
  getStoredPropertyState(e3) {
    return this._stateStorage[e3];
  }
  isPropertyUpdated(...e3) {
    return e3.some((e4) => this.getStoredPropertyState(e4) !== this[e4]);
  }
  storePropertyState(...e3) {
    e3.forEach((e4) => {
      this._stateStorage[e4] = this[e4];
    });
  }
  get directionStart() {
    return "rtl" === this.effectiveDir ? "right" : "left";
  }
  _createLabels() {
    if (!this.labelInterval || !this.showTickmarks)
      return;
    const e3 = this.labelInterval, t2 = this._effectiveStep, i2 = (this._effectiveMax - this._effectiveMin) / (t2 * e3);
    if (i2 === this._oldNumberOfLabels)
      return;
    this._oldNumberOfLabels = i2, this._labelWidth = 100 / i2, this._labelValues = [];
    const n2 = wR._getDecimalPrecisionOfNumber(t2);
    for (let o2 = 0; o2 <= i2; o2++) {
      const i3 = (o2 * t2 * e3 + this._effectiveMin).toFixed(n2);
      this._labelValues.push(i3);
    }
  }
  _handleActionKeyPressBase(e3, t2) {
    const i2 = wR._isIncreaseValueAction(e3), n2 = wR._isBigStepAction(e3), o2 = this[t2], r2 = this._effectiveMin, s2 = this._effectiveMax;
    let a2 = "rtl" === this.effectiveDir ? -this._effectiveStep : this._effectiveStep;
    return a2 = n2 && (s2 - r2) / a2 > 10 ? (s2 - r2) / 10 : a2, bS(e3) ? s2 - o2 : AS(e3) ? -1 * (o2 - r2) : i2 ? a2 : -1 * a2;
  }
  static _isDecreaseValueAction(e3) {
    return hS(e3) || _S(e3) || aS(e3) || uS(e3) || TS(e3) || ES(e3);
  }
  static _isIncreaseValueAction(e3) {
    return cS(e3) || pS(e3) || lS(e3) || dS(e3) || IS(e3) || SS(e3);
  }
  static _isBigStepAction(e3) {
    return _S(e3) || pS(e3) || uS(e3) || dS(e3) || SS(e3) || ES(e3);
  }
  get _tickmarksCount() {
    return (this._effectiveMax - this._effectiveMin) / this._effectiveStep;
  }
  _spaceBetweenTickmarks() {
    return this.getBoundingClientRect().width / this._tickmarksCount;
  }
  _validateStep(e3) {
    0 === e3 && console.warn("The 'step' property must be a positive float number"), e3 < 0 && console.warn("The 'step' property must be a positive float number. The provided negative number has been converted to its positve equivalent"), Number.isNaN(e3) && console.warn("The 'step' property must be a positive float number. It has been set to its default value of 1");
  }
  get _labels() {
    return this._labelValues || [];
  }
  get _effectiveStep() {
    let e3 = this.step;
    return e3 < 0 && (e3 = Math.abs(e3)), Number.isNaN(e3) && (e3 = 1), e3;
  }
  get _effectiveMin() {
    return Math.min(this.min, this.max);
  }
  get _effectiveMax() {
    return Math.max(this.min, this.max);
  }
  get _tabIndex() {
    return this.disabled ? "-1" : "0";
  }
  get _ariaLabelledByHandleRefs() {
    return [`${this._id}-accName`, `${this._id}-sliderDesc`].join(" ").trim();
  }
};
xR([tS({ validator: Rk, defaultValue: 0 })], CR.prototype, "min", void 0), xR([tS({ validator: Rk, defaultValue: 100 })], CR.prototype, "max", void 0), xR([tS({ validator: Rk, defaultValue: 1 })], CR.prototype, "step", void 0), xR([tS({ validator: nI, defaultValue: 0 })], CR.prototype, "labelInterval", void 0), xR([tS({ type: Boolean })], CR.prototype, "showTickmarks", void 0), xR([tS({ type: Boolean })], CR.prototype, "showTooltip", void 0), xR([tS({ type: Boolean })], CR.prototype, "disabled", void 0), xR([tS()], CR.prototype, "accessibleName", void 0), xR([tS({ defaultValue: "hidden" })], CR.prototype, "_tooltipVisibility", void 0), xR([tS({ type: Boolean })], CR.prototype, "_labelsOverlapping", void 0), xR([tS({ type: Boolean })], CR.prototype, "_hiddenTickmarks", void 0), CR = wR = xR([eS({ renderer: KS, styles: { packageName: "@ui5/webcomponents", fileName: "themes/SliderBase.css", content: '.ui5-hidden-text{position:absolute;clip:rect(1px,1px,1px,1px);user-select:none;left:-1000px;top:-1000px;pointer-events:none;font-size:0}:host([disabled]){opacity:var(--_ui5_slider_disabled_opacity);cursor:default;pointer-events:none}:host{box-sizing:border-box;cursor:pointer;vertical-align:top;width:100%}:host(:not([hidden])){display:inline-block}.ui5-slider-root{box-sizing:border-box;height:3.3125rem;outline:none;padding:var(--_ui5_slider_padding);touch-action:none}.ui5-slider-inner{background-repeat:no-repeat;position:relative;min-width:var(--_ui5_slider_inner_min_width);height:100%}.ui5-slider-progress-container{width:100%;background:var(--_ui5_slider_progress_container_background);border:var(--_ui5_slider_progress_border);border-radius:var(--_ui5_slider_progress_border_radius);height:var(--_ui5_slider_inner_height);position:relative;box-sizing:var(--_ui5_slider_progress_box_sizing);top:var(--_ui5_slider_progress_container_top)}.ui5-slider-progress-container:after,.ui5-slider-progress-container:before{display:var(--_ui5_slider_progress_container_dot_display);content:"";position:absolute;border-radius:50%;width:var(--_ui5_slider_start_end_point_size);height:var(--_ui5_slider_start_end_point_size);top:var(--_ui5_slider_start_end_point_top)}.ui5-slider-progress-container:before{inset-inline-start:var(--_ui5_slider_start_end_point_left);background-color:var(--_ui5_slider_progress_before_background);border:var(--_ui5_slider_progress_before_border)}.ui5-slider-progress-container:after{inset-inline-end:var(--_ui5_slider_start_end_point_left);background-color:var(--_ui5_slider_progress_after_background);border:var(--_ui5_slider_progress_after_border)}.ui5-slider-progress{background:var(--_ui5_slider_progress_background);border-radius:var(--_ui5_slider_progress_border_radius);height:var(--_ui5_slider_progress_height);position:relative;outline:none;box-sizing:border-box;border:var(--_ui5_slider_active_progress_border);left:var(--_ui5_slider_active_progress_left);top:var(--_ui5_slider_active_progress_top)}.ui5-slider-tickmarks{list-style:none;padding:0;margin:0;top:var(--_ui5_slider_tickmark_top);display:flex;box-sizing:border-box;width:100%;justify-content:space-between;position:absolute;z-index:1}.ui5-slider-tickmarks li{height:var(--_ui5_slider_tickmark_height);border-inline-start:1px solid var(--_ui5_slider_tickmark_bg)}.ui5-slider-handle{background:var(--_ui5_slider_handle_background);border:var(--_ui5_slider_handle_border);border-radius:var(--_ui5_slider_handle_border_radius);box-shadow:var(--_ui5_slider_handle_box_shadow);margin-inline-start:calc(var(--_ui5_slider_handle_width)*-1/2);top:var(--_ui5_slider_handle_top);position:absolute;outline:none;height:var(--_ui5_slider_handle_height);width:var(--_ui5_slider_handle_width);box-sizing:var(--_ui5_slider_handle_box_sizing);display:flex;justify-content:center;align-items:center;z-index:2}[slider-icon]{display:var(--_ui5_slider_handle_icon_display);color:var(--sapContent_Selected_ForegroundColor);width:var(--_ui5_slider_handle_icon_size);height:var(--_ui5_slider_handle_icon_size)}.ui5-slider-handle:hover,.ui5-slider-root:hover .ui5-slider-handle:not(:focus){background:var(--_ui5_slider_handle_hover_background);border:var(--_ui5_slider_handle_hover_border);box-shadow:var(--_ui5_slider_handle_hover_box_shadow)}.ui5-slider-handle:not(:active):focus,.ui5-slider-root:focus .ui5-slider-inner .ui5-slider-handle{outline:var(--_ui5_slider_handle_outline);outline-offset:var(--_ui5_slider_handle_outline_offset);border:var(--_ui5_slider_handle_focus_border);box-shadow:var(--_ui5_slider_handle_box_shadow_focus);background:var(--_ui5_slider_handle_background_focus)}.ui5-slider-handle:focus:active,.ui5-slider-root:active .ui5-slider-handle:focus{background:var(--_ui5_slider_handle_hover_background);border:var(--_ui5_slider_handle_active_border);box-shadow:var(--_ui5_slider_handle_active_box_shadow);outline:var(--_ui5_slider_handle_active_focused_outline)}.ui5-slider-handle--end:focus,.ui5-slider-handle.ui5-slider-handle--start:focus{border:var(--_ui5_slider_handle_focus_border)}.ui5-slider-handle:focus:hover,.ui5-slider-root:focus:hover .ui5-slider-handle{border:var(--_ui5_slider_handle_focus_border)}.ui5-slider-tooltip{display:flex;justify-content:center;align-items:center;visibility:hidden;pointer-events:none;line-height:1rem;position:absolute;left:50%;transform:translate(-50%);bottom:var(--_ui5_slider_tooltip_bottom);background:var(--_ui5_slider_tooltip_background);border:var(--_ui5_slider_tooltip_border);border-radius:var(--_ui5_slider_tooltip_border_radius);box-shadow:var(--_ui5_slider_tooltip_box_shadow);font-size:var(--_ui5_slider_tooltip_fontsize);color:var(--_ui5_slider_tooltip_color);height:var(--_ui5_slider_tooltip_height);min-width:var(--_ui5_slider_tooltip_min_width);padding:var(--_ui5_slider_tooltip_padding);box-sizing:var(--_ui5_slider_tooltip_border_box)}.ui5-slider-tooltip-value{position:relative;display:flex;justify-content:center;align-items:center}.ui5-slider-labels{position:absolute;top:1.25rem;margin:0;padding:0;white-space:nowrap}.ui5-slider-labels li{position:relative;list-style:none;padding-top:.3125rem;height:1rem;margin:0;text-align:center;display:inline-block;color:var(--_ui5_slider_label_color);font-size:var(--_ui5_slider_label_fontsize);padding-top:0;box-sizing:border-box;display:inline-flex;justify-content:center;align-items:center;vertical-align:top}.ui5-slider-hidden-labels li:not(:first-child):not(:last-child){visibility:hidden}.ui5-slider-handle:focus .ui5-slider-tooltip{bottom:var(--_ui5_slider_handle_focused_tooltip_distance)}.ui5-slider-tickmarks li.ui5-slider-tickmark-in-range{border-inline-start:1px solid var(--_ui5_slider_tickmark_in_range_bg)}:host([show-tickmarks]) .ui5-slider-progress{height:var(--_ui5_slider_no_tickmarks_progress_height);border:var(--_ui5_slider_no_tickmarks_active_progress_border);left:var(--_ui5_slider_no_tickmarks_active_progress_left);top:var(--_ui5_slider_no_tickmarks_active_progress_top)}:host([show-tickmarks]) .ui5-slider-progress-container{top:var(--_ui5_slider_no_tickmarks_progress_container_top)}.ui5-slider-handle:focus:after{content:"";display:var(--_ui5_slider_handle_focus_visibility);width:calc(100% + var(--sapContent_FocusWidth)*2 + 2px);height:calc(100% + var(--sapContent_FocusWidth)*2 + 2px);border:var(--sapContent_FocusWidth) dotted var(--sapContent_FocusColor);position:absolute;border-radius:var(--_ui5_slider_handle_border_radius);pointer-events:none}' } }), iS("change"), iS("input")], CR);
const SR = CR;
function ER(e3, t2, i2) {
  return XS`${this.showTickmarks ? IR.call(this, e3, t2, i2) : void 0}`;
}
function IR(e3, t2, i2) {
  return XS`<ul class="ui5-slider-tickmarks">${$S(this.tickmarksObject, (e4, t3) => e4._id || t3, (n2, o2) => TR.call(this, e3, t2, i2, n2, o2))}</ul>${this.labelInterval ? kR.call(this, e3, t2, i2) : void 0}`;
}
function TR(e3, t2, i2, n2, o2) {
  return XS`${n2 ? BR.call(this, e3, t2, i2, n2, o2) : MR.call(this, e3, t2, i2, n2, o2)}`;
}
function BR(e3, t2, i2, n2, o2) {
  return XS`<li class="ui5-slider-tickmark ui5-slider-tickmark-in-range"></li>`;
}
function MR(e3, t2, i2, n2, o2) {
  return XS`<li class="ui5-slider-tickmark"></li>`;
}
function kR(e3, t2, i2) {
  return XS`<ul class="ui5-slider-labels ${WS(this.classes.labelContainer)}" style="${qS(this.styles.labelContainer)}">${$S(this._labels, (e4, t3) => e4._id || t3, (n2, o2) => RR.call(this, e3, t2, i2, n2, o2))}</ul>`;
}
function RR(e3, t2, i2, n2, o2) {
  return XS`<li style="${qS(this.styles.label)}">${jS(n2)}</li>`;
}
function PR(e3, t2, i2) {
  return XS`<div class="ui5-slider-tooltip" style="${qS(this.styles.tooltip)}"><span class="ui5-slider-tooltip-value">${jS(this.tooltipValue)}</span></div>`;
}
var DR, LR = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
let FR = DR = class extends SR {
  constructor() {
    super(), this._progressPercentage = 0, this._handlePositionFromStart = 0, this._stateStorage.value = void 0;
  }
  onBeforeRendering() {
    this.isCurrentStateOutdated() && (this.notResized = true, this.syncUIAndState(), this._updateHandleAndProgress(this.value));
  }
  syncUIAndState() {
    this.isPropertyUpdated("step") && (this._validateStep(this.step), this.storePropertyState("step")), this.isPropertyUpdated("min", "max", "value") && (this.storePropertyState("min", "max"), this.value = SR.clipValue(this.value, this._effectiveMin, this._effectiveMax), this.updateStateStorageAndFireInputEvent("value"), this.storePropertyState("value")), this.labelInterval && this.showTickmarks && this._createLabels(), this.isPropertyUpdated("labelInterval") && this.storePropertyState("labelInterval");
  }
  _onmousedown(e3) {
    if (this.disabled || 0 === this.step)
      return;
    const t2 = this.handleDownBase(e3);
    this._valueOnInteractionStart = this.value, void 0 === this._valueInitial && (this._valueInitial = this.value);
    const i2 = this.constructor;
    this._isHandlePressed(i2.getPageXValueFromEvent(e3)) || (this._updateHandleAndProgress(t2), this.value = t2, this.updateStateStorageAndFireInputEvent("value"));
  }
  _onfocusin() {
    void 0 === this._valueInitial && (this._valueInitial = this.value), this.showTooltip && (this._tooltipVisibility = SR.TOOLTIP_VISIBILITY.VISIBLE);
  }
  _onfocusout() {
    this._isFocusing() ? this._preventFocusOut() : (this._valueInitial = void 0, this.showTooltip && (this._tooltipVisibility = SR.TOOLTIP_VISIBILITY.HIDDEN));
  }
  _handleMove(e3) {
    if (e3.preventDefault(), this.disabled || 0 === this._effectiveStep)
      return;
    const t2 = this.constructor.getValueFromInteraction(e3, this._effectiveStep, this._effectiveMin, this._effectiveMax, this.getBoundingClientRect(), this.directionStart);
    this._updateHandleAndProgress(t2), this.value = t2, this.updateStateStorageAndFireInputEvent("value");
  }
  _handleUp() {
    this._valueOnInteractionStart !== this.value && this.fireEvent("change"), this.handleUpBase(), this._valueOnInteractionStart = void 0;
  }
  _isHandlePressed(e3) {
    const t2 = this._sliderHandle.getBoundingClientRect();
    return e3 >= t2.left && e3 <= t2.right;
  }
  _updateHandleAndProgress(e3) {
    const t2 = this._effectiveMax, i2 = this._effectiveMin;
    this._progressPercentage = (e3 - i2) / (t2 - i2), this._handlePositionFromStart = 100 * this._progressPercentage;
  }
  _handleActionKeyPress(e3) {
    const t2 = this._effectiveMin, i2 = this._effectiveMax, n2 = this.value, o2 = this.constructor, r2 = yS(e3) ? this._valueInitial : o2.clipValue(this._handleActionKeyPressBase(e3, "value") + n2, t2, i2);
    r2 !== n2 && (this._updateHandleAndProgress(r2), this.value = r2, this.updateStateStorageAndFireInputEvent("value"));
  }
  get styles() {
    return { progress: { transform: `scaleX(${this._progressPercentage})`, "transform-origin": `${this.directionStart} top` }, handle: { [this.directionStart]: `${this._handlePositionFromStart}%` }, label: { width: `${this._labelWidth}%` }, labelContainer: { width: "100%", [this.directionStart]: `-${this._labelWidth / 2}%` }, tooltip: { visibility: `${this._tooltipVisibility}` } };
  }
  get _sliderHandle() {
    return this.shadowRoot.querySelector(".ui5-slider-handle");
  }
  get tooltipValue() {
    const e3 = this.constructor._getDecimalPrecisionOfNumber(this._effectiveStep);
    return this.value.toFixed(e3);
  }
  get _ariaDisabled() {
    return this.disabled || void 0;
  }
  get _ariaLabelledByText() {
    return DR.i18nBundle.getText(GE);
  }
  static async onDefine() {
    DR.i18nBundle = await Wx("@ui5/webcomponents");
  }
  get tickmarksObject() {
    const e3 = this._tickmarksCount, t2 = [];
    if (this._hiddenTickmarks)
      return [true, false];
    for (let i2 = 0; i2 <= e3; i2++)
      t2.push(this._effectiveMin + i2 * this.step <= this.value);
    return t2;
  }
};
LR([tS({ validator: Rk, defaultValue: 0 })], FR.prototype, "value", void 0), FR = DR = LR([eS({ tag: "ui5-slider", languageAware: true, template: function(e3, t2, i2) {
  return i2 ? XS`<div class="ui5-slider-root ${WS(this.classes.root)}" @mousedown="${this._onmousedown}" @touchstart="${this._ontouchstart}" @mouseover="${this._onmouseover}" @mouseout="${this._onmouseout}" @keydown="${this._onkeydown}" @keyup="${this._onkeyup}" part="root-container"><div class="ui5-slider-inner">${this.step ? ER.call(this, e3, t2, i2) : void 0}<div class="ui5-slider-progress-container" aria-hidden="true" part="progress-container"><div class="ui5-slider-progress" style="${qS(this.styles.progress)}" @focusout="${this._onfocusout}" @focusin="${this._onfocusin}" tabindex="-1" part="progress-bar"></div></div><div class="ui5-slider-handle" style="${qS(this.styles.handle)}" @focusout="${this._onfocusout}" @focusin="${this._onfocusin}" role="slider" tabindex="${jS(this._tabIndex)}" aria-orientation="horizontal" aria-valuemin="${jS(this.min)}" aria-valuemax="${jS(this.max)}" aria-valuenow="${jS(this.value)}" aria-labelledby="${jS(this._ariaLabelledByHandleRefs)}" aria-disabled="${jS(this._ariaDisabled)}" data-sap-focus-ref part="handle"><${ZS("ui5-icon", t2, i2)} name="direction-arrows" part="icon-slider" slider-icon></${ZS("ui5-icon", t2, i2)}>${this.showTooltip ? PR.call(this, e3, t2, i2) : void 0}</div></div><span id="${jS(this._id)}-accName" class="ui5-hidden-text">${jS(this.accessibleName)}</span><span id="${jS(this._id)}-sliderDesc" class="ui5-hidden-text">${jS(this._ariaLabelledByText)}</span></div> ` : XS`<div class="ui5-slider-root ${WS(this.classes.root)}" @mousedown="${this._onmousedown}" @touchstart="${this._ontouchstart}" @mouseover="${this._onmouseover}" @mouseout="${this._onmouseout}" @keydown="${this._onkeydown}" @keyup="${this._onkeyup}" part="root-container"><div class="ui5-slider-inner">${this.step ? ER.call(this, e3, t2, i2) : void 0}<div class="ui5-slider-progress-container" aria-hidden="true" part="progress-container"><div class="ui5-slider-progress" style="${qS(this.styles.progress)}" @focusout="${this._onfocusout}" @focusin="${this._onfocusin}" tabindex="-1" part="progress-bar"></div></div><div class="ui5-slider-handle" style="${qS(this.styles.handle)}" @focusout="${this._onfocusout}" @focusin="${this._onfocusin}" role="slider" tabindex="${jS(this._tabIndex)}" aria-orientation="horizontal" aria-valuemin="${jS(this.min)}" aria-valuemax="${jS(this.max)}" aria-valuenow="${jS(this.value)}" aria-labelledby="${jS(this._ariaLabelledByHandleRefs)}" aria-disabled="${jS(this._ariaDisabled)}" data-sap-focus-ref part="handle"><ui5-icon name="direction-arrows" part="icon-slider" slider-icon></ui5-icon>${this.showTooltip ? PR.call(this, e3, t2, i2) : void 0}</div></div><span id="${jS(this._id)}-accName" class="ui5-hidden-text">${jS(this.accessibleName)}</span><span id="${jS(this._id)}-sliderDesc" class="ui5-hidden-text">${jS(this._ariaLabelledByText)}</span></div> `;
}, dependencies: [WI] })], FR), FR.define();
const NR = FR;
Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
var OR, zR = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
const UR = 6.5;
let HR = OR = class extends ZC {
  static async onDefine() {
    OR.i18nBundle = await Wx("@ui5/webcomponents");
  }
  constructor() {
    super(), this._selectedCoordinates = { x: 249.5, y: 249.5 }, this._mainColor = { r: 255, g: 0, b: 0 }, this.selectedHue = 0, this.mouseDown = false, this.mouseIn = false;
  }
  onBeforeRendering() {
    this._color = Dk(this.color);
    const e3 = `rgba(${this._color.r}, ${this._color.g}, ${this._color.b}, 1)`;
    this._setHex(), this._setValues(), this.style.setProperty("--ui5_Color_Picker_Progress_Container_Color", e3);
  }
  _handleMouseDown(e3) {
    this.mouseDown = true, this.mouseIn = true, this._changeSelectedColor(e3.offsetX, e3.offsetY);
  }
  _handleMouseUp() {
    this.mouseDown = false;
  }
  _handleMouseOut(e3) {
    if (!this.mouseIn || !this.mouseDown)
      return;
    const t2 = e3.target, i2 = t2.offsetHeight, n2 = t2.offsetWidth, o2 = e3.offsetX <= 0, r2 = e3.offsetY <= 0, s2 = e3.offsetY >= t2.offsetHeight, a2 = e3.offsetX >= t2.offsetWidth;
    let l2, c2;
    l2 = o2 ? 0 : a2 ? n2 : e3.offsetX, c2 = r2 ? 0 : s2 ? i2 : e3.offsetY, this._changeSelectedColor(l2, c2), this.mouseIn = false, this.mouseDown = false;
  }
  _handleMouseMove(e3) {
    this.mouseDown && this.mouseIn && this._changeSelectedColor(e3.offsetX, e3.offsetY);
  }
  _handleAlphaInput(e3) {
    const t2 = e3.target.value;
    this._alpha = parseFloat(t2), this._setColor(this._color);
  }
  _handleHueInput(e3) {
    this.selectedHue = e3.target.value, this._hue = this.selectedHue, this._setMainColor(this._hue), this._isHueValueChanged = true;
    const t2 = this._selectedCoordinates.x + UR, i2 = this._selectedCoordinates.y + UR, n2 = this._calculateColorFromCoordinates(t2, i2);
    n2 && this._setColor(Nk(n2));
  }
  _handleHEXChange(e3) {
    const t2 = new RegExp("^[<0-9 abcdef]+$"), i2 = e3.target;
    let n2 = i2.value.toLowerCase();
    3 === n2.length && (n2 = `${n2[0]}${n2[0]}${n2[1]}${n2[1]}${n2[2]}${n2[2]}`);
    const o2 = 6 === n2.length && t2.test(n2);
    o2 && i2.value !== n2 && (this._wrongHEX = false, i2.value = n2), n2 !== this.hex && (this.hex = n2, o2 ? (this._wrongHEX = false, this._setColor(Ok(this.hex))) : this._wrongHEX = true);
  }
  _handleRGBInputsChange(e3) {
    const t2 = e3.target, i2 = parseInt(t2.value) || 0;
    let n2;
    switch (t2.id) {
      case "red":
        n2 = { ...this._color, r: i2 };
        break;
      case "green":
        n2 = { ...this._color, g: i2 };
        break;
      case "blue":
        n2 = { ...this._color, b: i2 };
        break;
      default:
        n2 = { ...this._color };
    }
    this._setColor(n2);
  }
  _setMainColor(e3) {
    this._mainColor = e3 <= 255 ? { r: 255, g: e3, b: 0 } : e3 <= 510 ? { r: 255 - (e3 - 255), g: 255, b: 0 } : e3 <= 765 ? { r: 0, g: 255, b: e3 - 510 } : e3 <= 1020 ? { r: 0, g: 765 - (e3 - 255), b: 255 } : e3 <= 1275 ? { r: e3 - 1020, g: 0, b: 255 } : { r: 255, g: 0, b: 1275 - (e3 - 255) };
  }
  _handleAlphaChange() {
    this._alpha = this._alpha < 0 ? 0 : this._alpha, this._alpha = this._alpha > 1 ? 1 : this._alpha;
  }
  _changeSelectedColor(e3, t2) {
    this._selectedCoordinates = { x: e3 - UR, y: t2 - UR }, this._isSelectedColorChanged = true;
    const i2 = this._calculateColorFromCoordinates(e3, t2);
    i2 && this._setColor(Nk(i2));
  }
  _onkeydown(e3) {
    rS(e3) && this._handleHEXChange(e3);
  }
  _calculateColorFromCoordinates(e3, t2) {
    const i2 = this._hue / 4.25, n2 = 1 - +(Math.round(parseFloat(t2 / 256 + "e+2")) + "e-2"), o2 = +(Math.round(parseFloat(e3 / 256 + "e+2")) + "e-2");
    if (n2 && o2)
      return { h: i2, s: n2, l: o2 };
  }
  _setColor(e3 = { r: 0, g: 0, b: 0 }) {
    this.color = `rgba(${e3.r}, ${e3.g}, ${e3.b}, ${this._alpha})`, this._wrongHEX = !this.isValidRGBColor(e3), this.fireEvent("change");
  }
  isValidRGBColor(e3) {
    return e3.r >= 0 && e3.r <= 255 && e3.g >= 0 && e3.g <= 255 && e3.b >= 0 && e3.b <= 255;
  }
  _setHex() {
    let e3 = this._color.r.toString(16), t2 = this._color.g.toString(16), i2 = this._color.b.toString(16);
    1 === e3.length && (e3 = `0${e3}`), 1 === t2.length && (t2 = `0${t2}`), 1 === i2.length && (i2 = `0${i2}`), this.hex = e3 + t2 + i2;
  }
  _setValues() {
    const e3 = ((e4) => {
      const t2 = e4.r / 255, i2 = e4.g / 255, n2 = e4.b / 255, o2 = Math.max(t2, i2, n2), r2 = Math.min(t2, i2, n2), s2 = o2 - r2;
      let a2, l2 = 0;
      0 === s2 ? l2 = 0 : o2 === t2 ? l2 = (i2 - n2) / s2 % 6 * 60 : o2 === i2 ? l2 = 60 * ((n2 - t2) / s2 + 2) : o2 === n2 && (l2 = 60 * ((t2 - i2) / s2 + 4));
      const c2 = (o2 + r2) / 2;
      return a2 = 0 === s2 ? 0 : s2 / (1 - Math.abs(2 * c2 - 1)), { h: l2, s: a2, l: c2 };
    })(this._color);
    this._selectedCoordinates = { x: 2.56 * Math.round(100 * e3.l) - UR, y: 256 - 2.56 * Math.round(100 * e3.s) - UR }, this._isSelectedColorChanged ? this._isSelectedColorChanged = false : this._isHueValueChanged ? (this._isHueValueChanged = false, this._hue = this.selectedHue ? this.selectedHue : this._hue) : this._hue = Math.round(4.25 * e3.h), this._setMainColor(this._hue);
  }
  get hueSliderLabel() {
    return OR.i18nBundle.getText(bE);
  }
  get alphaSliderLabel() {
    return OR.i18nBundle.getText(AE);
  }
  get hexInputLabel() {
    return OR.i18nBundle.getText(yE);
  }
  get redInputLabel() {
    return OR.i18nBundle.getText(wE);
  }
  get greenInputLabel() {
    return OR.i18nBundle.getText(xE);
  }
  get blueInputLabel() {
    return OR.i18nBundle.getText(CE);
  }
  get alphaInputLabel() {
    return OR.i18nBundle.getText(SE);
  }
  get inputsDisabled() {
    return !!this._wrongHEX || void 0;
  }
  get hexInputErrorState() {
    return this._wrongHEX ? "Error" : void 0;
  }
  get styles() {
    return { mainColor: { "background-color": `rgb(${this._mainColor.r}, ${this._mainColor.g}, ${this._mainColor.b})` }, circle: { left: `${this._selectedCoordinates.x}px`, top: `${this._selectedCoordinates.y}px` }, colorSpan: { "background-color": `rgba(${this._color.r}, ${this._color.g}, ${this._color.b}, ${this._alpha})` } };
  }
};
zR([tS({ validator: EM, defaultValue: "rgba(255, 255, 255, 1)" })], HR.prototype, "color", void 0), zR([tS({ defaultValue: "ffffff", noAttribute: true })], HR.prototype, "hex", void 0), zR([tS({ type: Object })], HR.prototype, "_mainColor", void 0), zR([tS({ type: Object })], HR.prototype, "_color", void 0), zR([tS({ type: Object })], HR.prototype, "_selectedCoordinates", void 0), zR([tS({ validator: Rk, defaultValue: 1 })], HR.prototype, "_alpha", void 0), zR([tS({ validator: nI, defaultValue: 0 })], HR.prototype, "_hue", void 0), zR([tS({ type: Boolean })], HR.prototype, "_isSelectedColorChanged", void 0), zR([tS({ type: Boolean })], HR.prototype, "_isHueValueChanged", void 0), zR([tS({ type: Boolean })], HR.prototype, "_wrongHEX", void 0), HR = OR = zR([eS({ tag: "ui5-color-picker", renderer: KS, styles: { packageName: "@ui5/webcomponents", fileName: "themes/ColorPicker.css", content: ':host(:not([hidden])){display:inline-block}.ui5-color-picker-root{width:100%;height:100%;display:flex;flex-direction:column;justify-content:center;align-items:center}.ui5-color-picker-main-color{width:16rem;height:16rem;position:relative;margin-bottom:1.5rem;border:1px solid var(--sapContent_ForegroundBorderColor);background-size:100%;background-image:-webkit-linear-gradient(left,#000,transparent),-webkit-linear-gradient(top,hsla(0,0%,100%,0),#fff);background-image:-moz-linear-gradient(left,#000,transparent),-moz-linear-gradient(top,hsla(0,0%,100%,0),#fff);background-image:linear-gradient(left,#000,transparent),linear-gradient(top,hsla(0,0%,100%,0),#fff);background-image:-webkit-linear-gradient(left,#000,transparent,#fff),-webkit-linear-gradient(top,hsla(0,0%,50.2%,0),grey);background-image:-moz-linear-gradient(left,#000,transparent,#fff),-moz-linear-gradient(top,hsla(0,0%,50.2%,0),grey);background-image:linear-gradient(left,#000,transparent,#fff),linear-gradient(top,hsla(0,0%,50.2%,0),grey);user-select:none;-moz-user-select:none}.ui5-color-picker-circle{position:absolute;box-sizing:border-box;width:13px;height:13px;border:var(--_ui5_color_picker_circle_outer_border);border-radius:.6875rem;pointer-events:none}.ui5-color-picker-circle:after{content:"";position:absolute;width:var(--_ui5_color_picker_circle_inner_circle_size);height:var(--_ui5_color_picker_circle_inner_circle_size);border:var(--_ui5_color_picker_circle_inner_border);border-radius:.9375rem;pointer-events:none}.ui5-color-picker-sliders-wrapper{width:calc(100% - 11px);margin-left:-10px}[ui5-slider]{--_ui5_slider_active_progress_border:none;--_ui5_slider_progress_box_sizing:content-box}[ui5-slider]::part(handle){width:.9375rem;height:1.5rem;background:transparent;margin-left:-2px;margin-top:var(--_ui5_color_picker_slider_handle_margin_top);box-sizing:border-box}[ui5-slider]::part(handle):after{content:"";border:2px solid #fff;display:block;height:1.25rem;border-radius:1rem;width:100%;box-sizing:border-box}[ui5-slider]::part(root-container){padding:1rem 0}[ui5-slider]::part(progress-container){width:calc(100% + 11px);height:18px;position:absolute;margin-top:var(--_ui5_color_picker_slider_container_margin_top);border-radius:0;border:1px solid var(--sapField_BorderColor)}[ui5-slider].ui5-color-picker-hue-slider::part(progress-container){background-size:100%;background-image:-webkit-linear-gradient(left,red,#ff0,#0f0,#0ff,#00f,#f0f,red);background-image:-moz-linear-gradient(left,red,#ff0,#0f0,#0ff,#00f,#f0f,red);background-image:linear-gradient(left,red,#ff0,#0f0,#0ff,#00f,#f0f,red);background-color:none}[ui5-slider].ui5-color-picker-alpha-slider::part(progress-container){background-image:-webkit-linear-gradient(left,rgba(65,120,13,0),var(--ui5_Color_Picker_Progress_Container_Color)),url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAIAAAF1V2h8AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAEZ0FNQQAAsY58+1GTAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAACTSURBVHjaYjhz5sz///8Z/v//f+bMGQAAAAD//2I4c+YM4////wEAAAD//2I8c+YMAwODsbExAAAA//9igMgzMUAARBkAAAD//4JKQ1UwMDD+//8fwj979iwDAwMAAAD//0LSzsDAwMAA0w0D6HyofohmLPIAAAAA//9C2IdsK07jsJsOB3BriNJNQBoAAAD//wMA+ew3HIMTh5IAAAAASUVORK5CYII=")}[ui5-slider]::part(progress-bar){background:transparent}.ui5-color-picker-current-color{width:100%;display:flex;justify-content:space-around;align-items:center}.ui5-color-picker-colors-wrapper{display:flex;flex-wrap:nowrap;height:1.5rem;border:1px solid var(--sapField_BorderColor)}.ui5-color-picker-color,.ui5-color-picker-white{width:3.1rem;background:#fff;display:block}.ui5-color-picker-color{background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAIAAAF1V2h8AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAEZ0FNQQAAsY58+1GTAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAACTSURBVHjaYjhz5sz///8Z/v//f+bMGQAAAAD//2I4c+YM4////wEAAAD//2I8c+YMAwODsbExAAAA//9igMgzMUAARBkAAAD//4JKQ1UwMDD+//8fwj979iwDAwMAAAD//0LSzsDAwMAA0w0D6HyofohmLPIAAAAA//9C2IdsK07jsJsOB3BriNJNQBoAAAD//wMA+ew3HIMTh5IAAAAASUVORK5CYII=")}.ui5-color-picker-color-inner{width:100%;height:100%}.ui5-color-picker-hex-input-wrapper{display:flex;align-items:center;flex-wrap:nowrap}.ui5-color-picker-hex-input{width:4.5rem;min-width:4.5rem;margin-left:.2rem}.ui5-color-picker-rgb-wrapper{display:flex;justify-content:space-around;width:100%}.ui5-color-picker-rgb{display:flex;flex-direction:column;align-items:center;margin-top:1rem}.ui5-color-picker-rgb-input{width:2.5rem;min-width:2.5rem;text-align:center}.ui5-color-picker-alpha-slider::part(progress-container):after,.ui5-color-picker-alpha-slider::part(progress-container):before,.ui5-color-picker-hue-slider::part(progress-container):after,.ui5-color-picker-hue-slider::part(progress-container):before,[ui5-slider].ui5-color-picker-alpha-slider::part(icon-slider),[ui5-slider].ui5-color-picker-hue-slider::part(icon-slider){display:none}.ui5-color-picker-alpha-slider::part(handle),.ui5-color-picker-hue-slider::part(handle){box-shadow:var(--_ui5_color_picker_slider_handle_box_shadow);border:var(--_ui5_color_picker_slider_handle_border)}.ui5-color-picker-alpha-slider::part(handle):hover,.ui5-color-picker-hue-slider::part(handle):hover{border:var(--_ui5_color_picker_slider_handle_outline_hover)}.ui5-color-picker-alpha-slider::part(handle):focus,.ui5-color-picker-hue-slider::part(handle):focus{outline:var(--_ui5_color_picker_slider_handle_outline_focus);outline-offset:.0625rem}.ui5-color-picker-alpha-slider::part(handle):focus:before,.ui5-color-picker-hue-slider::part(handle):focus:before{content:"";border:var(--_ui5_color_picker_slider_handle_inline_focus);display:block;height:1.625rem;border-radius:1rem;width:1.05rem;box-sizing:border-box;top:-3px;position:absolute;bottom:2px;left:-3px;right:-3px}.ui5-color-picker-alpha-slider::part(handle):before,.ui5-color-picker-hue-slider::part(handle):before{display:none}.ui5-color-picker-alpha-slider::part(handle):focus,.ui5-color-picker-hue-slider::part(handle):focus{margin-top:var(--_ui5_color_picker_slider_handle_focus_margin_top)}[dir=rtl] [ui5-slider].ui5-color-picker-hue-slider::part(progress-container){background-image:-webkit-linear-gradient(right,red,#ff0,#0f0,#0ff,#00f,#f0f,red);background-image:-moz-linear-gradient(right,red,#ff0,#0f0,#0ff,#00f,#f0f,red);background-image:linear-gradient(right,red,#ff0,#0f0,#0ff,#00f,#f0f,red)}[dir=rtl] .ui5-color-picker-alpha-slider::part(handle),[dir=rtl] .ui5-color-picker-hue-slider::part(handle){--_ui5_slider_handle_margin_left:0}[dir=rtl] .ui5-color-picker-sliders-wrapper{margin-left:10px}' }, template: function(e3, t2, i2) {
  return i2 ? XS`<section dir="${jS(this.effectiveDir)}" class="ui5-color-picker-root"><div class="ui5-color-picker-main-color" style="${qS(this.styles.mainColor)}" @mousedown="${this._handleMouseDown}" @mouseup="${this._handleMouseUp}" @mousemove="${this._handleMouseMove}" @mouseout="${this._handleMouseOut}"><div class="ui5-color-picker-circle" style="${qS(this.styles.circle)}"></div></div><div class="ui5-color-picker-sliders-wrapper"><${ZS("ui5-slider", t2, i2)} disabled="${jS(this.inputsDisabled)}" class="ui5-color-picker-hue-slider" min="0" max="1530" value="${jS(this._hue)}" accessible-name="${jS(this.hueSliderLabel)}" @ui5-input="${jS(this._handleHueInput)}"></${ZS("ui5-slider", t2, i2)}><${ZS("ui5-slider", t2, i2)} disabled="${jS(this.inputsDisabled)}" class="ui5-color-picker-alpha-slider" min="0" max="1" step="0.01" value="${jS(this._alpha)}" accessible-name="${jS(this.alphaSliderLabel)}" @ui5-input="${jS(this._handleAlphaInput)}"></${ZS("ui5-slider", t2, i2)}></div><div class="ui5-color-picker-current-color"><div class="ui5-color-picker-colors-wrapper"><span class="ui5-color-picker-white"></span><span class="ui5-color-picker-color"><div class="ui5-color-picker-color-inner" style="${qS(this.styles.colorSpan)}"></div></span></div><div class="ui5-color-picker-hex-input-wrapper"><${ZS("ui5-label", t2, i2)}>Hex</${ZS("ui5-label", t2, i2)}><${ZS("ui5-input", t2, i2)} class="ui5-color-picker-hex-input" value="${jS(this.hex)}" @keydown="${this._onkeydown}" accessible-name="${jS(this.hexInputLabel)}" @ui5-change="${jS(this._handleHEXChange)}" value-state="${jS(this.hexInputErrorState)}"></${ZS("ui5-input", t2, i2)}></div></div><div class="ui5-color-picker-rgb-wrapper" @ui5-change="${jS(this._handleRGBInputsChange)}"><div class="ui5-color-picker-rgb"><${ZS("ui5-input", t2, i2)} id="red" class="ui5-color-picker-rgb-input" disabled="${jS(this.inputsDisabled)}" accessible-name="${jS(this.redInputLabel)}" value="${jS(this._color.r)}"></${ZS("ui5-input", t2, i2)}><${ZS("ui5-label", t2, i2)}>R</${ZS("ui5-label", t2, i2)}></div><div class="ui5-color-picker-rgb"><${ZS("ui5-input", t2, i2)} id="green" class="ui5-color-picker-rgb-input" disabled="${jS(this.inputsDisabled)}" accessible-name="${jS(this.greenInputLabel)}" value="${jS(this._color.g)}"></${ZS("ui5-input", t2, i2)}><${ZS("ui5-label", t2, i2)}>G</${ZS("ui5-label", t2, i2)}></div><div class="ui5-color-picker-rgb"><${ZS("ui5-input", t2, i2)} id="blue" class="ui5-color-picker-rgb-input" disabled="${jS(this.inputsDisabled)}" accessible-name="${jS(this.blueInputLabel)}" value="${jS(this._color.b)}"></${ZS("ui5-input", t2, i2)}><${ZS("ui5-label", t2, i2)}>B</${ZS("ui5-label", t2, i2)}></div><div class="ui5-color-picker-rgb"><${ZS("ui5-input", t2, i2)} id="alpha" disabled="${jS(this.inputsDisabled)}" class="ui5-color-picker-rgb-input" value="${jS(this._alpha)}" accessible-name="${jS(this.alphaInputLabel)}" @ui5-input="${jS(this._handleAlphaInput)}" @ui5-change="${jS(this._handleAlphaChange)}"></${ZS("ui5-input", t2, i2)}><${ZS("ui5-label", t2, i2)}>A</${ZS("ui5-label", t2, i2)}></div></div></section>` : XS`<section dir="${jS(this.effectiveDir)}" class="ui5-color-picker-root"><div class="ui5-color-picker-main-color" style="${qS(this.styles.mainColor)}" @mousedown="${this._handleMouseDown}" @mouseup="${this._handleMouseUp}" @mousemove="${this._handleMouseMove}" @mouseout="${this._handleMouseOut}"><div class="ui5-color-picker-circle" style="${qS(this.styles.circle)}"></div></div><div class="ui5-color-picker-sliders-wrapper"><ui5-slider disabled="${jS(this.inputsDisabled)}" class="ui5-color-picker-hue-slider" min="0" max="1530" value="${jS(this._hue)}" accessible-name="${jS(this.hueSliderLabel)}" @ui5-input="${jS(this._handleHueInput)}"></ui5-slider><ui5-slider disabled="${jS(this.inputsDisabled)}" class="ui5-color-picker-alpha-slider" min="0" max="1" step="0.01" value="${jS(this._alpha)}" accessible-name="${jS(this.alphaSliderLabel)}" @ui5-input="${jS(this._handleAlphaInput)}"></ui5-slider></div><div class="ui5-color-picker-current-color"><div class="ui5-color-picker-colors-wrapper"><span class="ui5-color-picker-white"></span><span class="ui5-color-picker-color"><div class="ui5-color-picker-color-inner" style="${qS(this.styles.colorSpan)}"></div></span></div><div class="ui5-color-picker-hex-input-wrapper"><ui5-label>Hex</ui5-label><ui5-input class="ui5-color-picker-hex-input" value="${jS(this.hex)}" @keydown="${this._onkeydown}" accessible-name="${jS(this.hexInputLabel)}" @ui5-change="${jS(this._handleHEXChange)}" value-state="${jS(this.hexInputErrorState)}"></ui5-input></div></div><div class="ui5-color-picker-rgb-wrapper" @ui5-change="${jS(this._handleRGBInputsChange)}"><div class="ui5-color-picker-rgb"><ui5-input id="red" class="ui5-color-picker-rgb-input" disabled="${jS(this.inputsDisabled)}" accessible-name="${jS(this.redInputLabel)}" value="${jS(this._color.r)}"></ui5-input><ui5-label>R</ui5-label></div><div class="ui5-color-picker-rgb"><ui5-input id="green" class="ui5-color-picker-rgb-input" disabled="${jS(this.inputsDisabled)}" accessible-name="${jS(this.greenInputLabel)}" value="${jS(this._color.g)}"></ui5-input><ui5-label>G</ui5-label></div><div class="ui5-color-picker-rgb"><ui5-input id="blue" class="ui5-color-picker-rgb-input" disabled="${jS(this.inputsDisabled)}" accessible-name="${jS(this.blueInputLabel)}" value="${jS(this._color.b)}"></ui5-input><ui5-label>B</ui5-label></div><div class="ui5-color-picker-rgb"><ui5-input id="alpha" disabled="${jS(this.inputsDisabled)}" class="ui5-color-picker-rgb-input" value="${jS(this._alpha)}" accessible-name="${jS(this.alphaInputLabel)}" @ui5-input="${jS(this._handleAlphaInput)}" @ui5-change="${jS(this._handleAlphaChange)}"></ui5-input><ui5-label>A</ui5-label></div></div></section>`;
}, dependencies: [AR, NR, _M] }), iS("change")], HR), HR.define();
const QR = HR;
class VR {
  static get dependencies() {
    return [nM, ZI, QR];
  }
  static async init() {
    VR.i18nBundle = await Wx("@ui5/webcomponents");
  }
  get colorPaletteDialogTitle() {
    return VR.i18nBundle.getText(fE);
  }
  get colorPaletteDialogOKButton() {
    return VR.i18nBundle.getText(mE);
  }
  get colorPaletteCancelButton() {
    return VR.i18nBundle.getText(gE);
  }
}
function GR(e3, t2, i2) {
  return i2 ? XS`<div class="ui5-step-icon ui5-step-dec" title="${jS(this.decIconTitle)}"><${ZS("ui5-icon", t2, i2)} id="${jS(this._id)}-dec" name="${jS(this.decIconName)}" tabindex="-1" accessible-name="${jS(this.decIconTitle)}" @click="${this._decValue}" @focusout="${this._onButtonFocusOut}" @mousedown="${this._decSpin}" @mouseup="${this._resetSpin}" @mouseout="${this._resetSpinOut}" input-icon show-tooltip ?clickable="${this._decIconClickable}"></${ZS("ui5-icon", t2, i2)}></div>` : XS`<div class="ui5-step-icon ui5-step-dec" title="${jS(this.decIconTitle)}"><ui5-icon id="${jS(this._id)}-dec" name="${jS(this.decIconName)}" tabindex="-1" accessible-name="${jS(this.decIconTitle)}" @click="${this._decValue}" @focusout="${this._onButtonFocusOut}" @mousedown="${this._decSpin}" @mouseup="${this._resetSpin}" @mouseout="${this._resetSpinOut}" input-icon show-tooltip ?clickable="${this._decIconClickable}"></ui5-icon></div>`;
}
function $R(e3, t2, i2) {
  return XS`<slot name="valueStateMessage" slot="valueStateMessage"></slot>`;
}
function WR(e3, t2, i2) {
  return i2 ? XS`<div class="ui5-step-icon ui5-step-inc" title="${jS(this.incIconTitle)}"><${ZS("ui5-icon", t2, i2)} id="${jS(this._id)}-inc" name="${jS(this.incIconName)}" tabindex="-1" accessible-name="${jS(this.incIconTitle)}" @click="${this._incValue}" @focusout="${this._onButtonFocusOut}" @mousedown="${this._incSpin}" @mouseup="${this._resetSpin}" @mouseout="${this._resetSpinOut}" input-icon show-tooltip ?clickable="${this._incIconClickable}"></${ZS("ui5-icon", t2, i2)}></div>` : XS`<div class="ui5-step-icon ui5-step-inc" title="${jS(this.incIconTitle)}"><ui5-icon id="${jS(this._id)}-inc" name="${jS(this.incIconName)}" tabindex="-1" accessible-name="${jS(this.incIconTitle)}" @click="${this._incValue}" @focusout="${this._onButtonFocusOut}" @mousedown="${this._incSpin}" @mouseup="${this._resetSpin}" @mouseout="${this._resetSpinOut}" input-icon show-tooltip ?clickable="${this._incIconClickable}"></ui5-icon></div>`;
}
((e3, t2) => {
  Yy.set(e3, t2);
})("ColorPaletteMoreColors", VR);
const qR = "M464 224q16 0 16 16v32q0 16-16 16H48q-6 0-11-4.5T32 272v-32q0-7 5-11.5t11-4.5h416z";
Kx("less", { pathData: qR, ltr: false, collection: "SAP-icons-v4", packageName: "@ui5/webcomponents-icons" });
const jR = "M454 275H58q-11 0-18.5-7T32 250t7.5-18.5T58 224h396q11 0 18.5 7.5T480 250t-7.5 18-18.5 7z";
Kx("less", { pathData: jR, ltr: false, collection: "SAP-icons-v5", packageName: "@ui5/webcomponents-icons" }), dx();
const XR = "M32 240q0-7 5-11.5t11-4.5h176V48q0-7 5-11.5t11-4.5h32q16 0 16 16v176h176q16 0 16 16v32q0 16-16 16H288v176q0 16-16 16h-32q-6 0-11-4.5t-5-11.5V288H48q-6 0-11-4.5T32 272v-32z";
Kx("add", { pathData: XR, ltr: false, accData: uT, collection: "SAP-icons-v4", packageName: "@ui5/webcomponents-icons" });
const YR = "M454 231q11 0 18.5 7t7.5 18-7.5 18.5T454 282H282v173q0 11-7.5 18t-18.5 7-18.5-7-7.5-18V282H58q-11 0-18.5-7.5T32 256t7.5-18 18.5-7h172V58q0-11 7.5-18.5T256 32t18.5 7.5T282 58v173h172z";
Kx("add", { pathData: YR, ltr: false, accData: uT, collection: "SAP-icons-v5", packageName: "@ui5/webcomponents-icons" }), dx(), Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
var KR, ZR = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
let JR = KR = class extends ZC {
  static async onDefine() {
    KR.i18nBundle = await Wx("@ui5/webcomponents");
  }
  get type() {
    return Qk.Number;
  }
  get decIconTitle() {
    return KR.i18nBundle.getText(eI);
  }
  get decIconName() {
    return "less";
  }
  get incIconTitle() {
    return KR.i18nBundle.getText(tI);
  }
  get incIconName() {
    return "add";
  }
  get _decIconClickable() {
    return !this._decIconDisabled && !this.readonly && !this.disabled;
  }
  get _incIconClickable() {
    return !this._incIconDisabled && !this.readonly && !this.disabled;
  }
  get _isFocused() {
    return this.focused;
  }
  get _valuePrecisioned() {
    return this.value.toFixed(this.valuePrecision);
  }
  get accInfo() {
    return { ariaRequired: this.required, ariaLabel: bI(this) };
  }
  get inputAttributes() {
    return { min: void 0 === this.min ? void 0 : this.min, max: void 0 === this.max ? void 0 : this.max, step: this.step };
  }
  onBeforeRendering() {
    this._setButtonState(), void 0 === this._previousValue && (this._previousValue = this.value);
    const e3 = Ky("FormSupport");
    e3 ? e3.syncNativeHiddenInput(this) : this.name && console.warn('In order for the "name" property to have effect, you should also: import "@ui5/webcomponents/dist/features/InputElementsFormSupport.js";');
  }
  get input() {
    return this.shadowRoot.querySelector("[ui5-input]");
  }
  get inputOuter() {
    return this.shadowRoot.querySelector(".ui5-step-input-input");
  }
  _onButtonFocusOut() {
    setTimeout(() => {
      this._inputFocused || this.inputOuter.removeAttribute("focused");
    }, 0);
  }
  _onInputFocusIn() {
    this._inputFocused = true, this.value !== this._previousValue && (this._previousValue = this.value);
  }
  _onInputFocusOut() {
    this._inputFocused = false, this._onInputChange();
  }
  _setButtonState() {
    this._decIconDisabled = void 0 !== this.min && this.value <= this.min, this._incIconDisabled = void 0 !== this.max && this.value >= this.max;
  }
  _validate() {
    void 0 === this._initialValueState && (this._initialValueState = this.valueState), this.valueState = void 0 !== this.min && this.value < this.min || void 0 !== this.max && this.value > this.max ? eB.Error : this._initialValueState;
  }
  _preciseValue(e3) {
    const t2 = 10 ** this.valuePrecision;
    return Math.round(e3 * t2) / t2;
  }
  _fireChangeEvent() {
    this._previousValue !== this.value && (this._previousValue = this.value, this.fireEvent("change", { value: this.value }));
  }
  _modifyValue(e3, t2 = false) {
    let i2;
    this.value = this._preciseValue(parseFloat(this.input.value)), i2 = this.value + e3, void 0 !== this.min && i2 < this.min && (i2 = this.min), void 0 !== this.max && i2 > this.max && (i2 = this.max), i2 = this._preciseValue(i2), i2 !== this.value && (this.value = i2, this._validate(), this._setButtonState(), this.focused = true, this.inputOuter.setAttribute("focused", ""), t2 ? this._fireChangeEvent() : this.input.focus());
  }
  _incValue(e3) {
    this._incIconClickable && e3.isTrusted && !this.disabled && !this.readonly && (this._modifyValue(this.step, true), this._previousValue = this.value);
  }
  _decValue(e3) {
    this._decIconClickable && e3.isTrusted && !this.disabled && !this.readonly && (this._modifyValue(-this.step, true), this._previousValue = this.value);
  }
  _onInputChange() {
    "" === this.input.value && (this.input.value = this.min || 0);
    const e3 = this._preciseValue(parseFloat(this.input.value));
    this.value === this._previousValue && this.value === e3 || (this.value = e3, this._validate(), this._setButtonState(), this._fireChangeEvent());
  }
  _onfocusin() {
    this.focused = true;
  }
  _onfocusout() {
    this.focused = false;
  }
  _onkeydown(e3) {
    let t2 = true;
    this.disabled || this.readonly || (rS(e3) ? this._onInputChange() : (cS(e3) ? this._modifyValue(this.step) : hS(e3) ? this._modifyValue(-this.step) : yS(e3) ? (this.value = this._previousValue, this.input.value = this.value.toFixed(this.valuePrecision)) : void 0 !== this.max && (((e4) => (e4.key ? "PageUp" === e4.key : e4.keyCode === oS.PAGE_UP) && kS(e4, false, false, true))(e3) || ((e4) => (e4.key ? "ArrowUp" === e4.key || "Up" === e4.key : e4.keyCode === oS.ARROW_UP) && kS(e4, true, false, true))(e3)) ? this._modifyValue(this.max - this.value) : void 0 !== this.min && (((e4) => (e4.key ? "PageDown" === e4.key : e4.keyCode === oS.PAGE_DOWN) && kS(e4, false, false, true))(e3) || ((e4) => (e4.key ? "ArrowDown" === e4.key || "Down" === e4.key : e4.keyCode === oS.ARROW_DOWN) && kS(e4, true, false, true))(e3)) ? this._modifyValue(this.min - this.value) : pS(e3) || _S(e3) || gS(e3) || mS(e3) || (t2 = false), t2 && e3.preventDefault()));
  }
  _decSpin() {
    this._decIconDisabled || this._spinValue(false, true);
  }
  _incSpin() {
    this._incIconDisabled || this._spinValue(true, true);
  }
  _calcWaitTimeout() {
    return this._speed *= 0.8, this._waitTimeout = this._waitTimeout - this._speed < 50 ? 50 : this._waitTimeout - this._speed, this._waitTimeout;
  }
  _spinValue(e3, t2 = false) {
    t2 && (this._waitTimeout = 500, this._speed = 120, this._btnDown = true), this._spinTimeoutId = setTimeout(() => {
      this._btnDown && (this._spinStarted = true, this._modifyValue(e3 ? this.step : -this.step), this._setButtonState(), !this._incIconDisabled && e3 || !this._decIconDisabled && !e3 ? this._spinValue(e3) : (this._resetSpin(), this._fireChangeEvent()));
    }, this._calcWaitTimeout());
  }
  _resetSpin() {
    clearTimeout(this._spinTimeoutId), this._btnDown = false, this._spinStarted = false;
  }
  _resetSpinOut() {
    this._btnDown && (this._resetSpin(), this._fireChangeEvent());
  }
};
ZR([tS({ validator: Rk, defaultValue: 0 })], JR.prototype, "value", void 0), ZR([tS({ validator: Rk })], JR.prototype, "min", void 0), ZR([tS({ validator: Rk })], JR.prototype, "max", void 0), ZR([tS({ validator: Rk, defaultValue: 1 })], JR.prototype, "step", void 0), ZR([tS({ type: eB, defaultValue: eB.None })], JR.prototype, "valueState", void 0), ZR([tS({ type: Boolean })], JR.prototype, "required", void 0), ZR([tS({ type: Boolean })], JR.prototype, "disabled", void 0), ZR([tS({ type: Boolean })], JR.prototype, "readonly", void 0), ZR([tS({ defaultValue: void 0 })], JR.prototype, "placeholder", void 0), ZR([tS()], JR.prototype, "name", void 0), ZR([tS({ validator: nI, defaultValue: 0 })], JR.prototype, "valuePrecision", void 0), ZR([tS()], JR.prototype, "accessibleName", void 0), ZR([tS({ defaultValue: "" })], JR.prototype, "accessibleNameRef", void 0), ZR([tS({ type: Boolean, noAttribute: true })], JR.prototype, "_decIconDisabled", void 0), ZR([tS({ type: Boolean, noAttribute: true })], JR.prototype, "_incIconDisabled", void 0), ZR([tS({ type: Boolean })], JR.prototype, "focused", void 0), ZR([tS({ type: Boolean, noAttribute: true })], JR.prototype, "_inputFocused", void 0), ZR([tS({ validator: Rk, noAttribute: true })], JR.prototype, "_previousValue", void 0), ZR([tS({ validator: Rk, noAttribute: true })], JR.prototype, "_waitTimeout", void 0), ZR([tS({ validator: Rk, noAttribute: true })], JR.prototype, "_speed", void 0), ZR([tS({ type: Boolean, noAttribute: true })], JR.prototype, "_btnDown", void 0), ZR([tS({ validator: nI, noAttribute: true })], JR.prototype, "_spinTimeoutId", void 0), ZR([tS({ type: Boolean, noAttribute: true })], JR.prototype, "_spinStarted", void 0), ZR([nS()], JR.prototype, "valueStateMessage", void 0), ZR([nS()], JR.prototype, "formSupport", void 0), JR = KR = ZR([eS({ tag: "ui5-step-input", renderer: KS, styles: { packageName: "@ui5/webcomponents", fileName: "themes/StepInput.css", content: ':host{vertical-align:middle}.ui5-hidden-text{position:absolute;clip:rect(1px,1px,1px,1px);user-select:none;left:-1000px;top:-1000px;pointer-events:none;font-size:0}[input-icon]{color:var(--_ui5_input_icon_color);cursor:pointer;outline:none;padding:var(--_ui5_input_icon_padding);border-inline-start:var(--_ui5_input_icon_border);min-width:1rem;min-height:1rem;border-radius:var(--_ui5_input_icon_border_radius)}[input-icon][pressed]{background:var(--_ui5_input_icon_pressed_bg);box-shadow:var(--_ui5_input_icon_box_shadow);border-inline-start:var(--_ui5_select_hover_icon_left_border);color:var(--_ui5_input_icon_pressed_color)}[input-icon]:active{background-color:var(--sapButton_Active_Background);box-shadow:var(--_ui5_input_icon_box_shadow);border-inline-start:var(--_ui5_select_hover_icon_left_border);color:var(--_ui5_input_icon_pressed_color)}[input-icon]:not([pressed]):not(:active):hover{background:var(--_ui5_input_icon_hover_bg);box-shadow:var(--_ui5_input_icon_box_shadow)}[input-icon]:hover{border-inline-start:var(--_ui5_select_hover_icon_left_border);box-shadow:var(--_ui5_input_icon_box_shadow)}:host(:not([hidden])){display:inline-block;width:100%;line-height:normal;letter-spacing:normal;word-spacing:normal}:host{--ui5_input_focus_pseudo_element_content:none;color:var(--sapField_TextColor);background-color:var(--sapField_Background);border:var(--_ui5_step_input_border_style);border-radius:var(--sapField_BorderCornerRadius);box-sizing:border-box;height:var(--_ui5_input_height);position:relative;min-width:var(--_ui5_step_input_min_width);text-align:right}:host .ui5-step-input-input{text-align:inherit}:host(:not([value-state]):not([readonly]):not([disabled])){box-shadow:none}:host([value-state=Success]:not([readonly]):not([disabled])){background-color:var(--sapField_SuccessBackground)}:host([value-state=Error]:not([readonly]):not([disabled])){background-color:var(--sapField_InvalidBackground)}:host([value-state=Information]:not([readonly]):not([disabled])){background-color:var(--sapField_InformationBackground)}:host([value-state=Warning]:not([readonly]):not([disabled])){background-color:var(--sapField_WarningBackground)}:host(:not([value-state]):not([readonly]):not([disabled]):hover),:host([value-state=None]:not([readonly]):not([disabled]):hover){background-color:var(--_ui5_step_input_border_color_hover);border:var(--_ui5_step_input_border_hover)}:host(:not([value-state]):not([readonly]):not([disabled]):not([focused]):hover),:host([value-state=None]:not([readonly]):not([disabled]):not([focused]):hover){background-color:var(--sapField_Hover_Background);border:var(--_ui5_step_input_border_style_hover);box-shadow:var(--sapField_Hover_Shadow)}:host([value-state=Success]:not([readonly]):not([disabled]):not([focused]):hover){box-shadow:var(--sapField_Hover_SuccessShadow)}:host([value-state=Information]:not([readonly]):not([disabled]):not([focused]):hover){box-shadow:var(--sapField_Hover_InformationShadow)}:host([value-state=Warning]:not([readonly]):not([disabled]):not([focused]):hover){box-shadow:var(--sapField_Hover_WarningShadow)}:host([value-state=Error]:not([readonly]):not([disabled]):not([focused]):hover){box-shadow:var(--sapField_Hover_InvalidShadow)}:host([value-state=Error]:not([readonly]):not([disabled]):hover),:host([value-state=Information]:not([readonly]):not([disabled]):hover),:host([value-state=Success]:not([readonly]):not([disabled]):hover),:host([value-state=Warning]:not([readonly]):not([disabled]):hover){background-color:var(--_ui5-step_input_button_state_hover_background_color)}:host(:not([value-state]):not([readonly]):not([disabled])[focused]),:host([value-state=Error]:not([readonly]):not([disabled])[focused]),:host([value-state=Information]:not([readonly]):not([disabled])[focused]),:host([value-state=None]:not([readonly]):not([disabled])[focused]),:host([value-state=Success]:not([readonly]):not([disabled])[focused]),:host([value-state=Warning]:not([readonly]):not([disabled])[focused]){background-color:var(--sapField_Focus_Background)}:host([value-state=Error]:not([readonly]):not([disabled])):after,:host([value-state=Information]:not([readonly]):not([disabled])):after,:host([value-state=None]:not([readonly]):not([disabled])):after,:host([value-state=Success]:not([readonly]):not([disabled])):after,:host([value-state=Warning]:not([readonly]):not([disabled])):after{position:absolute;content:"";top:-1px;right:-1px;bottom:-1px;left:-1px;outline:none;pointer-events:none;border-radius:var(--sapField_BorderCornerRadius);border-style:var(--_ui5_input_error_warning_border_style);z-index:3;border-width:0}:host([value-state=Information]:not([readonly]):not([disabled])):after{border-color:var(--sapField_InformationColor);border-width:var(--_ui5_input_information_border_width)}:host([value-state=Warning]:not([readonly]):not([disabled])):after{border-color:var(--sapField_WarningColor);border-width:2px}:host([value-state=Success]:not([readonly]):not([disabled])):after{border-color:var(--sapField_SuccessColor);border-width:1px}:host([value-state=Error]:not([readonly]):not([disabled])):after{border-color:var(--sapField_InvalidColor);border-width:var(--_ui5_input_information_border_width)}:host([value-state]):after{border-width:var(--_ui5_input_state_border_width)}:host([value-state=Error]:not([readonly]):not([disabled])) .ui5-step-input-input{background-color:var(--_ui5_input_input_background_color)}:host([value-state=Error]:not([readonly]):not([disabled])) .ui5-step-input-input:hover{background-color:var(--_ui5_step_input_input_error_background_color)}:host([value-state]:not([value-state=None]) .ui5-step-input-input[focused]){outline:none}:host .ui5-step-input-input{width:100%;color:inherit;background-color:inherit;border:var(--_ui5_step_input_input_border);box-sizing:border-box;vertical-align:top;margin-top:var(--_ui5_step_input_input_margin_top);min-width:var(--_ui5_step_input_min_width);padding-inline-start:var(--_ui5_step_input_padding);padding-inline-end:var(--_ui5_step_input_padding);position:relative;outline:none;line-height:inherit;letter-spacing:inherit;word-spacing:inherit}:host .ui5-step-input-input[readonly]{padding:0}:host .ui5-step-input-input:hover,:host .ui5-step-input-input[focused]{box-shadow:none}:host .ui5-step-input-root{white-space:nowrap;line-height:inherit;letter-spacing:inherit;word-spacing:inherit}:host .ui5-step-input-input[text-align=left]{text-align:left}:host .ui5-step-input-input[text-align=center]{text-align:center}:host .ui5-step-input-input[text-align=right]{text-align:right}:host .ui5-step-icon{position:absolute;display:var(--_ui5_step_input_button_display);height:2rem;height:100%;background-color:var(--_ui5_step_input_button_background_color);z-index:2}:host .ui5-step-icon[focused]{border:none;outline:none}:host .ui5-step-icon.ui5-step-dec{left:var(--_ui5_step_input_button_left)}:host .ui5-step-icon.ui5-step-inc{right:var(--_ui5_step_input_button_right)}:host .ui5-step-icon :not([clickable]),:host .ui5-step-icon :not([clickable]):active,:host .ui5-step-icon :not([clickable]):hover{opacity:.5;background-color:transparent;color:var(--sapContent_IconColor)}:host .ui5-step-icon :not([clickable]) :active,:host .ui5-step-icon :not([clickable]) :hover{background-color:var(--sapField_Background);color:var(--sapContent_IconColor)}:host .ui5-step-input-input[focused]:after{position:absolute;content:"";border:var(--_ui5_step_input_input_border_focused_after);top:var(--_ui5_step_input_input_border_top_bottom_focused_after);right:0;bottom:var(--_ui5_step_input_input_border_top_bottom_focused_after);border-radius:var(--_ui5_step_input_input_border_radius_focused_after);left:0;outline:none;pointer-events:none;z-index:3}:host .ui5-step-input-input[focused]{outline:none}:host([value-state=Information]:not([readonly]):not([disabled])) .ui5-step-input-input[focused]:after{border-color:var(--_ui5_step_input_input_information_border_color_focused_after)}:host([value-state=Warning]:not([readonly]):not([disabled])) .ui5-step-input-input[focused]:after{border-color:var(--_ui5_step_input_input_warning_border_color_focused_after)}:host([value-state=Success]:not([readonly]):not([disabled])) .ui5-step-input-input[focused]:after{border-color:var(--_ui5_step_input_input_success_border_color_focused_after)}:host([value-state=Error]:not([readonly]):not([disabled])) .ui5-step-input-input[focused]:after{border-color:var(--_ui5_step_input_input_error_border_color_focused_after)}:host .ui5-step-input-input::-webkit-inner-spin-button,:host .ui5-step-input-input::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}:host([disabled]){opacity:var(--_ui5_input_disabled_opacity);cursor:default;pointer-events:none;background:var(--sapField_ReadOnly_Background);border-color:var(--sapField_ReadOnly_BorderColor)}:host([disabled]) .ui5-step-icon{background-color:var(--_ui5_step_input_disabled_button_background)}:host([disabled]) .ui5-step-icon [ui5-icon]{color:var(--sapField_ReadOnly_BorderColor)}' }, template: function(e3, t2, i2) {
  return i2 ? XS`<div id="${jS(this._id)}" class="ui5-step-input-root" @keydown="${this._onkeydown}" @focusin="${this._onfocusin}" @focusout="${this._onfocusout}">${this.readonly ? void 0 : GR.call(this, e3, t2, i2)}<${ZS("ui5-input", t2, i2)} id="${jS(this._id)}-inner" class="ui5-step-input-input" placeholder="${jS(this.placeholder)}" type="${jS(this.type)}" value="${jS(this._valuePrecisioned)}" ?disabled="${this.disabled}" ?required="${this.required}" ?readonly="${this.readonly}" value-state="${jS(this.valueState)}" data-sap-focus-ref ._inputAccInfo ="${jS(this.accInfo)}" ._nativeInputAttributes="${jS(this.inputAttributes)}" @ui5-change="${jS(this._onInputChange)}" @focusout="${this._onInputFocusOut}" @focusin="${this._onInputFocusIn}">${this.valueStateMessage.length ? $R.call(this, e3, t2, i2) : void 0}</${ZS("ui5-input", t2, i2)}>${this.readonly ? void 0 : WR.call(this, e3, t2, i2)}<slot name="formSupport"></slot></div>` : XS`<div id="${jS(this._id)}" class="ui5-step-input-root" @keydown="${this._onkeydown}" @focusin="${this._onfocusin}" @focusout="${this._onfocusout}">${this.readonly ? void 0 : GR.call(this, e3, t2, i2)}<ui5-input id="${jS(this._id)}-inner" class="ui5-step-input-input" placeholder="${jS(this.placeholder)}" type="${jS(this.type)}" value="${jS(this._valuePrecisioned)}" ?disabled="${this.disabled}" ?required="${this.required}" ?readonly="${this.readonly}" value-state="${jS(this.valueState)}" data-sap-focus-ref ._inputAccInfo ="${jS(this.accInfo)}" ._nativeInputAttributes="${jS(this.inputAttributes)}" @ui5-change="${jS(this._onInputChange)}" @focusout="${this._onInputFocusOut}" @focusin="${this._onInputFocusIn}">${this.valueStateMessage.length ? $R.call(this, e3, t2, i2) : void 0}</ui5-input>${this.readonly ? void 0 : WR.call(this, e3, t2, i2)}<slot name="formSupport"></slot></div>`;
}, dependencies: [WI, AR] }), iS("change")], JR), JR.define();
var eP = Object.defineProperty, tP = Object.getOwnPropertyDescriptor, iP = (e3, t2, i2, n2) => {
  for (var o2, r2 = n2 > 1 ? void 0 : n2 ? tP(t2, i2) : t2, s2 = e3.length - 1; s2 >= 0; s2--)
    (o2 = e3[s2]) && (r2 = (n2 ? o2(t2, i2, r2) : o2(r2)) || r2);
  return n2 && r2 && eP(t2, i2, r2), r2;
};
let nP = class extends ae {
  constructor() {
    super(...arguments), this.isColumnMode = false;
  }
  render() {
    return z`
    <div id="layout" class="${this.isColumnMode ? "ver-orientation" : "hor-orientation"}">
        <div class = "input-row" >
            <ui5-label show-colon>Show Axes</ui5-label>
            <ui5-checkbox
                ?checked="${this.environmentSettings.showAxes}" 
                @change="${this._handleShowAxesStateChanged}"></ui5-checkbox>
        </div>    
        <div id="divider" class="${this.isColumnMode ? "ver-orientation" : "hor-orientation"}"></div>
        <div>    
            <div class = "input-row" >
                <ui5-label show-colon>Background Color</ui5-label>
                <ui5-color-palette-item value=${this.environmentSettings.backgroundColor[0]} @click=${this._handleColorClicked}></ui5-color-palette-item>
            </div> 
            <ui5-color-palette-popover id="colorPalettePopover" show-more-colors="" @item-click=${this._handleColorChanged}>
                <ui5-color-palette-item value="#444444"></ui5-color-palette-item>
                <ui5-color-palette-item value="lightpink"></ui5-color-palette-item>
                <ui5-color-palette-item value="rgb(216,124,172)"></ui5-color-palette-item>
                <ui5-color-palette-item value="#6c666d"></ui5-color-palette-item>
                <ui5-color-palette-item value="rgb(55,81,95)"></ui5-color-palette-item>
                <ui5-color-palette-item value="#0072bb"></ui5-color-palette-item>
                <ui5-color-palette-item value="powderblue"></ui5-color-palette-item>
                <ui5-color-palette-item value="rgb(143,201,58)"></ui5-color-palette-item>
                <ui5-color-palette-item value="rgb(195,172,206)"></ui5-color-palette-item>
                <ui5-color-palette-item value="orange"></ui5-color-palette-item>
            </ui5-color-palette-popover>   
            <div class = "input-row" >
                <ui5-label show-colon>Gradient Effect</ui5-label>
                <ui5-checkbox 
                    ?checked="${this.environmentSettings.applyGradient}" 
                    @change="${this._handleApplyGradientStateChanged}"></ui5-checkbox>
            </div>    
        </div>    
        <div id="divider" class="${this.isColumnMode ? "ver-orientation" : "hor-orientation"}"></div> 
        <div class = "input-row" >
          <ui5-label show-colon>Light [%]</ui5-label>
          <ui5-step-input  value="100" min="0" max="500" step="10" @change="${this._handleBrightnessChanged}"></ui5-step-input>
        </div>
    </div>
        `;
  }
  _handleColorChanged(e3) {
    this.environmentSettings.backgroundColor = e3.detail.color, this.requestUpdate();
  }
  _handleColorClicked(e3) {
    this.colorPalettePopover.showAt(e3.target);
  }
  _handleShowAxesStateChanged(e3) {
    this.environmentSettings.showAxes = e3.target.checked;
  }
  _handleApplyGradientStateChanged(e3) {
    this.environmentSettings.applyGradient = e3.target.checked;
  }
  _handleBrightnessChanged(e3) {
    this.environmentSettings.brightness = e3.detail.value / 100;
  }
};
nP.styles = r`
        :host {
          height: 100%;
          width: 100%;
        }

        #divider.ver-orientation {
          border-top: 0.05rem solid darkgrey;
        }

        #divider.hor-orientation {
          border-left: 0.05rem solid darkgrey;
        }

        #layout.ver-orientation{
          flex-direction: column;
        }

        #layout.hor-orientation{
          flex-direction: row;
        }

        #layout{
          position: relative;
          display: flex;
          align-items: stretch;
          gap: 0.5rem;
        }

        .input-row{
          position: relative;
          display: flex;
          align-items: center;
          gap: 0.5rem;
        }

        .ver-orientation > .input-row{
            width: 11rem; 
        }
      `, iP([ue({ type: Boolean })], nP.prototype, "isColumnMode", 2), iP([ue({ type: Object })], nP.prototype, "environmentSettings", 2), iP([de("#colorPalettePopover")], nP.prototype, "colorPalettePopover", 2), nP = iP([ce("environment-settings")], nP);
var oP = Object.defineProperty, rP = Object.getOwnPropertyDescriptor, sP = (e3, t2, i2, n2) => {
  for (var o2, r2 = n2 > 1 ? void 0 : n2 ? rP(t2, i2) : t2, s2 = e3.length - 1; s2 >= 0; s2--)
    (o2 = e3[s2]) && (r2 = (n2 ? o2(t2, i2, r2) : o2(r2)) || r2);
  return n2 && r2 && oP(t2, i2, r2), r2;
};
let aP = class extends ae {
  constructor() {
    super(...arguments), this.isColumnMode = false, this.isAutoRotationDisabled = false, this._userAutoRotationOn = false;
  }
  render() {
    return z`
    <div id="layout" class="${this.isColumnMode ? "ver-orientation" : "hor-orientation"}">
      <div>    
        <ui5-title level="H5">3D</ui5-title>
        <div class = "input-row" >
          <ui5-label for="xOrientation" show-colon>X [&deg;]</ui5-label>
          <ui5-step-input id="xOrientation" value="0" min="0" max="359" step="10" @change="${this.handleXOrientationChanged}"></ui5-step-input>
        </div>
        <div class = "input-row" >
          <ui5-label for="yOrientation" show-colon>Y [&deg;]</ui5-label>
          <ui5-step-input id="yOrientation" value="0" min="0" max="359" step="10" @change="${this.handleYOrientationChanged}"></ui5-step-input>
        </div>
        <div class = "input-row" >
          <ui5-label for="zOrientation" show-colon>Z [&deg;]</ui5-label>
          <ui5-step-input id="zOrientation" value="0" min="0" max="359" step="10" @change="${this.handleZOrientationChanged}"></ui5-step-input>
        </div>
      </div>
      <div id="divider" class="${this.isColumnMode ? "ver-orientation" : "hor-orientation"}"></div>
      <div>    
        <ui5-title level="H5">2D</ui5-title>
        <div class = "input-row" >
          <ui5-label show-colon>Auto Rotation</ui5-label>
          <ui5-checkbox id= "autoRotationCheckbox" 
             text="${this.imageRotationSettings.isAutoRotationActivated ? "On" : "Off"}"
             ?checked="${this.imageRotationSettings.isAutoRotationActivated}" 
             ?disabled="${this.isAutoRotationDisabled}" 
             @change="${this._handleAutoRotationStateChanged}"></ui5-checkbox>
        </div>
        <div class = "input-row"  >
          <ui5-label for="imageAngle" show-colon>&phi; [&deg;]</ui5-label>
          <ui5-step-input id="imageAngle"
           value="${this.imageRotationSettings.isAutoRotationActivated ? this.imageRotationSettings.autoRotationAngle : this.imageRotationSettings.userSetRotationAngle}"
            min="-180" max="180" step="10" 
            ?disabled="${this.imageRotationSettings.isAutoRotationActivated}"
            @change="${this._handleRotationValueChanged}"></ui5-step-input>
        </div>
      </div>
    </div>
        `;
  }
  firstUpdated() {
    this.imageRotationSettings.on("rotation-angle-changed", () => this.requestUpdate());
  }
  updated(e3) {
    super.updated(e3), e3.has("isAutoRotationDisabled") && (this.isAutoRotationDisabled ? (this._userAutoRotationOn = this.imageRotationSettings.isAutoRotationActivated, this.imageRotationSettings.isAutoRotationActivated = true) : this.imageRotationSettings.isAutoRotationActivated != this._userAutoRotationOn && (this.imageRotationSettings.isAutoRotationActivated = this._userAutoRotationOn));
  }
  _handleRotationValueChanged(e3) {
    this.imageRotationSettings.isAutoRotationActivated || (this.imageRotationSettings.userSetRotationAngle = e3.detail.value);
  }
  _handleAutoRotationStateChanged(e3) {
    const t2 = e3.target.checked;
    this.imageRotationSettings.isAutoRotationActivated != t2 && (this.imageRotationSettings.isAutoRotationActivated = t2);
  }
  _handleDegreeInput(e3) {
    return t2 = e3.detail.value, i2 = 0, n2 = 359, Math.min(Math.max(Number(t2), i2), n2) * Math.PI / 180;
    var t2, i2, n2;
  }
  handleXOrientationChanged(e3) {
    this.modelOrientationSettings.xOrientationInRad = this._handleDegreeInput(e3);
  }
  handleYOrientationChanged(e3) {
    this.modelOrientationSettings.yOrientationInRad = this._handleDegreeInput(e3);
  }
  handleZOrientationChanged(e3) {
    this.modelOrientationSettings.zOrientationInRad = this._handleDegreeInput(e3);
  }
};
aP.styles = r`
        :host {
          height: 100%;
          width: 100%;
        }

        #divider.ver-orientation {
          border-top: 0.05rem solid darkgrey;
        }

        #divider.hor-orientation {
          border-left: 0.05rem solid darkgrey;
        }

        #layout.ver-orientation{
          flex-direction: column;
        }

        #layout.hor-orientation{
          flex-direction: row;
        }

        #layout{
          position: relative;
          display: flex;
          align-items: stretch;
          gap: 1rem;
        }

        .input-row{
          position: relative;
          display: flex;
          align-items: center;
          width: 11rem; 
          gap: 1rem;
        }
      `, sP([ue({ type: Boolean })], aP.prototype, "isColumnMode", 2), sP([ue({ type: Boolean })], aP.prototype, "isAutoRotationDisabled", 2), sP([ue({ type: Object })], aP.prototype, "imageRotationSettings", 2), sP([ue({ type: Object })], aP.prototype, "modelOrientationSettings", 2), aP = sP([ce("rotation-settings")], aP);
const lP = /* @__PURE__ */ new WeakMap();
class cP {
  static get tasks() {
    return lP;
  }
  static enqueue(e3, t2) {
    lP.has(e3) || lP.set(e3, []), lP.get(e3).push(t2);
  }
  static run(e3, t2) {
    return lP.has(e3) || lP.set(e3, []), t2().then(() => {
      const t3 = lP.get(e3);
      if (t3.length > 0)
        return cP.run(e3, t3.shift());
      lP.delete(e3);
    });
  }
  static push(e3, t2) {
    lP.get(e3) ? cP.enqueue(e3, t2) : cP.run(e3, t2);
  }
}
const hP = (e3) => {
  let t2, i2, n2, o2 = null, r2 = false;
  const s2 = new Promise((s3, a2) => {
    n2 = (i3) => {
      o2 = o2 || i3;
      const a3 = i3 - o2, l2 = e3.duration - a3;
      if (a3 <= e3.duration) {
        const i4 = 1 - l2 / e3.duration;
        e3.advance(i4), r2 || (t2 = requestAnimationFrame(n2));
      } else
        e3.advance(1), s3();
    }, i2 = () => {
      r2 = true, cancelAnimationFrame(t2), a2(new Error("animation stopped"));
    };
  }).catch((e4) => e4);
  return cP.push(e3.element, () => ("function" == typeof e3.beforeStart && e3.beforeStart(), requestAnimationFrame(n2), new Promise((e4) => {
    s2.then(() => e4());
  }))), { promise: () => s2, stop: () => i2 };
};
let uP;
const dP = () => (void 0 === uP && (pw(), uP = hw.animationMode), uP), pP = "M357.5 233q10 10 10 23t-10 23l-165 165q-12 11-23 0t0-23l160-159q6-6 0-12l-159-159q-5-5-5-11t5-11 11-5 11 5z";
Kx("slim-arrow-right", { pathData: pP, ltr: false, collection: "SAP-icons-v4", packageName: "@ui5/webcomponents-icons" });
const _P = "M172.5 154q-9-11-9-22 0-13 9-22 11-9 22-9 13 0 22 9l124 124q9 9 9 22 0 11-9 22l-124 124q-9 9-22 9-11 0-22-9-9-11-9-22 0-13 9-22l103-102z";
var gP;
Kx("slim-arrow-right", { pathData: _P, ltr: false, collection: "SAP-icons-v5", packageName: "@ui5/webcomponents-icons" }), dx(), function(e3) {
  e3.Complementary = "Complementary", e3.Form = "Form", e3.Region = "Region";
}(gP || (gP = {}));
const mP = gP;
function fP(e3, t2, i2) {
  return XS`<div class="ui5-panel-heading-wrapper" role="${jS(this.headingWrapperRole)}" aria-level="${jS(this.headingWrapperAriaLevel)}"><div @click="${this._headerClick}" @keydown="${this._headerKeyDown}" @keyup="${this._headerKeyUp}" class="ui5-panel-header" tabindex="${jS(this.headerTabIndex)}" role="${jS(this.accInfo.role)}" aria-expanded="${jS(this.accInfo.ariaExpanded)}" aria-controls="${jS(this.accInfo.ariaControls)}" aria-labelledby="${jS(this.accInfo.ariaLabelledby)}" part="header">${this.fixed ? void 0 : vP.call(this, e3, t2, i2)}${this._hasHeader ? yP.call(this, e3, t2, i2) : wP.call(this, e3, t2, i2)}</div></div>`;
}
function vP(e3, t2, i2) {
  return XS`<div class="ui5-panel-header-button-root">${this._hasHeader ? AP.call(this, e3, t2, i2) : bP.call(this, e3, t2, i2)}</div>`;
}
function AP(e3, t2, i2) {
  return i2 ? XS`<${ZS("ui5-button", t2, i2)} design="Transparent" class="ui5-panel-header-button ui5-panel-header-button-with-icon" @click="${this._toggleButtonClick}" .accessibilityAttributes=${jS(this.accInfo.button.accessibilityAttributes)} tooltip="${jS(this.accInfo.button.title)}" accessible-name="${jS(this.accInfo.button.ariaLabelButton)}"><div class="ui5-panel-header-icon-wrapper"><${ZS("ui5-icon", t2, i2)} class="ui5-panel-header-icon ${WS(this.classes.headerBtn)}" name="slim-arrow-right"></${ZS("ui5-icon", t2, i2)}></div></${ZS("ui5-button", t2, i2)}>` : XS`<ui5-button design="Transparent" class="ui5-panel-header-button ui5-panel-header-button-with-icon" @click="${this._toggleButtonClick}" .accessibilityAttributes=${jS(this.accInfo.button.accessibilityAttributes)} tooltip="${jS(this.accInfo.button.title)}" accessible-name="${jS(this.accInfo.button.ariaLabelButton)}"><div class="ui5-panel-header-icon-wrapper"><ui5-icon class="ui5-panel-header-icon ${WS(this.classes.headerBtn)}" name="slim-arrow-right"></ui5-icon></div></ui5-button>`;
}
function bP(e3, t2, i2) {
  return i2 ? XS`<${ZS("ui5-icon", t2, i2)} class="ui5-panel-header-button ui5-panel-header-icon ${WS(this.classes.headerBtn)}" name="slim-arrow-right" show-tooltip accessible-name="${jS(this.toggleButtonTitle)}"></${ZS("ui5-icon", t2, i2)}>` : XS`<ui5-icon class="ui5-panel-header-button ui5-panel-header-icon ${WS(this.classes.headerBtn)}" name="slim-arrow-right" show-tooltip accessible-name="${jS(this.toggleButtonTitle)}"></ui5-icon>`;
}
function yP(e3, t2, i2) {
  return XS`<slot name="header"></slot>`;
}
function wP(e3, t2, i2) {
  return XS`<div id="${jS(this._id)}-header-title" class="ui5-panel-header-title">${jS(this.headerText)}</div>`;
}
Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
var xP, CP = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
let SP = xP = class extends ZC {
  onBeforeRendering() {
    this._animationRunning || (this._contentExpanded = !this.collapsed), this._hasHeader = !!this.header.length;
  }
  shouldToggle(e3) {
    return !this.header.length || e3.classList.contains("ui5-panel-header-button");
  }
  shouldNotAnimate() {
    return this.noAnimation || dP() === lw.None;
  }
  _headerClick(e3) {
    this.shouldToggle(e3.target) && this._toggleOpen();
  }
  _toggleButtonClick(e3) {
    0 === e3.x && 0 === e3.y && e3.stopImmediatePropagation();
  }
  _headerKeyDown(e3) {
    this.shouldToggle(e3.target) && (rS(e3) && e3.preventDefault(), sS(e3) && e3.preventDefault());
  }
  _headerKeyUp(e3) {
    this.shouldToggle(e3.target) && (rS(e3) && this._toggleOpen(), sS(e3) && this._toggleOpen());
  }
  _toggleOpen() {
    if (this.fixed)
      return;
    if (this.collapsed = !this.collapsed, this.shouldNotAnimate())
      return void this.fireEvent("toggle");
    this._animationRunning = true;
    const e3 = this.getDomRef().querySelectorAll(".ui5-panel-content"), t2 = [];
    [].forEach.call(e3, (e4) => {
      this.collapsed ? t2.push(((e5) => {
        let t3, i2, n2, o2, r2, s2, a2, l2, c2, h2, u2, d2;
        const p2 = hP({ beforeStart: () => {
          const p3 = e5;
          t3 = getComputedStyle(p3), i2 = parseFloat(t3.paddingTop), n2 = parseFloat(t3.paddingBottom), o2 = parseFloat(t3.marginTop), r2 = parseFloat(t3.marginBottom), s2 = parseFloat(t3.height), a2 = p3.style.overflow, l2 = p3.style.paddingTop, c2 = p3.style.paddingBottom, h2 = p3.style.marginTop, u2 = p3.style.marginBottom, d2 = p3.style.height, p3.style.overflow = "hidden";
        }, duration: 400, element: e5, advance: (t4) => {
          e5.style.paddingTop = i2 - i2 * t4 + "px", e5.style.paddingBottom = n2 - n2 * t4 + "px", e5.style.marginTop = o2 - o2 * t4 + "px", e5.style.marginBottom = r2 - r2 * t4 + "px", e5.style.height = s2 - s2 * t4 + "px";
        } });
        return p2.promise().then((t4) => {
          t4 instanceof Error || (e5.style.overflow = a2, e5.style.paddingTop = l2, e5.style.paddingBottom = c2, e5.style.marginTop = h2, e5.style.marginBottom = u2, e5.style.height = d2, e5.style.display = "none");
        }), p2;
      })(e4).promise()) : t2.push(((e5) => {
        let t3, i2, n2, o2, r2, s2, a2, l2, c2, h2, u2, d2;
        const p2 = hP({ beforeStart: () => {
          e5.style.display = "block", t3 = getComputedStyle(e5), i2 = parseFloat(t3.paddingTop), n2 = parseFloat(t3.paddingBottom), o2 = parseFloat(t3.marginTop), r2 = parseFloat(t3.marginBottom), s2 = parseFloat(t3.height), a2 = e5.style.overflow, l2 = e5.style.paddingTop, c2 = e5.style.paddingBottom, h2 = e5.style.marginTop, u2 = e5.style.marginBottom, d2 = e5.style.height, e5.style.overflow = "hidden", e5.style.paddingTop = "0", e5.style.paddingBottom = "0", e5.style.marginTop = "0", e5.style.marginBottom = "0", e5.style.height = "0";
        }, duration: 400, element: e5, advance: (t4) => {
          e5.style.display = "block", e5.style.paddingTop = i2 * t4 + "px", e5.style.paddingBottom = n2 * t4 + "px", e5.style.marginTop = o2 * t4 + "px", e5.style.marginBottom = r2 * t4 + "px", e5.style.height = s2 * t4 + "px";
        } });
        return p2.promise().then(() => {
          e5.style.overflow = a2, e5.style.paddingTop = l2, e5.style.paddingBottom = c2, e5.style.marginTop = h2, e5.style.marginBottom = u2, e5.style.height = d2;
        }), p2;
      })(e4).promise());
    }), Promise.all(t2).then(() => {
      this._animationRunning = false, this._contentExpanded = !this.collapsed, this.fireEvent("toggle");
    });
  }
  _headerOnTarget(e3) {
    return e3.classList.contains("sapMPanelWrappingDiv");
  }
  get classes() {
    return { headerBtn: { "ui5-panel-header-button-animated": !this.shouldNotAnimate() } };
  }
  get toggleButtonTitle() {
    return xP.i18nBundle.getText(zE);
  }
  get expanded() {
    return !this.collapsed;
  }
  get accRole() {
    return this.accessibleRole.toLowerCase();
  }
  get effectiveAccessibleName() {
    return "string" == typeof this.accessibleName && this.accessibleName.length ? this.accessibleName : void 0;
  }
  get accInfo() {
    return { button: { accessibilityAttributes: { expanded: this.expanded }, title: this.toggleButtonTitle, ariaLabelButton: !this.nonFocusableButton && this.useAccessibleNameForToggleButton ? this.effectiveAccessibleName : void 0 }, ariaExpanded: this.nonFixedInternalHeader ? this.expanded : void 0, ariaControls: this.nonFixedInternalHeader ? `${this._id}-content` : void 0, ariaLabelledby: this.nonFocusableButton ? this.ariaLabelledbyReference : void 0, role: this.nonFixedInternalHeader ? "button" : void 0 };
  }
  get ariaLabelledbyReference() {
    return this.nonFocusableButton && this.headerText && !this.fixed ? `${this._id}-header-title` : void 0;
  }
  get fixedPanelAriaLabelledbyReference() {
    return this.fixed && !this.effectiveAccessibleName ? `${this._id}-header-title` : void 0;
  }
  get headerAriaLevel() {
    return this.headerLevel.slice(1);
  }
  get headerTabIndex() {
    return this.header.length || this.fixed ? "-1" : "0";
  }
  get headingWrapperAriaLevel() {
    return this._hasHeader ? void 0 : this.headerAriaLevel;
  }
  get headingWrapperRole() {
    return this._hasHeader ? void 0 : "heading";
  }
  get nonFixedInternalHeader() {
    return !this._hasHeader && !this.fixed;
  }
  get hasHeaderOrHeaderText() {
    return this._hasHeader || this.headerText;
  }
  get nonFocusableButton() {
    return !this.header.length;
  }
  get styles() {
    return { content: { display: this._contentExpanded ? "block" : "none" } };
  }
  static async onDefine() {
    xP.i18nBundle = await Wx("@ui5/webcomponents");
  }
};
CP([tS()], SP.prototype, "headerText", void 0), CP([tS({ type: Boolean })], SP.prototype, "fixed", void 0), CP([tS({ type: Boolean })], SP.prototype, "collapsed", void 0), CP([tS({ type: Boolean })], SP.prototype, "noAnimation", void 0), CP([tS({ type: mP, defaultValue: mP.Form })], SP.prototype, "accessibleRole", void 0), CP([tS({ type: LT, defaultValue: LT.H2 })], SP.prototype, "headerLevel", void 0), CP([tS()], SP.prototype, "accessibleName", void 0), CP([tS({ type: Boolean })], SP.prototype, "useAccessibleNameForToggleButton", void 0), CP([tS({ type: Boolean })], SP.prototype, "_hasHeader", void 0), CP([tS({ type: Boolean, noAttribute: true })], SP.prototype, "_contentExpanded", void 0), CP([tS({ type: Boolean, noAttribute: true })], SP.prototype, "_animationRunning", void 0), CP([nS()], SP.prototype, "header", void 0), SP = xP = CP([eS({ tag: "ui5-panel", fastNavigation: true, languageAware: true, renderer: KS, template: function(e3, t2, i2) {
  return XS`<div class="ui5-panel-root" role="${jS(this.accRole)}" aria-label="${jS(this.effectiveAccessibleName)}" aria-labelledby="${jS(this.fixedPanelAriaLabelledbyReference)}">${this.hasHeaderOrHeaderText ? fP.call(this, e3, t2, i2) : void 0}<div class="ui5-panel-content" id="${jS(this._id)}-content" tabindex="-1" style="${qS(this.styles.content)}" part="content"><slot></slot></div></div>`;
}, styles: { packageName: "@ui5/webcomponents", fileName: "themes/Panel.css", content: '.ui5-hidden-text{position:absolute;clip:rect(1px,1px,1px,1px);user-select:none;left:-1000px;top:-1000px;pointer-events:none;font-size:0}:host(:not([hidden])){display:block}:host{font-family:"72override",var(--sapFontFamily);background-color:var(--sapGroup_TitleBackground);border-radius:var(--_ui5_panel_border_radius)}:host(:not([collapsed])){border-bottom:var(--_ui5_panel_border_bottom)}:host([fixed]) .ui5-panel-header{padding-left:1rem}.ui5-panel-header{min-height:var(--_ui5_panel_header_height);width:100%;position:relative;display:flex;justify-content:flex-start;align-items:center;outline:none;box-sizing:border-box;padding-right:var(--_ui5_panel_header_padding_right)}.ui5-panel-header-icon{color:var(--_ui5_panel_icon_color)}.ui5-panel-header-button-animated{transition:transform .4s ease-out}:host(:not([_has-header]):not([fixed])) .ui5-panel-header{cursor:pointer}:host(:not([_has-header]):not([fixed])) .ui5-panel-header:focus:after{content:"";position:absolute;pointer-events:none;z-index:2;border:var(--_ui5_panel_focus_border);border-radius:var(--_ui5_panel_border_radius);top:var(--_ui5_panel_focus_offset);bottom:var(--_ui5_panel_focus_offset);left:var(--_ui5_panel_focus_offset);right:var(--_ui5_panel_focus_offset)}:host(:not([collapsed]):not([_has-header]):not([fixed])) .ui5-panel-header:focus:after{border-radius:var(--_ui5_panel_border_radius_expanded)}:host(:not([collapsed])) .ui5-panel-header-button:not(.ui5-panel-header-button-with-icon),:host(:not([collapsed])) .ui5-panel-header-icon-wrapper [ui5-icon]{transform:var(--_ui5_panel_toggle_btn_rotation)}:host([fixed]) .ui5-panel-header-title{width:100%}.ui5-panel-header-title{width:calc(100% - var(--_ui5_panel_button_root_width));overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-family:"72override",var(--sapFontHeaderFamily);font-size:var(--sapGroup_Title_FontSize);color:var(--sapGroup_TitleTextColor);font-weight:400}.ui5-panel-content{padding:var(--_ui5_panel_content_padding);background-color:var(--sapGroup_ContentBackground);outline:none;border-bottom-left-radius:var(--_ui5_panel_border_radius);border-bottom-right-radius:var(--_ui5_panel_border_radius)}.ui5-panel-header-button-root{display:flex;justify-content:center;align-items:center;flex-shrink:0;width:var(--_ui5_panel_button_root_width);height:var(--_ui5_panel_button_root_width);padding:var(--_ui5_panel_header_button_wrapper_padding);box-sizing:border-box}:host([collapsed]) .ui5-panel-header,:host([fixed]:not([collapsed]):not([_has-header])) .ui5-panel-header{border-bottom:.0625rem solid var(--sapGroup_TitleBorderColor)}:host([collapsed]) .ui5-panel-header{border-bottom-left-radius:var(--_ui5_panel_border_radius);border-bottom-right-radius:var(--_ui5_panel_border_radius)}:host(:not([fixed]):not([collapsed])) .ui5-panel-header{border-bottom:var(--_ui5_panel_default_header_border)}[ui5-button].ui5-panel-header-button{display:flex;justify-content:center;align-items:center;min-width:0;height:100%;width:100%}.ui5-panel-header-icon-wrapper{display:flex;justify-content:center;align-items:center}.ui5-panel-header-icon-wrapper,.ui5-panel-header-icon-wrapper .ui5-panel-header-icon{color:inherit}.ui5-panel-header-icon-wrapper,[ui5-button].ui5-panel-header-button-with-icon [ui5-icon]{pointer-events:none}' }, dependencies: [ZI, WI] }), iS("toggle")], SP), SP.define();
const EP = (e3) => {
  let t2 = e3;
  return e3.shadowRoot && e3.shadowRoot.activeElement && (t2 = e3.shadowRoot.activeElement), t2;
};
let IP = null;
var TP;
!function(e3) {
  e3.None = "None", e3.SingleSelect = "SingleSelect", e3.SingleSelectBegin = "SingleSelectBegin", e3.SingleSelectEnd = "SingleSelectEnd", e3.SingleSelectAuto = "SingleSelectAuto", e3.MultiSelect = "MultiSelect", e3.Delete = "Delete";
}(TP || (TP = {}));
const BP = TP;
var MP;
!function(e3) {
  e3.Button = "Button", e3.Scroll = "Scroll", e3.None = "None";
}(MP || (MP = {}));
const kP = MP;
var RP;
!function(e3) {
  e3.All = "All", e3.Inner = "Inner", e3.None = "None";
}(RP || (RP = {}));
const PP = RP;
var DP;
!function(e3) {
  e3.Small = "Small", e3.Medium = "Medium", e3.Large = "Large";
}(DP || (DP = {}));
const LP = DP;
function FP(e3, t2, i2) {
  return XS`<div class="ui5-busy-indicator-busy-area" title="${jS(this.ariaTitle)}" tabindex="0" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuetext="Busy" aria-labelledby="${jS(this.labelId)}" data-sap-focus-ref><div class="ui5-busy-indicator-circles-wrapper"><div class="ui5-busy-indicator-circle circle-animation-0"></div><div class="ui5-busy-indicator-circle circle-animation-1"></div><div class="ui5-busy-indicator-circle circle-animation-2"></div></div>${this.text ? NP.call(this, e3, t2, i2) : void 0}</div>`;
}
function NP(e3, t2, i2) {
  return i2 ? XS`<${ZS("ui5-label", t2, i2)} id="${jS(this._id)}-label" class="ui5-busy-indicator-text">${jS(this.text)}</${ZS("ui5-label", t2, i2)}>` : XS`<ui5-label id="${jS(this._id)}-label" class="ui5-busy-indicator-text">${jS(this.text)}</ui5-label>`;
}
function OP(e3, t2, i2) {
  return XS`<span data-ui5-focus-redirect tabindex="0" @focusin="${this._redirectFocus}"></span>`;
}
Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
var zP, UP = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
let HP = zP = class extends ZC {
  constructor() {
    super(), this._keydownHandler = this._handleKeydown.bind(this), this._preventEventHandler = this._preventEvent.bind(this);
  }
  onEnterDOM() {
    this.addEventListener("keydown", this._keydownHandler, { capture: true }), this.addEventListener("keyup", this._preventEventHandler, { capture: true });
  }
  onExitDOM() {
    this._busyTimeoutId && (clearTimeout(this._busyTimeoutId), delete this._busyTimeoutId), this.removeEventListener("keydown", this._keydownHandler, true), this.removeEventListener("keyup", this._preventEventHandler, true);
  }
  static async onDefine() {
    zP.i18nBundle = await Wx("@ui5/webcomponents");
  }
  get ariaTitle() {
    return zP.i18nBundle.getText(lE);
  }
  get labelId() {
    return this.text ? `${this._id}-label` : void 0;
  }
  get classes() {
    return { root: { "ui5-busy-indicator-root": true } };
  }
  onBeforeRendering() {
    this.active ? this._isBusy || this._busyTimeoutId || (this._busyTimeoutId = setTimeout(() => {
      delete this._busyTimeoutId, this._isBusy = true;
    }, Math.max(0, this.delay))) : (this._busyTimeoutId && (clearTimeout(this._busyTimeoutId), delete this._busyTimeoutId), this._isBusy = false);
  }
  _handleKeydown(e3) {
    this._isBusy && (e3.stopImmediatePropagation(), wS(e3) && (this.focusForward = true, this.shadowRoot.querySelector("[data-ui5-focus-redirect]").focus(), this.focusForward = false));
  }
  _preventEvent(e3) {
    this._isBusy && e3.stopImmediatePropagation();
  }
  _redirectFocus(e3) {
    this.focusForward || (e3.preventDefault(), this.shadowRoot.querySelector(".ui5-busy-indicator-busy-area").focus());
  }
};
UP([tS()], HP.prototype, "text", void 0), UP([tS({ type: LP, defaultValue: LP.Medium })], HP.prototype, "size", void 0), UP([tS({ type: Boolean })], HP.prototype, "active", void 0), UP([tS({ validator: nI, defaultValue: 1e3 })], HP.prototype, "delay", void 0), UP([tS({ type: Boolean })], HP.prototype, "_isBusy", void 0), HP = zP = UP([eS({ tag: "ui5-busy-indicator", languageAware: true, styles: { packageName: "@ui5/webcomponents", fileName: "themes/BusyIndicator.css", content: ':host(:not([hidden])){display:inline-block}:host([_is-busy]){color:var(--_ui5_busy_indicator_color)}:host([size=Small]) .ui5-busy-indicator-root{min-width:1.5rem;min-height:.5rem}:host([size=Small][text]:not([text=""])) .ui5-busy-indicator-root{min-height:1.75rem}:host([size=Small]) .ui5-busy-indicator-circle{width:.5rem;height:.5rem}:host(:not([size])) .ui5-busy-indicator-root,:host([size=Medium]) .ui5-busy-indicator-root{min-width:3rem;min-height:1rem}:host(:not([size])[text]:not([text=""])) .ui5-busy-indicator-root,:host([size=Medium][text]:not([text=""])) .ui5-busy-indicator-root{min-height:2.25rem}:host(:not([size])) .ui5-busy-indicator-circle,:host([size=Medium]) .ui5-busy-indicator-circle{width:1rem;height:1rem}:host([size=Large]) .ui5-busy-indicator-root{min-width:6rem;min-height:2rem}:host([size=Large][text]:not([text=""])) .ui5-busy-indicator-root{min-height:3.25rem}:host([size=Large]) .ui5-busy-indicator-circle{width:2rem;height:2rem}.ui5-busy-indicator-root{display:flex;justify-content:center;align-items:center;position:relative;background-color:inherit;height:inherit}.ui5-busy-indicator-busy-area{position:absolute;z-index:99;left:0;right:0;top:0;bottom:0;display:flex;justify-content:center;align-items:center;background-color:inherit;flex-direction:column}.ui5-busy-indicator-busy-area:focus-visible{outline:var(--_ui5_busy_indicator_focus_outline);outline-offset:-2px;border-radius:var(--_ui5_busy_indicator_focus_border_radius)}.ui5-busy-indicator-circles-wrapper{line-height:0}.ui5-busy-indicator-circle{display:inline-block;background-color:currentColor;border-radius:50%}.ui5-busy-indicator-circle:before{content:"";width:100%;height:100%;border-radius:100%}.circle-animation-0{animation:grow 1.6s cubic-bezier(.32,.06,.85,1.11) infinite}.circle-animation-1{animation:grow 1.6s cubic-bezier(.32,.06,.85,1.11) infinite;animation-delay:.2s}.circle-animation-2{animation:grow 1.6s cubic-bezier(.32,.06,.85,1.11) infinite;animation-delay:.4s}.ui5-busy-indicator-text{width:100%;margin-top:.25rem;text-align:center}@keyframes grow{0%,50%,to{-webkit-transform:scale(.5);-moz-transform:scale(.5);transform:scale(.5)}25%{-webkit-transform:scale(1);-moz-transform:scale(1);transform:scale(1)}}' }, renderer: KS, template: function(e3, t2, i2) {
  return XS`<div class="${WS(this.classes.root)}">${this._isBusy ? FP.call(this, e3, t2, i2) : void 0}<slot></slot>${this._isBusy ? OP.call(this, e3, t2, i2) : void 0}</div>`;
}, dependencies: [_M] })], HP), HP.define();
const QP = HP;
function VP(e3, t2, i2) {
  return XS`<slot name="header" />`;
}
function GP(e3, t2, i2) {
  return XS`<header id="${jS(this.headerID)}" class="ui5-list-header">${jS(this.headerText)}</header>`;
}
function $P(e3, t2, i2) {
  return XS`<div id="${jS(this._id)}-before" tabindex="0" role="none" class="ui5-list-focusarea"></div>`;
}
function WP(e3, t2, i2) {
  return XS`<li id="${jS(this._id)}-nodata" class="ui5-list-nodata"><div id="${jS(this._id)}-nodata-text" class="ui5-list-nodata-text">${jS(this.noDataText)}</div></li>`;
}
function qP(e3, t2, i2) {
  return XS`<div growing-button><div tabindex="0" role="button" id="${jS(this._id)}-growing-btn" aria-labelledby="${jS(this._id)}-growingButton-text" ?active="${this._loadMoreActive}" @click="${this._onLoadMoreClick}" @keydown="${this._onLoadMoreKeydown}" @keyup="${this._onLoadMoreKeyup}" @mousedown="${this._onLoadMoreMousedown}" @mouseup="${this._onLoadMoreMouseup}" growing-button-inner><span id="${jS(this._id)}-growingButton-text" growing-button-text>${jS(this._growingButtonText)}</span></div></div>`;
}
function jP(e3, t2, i2) {
  return XS`<footer id="${jS(this._id)}-footer" class="ui5-list-footer">${jS(this.footerText)}</footer>`;
}
function XP(e3, t2, i2) {
  return XS`<div id="${jS(this._id)}-after" tabindex="0" role="none" class="ui5-list-focusarea"></div>`;
}
function YP(e3, t2, i2) {
  return i2 ? XS`<div class="ui5-list-busy-row"><${ZS("ui5-busy-indicator", t2, i2)} delay="${jS(this.busyDelay)}" active size="Medium" class="ui5-list-busy-ind" style="${qS(this.styles.busyInd)}" data-sap-focus-ref></${ZS("ui5-busy-indicator", t2, i2)}></div>` : XS`<div class="ui5-list-busy-row"><ui5-busy-indicator delay="${jS(this.busyDelay)}" active size="Medium" class="ui5-list-busy-ind" style="${qS(this.styles.busyInd)}" data-sap-focus-ref></ui5-busy-indicator></div>`;
}
Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
var KP, ZP = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
let JP = KP = class extends ZC {
  static async onDefine() {
    KP.i18nBundle = await Wx("@ui5/webcomponents");
  }
  constructor() {
    super(), this._previouslyFocusedItem = null, this._forwardingFocus = false, this.resizeListenerAttached = false, this.listEndObserved = false, this._itemNavigation = new NS(this, { skipItemsSize: 10, navigationMode: DS.Vertical, getItemsCallback: () => this.getEnabledItems() }), this._handleResize = this.checkListInViewport.bind(this), this._handleResize = this.checkListInViewport.bind(this), this.initialIntersection = true;
  }
  onExitDOM() {
    this.unobserveListEnd(), this.resizeListenerAttached = false, iE.deregister(this.getDomRef(), this._handleResize);
  }
  onBeforeRendering() {
    this.prepareListItems();
  }
  onAfterRendering() {
    this.growsOnScroll ? this.observeListEnd() : this.listEndObserved && this.unobserveListEnd(), this.grows && (this.checkListInViewport(), this.attachForResize());
  }
  attachForResize() {
    this.resizeListenerAttached || (this.resizeListenerAttached = true, iE.register(this.getDomRef(), this._handleResize));
  }
  get shouldRenderH1() {
    return !this.header.length && this.headerText;
  }
  get headerID() {
    return `${this._id}-header`;
  }
  get modeLabelID() {
    return `${this._id}-modeLabel`;
  }
  get listEndDOM() {
    return this.shadowRoot.querySelector(".ui5-list-end-marker");
  }
  get hasData() {
    return 0 !== this.getItems().length;
  }
  get showNoDataText() {
    return !this.hasData && this.noDataText;
  }
  get isDelete() {
    return this.mode === BP.Delete;
  }
  get isSingleSelect() {
    return [BP.SingleSelect, BP.SingleSelectBegin, BP.SingleSelectEnd, BP.SingleSelectAuto].includes(this.mode);
  }
  get isMultiSelect() {
    return this.mode === BP.MultiSelect;
  }
  get ariaLabelledBy() {
    if (this.accessibleNameRef || this.accessibleName)
      return;
    const e3 = [];
    return (this.isMultiSelect || this.isSingleSelect || this.isDelete) && e3.push(this.modeLabelID), this.shouldRenderH1 && e3.push(this.headerID), e3.length ? e3.join(" ") : void 0;
  }
  get ariaLabelTxt() {
    return bI(this);
  }
  get ariaLabelModeText() {
    return this.isMultiSelect ? KP.i18nBundle.getText(NE) : this.isSingleSelect ? KP.i18nBundle.getText(FE) : this.isDelete ? KP.i18nBundle.getText(OE) : "";
  }
  get grows() {
    return this.growing !== kP.None;
  }
  get growsOnScroll() {
    return this.growing === kP.Scroll;
  }
  get growsWithButton() {
    return this.growing === kP.Button;
  }
  get _growingButtonText() {
    return KP.i18nBundle.getText($E);
  }
  get busyIndPosition() {
    return this.grows ? this._inViewport ? "absolute" : "sticky" : "absolute";
  }
  get styles() {
    return { busyInd: { position: this.busyIndPosition } };
  }
  get classes() {
    return { root: { "ui5-list-root": true, "ui5-content-native-scrollbars": lB() } };
  }
  prepareListItems() {
    const e3 = this.getItemsForProcessing();
    e3.forEach((t2, i2) => {
      const n2 = i2 === e3.length - 1, o2 = this.separators === PP.All || this.separators === PP.Inner && !n2;
      t2.hasConfigurableMode && (t2._mode = this.mode), t2.hasBorder = o2;
    });
  }
  async observeListEnd() {
    this.listEndObserved || (await Nw(), this.getIntersectionObserver().observe(this.listEndDOM), this.listEndObserved = true);
  }
  unobserveListEnd() {
    this.growingIntersectionObserver && (this.growingIntersectionObserver.disconnect(), this.growingIntersectionObserver = null, this.listEndObserved = false);
  }
  onInteresection(e3) {
    this.initialIntersection ? this.initialIntersection = false : e3.forEach((e4) => {
      var t2, i2;
      e4.isIntersecting && (t2 = this.loadMore.bind(this), i2 = 250, IP && clearTimeout(IP), IP = setTimeout(() => {
        IP = null, t2();
      }, i2));
    });
  }
  onSelectionRequested(e3) {
    const t2 = this.getSelectedItems();
    let i2 = false;
    this._selectionRequested = true, this.mode !== BP.None && this[`handle${this.mode}`] && (i2 = this[`handle${this.mode}`](e3.detail.item, !!e3.detail.selected)), i2 && this.fireEvent("selection-change", { selectedItems: this.getSelectedItems(), previouslySelectedItems: t2, selectionComponentPressed: e3.detail.selectionComponentPressed, targetItem: e3.detail.item, key: e3.detail.key });
  }
  handleSingleSelect(e3) {
    return !e3.selected && (this.deselectSelectedItems(), e3.selected = true, true);
  }
  handleSingleSelectBegin(e3) {
    return this.handleSingleSelect(e3);
  }
  handleSingleSelectEnd(e3) {
    return this.handleSingleSelect(e3);
  }
  handleSingleSelectAuto(e3) {
    return this.handleSingleSelect(e3);
  }
  handleMultiSelect(e3, t2) {
    return e3.selected = t2, true;
  }
  handleDelete(e3) {
    return this.fireEvent("item-delete", { item: e3 }), true;
  }
  deselectSelectedItems() {
    this.getSelectedItems().forEach((e3) => {
      e3.selected = false;
    });
  }
  getSelectedItems() {
    return this.getItems().filter((e3) => e3.selected);
  }
  getEnabledItems() {
    return this.getItems().filter((e3) => !e3.disabled);
  }
  getItems() {
    return this.getSlottedNodes("items");
  }
  getItemsForProcessing() {
    return this.getItems();
  }
  _onkeydown(e3) {
    wS(e3) && this._handleTabNext(e3);
  }
  _onLoadMoreKeydown(e3) {
    sS(e3) && (e3.preventDefault(), this._loadMoreActive = true), rS(e3) && (this._onLoadMoreClick(), this._loadMoreActive = true), wS(e3) && this.focusAfterElement(), xS(e3) && (this.getPreviouslyFocusedItem() ? this.focusPreviouslyFocusedItem() : this.focusFirstItem(), e3.preventDefault());
  }
  _onLoadMoreKeyup(e3) {
    sS(e3) && this._onLoadMoreClick(), this._loadMoreActive = false;
  }
  _onLoadMoreMousedown() {
    this._loadMoreActive = true;
  }
  _onLoadMoreMouseup() {
    this._loadMoreActive = false;
  }
  _onLoadMoreClick() {
    this.loadMore();
  }
  checkListInViewport() {
    this._inViewport = ((e3) => {
      const t2 = e3.getBoundingClientRect();
      return t2.top >= 0 && t2.left >= 0 && t2.bottom <= (window.innerHeight || document.documentElement.clientHeight) && t2.right <= (window.innerWidth || document.documentElement.clientWidth);
    })(this.getDomRef());
  }
  loadMore() {
    this.fireEvent("load-more");
  }
  _handleTabNext(e3) {
    EP(e3.target);
  }
  _onfocusin(e3) {
    const t2 = EP(e3.target);
    if (this.isForwardElement(t2)) {
      if (!this.getPreviouslyFocusedItem())
        return this.growsWithButton && this.isForwardAfterElement(t2) ? this.focusGrowingButton() : this.focusFirstItem(), void e3.stopImmediatePropagation();
      if (!this.getForwardingFocus()) {
        if (this.growsWithButton && this.isForwardAfterElement(t2))
          return this.focusGrowingButton(), void e3.stopImmediatePropagation();
        this.focusPreviouslyFocusedItem(), e3.stopImmediatePropagation();
      }
      this.setForwardingFocus(false);
    } else
      e3.stopImmediatePropagation();
  }
  isForwardElement(e3) {
    const t2 = e3.id, i2 = this.getBeforeElement();
    return !!(this._id === t2 || i2 && i2.id === t2) || this.isForwardAfterElement(e3);
  }
  isForwardAfterElement(e3) {
    const t2 = e3.id, i2 = this.getAfterElement();
    return i2 && i2.id === t2;
  }
  onItemFocused(e3) {
    const t2 = e3.target;
    if (e3.stopPropagation(), this._itemNavigation.setCurrentItem(t2), this.fireEvent("item-focused", { item: t2 }), this.mode === BP.SingleSelectAuto) {
      const i2 = { item: t2, selectionComponentPressed: false, selected: true, key: e3.detail.key };
      this.onSelectionRequested({ detail: i2 });
    }
  }
  onItemPress(e3) {
    const t2 = e3.detail.item;
    if (this.fireEvent("item-click", { item: t2 }, true)) {
      if (!this._selectionRequested && this.mode !== BP.Delete) {
        this._selectionRequested = true;
        const i2 = { item: t2, selectionComponentPressed: false, selected: !t2.selected, key: e3.detail.key };
        this.onSelectionRequested({ detail: i2 });
      }
      this._selectionRequested = false;
    }
  }
  onItemClose(e3) {
    this.fireEvent("item-close", { item: e3.detail.item });
  }
  onItemToggle(e3) {
    this.fireEvent("item-toggle", { item: e3.detail.item });
  }
  onForwardBefore(e3) {
    this.setPreviouslyFocusedItem(e3.target), this.focusBeforeElement(), e3.stopPropagation();
  }
  onForwardAfter(e3) {
    this.setPreviouslyFocusedItem(e3.target), this.growsWithButton ? (this.focusGrowingButton(), e3.preventDefault()) : this.focusAfterElement(), e3.stopPropagation();
  }
  focusBeforeElement() {
    this.setForwardingFocus(true), this.getBeforeElement().focus();
  }
  focusAfterElement() {
    this.setForwardingFocus(true), this.getAfterElement().focus();
  }
  focusGrowingButton() {
    const e3 = this.getGrowingButton();
    e3 && e3.focus();
  }
  getGrowingButton() {
    return this.shadowRoot.querySelector(`#${this._id}-growing-btn`);
  }
  focusFirstItem() {
    const e3 = this.getFirstItem((e4) => !e4.disabled);
    e3 && e3.focus();
  }
  focusPreviouslyFocusedItem() {
    const e3 = this.getPreviouslyFocusedItem();
    e3 && e3.focus();
  }
  focusFirstSelectedItem() {
    const e3 = this.getFirstItem((e4) => e4.selected && !e4.disabled);
    e3 && e3.focus();
  }
  focusItem(e3) {
    this._itemNavigation.setCurrentItem(e3), e3.focus();
  }
  onFocusRequested(e3) {
    setTimeout(() => {
      this.setPreviouslyFocusedItem(e3.target), this.focusPreviouslyFocusedItem();
    }, 0);
  }
  setForwardingFocus(e3) {
    this._forwardingFocus = e3;
  }
  getForwardingFocus() {
    return this._forwardingFocus;
  }
  setPreviouslyFocusedItem(e3) {
    this._previouslyFocusedItem = e3;
  }
  getPreviouslyFocusedItem() {
    return this._previouslyFocusedItem;
  }
  getFirstItem(e3) {
    const t2 = this.getItems();
    let i2 = null;
    if (!e3)
      return t2.length ? t2[0] : null;
    for (let n2 = 0; n2 < t2.length; n2++)
      if (e3(t2[n2])) {
        i2 = t2[n2];
        break;
      }
    return i2;
  }
  getAfterElement() {
    return this._afterElement || (this._afterElement = this.shadowRoot.querySelector(`#${this._id}-after`)), this._afterElement;
  }
  getBeforeElement() {
    return this._beforeElement || (this._beforeElement = this.shadowRoot.querySelector(`#${this._id}-before`)), this._beforeElement;
  }
  getIntersectionObserver() {
    return this.growingIntersectionObserver || (this.growingIntersectionObserver = new IntersectionObserver(this.onInteresection.bind(this), { root: null, rootMargin: "0px", threshold: 1 })), this.growingIntersectionObserver;
  }
};
ZP([tS()], JP.prototype, "headerText", void 0), ZP([tS()], JP.prototype, "footerText", void 0), ZP([tS({ type: Boolean })], JP.prototype, "indent", void 0), ZP([tS({ type: BP, defaultValue: BP.None })], JP.prototype, "mode", void 0), ZP([tS()], JP.prototype, "noDataText", void 0), ZP([tS({ type: PP, defaultValue: PP.All })], JP.prototype, "separators", void 0), ZP([tS({ type: kP, defaultValue: kP.None })], JP.prototype, "growing", void 0), ZP([tS({ type: Boolean })], JP.prototype, "busy", void 0), ZP([tS({ validator: nI, defaultValue: 1e3 })], JP.prototype, "busyDelay", void 0), ZP([tS()], JP.prototype, "accessibleName", void 0), ZP([tS({ defaultValue: "" })], JP.prototype, "accessibleNameRef", void 0), ZP([tS({ defaultValue: "list" })], JP.prototype, "accessibleRole", void 0), ZP([tS({ defaultValue: void 0, noAttribute: true })], JP.prototype, "accessibleRoleDescription", void 0), ZP([tS({ type: Boolean })], JP.prototype, "_inViewport", void 0), ZP([tS({ type: Boolean })], JP.prototype, "_loadMoreActive", void 0), ZP([nS({ type: HTMLElement, default: true })], JP.prototype, "items", void 0), ZP([nS()], JP.prototype, "header", void 0), JP = KP = ZP([eS({ tag: "ui5-list", fastNavigation: true, renderer: KS, template: function(e3, t2, i2) {
  return XS`<div class="${WS(this.classes.root)}" @focusin="${this._onfocusin}" @keydown="${this._onkeydown}" @ui5-_press=${jS(this.onItemPress)} @ui5-close=${jS(this.onItemClose)} @ui5-toggle=${jS(this.onItemToggle)} @ui5-_focused=${jS(this.onItemFocused)} @ui5-_forward-after=${jS(this.onForwardAfter)} @ui5-_forward-before=${jS(this.onForwardBefore)} @ui5-_selection-requested=${jS(this.onSelectionRequested)} @ui5-_focus-requested=${jS(this.onFocusRequested)}><div class="ui5-list-scroll-container">${this.header.length ? VP.call(this, e3, t2, i2) : void 0}${this.shouldRenderH1 ? GP.call(this, e3, t2, i2) : void 0}${this.hasData ? $P.call(this, e3, t2, i2) : void 0}<span id="${jS(this._id)}-modeLabel" class="ui5-hidden-text">${jS(this.ariaLabelModeText)}</span><ul id="${jS(this._id)}-listUl" class="ui5-list-ul" role="${jS(this.accessibleRole)}" aria-label="${jS(this.ariaLabelTxt)}" aria-labelledby="${jS(this.ariaLabelledBy)}" aria-roledescription="${jS(this.accessibleRoleDescription)}"><slot></slot>${this.showNoDataText ? WP.call(this, e3, t2, i2) : void 0}</ul>${this.growsWithButton ? qP.call(this, e3, t2, i2) : void 0}${this.footerText ? jP.call(this, e3, t2, i2) : void 0}${this.hasData ? XP.call(this, e3, t2, i2) : void 0}<span tabindex="-1" aria-hidden="true" class="ui5-list-end-marker"></span></div>${this.busy ? YP.call(this, e3, t2, i2) : void 0}</div> `;
}, styles: [YB, { packageName: "@ui5/webcomponents", fileName: "themes/List.css", content: '.ui5-hidden-text{position:absolute;clip:rect(1px,1px,1px,1px);user-select:none;left:-1000px;top:-1000px;pointer-events:none;font-size:0}[growing-button]{display:flex;align-items:center;padding:var(--_ui5_load_more_padding);border-top:1px solid var(--sapList_BorderColor);border-bottom:var(--_ui5_load_more_border-bottom);box-sizing:border-box;cursor:pointer;outline:none}[growing-button-inner]{display:flex;align-items:center;justify-content:center;flex-direction:column;min-height:var(--_ui5_load_more_text_height);width:100%;color:var(--sapButton_TextColor);background-color:var(--sapList_Background);border:var(--_ui5_load_more_border);border-radius:var(--_ui5_load_more_border_radius);box-sizing:border-box}[growing-button-inner]:focus{outline:var(--_ui5_load_more_outline_width) var(--sapContent_FocusStyle) var(--sapContent_FocusColor);outline-offset:-.125rem;border-color:transparent}[growing-button-inner]:hover{background-color:var(--sapList_Hover_Background)}[growing-button-inner]:active,[growing-button-inner][active]{background-color:var(--sapList_Active_Background);border-color:var(--sapList_Active_Background)}[growing-button-inner]:active>*,[growing-button-inner][active]>*{color:var(--sapList_Active_TextColor)}[growing-button-subtext],[growing-button-text]{width:100%;text-align:center;font-family:"72override",var(--sapFontFamily);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;box-sizing:border-box}[growing-button-text]{height:var(--_ui5_load_more_text_height);padding:.875rem 1rem 0 1rem;font-size:var(--_ui5_load_more_text_font_size);font-weight:700}[growing-button-subtext]{font-size:var(--sapFontSize);padding:var(--_ui5_load_more_desc_padding)}:host(:not([hidden])){display:block;max-width:100%;width:100%;-webkit-tap-highlight-color:transparent}:host([indent]) .ui5-list-root{padding:2rem}:host([separators=None]) .ui5-list-nodata{border-bottom:0}:host([busy]){opacity:.72}:host([busy]) .ui5-list-busy-row{position:absolute;left:0;right:0;bottom:0;top:0;outline:none}:host([busy]) .ui5-list-busy-ind{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);z-index:1}.ui5-list-root{width:100%;height:100%;position:relative;box-sizing:border-box}.ui5-list-scroll-container{overflow:auto;height:100%}.ui5-list-ul{list-style-type:none;padding:0;margin:0}.ui5-list-ul:focus{outline:none}.ui5-list-focusarea{position:fixed}.ui5-list-header{overflow:hidden;white-space:nowrap;text-overflow:ellipsis;box-sizing:border-box;font-size:var(--sapFontHeader4Size);font-family:"72override",var(--sapFontFamily);color:var(--sapGroup_TitleTextColor);height:3rem;line-height:3rem;padding:0 1rem;background-color:var(--sapGroup_TitleBackground);border-bottom:1px solid var(--sapGroup_TitleBorderColor)}.ui5-list-footer{height:2rem;box-sizing:border-box;-webkit-text-size-adjust:none;font-size:var(--sapFontSize);font-family:"72override",var(--sapFontFamily);line-height:2rem;background-color:var(--sapList_FooterBackground);color:var(--ui5_list_footer_text_color);padding:0 1rem;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.ui5-list-nodata{list-style-type:none;display:-webkit-box;display:flex;-webkit-box-align:center;align-items:center;-webkit-box-pack:center;justify-content:center;color:var(--sapTextColor);background-color:var(--sapList_Background);border-bottom:1px solid var(--sapList_BorderColor);padding:0 1rem!important;height:var(--_ui5_list_no_data_height);font-size:var(--_ui5_list_no_data_font_size);font-family:"72override",var(--sapFontFamily)}.ui5-list-nodata-text{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}' }], dependencies: [QP] }), iS("item-click", { detail: { item: { type: HTMLElement } } }), iS("item-close", { detail: { item: { type: HTMLElement } } }), iS("item-toggle", { detail: { item: { type: HTMLElement } } }), iS("item-delete", { detail: { item: { type: HTMLElement } } }), iS("selection-change", { detail: { selectedItems: { type: Array }, previouslySelectedItems: { type: Array }, targetItem: { type: HTMLElement }, selectionComponentPressed: { type: Boolean } } }), iS("load-more"), iS("item-focused", { detail: { item: { type: HTMLElement } } })], JP), JP.define();
const eD = "M475 104q5 7 5 12 0 6-5 11L150 453q-4 4-8 4L32 480l22-110q0-5 4-9L384 36q4-4 11-4t11 4zm-121 99l-46-45L84 381l46 46zm87-88l-46-44-64 64 45 45z";
Kx("edit", { pathData: eD, ltr: false, collection: "SAP-icons-v4", packageName: "@ui5/webcomponents-icons" });
const tD = "M501.5 88q8 7 8 19 0 10-8 18l-373 379q-5 4-9 6t-10 2h-80q-12 0-19.5-7.5T2.5 485v-80q0-10 8-18l374-379q8-8 18-8 11 0 19 8zm-136 99l-43-43-256 261 43 43zm80-80l-43-43-42 43 42 42z";
var iD;
Kx("edit", { pathData: tD, ltr: false, collection: "SAP-icons-v5", packageName: "@ui5/webcomponents-icons" }), dx(), function(e3) {
  e3.Inactive = "Inactive", e3.Active = "Active", e3.Detail = "Detail", e3.Navigation = "Navigation";
}(iD || (iD = {}));
const nD = iD, oD = (e3, t2) => {
  const i2 = t2 || [];
  return e3 ? (e3.forEach((e4) => {
    if (e4.nodeType === Node.TEXT_NODE || e4.nodeType === Node.COMMENT_NODE)
      return;
    let t3 = e4;
    if (!t3.hasAttribute("data-sap-no-tab-ref")) {
      if (t3.shadowRoot) {
        const e5 = t3.shadowRoot.children;
        t3 = Array.from(e5).find((e6) => "STYLE" !== e6.tagName);
      }
      t3 && (((e5) => {
        if (!e5)
          return false;
        const t4 = e5.nodeName.toLowerCase();
        if (e5.hasAttribute("data-sap-no-tab-ref"))
          return false;
        if (tB(e5))
          return false;
        const i3 = e5.getAttribute("tabindex");
        return null != i3 ? parseInt(i3) >= 0 : !("a" !== t4 && !/input|select|textarea|button|object/.test(t4) || e5.disabled);
      })(t3) && i2.push(t3), "SLOT" === t3.tagName ? oD(t3.assignedNodes(), i2) : oD([...t3.children], i2));
    }
  }), i2) : i2;
};
Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
var rD = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
let sD = class extends ZC {
  _onfocusin(e3) {
    e3.target === this.getFocusDomRef() && (this.focused = true, this.fireEvent("_focused", e3));
  }
  _onfocusout() {
    this.focused = false;
  }
  _onkeydown(e3) {
    return wS(e3) ? this._handleTabNext(e3) : xS(e3) ? this._handleTabPrevious(e3) : void 0;
  }
  _onkeyup(e3) {
  }
  _handleTabNext(e3) {
    this.shouldForwardTabAfter() && (this.fireEvent("_forward-after", {}, true) || e3.preventDefault());
  }
  _handleTabPrevious(e3) {
    const t2 = e3.target;
    this.shouldForwardTabBefore(t2) && this.fireEvent("_forward-before");
  }
  shouldForwardTabAfter() {
    const e3 = (t2 = this.getFocusDomRef(), oD([...t2.children]));
    var t2;
    return 0 === e3.length || e3[e3.length - 1] === RS();
  }
  shouldForwardTabBefore(e3) {
    return this.getFocusDomRef() === e3;
  }
  get classes() {
    return { main: { "ui5-li-root": true, "ui5-li--focusable": !this.disabled } };
  }
  get _ariaDisabled() {
    return !!this.disabled || void 0;
  }
  get hasConfigurableMode() {
    return false;
  }
  get _effectiveTabIndex() {
    return this.disabled ? -1 : this.selected ? 0 : this._tabIndex;
  }
};
rD([tS({ type: Boolean })], sD.prototype, "selected", void 0), rD([tS({ type: Boolean })], sD.prototype, "hasBorder", void 0), rD([tS({ defaultValue: "-1", noAttribute: true })], sD.prototype, "_tabIndex", void 0), rD([tS({ type: Boolean })], sD.prototype, "disabled", void 0), rD([tS({ type: Boolean })], sD.prototype, "focused", void 0), sD = rD([eS({ renderer: KS, styles: { packageName: "@ui5/webcomponents", fileName: "themes/ListItemBase.css", content: ':host(:not([hidden])){display:block}:host{height:var(--_ui5_list_item_base_height);background:var(--ui5-listitem-background-color);box-sizing:border-box;border-bottom:1px solid transparent}:host([selected]){background:var(--sapList_SelectionBackgroundColor)}:host([has-border]){border-bottom:var(--ui5-listitem-border-bottom)}:host([selected]){border-bottom:var(--ui5-listitem-selected-border-bottom)}:host(:not([focused])[selected][has-border]){border-bottom:var(--ui5-listitem-selected-border-bottom)}:host([focused][selected]){border-bottom:var(--ui5-listitem-focused-selected-border-bottom)}.ui5-li-root{position:relative;display:flex;align-items:center;width:100%;height:100%;padding:0 1rem 0 1rem;box-sizing:border-box}:host([focused]) .ui5-li-root.ui5-li--focusable{outline:none}:host([focused]) .ui5-li-root.ui5-li--focusable:after{content:"";border:var(--sapContent_FocusWidth) var(--sapContent_FocusStyle) var(--sapContent_FocusColor);position:absolute;top:.125rem;right:.125rem;bottom:.125rem;left:.125rem;pointer-events:none}:host([focused]) .ui5-li-content:focus:after{content:"";border:var(--sapContent_FocusWidth) var(--sapContent_FocusStyle) var(--sapContent_FocusColor);position:absolute;top:0;right:0;bottom:0;left:0;pointer-events:none}:host([active][focused]) .ui5-li-root.ui5-li--focusable:after{border-color:var(--ui5-listitem-active-border-color)}:host([disabled]){opacity:var(--_ui5-listitembase_disabled_opacity);pointer-events:none}.ui5-li-content{max-width:100%;font-family:"72override",var(--sapFontFamily);color:var(--sapList_TextColor)}' } }), iS("_focused"), iS("_forward-after"), iS("_forward-before")], sD);
const aD = sD;
class lD {
  static hasGroup(e3) {
    return this.groups.has(e3);
  }
  static getGroup(e3) {
    return this.groups.get(e3);
  }
  static getCheckedRadioFromGroup(e3) {
    return this.checkedRadios.get(e3);
  }
  static removeGroup(e3) {
    return this.checkedRadios.delete(e3), this.groups.delete(e3);
  }
  static addToGroup(e3, t2) {
    this.hasGroup(t2) ? (this.enforceSingleSelection(e3, t2), this.getGroup(t2) && this.getGroup(t2).push(e3)) : this.createGroup(e3, t2), this.updateTabOrder(t2);
  }
  static removeFromGroup(e3, t2) {
    const i2 = this.getGroup(t2);
    if (!i2)
      return;
    const n2 = this.getCheckedRadioFromGroup(t2);
    i2.forEach((t3, i3, n3) => {
      if (e3._id === t3._id)
        return n3.splice(i3, 1);
    }), n2 === e3 && this.checkedRadios.set(t2, null), i2.length || this.removeGroup(t2), this.updateTabOrder(t2);
  }
  static createGroup(e3, t2) {
    e3.checked && this.checkedRadios.set(t2, e3), this.groups.set(t2, [e3]);
  }
  static selectNextItem(e3, t2) {
    const i2 = this.getGroup(t2);
    if (!i2)
      return;
    const n2 = i2.length, o2 = i2.indexOf(e3);
    if (n2 <= 1)
      return;
    const r2 = this._nextSelectable(o2, i2);
    r2 && this.updateSelectionInGroup(r2, t2);
  }
  static updateTabOrder(e3) {
    const t2 = this.getGroup(e3);
    if (!t2)
      return;
    const i2 = t2.some((e4) => e4.checked);
    t2.filter((e4) => !e4.disabled).forEach((e4, t3) => {
      e4._tabIndex = i2 ? e4.checked ? "0" : "-1" : 0 === t3 ? "0" : "-1";
    });
  }
  static selectPreviousItem(e3, t2) {
    const i2 = this.getGroup(t2);
    if (!i2)
      return;
    const n2 = i2.length, o2 = i2.indexOf(e3);
    if (n2 <= 1)
      return;
    const r2 = this._previousSelectable(o2, i2);
    r2 && this.updateSelectionInGroup(r2, t2);
  }
  static selectItem(e3, t2) {
    this.updateSelectionInGroup(e3, t2), this.updateTabOrder(t2);
  }
  static updateSelectionInGroup(e3, t2) {
    const i2 = this.getCheckedRadioFromGroup(t2);
    i2 && this._deselectRadio(i2), this._selectRadio(e3), this.checkedRadios.set(t2, e3);
  }
  static _deselectRadio(e3) {
    e3 && (e3.checked = false);
  }
  static _selectRadio(e3) {
    e3 && (e3.focus({ focusVisible: true }), e3.checked = true, e3._checked = true, e3.fireEvent("change"));
  }
  static _nextSelectable(e3, t2) {
    if (!t2)
      return null;
    let i2 = null;
    if (e3 === t2.length - 1) {
      if (t2[0].disabled || t2[0].readonly)
        return this._nextSelectable(1, t2);
      i2 = t2[0];
    } else {
      if (t2[e3 + 1].disabled || t2[e3 + 1].readonly)
        return this._nextSelectable(e3 + 1, t2);
      i2 = t2[e3 + 1];
    }
    return i2;
  }
  static _previousSelectable(e3, t2) {
    const i2 = t2.length;
    let n2 = null;
    if (0 === e3) {
      if (t2[i2 - 1].disabled || t2[i2 - 1].readonly)
        return this._previousSelectable(i2 - 1, t2);
      n2 = t2[i2 - 1];
    } else {
      if (t2[e3 - 1].disabled || t2[e3 - 1].readonly)
        return this._previousSelectable(e3 - 1, t2);
      n2 = t2[e3 - 1];
    }
    return n2;
  }
  static enforceSingleSelection(e3, t2) {
    const i2 = this.getCheckedRadioFromGroup(t2);
    e3.checked ? i2 ? e3 !== i2 && (this._deselectRadio(i2), this.checkedRadios.set(t2, e3)) : this.checkedRadios.set(t2, e3) : e3 === i2 && this.checkedRadios.set(t2, null), this.updateTabOrder(t2);
  }
  static get groups() {
    return this._groups || (this._groups = /* @__PURE__ */ new Map()), this._groups;
  }
  static get checkedRadios() {
    return this._checkedRadios || (this._checkedRadios = /* @__PURE__ */ new Map()), this._checkedRadios;
  }
}
function cD(e3, t2, i2) {
  return i2 ? XS`<${ZS("ui5-label", t2, i2)} id="${jS(this._id)}-label" class="ui5-radio-label" for="${jS(this._id)}" wrapping-type="${jS(this.wrappingType)}">${jS(this.text)}</${ZS("ui5-label", t2, i2)}>` : XS`<ui5-label id="${jS(this._id)}-label" class="ui5-radio-label" for="${jS(this._id)}" wrapping-type="${jS(this.wrappingType)}">${jS(this.text)}</ui5-label>`;
}
function hD(e3, t2, i2) {
  return XS`<span id="${jS(this._id)}-descr" class="ui5-hidden-text">${jS(this.valueStateText)}</span>`;
}
function uD(e3, t2, i2) {
  return YS`<circle class="ui5-radio-svg-outer" cx="50%" cy="50%" r="50%" /><circle class="ui5-radio-svg-inner" cx="50%" cy="50%" />`;
}
Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
var dD, pD = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
let _D, gD = false, mD = dD = class extends ZC {
  constructor() {
    super(), this._deactivate = () => {
      _D && (_D.active = false);
    }, gD || (document.addEventListener("mouseup", this._deactivate), gD = true);
  }
  static async onDefine() {
    dD.i18nBundle = await Wx("@ui5/webcomponents");
  }
  onBeforeRendering() {
    this.syncGroup(), this._enableFormSupport();
  }
  onExitDOM() {
    this.syncGroup(true);
  }
  syncGroup(e3) {
    const t2 = this._name, i2 = this.name, n2 = this._checked, o2 = this.checked;
    e3 && lD.removeFromGroup(this, t2), i2 !== t2 ? (t2 && lD.removeFromGroup(this, t2), i2 && lD.addToGroup(this, i2)) : i2 && lD.enforceSingleSelection(this, i2), this.name && o2 !== n2 && lD.updateTabOrder(this.name), this._name = this.name, this._checked = this.checked;
  }
  _enableFormSupport() {
    const e3 = Ky("FormSupport");
    e3 ? e3.syncNativeHiddenInput(this, (e4, t2) => {
      t2.value = e4.value, t2.type = "radio", t2.checked = e4.checked;
    }) : this.value && console.warn('In order for the "value" property to have effect, you should also: import "@ui5/webcomponents/dist/features/InputElementsFormSupport.js";');
  }
  _onclick() {
    return this.toggle();
  }
  _handleDown(e3) {
    const t2 = this.name;
    t2 && (e3.preventDefault(), lD.selectNextItem(this, t2));
  }
  _handleUp(e3) {
    const t2 = this.name;
    t2 && (e3.preventDefault(), lD.selectPreviousItem(this, t2));
  }
  _onkeydown(e3) {
    if (sS(e3))
      return this.active = true, e3.preventDefault();
    if (rS(e3))
      return this.active = true, this.toggle();
    const t2 = "rtl" === this.effectiveDir;
    (hS(e3) || !t2 && lS(e3) || t2 && aS(e3)) && this._handleDown(e3), (cS(e3) || !t2 && aS(e3) || t2 && lS(e3)) && this._handleUp(e3);
  }
  _onkeyup(e3) {
    sS(e3) && this.toggle(), this.active = false;
  }
  _onmousedown() {
    this.active = true, _D = this;
  }
  _onmouseup() {
    this.active = false;
  }
  _onfocusout() {
    this.active = false;
  }
  toggle() {
    return this.canToggle() ? this.name ? (lD.selectItem(this, this.name), this) : (this.checked = !this.checked, this.fireEvent("change"), this) : this;
  }
  canToggle() {
    return !(this.disabled || this.readonly || this.checked);
  }
  get classes() {
    return { inner: { "ui5-radio-inner--hoverable": !this.disabled && !this.readonly && mI() } };
  }
  get effectiveAriaDisabled() {
    return this.disabled ? "true" : null;
  }
  get ariaLabelText() {
    return [bI(this), this.text].filter(Boolean).join(" ");
  }
  get effectiveAriaDescribedBy() {
    return this.hasValueState ? `${this._id}-descr` : void 0;
  }
  get hasValueState() {
    return this.valueState !== eB.None;
  }
  get valueStateText() {
    switch (this.valueState) {
      case eB.Error:
        return dD.i18nBundle.getText(YE);
      case eB.Warning:
        return dD.i18nBundle.getText(KE);
      case eB.Success:
        return dD.i18nBundle.getText(JE);
      case eB.Information:
        return dD.i18nBundle.getText(ZE);
      default:
        return "";
    }
  }
  get effectiveTabIndex() {
    const e3 = this.getAttribute("tabindex");
    return this.disabled ? "-1" : this.name ? this._tabIndex : e3 || "0";
  }
  get strokeWidth() {
    return "None" === this.valueState ? "1" : "2";
  }
};
pD([tS({ type: Boolean })], mD.prototype, "disabled", void 0), pD([tS({ type: Boolean })], mD.prototype, "readonly", void 0), pD([tS({ type: Boolean })], mD.prototype, "required", void 0), pD([tS({ type: Boolean })], mD.prototype, "checked", void 0), pD([tS()], mD.prototype, "text", void 0), pD([tS({ type: eB, defaultValue: eB.None })], mD.prototype, "valueState", void 0), pD([tS()], mD.prototype, "name", void 0), pD([tS()], mD.prototype, "value", void 0), pD([tS({ type: NT, defaultValue: NT.None })], mD.prototype, "wrappingType", void 0), pD([tS()], mD.prototype, "accessibleName", void 0), pD([tS()], mD.prototype, "accessibleNameRef", void 0), pD([tS({ defaultValue: "-1", noAttribute: true })], mD.prototype, "_tabIndex", void 0), pD([tS({ type: Boolean })], mD.prototype, "active", void 0), pD([nS()], mD.prototype, "formSupport", void 0), mD = dD = pD([eS({ tag: "ui5-radio-button", languageAware: true, renderer: KS, template: function(e3, t2, i2) {
  return XS`<div class="ui5-radio-root" role="radio" aria-checked="${jS(this.checked)}" aria-disabled="${jS(this.effectiveAriaDisabled)}" aria-describedby="${jS(this.effectiveAriaDescribedBy)}" aria-label="${jS(this.ariaLabelText)}" tabindex="${jS(this.effectiveTabIndex)}" @click="${this._onclick}" @keydown="${this._onkeydown}" @keyup="${this._onkeyup}" @mousedown="${this._onmousedown}" @mouseup="${this._onmouseup}" @focusout="${this._onfocusout}"><div class='ui5-radio-inner ${WS(this.classes.inner)}'><svg class="ui5-radio-svg" focusable="false" aria-hidden="true">${uD.call(this, e3, t2, i2)}</svg><input type='radio' ?required="${this.required}" ?checked="${this.checked}" ?readonly="${this.readonly}" ?disabled="${this.effectiveAriaDisabled}" name="${jS(this.name)}"  data-sap-no-tab-ref/></div>${this.text ? cD.call(this, e3, t2, i2) : void 0}${this.hasValueState ? hD.call(this, e3, t2, i2) : void 0}<slot name="formSupport"></slot></div>`;
}, styles: { packageName: "@ui5/webcomponents", fileName: "themes/RadioButton.css", content: '.ui5-hidden-text{position:absolute;clip:rect(1px,1px,1px,1px);user-select:none;left:-1000px;top:-1000px;pointer-events:none;font-size:0}:host(:not([hidden])){display:inline-block}:host{min-width:var(--_ui5_radio_button_min_width);max-width:100%;text-overflow:ellipsis;overflow:hidden;color:var(--_ui5_radio_button_color);border-radius:var(--_ui5_radio_button_border_radius);transition:var(--_ui5_radio_button_transition)}:host(:not([disabled])) .ui5-radio-root{cursor:pointer}:host([checked]){color:var(--_ui5_radio_button_checked_fill)}:host([checked]) .ui5-radio-svg-inner{fill:var(--_ui5_radio_button_inner_ring_color)}:host([checked]) .ui5-radio-svg-outer{stroke:var(--_ui5_radio_button_outer_ring_color)}:host([disabled]) .ui5-radio-root{color:var(--_ui5_radio_button_color);opacity:var(--sapContent_DisabledOpacity)}:host([disabled][checked]) .ui5-radio-svg-outer{stroke:var(--_ui5_radio_button_color)}:host(:not([disabled])) .ui5-radio-root:focus-visible:before{content:"";display:var(--_ui5_radio_button_focus_outline);position:absolute;top:var(--_ui5_radio_button_focus_dist);bottom:var(--_ui5_radio_button_focus_dist);left:var(--_ui5_radio_button_focus_dist);right:var(--_ui5_radio_button_focus_dist);pointer-events:none;border:var(--_ui5_radio_button_border_width) var(--sapContent_FocusStyle) var(--sapContent_FocusColor);border-radius:var(--_ui5_radio_button_border_radius)}:host(:not([disabled])[readonly]) .ui5-radio-root:focus-visible:before{border:var(--_ui5_radio_button_border_width) var(--_ui5_radio_button_border_readonly_focus_style) var(--sapContent_FocusColor)}:host(:not([disabled])) .ui5-radio-root:focus-visible{border-radius:var(--_ui5_radio_button_border_radius);border:var(--_ui5_radio_button_focus_border)}:host(:not([disabled]):hover){background:var(--_ui5_radio_button_hover_background);box-shadow:var(--_ui5_radio_button_hover_shadow)}:host(:not([value-state=Error]):not([value-state=Warning]):not([value-state=Success]):not([value-state=Information])) .ui5-radio-root:hover .ui5-radio-inner--hoverable .ui5-radio-svg-outer{stroke:var(--_ui5_radio_button_outer_ring_hover_color)}:host(:not([value-state=Error]):not([value-state=Warning]):not([value-state=Success]):not([value-state=Information])) .ui5-radio-root:hover .ui5-radio-inner--hoverable{filter:drop-shadow(var(--_ui5_radio_button_outer_ring_hover_shadow))}:host(:not([value-state=Error]):not([value-state=Warning]):not([value-state=Success]):not([value-state=Information])[checked]) .ui5-radio-root:hover .ui5-radio-inner--hoverable .ui5-radio-svg-outer{stroke:var(--_ui5_radio_button_outer_ring_checked_hover_color)}.ui5-radio-root:hover .ui5-radio-inner--hoverable .ui5-radio-svg-outer,:host([checked]) .ui5-radio-root:hover .ui5-radio-inner--hoverable .ui5-radio-svg-outer{fill:var(--_ui5_radio_button_hover_fill)}:host([active][checked]:not([value-state]):not([disabled]):not([readonly])) .ui5-radio-svg-outer{stroke:var(--_ui5_radio_button_outer_ring_checked_hover_color)}:host([active]:not([checked]):not([value-state]):not([disabled]):not([readonly])) .ui5-radio-svg-outer{stroke:var(--_ui5_radio_button_outer_ring_active_color)}:host([text]) .ui5-radio-root:focus-visible:before{inset-inline:var(--_ui5_radio_button_focus_dist) 0}:host([text]) .ui5-radio-inner{padding:var(--_ui5_radio_button_outer_ring_padding_with_label)}:host([checked][readonly]) .ui5-radio-svg-inner{fill:var(--sapContent_NonInteractiveIconColor)}:host([readonly]) .ui5-radio-root .ui5-radio-svg-outer{fill:var(--sapField_ReadOnly_Background);stroke:var(--sapField_ReadOnly_BorderColor);stroke-dasharray:var(--_ui5_radio_button_read_only_border_type);stroke-width:var(--_ui5_radio_button_read_only_border_width)}:host([value-state=Error]) .ui5-radio-svg-outer,:host([value-state=Warning]) .ui5-radio-svg-outer{stroke-width:var(--sapField_InvalidBorderWidth)}:host([value-state=Information]) .ui5-radio-svg-outer{stroke-width:var(--_ui5_radio_button_information_border_width)}:host([value-state=Error][checked]) .ui5-radio-svg-inner{fill:var(--_ui5_radio_button_checked_error_fill)}:host([value-state=Error]) .ui5-radio-root:hover .ui5-radio-inner.ui5-radio-inner--hoverable:hover .ui5-radio-svg-outer,:host([value-state=Error]) .ui5-radio-svg-outer{stroke:var(--sapField_InvalidColor);fill:var(--sapField_InvalidBackground)}:host([value-state=Error]) .ui5-radio-root:hover .ui5-radio-inner.ui5-radio-inner--hoverable .ui5-radio-svg-outer{fill:var(--_ui5_radio_button_hover_fill_error)}:host([value-state=Error]) .ui5-radio-root:hover .ui5-radio-inner.ui5-radio-inner--hoverable{filter:drop-shadow(var(--_ui5_radio_button_outer_ring_hover_shadow_error))}:host([value-state=Warning][checked]) .ui5-radio-svg-inner{fill:var(--_ui5_radio_button_checked_warning_fill)}:host([value-state=Warning]) .ui5-radio-root:hover .ui5-radio-inner.ui5-radio-inner--hoverable:hover .ui5-radio-svg-outer,:host([value-state=Warning]) .ui5-radio-svg-outer{stroke:var(--sapField_WarningColor);fill:var(--sapField_WarningBackground)}:host([value-state=Warning]) .ui5-radio-root:hover .ui5-radio-inner.ui5-radio-inner--hoverable .ui5-radio-svg-outer{fill:var(--_ui5_radio_button_hover_fill_warning)}:host([value-state=Warning]) .ui5-radio-root:hover .ui5-radio-inner.ui5-radio-inner--hoverable{filter:drop-shadow(var(--_ui5_radio_button_outer_ring_hover_shadow_warning))}:host([value-state=Success][checked]) .ui5-radio-svg-inner{fill:var(--_ui5_radio_button_checked_success_fill)}:host([value-state=Success]) .ui5-radio-root:hover .ui5-radio-inner.ui5-radio-inner--hoverable:hover .ui5-radio-svg-outer,:host([value-state=Success]) .ui5-radio-svg-outer{stroke:var(--sapField_SuccessColor);fill:var(--sapField_SuccessBackground)}:host([value-state=Success]) .ui5-radio-root:hover .ui5-radio-inner.ui5-radio-inner--hoverable .ui5-radio-svg-outer{fill:var(--_ui5_radio_button_hover_fill_success)}:host([value-state=Success]) .ui5-radio-root:hover .ui5-radio-inner.ui5-radio-inner--hoverable{filter:drop-shadow(var(--_ui5_radio_button_outer_ring_hover_shadow_success))}:host([value-state=Information][checked]) .ui5-radio-svg-inner{fill:var(--_ui5_radio_button_checked_information_fill)}:host([value-state=Information]) .ui5-radio-root:hover .ui5-radio-inner.ui5-radio-inner--hoverable:hover .ui5-radio-svg-outer,:host([value-state=Information]) .ui5-radio-svg-outer{stroke:var(--sapField_InformationColor);fill:var(--sapField_InformationBackground)}:host([value-state=Information]) .ui5-radio-root:hover .ui5-radio-inner.ui5-radio-inner--hoverable .ui5-radio-svg-outer{fill:var(--_ui5_radio_button_hover_fill_information)}:host([value-state=Information]) .ui5-radio-root:hover .ui5-radio-inner.ui5-radio-inner--hoverable{filter:drop-shadow(var(--_ui5_radio_button_outer_ring_hover_shadow_information))}:host([value-state=Error]) .ui5-radio-root,:host([value-state=Information]) .ui5-radio-root,:host([value-state=Warning]) .ui5-radio-root{stroke-dasharray:var(--_ui5_radio_button_warning_error_border_dash)}.ui5-radio-root{height:var(--_ui5_radio_button_height);position:relative;display:inline-flex;flex-wrap:nowrap;outline:none;max-width:100%;width:var(--_ui5_radio_button_inner_width);box-sizing:border-box;border:var(--_ui5_radio_button_border);border-radius:var(--_ui5_radio_button_border_radius);transition:var(--_ui5_radio_button_transition)}.ui5-radio-inner{display:flex;align-items:center;padding:var(--_ui5_radio_button_outer_ring_padding);flex-shrink:0;height:var(--_ui5_radio_button_inner_size);font-size:1rem;pointer-events:none;vertical-align:top}.ui5-radio-inner{outline:none}.ui5-radio-inner input{-webkit-appearance:none;visibility:hidden;width:0;left:0;position:absolute;font-size:inherit;margin:0}[ui5-label].ui5-radio-label{display:flex;align-items:center;padding-inline-end:var(--_ui5_radio_button_label_offset);vertical-align:top;max-width:100%;text-overflow:ellipsis;overflow:hidden;pointer-events:none;color:var(--_ui5_radio_button_label_color)}:host([wrapping-type=Normal][text]) .ui5-radio-root{height:auto}:host([wrapping-type=Normal][text]) [ui5-label].ui5-radio-label{padding:var(--_ui5_radio_button_label_side_padding) 0;overflow-wrap:break-word}.ui5-radio-svg{height:var(--_ui5_radio_button_svg_size);width:var(--_ui5_radio_button_svg_size);overflow:visible;pointer-events:none}.ui5-radio-svg-outer{fill:var(--_ui5_radio_button_outer_ring_bg);stroke:currentColor;stroke-width:var(--_ui5_radio_button_outer_ring_width)}.ui5-radio-svg-inner{fill:none;r:var(--_ui5_radio_button_inner_ring_radius)}.ui5-radio-svg-inner,.ui5-radio-svg-outer{flex-shrink:0}:host(.ui5-li-singlesel-radiobtn) .ui5-radio-root .ui5-radio-inner .ui5-radio-svg-outer{fill:var(--sapList_Background)}' }, dependencies: [_M] }), iS("change")], mD), mD.define();
const fD = mD;
Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
var vD;
!function(e3) {
  e3.Dialog = "Dialog", e3.Grid = "Grid", e3.ListBox = "ListBox", e3.Menu = "Menu", e3.Tree = "Tree";
}(vD || (vD = {}));
const AD = vD;
var bD, yD = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
let wD = bD = class extends aD {
  constructor() {
    super(), this.deactivateByKey = (e3) => {
      rS(e3) && this.deactivate();
    }, this.deactivate = () => {
      this.active && (this.active = false);
    };
    this._ontouchstart = { handleEvent: (e3) => {
      this._onmousedown(e3);
    }, passive: true };
  }
  onBeforeRendering() {
    this.actionable = (this.type === nD.Active || this.type === nD.Navigation) && this._mode !== BP.Delete;
  }
  onEnterDOM() {
    document.addEventListener("mouseup", this.deactivate), document.addEventListener("touchend", this.deactivate), document.addEventListener("keyup", this.deactivateByKey);
  }
  onExitDOM() {
    document.removeEventListener("mouseup", this.deactivate), document.removeEventListener("keyup", this.deactivateByKey), document.removeEventListener("touchend", this.deactivate);
  }
  _onkeydown(e3) {
    super._onkeydown(e3);
    const t2 = this.type === nD.Active, i2 = this.typeNavigation;
    sS(e3) && e3.preventDefault(), (sS(e3) || rS(e3)) && (t2 || i2) && this.activate(), rS(e3) && this.fireItemPress(e3);
  }
  _onkeyup(e3) {
    (sS(e3) || rS(e3)) && this.deactivate(), sS(e3) && this.fireItemPress(e3), this.modeDelete && CS(e3) && this.onDelete();
  }
  _onmousedown(e3) {
    "button" !== MI(e3) && this.activate();
  }
  _onmouseup(e3) {
    "button" !== MI(e3) && this.deactivate();
  }
  _ontouchend(e3) {
    this._onmouseup(e3);
  }
  _onfocusout() {
    super._onfocusout(), this.deactivate();
  }
  _onclick(e3) {
    "button" !== MI(e3) && this.fireItemPress(e3);
  }
  onMultiSelectionComponentPress(e3) {
    this.isInactive || this.fireEvent("_selection-requested", { item: this, selected: e3.target.checked, selectionComponentPressed: true });
  }
  onSingleSelectionComponentPress(e3) {
    this.isInactive || this.fireEvent("_selection-requested", { item: this, selected: !e3.target.checked, selectionComponentPressed: true });
  }
  activate() {
    this.type !== nD.Active && this.type !== nD.Navigation || (this.active = true);
  }
  onDelete() {
    this.fireEvent("_selection-requested", { item: this, selectionComponentPressed: false });
  }
  onDetailClick() {
    this.fireEvent("detail-click", { item: this, selected: this.selected });
  }
  fireItemPress(e3) {
    this.isInactive || (rS(e3) && e3.preventDefault(), this.fireEvent("_press", { item: this, selected: this.selected, key: e3.key }));
  }
  get isInactive() {
    return this.type === nD.Inactive || this.type === nD.Detail;
  }
  get placeSelectionElementBefore() {
    return this._mode === BP.MultiSelect || this._mode === BP.SingleSelectBegin;
  }
  get placeSelectionElementAfter() {
    return !this.placeSelectionElementBefore && (this._mode === BP.SingleSelectEnd || this._mode === BP.Delete);
  }
  get modeSingleSelect() {
    return [BP.SingleSelectBegin, BP.SingleSelectEnd, BP.SingleSelect].includes(this._mode);
  }
  get modeMultiSelect() {
    return this._mode === BP.MultiSelect;
  }
  get modeDelete() {
    return this._mode === BP.Delete;
  }
  get renderDeleteButton() {
    return this.modeDelete;
  }
  get typeDetail() {
    return this.type === nD.Detail;
  }
  get typeNavigation() {
    return this.type === nD.Navigation;
  }
  get typeActive() {
    return this.type === nD.Active;
  }
  get _ariaSelected() {
    if (this.modeMultiSelect || this.modeSingleSelect)
      return this.selected;
  }
  get ariaSelectedText() {
    let e3;
    return void 0 !== this._ariaSelected && (e3 = this._ariaSelected ? bD.i18nBundle.getText(RE) : bD.i18nBundle.getText(PE)), e3;
  }
  get deleteText() {
    return bD.i18nBundle.getText(EE);
  }
  get hasDeleteButtonSlot() {
    return !!this.deleteButton.length;
  }
  get _accessibleNameRef() {
    return this.accessibleName ? `${this._id}-invisibleText` : `${this._id}-content ${this._id}-invisibleText`;
  }
  get _accInfo() {
    return { role: this.accessibleRole || this.role, ariaExpanded: void 0, ariaLevel: this._level || void 0, ariaLabel: bD.i18nBundle.getText(DE), ariaLabelRadioButton: bD.i18nBundle.getText(LE), ariaSelectedText: this.ariaSelectedText, ariaHaspopup: this.ariaHaspopup || void 0 };
  }
  get hasConfigurableMode() {
    return true;
  }
  static async onDefine() {
    bD.i18nBundle = await Wx("@ui5/webcomponents");
  }
};
yD([tS({ type: nD, defaultValue: nD.Active })], wD.prototype, "type", void 0), yD([tS({ type: Boolean })], wD.prototype, "navigated", void 0), yD([tS({ type: Boolean })], wD.prototype, "active", void 0), yD([tS()], wD.prototype, "title", void 0), yD([tS({ type: Boolean })], wD.prototype, "actionable", void 0), yD([tS({ defaultValue: "listitem" })], wD.prototype, "role", void 0), yD([tS({ defaultValue: void 0, noAttribute: true })], wD.prototype, "accessibleRoleDescription", void 0), yD([tS()], wD.prototype, "accessibleRole", void 0), yD([tS({ type: BP, defaultValue: BP.None })], wD.prototype, "_mode", void 0), yD([tS({ type: AD, noAttribute: true })], wD.prototype, "ariaHaspopup", void 0), yD([tS({ type: nI })], wD.prototype, "_level", void 0), yD([tS({ type: Boolean, noAttribute: true })], wD.prototype, "disableDeleteButton", void 0), yD([nS()], wD.prototype, "deleteButton", void 0), wD = bD = yD([eS({ languageAware: true, styles: [aD.styles, { packageName: "@ui5/webcomponents", fileName: "themes/ListItem.css", content: ".ui5-hidden-text{position:absolute;clip:rect(1px,1px,1px,1px);user-select:none;left:-1000px;top:-1000px;pointer-events:none;font-size:0}:host([actionable]:not([disabled])){cursor:pointer}:host([selected][actionable]:not([active]):hover){background:var(--sapList_Hover_SelectionBackground)}:host([active][actionable]),:host([selected][active][actionable]){background:var(--sapList_Active_Background)}:host([actionable]:not([active]):not([selected]):hover){background:var(--sapList_Hover_Background)}:host([active][actionable]) .ui5-li-root.ui5-li--focusable .ui5-li-content:focus,:host([active][actionable]) .ui5-li-root.ui5-li--focusable:focus{outline-color:var(--sapContent_ContrastFocusColor)}:host([navigated]) .ui5-li-root .ui5-li-navigated{width:.1875rem;position:absolute;right:0;top:0;bottom:0;background-color:var(--sapList_SelectionBorderColor)}:host([active][actionable]) .ui5-li-root .ui5-li-icon{color:var(--sapList_Active_TextColor)}:host([active][actionable]) .ui5-li-additional-text,:host([active][actionable]) .ui5-li-desc,:host([active][actionable]) .ui5-li-title{color:var(--sapList_Active_TextColor)}:host([additional-text-state=Warning]) .ui5-li-additional-text{color:var(--sapCriticalTextColor)}:host([additional-text-state=Success]) .ui5-li-additional-text{color:var(--sapPositiveTextColor)}:host([additional-text-state=Error]) .ui5-li-additional-text{color:var(--sapNegativeTextColor)}:host([additional-text-state=Information]) .ui5-li-additional-text{color:var(--sapInformativeTextColor)}:host([has-title][description]){height:5rem}:host([has-title][image]){height:5rem}:host([_has-image-content]){height:5rem}:host([image]) .ui5-li-content{height:3rem}:host([description]) .ui5-li-root{padding:1rem}:host([description]) .ui5-li-content{height:3rem}:host([has-title][description]) .ui5-li-title{padding-bottom:.375rem}.ui5-li-text-wrapper{display:flex;flex-direction:column;flex:auto;min-width:1px;line-height:normal}:host([description]) .ui5-li-text-wrapper{height:100%;justify-content:space-between;padding:.125rem 0}.ui5-li-description-info-wrapper{display:flex;justify-content:space-between}.ui5-li-title{color:var(--sapTextColor);font-size:var(--_ui5_list_item_title_size)}.ui5-li-additional-text,.ui5-li-desc,:host(:not([wrapping-type=Normal])) .ui5-li-title{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}:host([wrapping-type=Normal]){height:auto}:host([wrapping-type=Normal]) .ui5-li-content{margin:var(--_ui5_list_item_content_vertical_offset) 0}.ui5-li-desc{color:var(--sapContent_LabelColor);font-size:var(--sapFontSize)}.ui5-li-additional-text{margin:0 .25rem;color:var(--sapNeutralTextColor);font-size:.875rem;min-width:3.75rem;text-align:end;max-width:40%}:host([description]) .ui5-li-additional-text{align-self:flex-end}.ui5-li-img{width:var(--_ui5_list_item_img_size);height:var(--_ui5_list_item_img_size);border-radius:var(--ui5-avatar-border-radius)}.ui5-li-img,.ui5-li-imgContent{min-width:var(--_ui5_list_item_img_size);min-height:var(--_ui5_list_item_img_size);margin-top:var(--_ui5_list_item_img_top_margin);margin-bottom:var(--_ui5_list_item_img_bottom_margin);margin-inline-end:var(--_ui5_list_item_img_hn_margin)}.ui5-li-img-inner{object-fit:contain}.ui5-li-icon{min-width:var(--_ui5_list_item_icon_size);min-height:var(--_ui5_list_item_icon_size);color:var(--sapContent_NonInteractiveIconColor);padding-inline-end:var(--_ui5_list_item_icon_padding-inline-end)}.ui5-li-content{display:flex;align-items:center;flex:auto;overflow:hidden}.ui5-li-deletebtn,.ui5-li-detailbtn{display:flex;align-items:center;margin-left:var(--_ui5_list_buttons_left_space)}.ui5-li-multisel-cb,.ui5-li-singlesel-radiobtn{flex-shrink:0}:host([description]) .ui5-li-singlesel-radiobtn{align-self:flex-start;margin-top:var(--_ui5_list_item_selection_btn_margin_top)}:host([description]) .ui5-li-multisel-cb{align-self:flex-start;margin-top:var(--_ui5_list_item_selection_btn_margin_top)}:host([_mode=SingleSelectBegin]) .ui5-li-root{padding-inline:0 1rem}:host([_mode=MultiSelect]) .ui5-li-root{padding-inline:0 1rem}:host([_mode=SingleSelectEnd]) .ui5-li-root{padding-inline:1rem 0}:host [ui5-checkbox].ui5-li-singlesel-radiobtn{margin-right:var(--_ui5_list_item_cb_margin_right)}" }], dependencies: [ZI, fD, SM] }), iS("detail-click"), iS("_press"), iS("_focused"), iS("_selection-requested")], wD);
const xD = wD;
function CD(e3, t2, i2) {
  return XS`<slot></slot>`;
}
function SD(e3, t2, i2) {
  return XS`${this.icon ? ED.call(this, e3, t2, i2) : void 0}${this.initials ? ID.call(this, e3, t2, i2) : void 0}`;
}
function ED(e3, t2, i2) {
  return i2 ? XS`<${ZS("ui5-icon", t2, i2)} class="ui5-avatar-icon" name="${jS(this.icon)}" accessible-name="${jS(this.accessibleNameText)}"></${ZS("ui5-icon", t2, i2)}>` : XS`<ui5-icon class="ui5-avatar-icon" name="${jS(this.icon)}" accessible-name="${jS(this.accessibleNameText)}"></ui5-icon>`;
}
function ID(e3, t2, i2) {
  return i2 ? XS`<span class="ui5-avatar-initials">${jS(this.validInitials)}</span><${ZS("ui5-icon", t2, i2)} class="ui5-avatar-icon ui5-avatar-icon-fallback" name="employee" accessible-name="${jS(this.accessibleNameText)}"></${ZS("ui5-icon", t2, i2)}>` : XS`<span class="ui5-avatar-initials">${jS(this.validInitials)}</span><ui5-icon class="ui5-avatar-icon ui5-avatar-icon-fallback" name="employee" accessible-name="${jS(this.accessibleNameText)}"></ui5-icon>`;
}
Ww("@ui5/webcomponents-theming", "sap_fiori_3", async () => HI), Ww("@ui5/webcomponents", "sap_fiori_3", async () => QI);
var TD;
!function(e3) {
  e3.XS = "XS", e3.S = "S", e3.M = "M", e3.L = "L", e3.XL = "XL";
}(TD || (TD = {}));
const BD = TD;
var MD;
!function(e3) {
  e3.Circle = "Circle", e3.Square = "Square";
}(MD || (MD = {}));
const kD = MD;
var RD;
!function(e3) {
  e3.Accent1 = "Accent1", e3.Accent2 = "Accent2", e3.Accent3 = "Accent3", e3.Accent4 = "Accent4", e3.Accent5 = "Accent5", e3.Accent6 = "Accent6", e3.Accent7 = "Accent7", e3.Accent8 = "Accent8", e3.Accent9 = "Accent9", e3.Accent10 = "Accent10", e3.Placeholder = "Placeholder";
}(RD || (RD = {}));
const PD = RD, DD = "M448 512H64V384q0-26 10-49.5t27.5-41T142 266t50-10h64q-27 0-50-10t-40.5-27.5T138 178t-10-50q0-26 10-49.5t27.5-41T206 10t50-10q26 0 49.5 10t41 27.5 27.5 41 10 49.5q0 27-10 50t-27.5 40.5-41 27.5-49.5 10h64q26 0 49.5 10t41 27.5 27.5 41 10 49.5v128zM96 384v96h320v-96q0-40-28-68t-68-28H192q-40 0-68 28t-28 68zm160-160q40 0 68-28t28-68-28-68-68-28-68 28-28 68 28 68 68 28zm32 192v-32h96v32h-96z";
Kx("employee", { pathData: DD, ltr: false, collection: "SAP-icons-v4", packageName: "@ui5/webcomponents-icons" });
const LD = "M370 370q13 0 20.5 8t7.5 21q0 28-28 28h-29q-28 0-28-28 0-13 7.5-21t20.5-8h29zm-12-127q56 21 90.5 70.5T483 427v57q0 28-28 28H57q-28 0-28-28v-57q0-64 34.5-113.5T154 243q-40-40-40-100 0-30 11-55.5t30.5-45 45-30.5T256 1t56 11 45 30.5 30 45 11 55.5q0 60-40 100zM256 58q-36 0-60.5 24.5T171 143q0 37 24.5 61t60.5 24 60.5-24 24.5-61q0-36-24.5-60.5T256 58zM86 453h142V350l-20-19q-8-9-8-20.5t8-19.5l6-6q-27 3-50 15.5t-40.5 31-27.5 43T86 427v29-3zm340-23q0-28-10-52.5t-27-44-40-31.5-50-14l5 6q9 8 9 19.5t-9 19.5l-19 20v103h141v-26z";
Kx("employee", { pathData: LD, ltr: false, collection: "SAP-icons-v5", packageName: "@ui5/webcomponents-icons" }), dx();
var FD, ND = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
let OD = FD = class extends ZC {
  constructor() {
    super(), this._handleResizeBound = this.handleResize.bind(this);
  }
  static async onDefine() {
    FD.i18nBundle = await Wx("@ui5/webcomponents");
  }
  get tabindex() {
    return this._tabIndex || (this.interactive ? "0" : "-1");
  }
  get _effectiveSize() {
    return this.getAttribute("size") || this._size;
  }
  get _effectiveBackgroundColor() {
    return this.getAttribute("color-scheme") || this._colorScheme;
  }
  get _role() {
    return this.interactive ? "button" : void 0;
  }
  get _ariaHasPopup() {
    return this._getAriaHasPopup();
  }
  get validInitials() {
    return this.initials;
  }
  get accessibleNameText() {
    return this.accessibleName ? this.accessibleName : FD.i18nBundle.getText(aE) || void 0;
  }
  get hasImage() {
    return this._hasImage = !!this.image.length, this._hasImage;
  }
  get initialsContainer() {
    return this.getDomRef().querySelector(".ui5-avatar-initials");
  }
  onBeforeRendering() {
    this._onclick = this.interactive ? this._onClickHandler.bind(this) : void 0;
  }
  async onAfterRendering() {
    await Nw(), this.initials && !this.icon && this._checkInitials();
  }
  onEnterDOM() {
    this.initialsContainer && iE.register(this.initialsContainer, this._handleResizeBound);
  }
  onExitDOM() {
    this.initialsContainer && iE.deregister(this.initialsContainer, this._handleResizeBound);
  }
  handleResize() {
    this.initials && !this.icon && this._checkInitials();
  }
  _checkInitials() {
    const e3 = this.getDomRef(), t2 = e3.querySelector(".ui5-avatar-initials");
    this.validInitials ? (t2 && t2.classList.remove("ui5-avatar-initials-hidden"), this.initials && 3 === this.initials.length && t2 && t2.scrollWidth > e3.scrollWidth && t2.classList.add("ui5-avatar-initials-hidden")) : t2.classList.add("ui5-avatar-initials-hidden");
  }
  _onClickHandler(e3) {
    e3.stopPropagation(), this.fireEvent("click");
  }
  _onkeydown(e3) {
    this.interactive && (rS(e3) && this.fireEvent("click"), sS(e3) && e3.preventDefault());
  }
  _onkeyup(e3) {
    this.interactive && !e3.shiftKey && sS(e3) && this.fireEvent("click");
  }
  _onfocusout() {
    this.focused = false;
  }
  _onfocusin() {
    this.interactive && (this.focused = true);
  }
  _getAriaHasPopup() {
    if (this.interactive && "" !== this.ariaHaspopup)
      return this.ariaHaspopup;
  }
};
ND([tS({ type: Boolean })], OD.prototype, "interactive", void 0), ND([tS({ type: Boolean })], OD.prototype, "focused", void 0), ND([tS()], OD.prototype, "icon", void 0), ND([tS()], OD.prototype, "initials", void 0), ND([tS({ type: kD, defaultValue: kD.Circle })], OD.prototype, "shape", void 0), ND([tS({ type: BD, defaultValue: BD.S })], OD.prototype, "size", void 0), ND([tS({ type: BD, defaultValue: BD.S })], OD.prototype, "_size", void 0), ND([tS({ type: PD, defaultValue: PD.Accent6 })], OD.prototype, "colorScheme", void 0), ND([tS({ type: PD, defaultValue: PD.Accent6 })], OD.prototype, "_colorScheme", void 0), ND([tS()], OD.prototype, "accessibleName", void 0), ND([tS()], OD.prototype, "ariaHaspopup", void 0), ND([tS({ noAttribute: true })], OD.prototype, "_tabIndex", void 0), ND([tS({ type: Boolean })], OD.prototype, "_hasImage", void 0), ND([nS({ type: HTMLElement, default: true })], OD.prototype, "image", void 0), ND([nS()], OD.prototype, "badge", void 0), OD = FD = ND([eS({ tag: "ui5-avatar", languageAware: true, renderer: KS, styles: { packageName: "@ui5/webcomponents", fileName: "themes/Avatar.css", content: ':host(:not([hidden])){display:inline-block;box-sizing:border-box;position:relative}:host(:not([hidden]).ui5_hovered){opacity:.7}:host([focused]){outline:var(--_ui5_avatar_outline);outline-offset:var(--_ui5_avatar_focus_offset)}:host([interactive]){cursor:pointer}:host{height:3rem;width:3rem;border-radius:50%;border:var(--ui5-avatar-initials-border);outline:none;color:var(--ui5-avatar-initials-color)}.ui5-avatar-root{display:flex;align-items:center;justify-content:center;outline:none;height:100%;width:100%}:host([_size=XS]),:host([size=XS]){height:2rem;width:2rem;min-height:2rem;min-width:2rem;font-size:var(--_ui5_avatar_fontsize_XS)}:host([_size=S]),:host([size=S]){min-height:3rem;min-width:3rem;font-size:var(--_ui5_avatar_fontsize_S)}:host([_size=M]),:host([size=M]){min-height:4rem;min-width:4rem;font-size:var(--_ui5_avatar_fontsize_M)}:host([_size=L]),:host([size=L]){min-height:5rem;min-width:5rem;font-size:var(--_ui5_avatar_fontsize_L)}:host([_size=XL]),:host([size=XL]){min-height:7rem;min-width:7rem;font-size:var(--_ui5_avatar_fontsize_XL)}:host .ui5-avatar-icon{height:var(--_ui5_avatar_fontsize_S);width:var(--_ui5_avatar_fontsize_S);color:inherit}:host([_size=XS]) .ui5-avatar-icon,:host([size=XS]) .ui5-avatar-icon{height:var(--_ui5_avatar_icon_XS);width:var(--_ui5_avatar_icon_XS)}:host([_size=S]) .ui5-avatar-icon,:host([size=S]) .ui5-avatar-icon{height:var(--_ui5_avatar_icon_S);width:var(--_ui5_avatar_icon_S)}:host([_size=M]) .ui5-avatar-icon,:host([size=M]) .ui5-avatar-icon{height:var(--_ui5_avatar_icon_M);width:var(--_ui5_avatar_icon_M)}:host([_size=L]) .ui5-avatar-icon,:host([size=L]) .ui5-avatar-icon{height:var(--_ui5_avatar_icon_L);width:var(--_ui5_avatar_icon_L)}:host([_size=XL]) .ui5-avatar-icon,:host([size=XL]) .ui5-avatar-icon{height:var(--_ui5_avatar_icon_XL);width:var(--_ui5_avatar_icon_XL)}::slotted(*){border-radius:50%;width:100%;height:100%;pointer-events:none}:host([shape=Square]){border-radius:var(--ui5-avatar-border-radius)}:host([shape=Square]) ::slotted(*){border-radius:calc(var(--ui5-avatar-border-radius) - var(--ui5-avatar-border-radius-img-deduction))}:host(:not([_has-image])),:host(:not([color-scheme])),:host([_color-scheme=Accent6]),:host([ui5-avatar][color-scheme=Accent6]){background-color:var(--ui5-avatar-accent6);color:var(--ui5-avatar-accent6-color);border-color:var(--ui5-avatar-accent6-border-color)}:host([_color-scheme=Accent1]),:host([ui5-avatar][color-scheme=Accent1]){background-color:var(--ui5-avatar-accent1);color:var(--ui5-avatar-accent1-color);border-color:var(--ui5-avatar-accent1-border-color)}:host([_color-scheme=Accent2]),:host([ui5-avatar][color-scheme=Accent2]){background-color:var(--ui5-avatar-accent2);color:var(--ui5-avatar-accent2-color);border-color:var(--ui5-avatar-accent2-border-color)}:host([_color-scheme=Accent3]),:host([ui5-avatar][color-scheme=Accent3]){background-color:var(--ui5-avatar-accent3);color:var(--ui5-avatar-accent3-color);border-color:var(--ui5-avatar-accent3-border-color)}:host([_color-scheme=Accent4]),:host([ui5-avatar][color-scheme=Accent4]){background-color:var(--ui5-avatar-accent4);color:var(--ui5-avatar-accent4-color);border-color:var(--ui5-avatar-accent4-border-color)}:host([_color-scheme=Accent5]),:host([ui5-avatar][color-scheme=Accent5]){background-color:var(--ui5-avatar-accent5);color:var(--ui5-avatar-accent5-color);border-color:var(--ui5-avatar-accent5-border-color)}:host([_color-scheme=Accent7]),:host([ui5-avatar][color-scheme=Accent7]){background-color:var(--ui5-avatar-accent7);color:var(--ui5-avatar-accent7-color);border-color:var(--ui5-avatar-accent7-border-color)}:host([_color-scheme=Accent8]),:host([ui5-avatar][color-scheme=Accent8]){background-color:var(--ui5-avatar-accent8);color:var(--ui5-avatar-accent8-color);border-color:var(--ui5-avatar-accent8-border-color)}:host([_color-scheme=Accent9]),:host([ui5-avatar][color-scheme=Accent9]){background-color:var(--ui5-avatar-accent9);color:var(--ui5-avatar-accent9-color);border-color:var(--ui5-avatar-accent9-border-color)}:host([_color-scheme=Accent10]),:host([ui5-avatar][color-scheme=Accent10]){background-color:var(--ui5-avatar-accent10);color:var(--ui5-avatar-accent10-color);border-color:var(--ui5-avatar-accent10-border-color)}:host([_color-scheme=Placeholder]),:host([ui5-avatar][color-scheme=Placeholder]){background-color:var(--ui5-avatar-placeholder);color:var(--ui5-avatar-placeholder-color);border-color:var(--ui5-avatar-placeholder-border-color)}:host([_has-image]){background-color:transparent;vertical-align:middle}.ui5-avatar-initials{color:inherit}.ui5-avatar-icon~.ui5-avatar-icon-fallback,.ui5-avatar-icon~.ui5-avatar-initials{display:none}.ui5-avatar-initials:not(.ui5-avatar-initials-hidden)+.ui5-avatar-icon-fallback{display:none}.ui5-avatar-initials-hidden{position:absolute;visibility:hidden;z-index:0;pointer-events:none}::slotted([slot=badge]){position:absolute;bottom:0;right:0;width:1.125rem;height:1.125rem;background:var(--sapButton_Emphasized_Background);border:var(--sapButton_Emphasized_Background);border-radius:1rem;color:var(--sapContent_BadgeTextColor);justify-content:center;font-family:"72override",var(--sapFontFamily);font-size:var(--sapFontSmallSize)}::slotted([ui5-badge][slot=badge]){padding:.1875rem}:host([_size=L]) ::slotted([slot=badge]),:host([size=L]) ::slotted([slot=badge]){width:1.25rem;height:1.25rem}:host([_size=XL]) ::slotted([slot=badge]),:host([size=XL]) ::slotted([slot=badge]){padding:.375rem;width:1.75rem;height:1.75rem}:host([shape=Square]) ::slotted([slot=badge]){bottom:-.125rem;right:-.125rem}:host([_size=L][shape=Square]) ::slotted([slot=badge]),:host([size=L][shape=Square]) ::slotted([slot=badge]){bottom:-.1875rem;right:-.1875rem}:host([_size=XL][shape=Square]) ::slotted([slot=badge]),:host([size=XL][shape=Square]) ::slotted([slot=badge]){bottom:-.25rem;right:-.25rem}' }, template: function(e3, t2, i2) {
  return XS`<div class="ui5-avatar-root" tabindex="${jS(this.tabindex)}" data-sap-focus-ref @keyup=${this._onkeyup} @keydown=${this._onkeydown} @focusout=${this._onfocusout} @focusin=${this._onfocusin} @click=${this._onclick} role="${jS(this._role)}" aria-haspopup="${jS(this._ariaHasPopup)}">${this.hasImage ? CD.call(this, e3, t2, i2) : SD.call(this, e3, t2, i2)}<slot name="badge"></slot></div>`;
}, dependencies: [WI] }), iS("click")], OD), OD.define();
const zD = OD;
function UD(e3, t2, i2) {
  return XS`${this.modeSingleSelect ? HD.call(this, e3, t2, i2) : void 0}${this.modeMultiSelect ? QD.call(this, e3, t2, i2) : void 0}${this.renderDeleteButton ? VD.call(this, e3, t2, i2) : void 0}`;
}
function HD(e3, t2, i2) {
  return i2 ? XS`<${ZS("ui5-radio-button", t2, i2)} ?disabled="${this.isInactive}" accessible-name="${jS(this._accInfo.ariaLabelRadioButton)}" tabindex="-1" id="${jS(this._id)}-singleSelectionElement" class="ui5-li-singlesel-radiobtn" ?checked="${this.selected}" @click="${this.onSingleSelectionComponentPress}"></${ZS("ui5-radio-button", t2, i2)}>` : XS`<ui5-radio-button ?disabled="${this.isInactive}" accessible-name="${jS(this._accInfo.ariaLabelRadioButton)}" tabindex="-1" id="${jS(this._id)}-singleSelectionElement" class="ui5-li-singlesel-radiobtn" ?checked="${this.selected}" @click="${this.onSingleSelectionComponentPress}"></ui5-radio-button>`;
}
function QD(e3, t2, i2) {
  return i2 ? XS`<${ZS("ui5-checkbox", t2, i2)} ?disabled="${this.isInactive}" ?indeterminate=${this.indeterminate} tabindex="-1" id="${jS(this._id)}-multiSelectionElement" class="ui5-li-multisel-cb" ?checked="${this.selected}" accessible-name="${jS(this._accInfo.ariaLabel)}" @click="${this.onMultiSelectionComponentPress}"></${ZS("ui5-checkbox", t2, i2)}>` : XS`<ui5-checkbox ?disabled="${this.isInactive}" ?indeterminate=${this.indeterminate} tabindex="-1" id="${jS(this._id)}-multiSelectionElement" class="ui5-li-multisel-cb" ?checked="${this.selected}" accessible-name="${jS(this._accInfo.ariaLabel)}" @click="${this.onMultiSelectionComponentPress}"></ui5-checkbox>`;
}
function VD(e3, t2, i2) {
  return XS`<div class="ui5-li-deletebtn">${this.hasDeleteButtonSlot ? GD.call(this, e3, t2, i2) : $D.call(this, e3, t2, i2)}</div>`;
}
function GD(e3, t2, i2) {
  return XS`<slot name="deleteButton"></slot>`;
}
function $D(e3, t2, i2) {
  return i2 ? XS`<${ZS("ui5-button", t2, i2)} tabindex="-1" data-sap-no-tab-ref id="${jS(this._id)}-deleteSelectionElement" design="Transparent" icon="decline" ?disabled="${this.disableDeleteButton}" @click="${this.onDelete}" tooltip="${jS(this.deleteText)}"></${ZS("ui5-button", t2, i2)}>` : XS`<ui5-button tabindex="-1" data-sap-no-tab-ref id="${jS(this._id)}-deleteSelectionElement" design="Transparent" icon="decline" ?disabled="${this.disableDeleteButton}" @click="${this.onDelete}" tooltip="${jS(this.deleteText)}"></ui5-button>`;
}
function WD(e3, t2, i2) {
  return XS`<div class="ui5-li-imgContent"><slot name="imageContent"></slot></div>`;
}
function qD(e3, t2, i2) {
  return XS`${this.displayImage ? jD.call(this, e3, t2, i2) : void 0}`;
}
function jD(e3, t2, i2) {
  return i2 ? XS`<${ZS("ui5-avatar", t2, i2)} shape="Square" class="ui5-li-img"><img src="${jS(this.image)}" class="ui5-li-img-inner" /></${ZS("ui5-avatar", t2, i2)}>` : XS`<ui5-avatar shape="Square" class="ui5-li-img"><img src="${jS(this.image)}" class="ui5-li-img-inner" /></ui5-avatar>`;
}
function XD(e3, t2, i2) {
  return i2 ? XS`<${ZS("ui5-icon", t2, i2)} part="icon" name="${jS(this.icon)}" class="ui5-li-icon" accessible-role="presentation" aria-hidden="true"></${ZS("ui5-icon", t2, i2)}>` : XS`<ui5-icon part="icon" name="${jS(this.icon)}" class="ui5-li-icon" accessible-role="presentation" aria-hidden="true"></ui5-icon>`;
}
function YD(e3, t2, i2) {
  return XS`<div class="ui5-li-description-info-wrapper"><span part="description" class="ui5-li-desc">${jS(this.description)}</span>${this.additionalText ? KD.call(this, e3, t2, i2) : void 0}</div>`;
}
function KD(e3, t2, i2) {
  return XS`<span part="additional-text" class="ui5-li-additional-text">${jS(this.additionalText)}</span>`;
}
function ZD(e3, t2, i2) {
  return XS`<span class="ui5-hidden-text">${jS(this.type)}</span>`;
}
function JD(e3, t2, i2) {
  return XS`${this.additionalText ? eL.call(this, e3, t2, i2) : void 0}`;
}
function eL(e3, t2, i2) {
  return XS`<span part="additional-text" class="ui5-li-additional-text">${jS(this.additionalText)}</span>`;
}
function tL(e3, t2, i2) {
  return i2 ? XS`<${ZS("ui5-icon", t2, i2)} part="icon" name="${jS(this.icon)}" class="ui5-li-icon" accessible-role="presentation" aria-hidden="true"></${ZS("ui5-icon", t2, i2)}>` : XS`<ui5-icon part="icon" name="${jS(this.icon)}" class="ui5-li-icon" accessible-role="presentation" aria-hidden="true"></ui5-icon>`;
}
function iL(e3, t2, i2) {
  return i2 ? XS`<div class="ui5-li-detailbtn"><${ZS("ui5-button", t2, i2)} design="Transparent" icon="edit" @click="${this.onDetailClick}"></${ZS("ui5-button", t2, i2)}></div>` : XS`<div class="ui5-li-detailbtn"><ui5-button design="Transparent" icon="edit" @click="${this.onDetailClick}"></ui5-button></div>`;
}
function nL(e3, t2, i2) {
  return i2 ? XS`<${ZS("ui5-icon", t2, i2)} name ="slim-arrow-right"></${ZS("ui5-icon", t2, i2)}>` : XS`<ui5-icon name ="slim-arrow-right"></ui5-icon>`;
}
function oL(e3, t2, i2) {
  return XS`<div class="ui5-li-navigated"></div>`;
}
function rL(e3, t2, i2) {
  return XS`${this.modeSingleSelect ? sL.call(this, e3, t2, i2) : void 0}${this.modeMultiSelect ? aL.call(this, e3, t2, i2) : void 0}${this.renderDeleteButton ? lL.call(this, e3, t2, i2) : void 0}`;
}
function sL(e3, t2, i2) {
  return i2 ? XS`<${ZS("ui5-radio-button", t2, i2)} ?disabled="${this.isInactive}" accessible-name="${jS(this._accInfo.ariaLabelRadioButton)}" tabindex="-1" id="${jS(this._id)}-singleSelectionElement" class="ui5-li-singlesel-radiobtn" ?checked="${this.selected}" @click="${this.onSingleSelectionComponentPress}"></${ZS("ui5-radio-button", t2, i2)}>` : XS`<ui5-radio-button ?disabled="${this.isInactive}" accessible-name="${jS(this._accInfo.ariaLabelRadioButton)}" tabindex="-1" id="${jS(this._id)}-singleSelectionElement" class="ui5-li-singlesel-radiobtn" ?checked="${this.selected}" @click="${this.onSingleSelectionComponentPress}"></ui5-radio-button>`;
}
function aL(e3, t2, i2) {
  return i2 ? XS`<${ZS("ui5-checkbox", t2, i2)} ?disabled="${this.isInactive}" ?indeterminate=${this.indeterminate} tabindex="-1" id="${jS(this._id)}-multiSelectionElement" class="ui5-li-multisel-cb" ?checked="${this.selected}" accessible-name="${jS(this._accInfo.ariaLabel)}" @click="${this.onMultiSelectionComponentPress}"></${ZS("ui5-checkbox", t2, i2)}>` : XS`<ui5-checkbox ?disabled="${this.isInactive}" ?indeterminate=${this.indeterminate} tabindex="-1" id="${jS(this._id)}-multiSelectionElement" class="ui5-li-multisel-cb" ?checked="${this.selected}" accessible-name="${jS(this._accInfo.ariaLabel)}" @click="${this.onMultiSelectionComponentPress}"></ui5-checkbox>`;
}
function lL(e3, t2, i2) {
  return XS`<div class="ui5-li-deletebtn">${this.hasDeleteButtonSlot ? cL.call(this, e3, t2, i2) : hL.call(this, e3, t2, i2)}</div>`;
}
function cL(e3, t2, i2) {
  return XS`<slot name="deleteButton"></slot>`;
}
function hL(e3, t2, i2) {
  return i2 ? XS`<${ZS("ui5-button", t2, i2)} tabindex="-1" data-sap-no-tab-ref id="${jS(this._id)}-deleteSelectionElement" design="Transparent" icon="decline" ?disabled="${this.disableDeleteButton}" @click="${this.onDelete}" tooltip="${jS(this.deleteText)}"></${ZS("ui5-button", t2, i2)}>` : XS`<ui5-button tabindex="-1" data-sap-no-tab-ref id="${jS(this._id)}-deleteSelectionElement" design="Transparent" icon="decline" ?disabled="${this.disableDeleteButton}" @click="${this.onDelete}" tooltip="${jS(this.deleteText)}"></ui5-button>`;
}
var uL = globalThis && globalThis.__decorate || function(e3, t2, i2, n2) {
  var o2, r2 = arguments.length, s2 = r2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s2 = Reflect.decorate(e3, t2, i2, n2);
  else
    for (var a2 = e3.length - 1; a2 >= 0; a2--)
      (o2 = e3[a2]) && (s2 = (r2 < 3 ? o2(s2) : r2 > 3 ? o2(t2, i2, s2) : o2(t2, i2)) || s2);
  return r2 > 3 && s2 && Object.defineProperty(t2, i2, s2), s2;
};
let dL = class extends xD {
  onBeforeRendering() {
    super.onBeforeRendering(), this.hasTitle = !!this.textContent, this._hasImageContent = this.hasImageContent;
  }
  get displayImage() {
    return !!this.image;
  }
  get displayIconBegin() {
    return !(!this.icon || this.iconEnd);
  }
  get displayIconEnd() {
    return !(!this.icon || !this.iconEnd);
  }
  get hasImageContent() {
    return !!this.imageContent.length;
  }
};
uL([tS()], dL.prototype, "description", void 0), uL([tS()], dL.prototype, "icon", void 0), uL([tS({ type: Boolean })], dL.prototype, "iconEnd", void 0), uL([tS()], dL.prototype, "image", void 0), uL([tS()], dL.prototype, "additionalText", void 0), uL([tS({ type: eB, defaultValue: eB.None })], dL.prototype, "additionalTextState", void 0), uL([tS()], dL.prototype, "accessibleName", void 0), uL([tS({ type: NT, defaultValue: NT.None })], dL.prototype, "wrappingType", void 0), uL([tS({ type: Boolean })], dL.prototype, "hasTitle", void 0), uL([tS({ type: Boolean })], dL.prototype, "_hasImageContent", void 0), uL([nS()], dL.prototype, "imageContent", void 0), dL = uL([eS({ tag: "ui5-li", template: function(e3, t2, i2) {
  return XS`<li part="native-li" data-sap-focus-ref tabindex="${jS(this._effectiveTabIndex)}" class="${WS(this.classes.main)}" @focusin="${this._onfocusin}" @focusout="${this._onfocusout}" @keyup="${this._onkeyup}" @keydown="${this._onkeydown}" @mouseup="${this._onmouseup}" @mousedown="${this._onmousedown}" @touchstart="${this._ontouchstart}" @touchend="${this._ontouchend}" @click="${this._onclick}" role="${jS(this._accInfo.role)}" aria-expanded="${jS(this._accInfo.ariaExpanded)}" title="${jS(this.title)}" aria-level="${jS(this._accInfo.ariaLevel)}" aria-haspopup="${jS(this._accInfo.ariaHaspopup)}" aria-posinset="${jS(this._accInfo.posinset)}" aria-roledescription="${jS(this.accessibleRoleDescription)}" aria-setsize="${jS(this._accInfo.setsize)}" aria-describedby="${jS(this._id)}-invisibleText-describedby" aria-labelledby="${jS(this._accessibleNameRef)}" aria-disabled="${jS(this._ariaDisabled)}" aria-selected="${jS(this._accInfo.ariaSelected)}" aria-checked="${jS(this._accInfo.ariaChecked)}" aria-owns="${jS(this._accInfo.ariaOwns)}">${this.placeSelectionElementBefore ? UD.call(this, e3, t2, i2) : void 0}<div id="${jS(this._id)}-content" class="ui5-li-content">${this.hasImageContent ? WD.call(this, e3, t2, i2) : qD.call(this, e3, t2, i2)}${this.displayIconBegin ? XD.call(this, e3, t2, i2) : void 0}<div class="ui5-li-text-wrapper"><span part="title" class="ui5-li-title"><slot></slot></span>${this.description ? YD.call(this, e3, t2, i2) : void 0}${this.typeActive ? void 0 : ZD.call(this, e3, t2, i2)}</div>${this.description ? void 0 : JD.call(this, e3, t2, i2)}</div>${this.displayIconEnd ? tL.call(this, e3, t2, i2) : void 0}${this.typeDetail ? iL.call(this, e3, t2, i2) : void 0}${this.typeNavigation ? nL.call(this, e3, t2, i2) : void 0}${this.navigated ? oL.call(this, e3, t2, i2) : void 0}${this.placeSelectionElementAfter ? rL.call(this, e3, t2, i2) : void 0}<span id="${jS(this._id)}-invisibleText" class="ui5-hidden-text">${jS(this._accInfo.listItemAriaLabel)}${jS(this.accessibleName)}</span><span id="${jS(this._id)}-invisibleText-describedby" class="ui5-hidden-text">${jS(this._accInfo.ariaSelectedText)}</span></li> `;
}, dependencies: [...xD.dependencies, WI, zD] })], dL), dL.define();
var pL = Object.defineProperty, _L = Object.getOwnPropertyDescriptor, gL = (e3, t2, i2, n2) => {
  for (var o2, r2 = n2 > 1 ? void 0 : n2 ? _L(t2, i2) : t2, s2 = e3.length - 1; s2 >= 0; s2--)
    (o2 = e3[s2]) && (r2 = (n2 ? o2(t2, i2, r2) : o2(r2)) || r2);
  return n2 && r2 && pL(t2, i2, r2), r2;
};
let mL = class extends yT {
  constructor() {
    super(...arguments), this.isColumnMode = false;
  }
  render() {
    return z`
      <div id="layout" class="${this.isColumnMode ? "ver-orientation" : "hor-orientation"}">
        <div class="alignCenter ${this.isColumnMode ? "ver-orientation" : "hor-orientation"}" >
            <ui5-button 
              @click="${this._handleNewPathClicked}" >New</ui5-button>
        </div>
        <div class="alignCenter ${this.isColumnMode ? "ver-orientation" : "hor-orientation"}" >
          <ui5-label level="H1">&Sigma;:</ui5-label>
          <ui5-label>${this.measurementTool.measuredLength.toFixed(1)}</ui5-label> 
          <ui5-label> mm</ui5-label>
        </div>
        <div class="alignCenter ${this.isColumnMode ? "ver-orientation" : "hor-orientation"}" >
            <ui5-button 
              ?disabled="${!this.measurementTool.isEditModeActive && 0 == this.measurementTool.numPoints}"
               @click="${this._handleUpdateEditStateClicked}" >${this.measurementTool.isEditModeActive ? "Stop" : "Continue"}</ui5-button>
        </div>
      </div>
        `;
  }
  firstUpdated() {
    this.measurementTool.on("update-requested", () => this.requestUpdate());
  }
  updated(e3) {
    super.updated(e3), e3.has("isSelected") && (this.measurementTool.isActive = this.isSelected);
  }
  _handleNewPathClicked() {
    this.measurementTool.resetPoints(), this.measurementTool.isEditModeActive = true, this.requestUpdate();
  }
  _handleUpdateEditStateClicked() {
    this.measurementTool.isEditModeActive = !this.measurementTool.isEditModeActive, this.requestUpdate();
  }
};
mL.styles = r`
    :host {
      height: 100%;
      width: 100%;
    }

    #layout.ver-orientation{
      flex-direction: column;
      width: 100%;
    }

    #layout.hor-orientation{
      flex-direction: row;
      height: 100%;
    }

    #layout{
      position: relative;
      display: flex;
      align-items: stretch;
      gap: 1rem;
    }

    
    .alignCenter.ver-orientation{
      width: 100%;
      justify-content: center;
    }

    .alignCenter.hor-orientation{
      height: 100%;
      align-items: center;
    }

    .alignCenter
    {
      display: flex;
    }

    ui5-button{
      padding: 0.25rem;
    }

    ui5-label{
      --sapFontSize: 15;
    }

  `, gL([ue({ type: Boolean })], mL.prototype, "isColumnMode", 2), gL([ue({ type: Object })], mL.prototype, "measurementTool", 2), mL = gL([ce("measurement-tool")], mL);
var fL = Object.defineProperty, vL = Object.getOwnPropertyDescriptor, AL = (e3, t2, i2, n2) => {
  for (var o2, r2 = n2 > 1 ? void 0 : n2 ? vL(t2, i2) : t2, s2 = e3.length - 1; s2 >= 0; s2--)
    (o2 = e3[s2]) && (r2 = (n2 ? o2(t2, i2, r2) : o2(r2)) || r2);
  return n2 && r2 && fL(t2, i2, r2), r2;
};
const bL = { doubleview: () => Ly('<?xml version="1.0" encoding="utf-8"?>\n<!-- Generator: Adobe Illustrator 16.0.3, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n<g id="double_view">\n	<g>	\n		<path d="M28.347,56.693h226.771v4h-226.77z"/>\n		<path d="M28.347,56.693v170.079h4v-170.079z"/>\n		<path d="M255.118,226.772h-226.771v4h226.77z"/>\n		<path d="M255.118,226.772v-170.079h-4v170.079z"/>\n	</g>\n	<g>\n		<path d="M76.136,141.443c1.634,1.878,2.45,4.154,2.45,6.823c0,2.177-0.588,4.194-1.765,6.057\n			c-1.177,1.863-2.968,3.365-5.373,4.505c-2.406,1.143-5.383,1.711-8.93,1.711c-2.6,0-5.172-0.314-7.718-0.945\n			c-2.547-0.633-4.75-1.528-6.612-2.688l3.793-7.848c1.44,0.981,3.063,1.737,4.873,2.263c1.809,0.529,3.59,0.791,5.348,0.791\n			c1.791,0,3.213-0.334,4.267-0.999c1.054-0.668,1.58-1.616,1.58-2.845c0-2.391-1.879-3.583-5.637-3.583H58.04v-6.586l6.585-7.112\n			h-14.54v-8.061h26.657v6.533l-7.639,8.217C72.159,138.309,74.504,139.564,76.136,141.443z"/>\n		<path d="M83.854,122.925h17.438c4.038,0,7.621,0.756,10.747,2.266c3.124,1.51,5.549,3.653,7.27,6.427\n			c1.72,2.775,2.581,6.023,2.581,9.746c0,3.724-0.86,6.972-2.581,9.747c-1.72,2.771-4.146,4.916-7.27,6.426\n			c-3.126,1.51-6.709,2.266-10.747,2.266H83.854V122.925z M100.871,151.478c3.161,0,5.698-0.896,7.612-2.688\n			s2.871-4.267,2.871-7.428c0-3.162-0.957-5.637-2.871-7.428c-1.914-1.792-4.451-2.687-7.612-2.687h-6.585v20.229L100.871,151.478\n			L100.871,151.478z"/>\n	</g>\n	<g>\n		<path d="M192.225,152.283v8.282h-28.752v-6.541l13.821-12.924c1.336-1.266,2.232-2.347,2.69-3.246\n			c0.456-0.897,0.685-1.802,0.685-2.716c0-1.195-0.402-2.128-1.211-2.796c-0.81-0.668-1.988-1.002-3.535-1.002\n			c-1.371,0-2.629,0.308-3.771,0.923c-1.145,0.616-2.084,1.504-2.822,2.664l-7.754-4.326c1.439-2.392,3.463-4.274,6.065-5.645\n			s5.68-2.057,9.231-2.057c2.813,0,5.303,0.458,7.465,1.371c2.164,0.915,3.853,2.226,5.063,3.931\n			c1.215,1.706,1.823,3.685,1.823,5.935c0,2.004-0.432,3.896-1.294,5.671c-0.862,1.777-2.524,3.791-4.985,6.041l-6.965,6.437h14.245\n			V152.283z"/>\n		<path d="M197.186,123.637h17.461c4.045,0,7.632,0.756,10.763,2.269c3.131,1.512,5.559,3.659,7.28,6.436\n			c1.724,2.78,2.585,6.033,2.585,9.76c0,3.729-0.861,6.981-2.585,9.76s-4.149,4.923-7.28,6.437\n			c-3.131,1.512-6.718,2.268-10.763,2.268h-17.461V123.637z M214.226,152.23c3.165,0,5.706-0.896,7.623-2.689\n			c1.917-1.795,2.874-4.271,2.874-7.438s-0.957-5.645-2.874-7.438s-4.458-2.691-7.623-2.691h-6.596v20.258L214.226,152.23\n			L214.226,152.23z"/>\n	</g>\n	<line stroke-width="2" stroke-miterlimit="10" x1="141.732" y1="56.693" x2="141.732" y2="226.772"/>\n</g>\n'), "doubleview-mobile": () => Ly('<?xml version="1.0" encoding="utf-8"?>\n<!-- Generator: Adobe Illustrator 16.0.3, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n<g id="double_view_mobile">\n		<rect x="56.693" y="28.347" fill="none" stroke-width="4" stroke-miterlimit="10" width="170.079" height="226.771"/>\n	<g>\n		<path d="M132.829,84.75c1.634,1.878,2.45,4.154,2.45,6.823c0,2.177-0.588,4.194-1.765,6.057c-1.177,1.863-2.969,3.365-5.373,4.505\n			c-2.406,1.142-5.384,1.711-8.93,1.711c-2.6,0-5.172-0.315-7.718-0.946c-2.548-0.633-4.751-1.528-6.612-2.688l3.793-7.848\n			c1.44,0.982,3.063,1.737,4.873,2.263c1.809,0.529,3.591,0.791,5.349,0.791c1.79,0,3.213-0.334,4.267-0.999\n			c1.054-0.668,1.58-1.617,1.58-2.845c0-2.39-1.88-3.583-5.638-3.583h-4.372v-6.586l6.586-7.111h-14.541v-8.061h26.657v6.533\n			l-7.639,8.217C128.853,81.617,131.197,82.873,132.829,84.75z"/>\n		<path d="M140.547,66.233h17.439c4.037,0,7.621,0.756,10.746,2.266c3.125,1.51,5.551,3.652,7.27,6.427\n			c1.722,2.775,2.582,6.023,2.582,9.746c0,3.723-0.86,6.972-2.582,9.747c-1.719,2.772-4.145,4.917-7.27,6.426\n			c-3.125,1.509-6.709,2.265-10.746,2.265h-17.439V66.233z M157.564,94.786c3.16,0,5.697-0.896,7.611-2.687s2.871-4.267,2.871-7.428\n			c0-3.161-0.957-5.637-2.871-7.428c-1.914-1.792-4.451-2.687-7.611-2.687h-6.586v20.229L157.564,94.786L157.564,94.786z"/>\n	</g>\n	<g>\n		<path d="M135.532,208.976v8.281H106.78v-6.541l13.821-12.924c1.337-1.268,2.233-2.349,2.691-3.246\n			c0.456-0.896,0.685-1.803,0.685-2.717c0-1.194-0.403-2.127-1.212-2.797c-0.809-0.668-1.988-1.002-3.535-1.002\n			c-1.371,0-2.629,0.309-3.771,0.924c-1.144,0.615-2.084,1.504-2.822,2.664l-7.755-4.326c1.44-2.392,3.464-4.273,6.066-5.646\n			c2.602-1.372,5.68-2.058,9.232-2.058c2.813,0,5.303,0.457,7.465,1.371c2.163,0.916,3.852,2.227,5.063,3.932\n			c1.215,1.706,1.823,3.686,1.823,5.936c0,2.004-0.432,3.896-1.294,5.672c-0.862,1.776-2.524,3.791-4.985,6.041l-6.965,6.436\n			H135.532z"/>\n		<path d="M140.493,180.33h17.461c4.045,0,7.631,0.756,10.762,2.27c3.131,1.512,5.559,3.658,7.281,6.436\n			c1.724,2.78,2.584,6.033,2.584,9.762s-0.86,6.98-2.584,9.761c-1.724,2.778-4.15,4.923-7.281,6.437\n			c-3.131,1.512-6.717,2.268-10.762,2.268h-17.461V180.33z M157.535,208.923c3.164,0,5.705-0.896,7.623-2.69\n			c1.916-1.794,2.873-4.271,2.873-7.438c0-3.166-0.957-5.645-2.873-7.438c-1.918-1.793-4.459-2.691-7.623-2.691h-6.597v20.26h6.597\n			V208.923z"/>\n	</g>\n	<line stroke-width="2" stroke-miterlimit="10" x1="226.772" y1="141.733" x2="56.692" y2="141.733"/>\n</g>'), singleview: () => Ly('<?xml version="1.0" encoding="utf-8"?>\n<!-- Generator: Adobe Illustrator 16.0.3, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n<g>	\n	<path d="M28.347,56.693h226.771v4h-226.77z"/>\n	<path d="M28.347,56.693v170.079h4v-170.079z"/>\n	<path d="M255.118,226.772h-226.771v4h226.77z"/>\n	<path d="M255.118,226.772v-170.079h-4v170.079z"/>\n</g>\n<g>\n	<path d="M84.09,100.5c1.634,1.879,2.45,4.154,2.45,6.822c0,2.179-0.588,4.198-1.765,6.058c-1.177,1.863-2.968,3.364-5.373,4.505\n		c-2.406,1.141-5.383,1.712-8.93,1.712c-2.6,0-5.172-0.316-7.718-0.949c-2.547-0.631-4.75-1.527-6.612-2.686l3.793-7.851\n		c1.44,0.985,3.063,1.739,4.873,2.266c1.809,0.526,3.59,0.791,5.348,0.791c1.791,0,3.213-0.333,4.267-1.002\n		c1.054-0.666,1.58-1.614,1.58-2.845c0-2.388-1.879-3.582-5.637-3.582h-4.372v-6.586l6.585-7.111h-14.54v-8.061h26.657v6.533\n		l-7.639,8.218C80.113,97.366,82.458,98.622,84.09,100.5z"/>\n	<path d="M91.808,81.982h17.438c4.038,0,7.621,0.756,10.747,2.266c3.124,1.51,5.549,3.653,7.269,6.427\n		c1.721,2.775,2.581,6.023,2.581,9.746s-0.86,6.972-2.581,9.746c-1.72,2.775-4.145,4.918-7.269,6.427\n		c-3.126,1.511-6.709,2.266-10.747,2.266H91.808V81.982z M108.824,110.536c3.161,0,5.697-0.895,7.612-2.686\n		c1.914-1.792,2.871-4.268,2.871-7.428c0-3.161-0.957-5.637-2.871-7.428c-1.915-1.792-4.451-2.687-7.612-2.687h-6.585v20.229\n		H108.824z"/>\n</g>\n<g>\n	<line stroke-width="3" stroke-miterlimit="10" stroke-dasharray="9.9442,4.9721" x1="36.324" y1="220.789" x2="249.128" y2="61.185"/>\n</g>\n<g>\n	<path d="M184.332,193.225v8.282H155.58v-6.541l13.821-12.926c1.337-1.266,2.233-2.349,2.69-3.244\n		c0.457-0.897,0.686-1.803,0.686-2.717c0-1.194-0.402-2.127-1.212-2.797c-0.81-0.668-1.987-1.004-3.535-1.004\n		c-1.37,0-2.629,0.309-3.771,0.924c-1.145,0.618-2.084,1.506-2.822,2.666l-7.755-4.326c1.44-2.392,3.464-4.272,6.065-5.646\n		c2.604-1.371,5.68-2.058,9.232-2.058c2.813,0,5.303,0.457,7.465,1.371c2.164,0.916,3.852,2.226,5.063,3.932\n		c1.216,1.706,1.824,3.686,1.824,5.934c0,2.004-0.433,3.896-1.295,5.672c-0.861,1.776-2.523,3.791-4.984,6.041l-6.965,6.437H184.332\n		L184.332,193.225z"/>\n	<path d="M189.292,164.58h17.461c4.045,0,7.632,0.756,10.763,2.269c3.13,1.513,5.558,3.657,7.28,6.437\n		c1.724,2.778,2.584,6.031,2.584,9.76c0,3.729-0.86,6.981-2.584,9.762c-1.724,2.777-4.15,4.923-7.28,6.436\n		c-3.131,1.512-6.718,2.269-10.763,2.269h-17.461V164.58z M206.333,193.171c3.164,0,5.705-0.896,7.621-2.689\n		c1.918-1.794,2.875-4.271,2.875-7.439c0-3.164-0.957-5.644-2.875-7.438c-1.916-1.794-4.457-2.691-7.621-2.691h-6.599v20.26h6.599\n		V193.171z"/>\n</g>\n'), "singleview-mobile": () => Ly('<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n<g>\n    <g transform="matrix(1,0,0,1,20.1202,-17.6776)">\n        <path d="M84.09,100.5C85.724,102.379 86.54,104.654 86.54,107.322C86.54,109.501 85.952,111.52 84.775,113.38C83.598,115.243 81.807,116.744 79.402,117.885C76.996,119.026 74.019,119.597 70.472,119.597C67.872,119.597 65.3,119.281 62.754,118.648C60.207,118.017 58.004,117.121 56.142,115.962L59.935,108.111C61.375,109.096 62.998,109.85 64.808,110.377C66.617,110.903 68.398,111.168 70.156,111.168C71.947,111.168 73.369,110.835 74.423,110.166C75.477,109.5 76.003,108.552 76.003,107.321C76.003,104.933 74.124,103.739 70.366,103.739L65.994,103.739L65.994,97.153L72.579,90.042L58.039,90.042L58.039,81.981L84.696,81.981L84.696,88.514L77.057,96.732C80.113,97.366 82.458,98.622 84.09,100.5Z" style="fill-rule:nonzero;"/>\n    </g>\n    <g transform="matrix(1,0,0,1,20.1202,-17.6776)">\n        <path d="M91.808,81.982L109.246,81.982C113.284,81.982 116.867,82.738 119.993,84.248C123.117,85.758 125.542,87.901 127.262,90.675C128.983,93.45 129.843,96.698 129.843,100.421C129.843,104.144 128.983,107.393 127.262,110.167C125.542,112.942 123.117,115.085 119.993,116.594C116.867,118.105 113.284,118.86 109.246,118.86L91.808,118.86L91.808,81.982ZM108.824,110.536C111.985,110.536 114.521,109.641 116.436,107.85C118.35,106.058 119.307,103.582 119.307,100.422C119.307,97.261 118.35,94.785 116.436,92.994C114.521,91.202 111.985,90.307 108.824,90.307L102.239,90.307L102.239,110.536L108.824,110.536Z" style="fill-rule:nonzero;"/>\n    </g>\n</g>\n<g transform="matrix(0.992491,-0.32133,0.25458,0.992398,-36.1177,47.6794)">\n    <g>\n        <path d="M36.324,220.789L249.128,61.185" stroke-width="3" stroke-miterlimit="10" stroke-dasharray="9.9442,4.9721"/>\n    </g>\n</g>\n<g>\n    <g transform="matrix(1,0,0,1,-19.0438,15.0153)">\n        <path d="M184.332,193.225L184.332,201.507L155.58,201.507L155.58,194.966L169.401,182.04C170.738,180.774 171.634,179.691 172.091,178.796C172.548,177.899 172.777,176.993 172.777,176.079C172.777,174.885 172.375,173.952 171.565,173.282C170.755,172.614 169.578,172.278 168.03,172.278C166.66,172.278 165.401,172.587 164.259,173.202C163.114,173.82 162.175,174.708 161.437,175.868L153.682,171.542C155.122,169.15 157.146,167.27 159.747,165.896C162.351,164.525 165.427,163.838 168.979,163.838C171.792,163.838 174.282,164.295 176.444,165.209C178.608,166.125 180.296,167.435 181.507,169.141C182.723,170.847 183.331,172.827 183.331,175.075C183.331,177.079 182.898,178.971 182.036,180.747C181.175,182.523 179.513,184.538 177.052,186.788L170.087,193.225L184.332,193.225Z" style="fill-rule:nonzero;"/>\n    </g>\n    <g transform="matrix(1,0,0,1,-19.0438,15.0153)">\n        <path d="M189.292,164.58L206.753,164.58C210.798,164.58 214.385,165.336 217.516,166.849C220.646,168.362 223.074,170.506 224.796,173.286C226.52,176.064 227.38,179.317 227.38,183.046C227.38,186.775 226.52,190.027 224.796,192.808C223.072,195.585 220.646,197.731 217.516,199.244C214.385,200.756 210.798,201.513 206.753,201.513L189.292,201.513L189.292,164.58ZM206.333,193.171C209.497,193.171 212.038,192.275 213.954,190.482C215.872,188.688 216.829,186.211 216.829,183.043C216.829,179.879 215.872,177.399 213.954,175.605C212.038,173.811 209.497,172.914 206.333,172.914L199.734,172.914L199.734,193.174L206.333,193.174L206.333,193.171Z" style="fill-rule:nonzero;"/>\n    </g>\n</g>\n<g>\n    <rect x="56.693" y="28.347" width="170.079" height="226.771" stroke-width="4" fill="none"/>\n</g>\n'), "doubleview-synced": () => Ly('<?xml version="1.0" encoding="utf-8"?>\n<!-- Generator: Adobe Illustrator 16.0.3, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n<g id="double_view_synced">\n	<g>	\n		<path d="M28.347,56.693h226.771v4h-226.77z"/>\n		<path d="M28.347,56.693v170.079h4v-170.079z"/>\n		<path d="M255.118,226.772h-226.771v4h226.77z"/>\n		<path d="M255.118,226.772v-170.079h-4v170.079z"/>\n	</g>\n	<g>\n		<path d="M76.136,141.443c1.634,1.878,2.45,4.154,2.45,6.823c0,2.177-0.588,4.194-1.765,6.057\n			c-1.177,1.863-2.968,3.365-5.373,4.505c-2.406,1.143-5.383,1.711-8.93,1.711c-2.6,0-5.172-0.314-7.718-0.945\n			c-2.547-0.633-4.75-1.528-6.612-2.688l3.793-7.848c1.44,0.981,3.063,1.737,4.873,2.263c1.809,0.529,3.59,0.791,5.348,0.791\n			c1.791,0,3.213-0.334,4.267-0.999c1.054-0.668,1.58-1.616,1.58-2.845c0-2.391-1.879-3.583-5.637-3.583H58.04v-6.586l6.585-7.112\n			h-14.54v-8.061h26.657v6.533l-7.639,8.217C72.159,138.309,74.504,139.564,76.136,141.443z"/>\n		<path d="M83.854,122.925h17.438c4.038,0,7.621,0.756,10.747,2.266c3.124,1.51,5.549,3.653,7.27,6.427\n			c1.72,2.775,2.581,6.023,2.581,9.746c0,3.724-0.86,6.972-2.581,9.747c-1.72,2.771-4.146,4.916-7.27,6.426\n			c-3.126,1.51-6.709,2.266-10.747,2.266H83.854V122.925z M100.871,151.478c3.161,0,5.698-0.896,7.612-2.688\n			s2.871-4.267,2.871-7.428c0-3.162-0.957-5.637-2.871-7.428c-1.914-1.792-4.451-2.687-7.612-2.687h-6.585v20.229L100.871,151.478\n			L100.871,151.478z"/>\n	</g>\n	<g>\n		<path d="M192.225,152.283v8.282h-28.752v-6.541l13.821-12.924c1.336-1.266,2.232-2.347,2.69-3.246\n			c0.456-0.897,0.685-1.802,0.685-2.716c0-1.195-0.402-2.128-1.211-2.796c-0.81-0.668-1.988-1.002-3.535-1.002\n			c-1.371,0-2.629,0.308-3.771,0.923c-1.145,0.616-2.084,1.504-2.822,2.664l-7.754-4.326c1.439-2.392,3.463-4.274,6.065-5.645\n			s5.68-2.057,9.231-2.057c2.813,0,5.303,0.458,7.465,1.371c2.164,0.915,3.853,2.226,5.063,3.931\n			c1.215,1.706,1.823,3.685,1.823,5.935c0,2.004-0.432,3.896-1.294,5.671c-0.862,1.777-2.524,3.791-4.985,6.041l-6.965,6.437h14.245\n			V152.283z"/>\n		<path d="M197.186,123.637h17.461c4.045,0,7.632,0.756,10.763,2.269c3.131,1.512,5.559,3.659,7.28,6.436\n			c1.724,2.78,2.585,6.033,2.585,9.76c0,3.729-0.861,6.981-2.585,9.76s-4.149,4.923-7.28,6.437\n			c-3.131,1.512-6.718,2.268-10.763,2.268h-17.461V123.637z M214.226,152.23c3.165,0,5.706-0.896,7.623-2.689\n			c1.917-1.795,2.874-4.271,2.874-7.438s-0.957-5.645-2.874-7.438s-4.458-2.691-7.623-2.691h-6.596v20.258L214.226,152.23\n			L214.226,152.23z"/>\n	</g>\n	<line stroke-width="2" stroke-miterlimit="10" x1="141.732" y1="56.693" x2="141.732" y2="226.772"/>\n	<path d="M171.183,87.604c-4.617-7.616-11.391-13.276-19.449-16.142c-9.447-3.359-19.521-2.491-28.371,2.445\n		c-8.85,4.936-15.413,13.347-18.481,23.685l8.746,3.109c2.31-7.78,7.25-14.11,13.911-17.827c6.661-3.715,14.245-4.369,21.354-1.84\n		c5.717,2.034,10.555,5.953,14.004,11.192l-7.537,4.204l10.929,7.769l10.935,7.771l0.679-14.248l0.684-14.244L171.183,87.604z"/>\n	<path d="M112.281,195.862c4.618,7.616,11.388,13.276,19.45,16.144c9.446,3.357,19.522,2.49,28.372-2.445\n		s15.413-13.348,18.479-23.686l-8.744-3.108c-2.31,7.78-7.25,14.11-13.91,17.825c-6.66,3.716-14.246,4.369-21.355,1.844\n		c-5.716-2.035-10.552-5.955-14.002-11.193l7.538-4.203l-10.931-7.77l-10.933-7.771l-0.679,14.246l-0.684,14.248L112.281,195.862z"\n		/>\n</g>\n'), "doubleview-synced-mobile": () => Ly('<?xml version="1.0" encoding="utf-8"?>\n<!-- Generator: Adobe Illustrator 16.0.3, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n<g id="double_view_synced_mobile">\n		<rect x="56.693" y="28.347" fill="none" stroke-width="4" stroke-miterlimit="10" width="170.079" height="226.771"/>\n	<g>\n		<path d="M132.829,70.578c1.634,1.878,2.45,4.154,2.45,6.823c0,2.177-0.588,4.194-1.765,6.057\n			c-1.177,1.863-2.969,3.365-5.373,4.505c-2.406,1.142-5.384,1.711-8.93,1.711c-2.6,0-5.172-0.315-7.718-0.946\n			c-2.548-0.633-4.751-1.528-6.612-2.688l3.793-7.848c1.44,0.982,3.063,1.737,4.873,2.263c1.809,0.529,3.591,0.791,5.349,0.791\n			c1.79,0,3.213-0.334,4.267-0.999c1.054-0.668,1.58-1.617,1.58-2.845c0-2.39-1.88-3.583-5.638-3.583h-4.372v-6.586l6.586-7.111\n			h-14.541V52.06h26.657v6.533l-7.639,8.217C128.853,67.444,131.197,68.7,132.829,70.578z"/>\n		<path d="M140.547,52.06h17.439c4.037,0,7.621,0.756,10.746,2.266c3.125,1.51,5.551,3.652,7.27,6.427\n			c1.722,2.775,2.582,6.023,2.582,9.746s-0.86,6.972-2.582,9.747c-1.719,2.772-4.145,4.917-7.27,6.426\n			c-3.125,1.509-6.709,2.265-10.746,2.265h-17.439V52.06z M157.564,80.613c3.16,0,5.697-0.896,7.611-2.687\n			c1.914-1.791,2.871-4.267,2.871-7.428s-0.957-5.637-2.871-7.428c-1.914-1.792-4.451-2.687-7.611-2.687h-6.586v20.229\n			L157.564,80.613L157.564,80.613z"/>\n	</g>\n	<g>\n		<path d="M135.532,223.15v8.282H106.78v-6.542l13.821-12.924c1.337-1.268,2.233-2.348,2.691-3.246\n			c0.456-0.896,0.685-1.803,0.685-2.717c0-1.194-0.403-2.127-1.212-2.797c-0.809-0.668-1.988-1.002-3.535-1.002\n			c-1.371,0-2.629,0.309-3.771,0.924c-1.144,0.615-2.084,1.504-2.822,2.664l-7.755-4.326c1.44-2.391,3.464-4.273,6.066-5.646\n			c2.602-1.372,5.68-2.057,9.232-2.057c2.813,0,5.303,0.457,7.465,1.371c2.163,0.915,3.852,2.226,5.063,3.931\n			c1.215,1.706,1.823,3.686,1.823,5.936c0,2.004-0.432,3.896-1.294,5.672c-0.862,1.777-2.524,3.791-4.985,6.041l-6.965,6.436\n			H135.532z"/>\n		<path d="M140.493,194.503h17.461c4.045,0,7.631,0.756,10.762,2.269s5.559,3.658,7.281,6.437c1.724,2.779,2.584,6.033,2.584,9.761\n			c0,3.729-0.86,6.981-2.584,9.761c-1.724,2.777-4.15,4.923-7.281,6.436s-6.717,2.269-10.762,2.269h-17.461V194.503z\n			 M157.535,223.097c3.164,0,5.705-0.896,7.623-2.69c1.916-1.794,2.873-4.271,2.873-7.438s-0.957-5.646-2.873-7.438\n			c-1.918-1.793-4.459-2.691-7.623-2.691h-6.597v20.26h6.597V223.097z"/>\n	</g>\n	<line  stroke-width="2" stroke-miterlimit="10" x1="226.772" y1="141.733" x2="56.692" y2="141.733"/>\n	<path d="M195.861,171.183c7.616-4.617,13.276-11.391,16.143-19.449c3.359-9.447,2.492-19.521-2.444-28.371\n		c-4.937-8.85-13.349-15.413-23.685-18.481l-3.109,8.746c7.779,2.31,14.109,7.249,17.826,13.911\n		c3.716,6.661,4.369,14.245,1.841,21.354c-2.034,5.717-5.953,10.555-11.192,14.004l-4.203-7.537l-7.77,10.929l-7.771,10.935\n		l14.248,0.679l14.243,0.684L195.861,171.183z"/>\n	<path d="M87.603,112.282c-7.616,4.617-13.276,11.388-16.143,19.449c-3.358,9.446-2.49,19.522,2.445,28.372\n		c4.936,8.85,13.347,15.413,23.685,18.479l3.109-8.744c-7.78-2.31-14.11-7.25-17.826-13.91c-3.715-6.66-4.369-14.245-1.843-21.354\n		c2.035-5.717,5.955-10.553,11.193-14.002l4.204,7.538l7.769-10.932l7.771-10.933l-14.246-0.679l-14.247-0.685L87.603,112.282z"/>\n</g>\n'), rotation: () => Ly('<?xml version="1.0" encoding="utf-8"?>\n<!-- Generator: Adobe Illustrator 16.0.3, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n<g id="Ebene_2_Kopie">\n	\n		<line fill="none" stroke-width="15" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" x1="28.347" y1="255.121" x2="28.347" y2="28.344"/>\n	\n		<line fill="none" stroke-width="15" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" x1="28.342" y1="255.121" x2="255.119" y2="255.121"/>\n	\n		<line fill="none" stroke-width="15" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" x1="28.342" y1="255.121" x2="221.982" y2="61.482"/>\n	<g>\n		<path d="M202.653,96.368l-7.829,7.829c4.909,5.954,8.646,12.978,10.756,20.852c8.142,30.384-10.805,61.953-42.229,70.373\n			l-3.644-13.592l-28.735,27.984l38.878,9.863l-3.643-13.596c37.303-9.994,59.748-47.629,50.031-83.89\n			C213.609,112.381,208.876,103.672,202.653,96.368z"/>\n		<path d="M177.707,90.202l8.084-8.083c-15.77-9.456-35.422-12.758-54.826-7.559c-17.677,4.736-32.636,15.802-42.119,31.156\n			l9.388,5.8c8-12.952,20.639-22.291,35.587-26.297C149.246,81.085,164.847,83.297,177.707,90.202z"/>\n	</g>\n</g>\n</svg>\n'), measure: () => Ly('<?xml version="1.0" encoding="utf-8"?>\n<!-- Generator: Adobe Illustrator 16.0.3, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n\n<g>\n	<g>\n		<line fill="none" stroke-width="10" stroke-miterlimit="10" x1="56.692" y1="204.288" x2="56.692" y2="232.538"/>\n		\n			<line fill="none" stroke-width="10" stroke-miterlimit="10" x1="113.385" y1="204.288" x2="113.385" y2="232.538"/>\n		<line fill="none" stroke-width="10" stroke-miterlimit="10" x1="170.08" y1="204.288" x2="170.08" y2="232.538"/>\n		\n			<line fill="none" stroke-width="7" stroke-miterlimit="10" x1="141.732" y1="204.287" x2="141.732" y2="221.237"/>\n		<line fill="none" stroke-width="7" stroke-miterlimit="10" x1="85.039" y1="204.287" x2="85.039" y2="221.237"/>\n		<g>\n			<path fill="none" stroke-width="10" stroke-miterlimit="10" d="M216.394,246.657l-24.545-42.369H14.173v56.5\n				h226.772c0.127,0,0.25-0.008,0.375-0.01C231.4,260.901,221.707,255.827,216.394,246.657z"/>\n		</g>\n	</g>\n	<g>\n		<line fill="none" stroke-width="10" stroke-miterlimit="10" x1="173.365" y1="59.376" x2="148.816" y2="73.501"/>\n		\n			<line fill="none" stroke-width="10" stroke-miterlimit="10" x1="201.71" y1="108.308" x2="177.164" y2="122.434"/>\n		\n			<line fill="none"  stroke-width="10" stroke-miterlimit="10" x1="230.056" y1="157.242" x2="205.509" y2="171.368"/>\n		\n			<line fill="none" stroke-width="7" stroke-miterlimit="10" x1="215.884" y1="132.773" x2="201.156" y2="141.25"/>\n		<line fill="none" stroke-width="7" stroke-miterlimit="10" x1="187.539" y1="83.841" x2="172.808" y2="92.317"/>\n		<path fill="none" stroke-width="10" stroke-miterlimit="10" d="M265.49,218.408L265.49,218.408L152.105,22.677\n			l-49.099,28.25l113.388,195.73c7.828,13.511,25.162,18.142,38.721,10.342C268.673,249.198,273.316,231.92,265.49,218.408z\n			 M240.945,246.663c-7.826,0-14.172-6.324-14.172-14.124c0-7.801,6.346-14.125,14.172-14.125c7.828,0,14.174,6.324,14.174,14.125\n			C255.119,240.338,248.773,246.663,240.945,246.663z"/>\n	</g>\n</g>\n'), environment3D: () => Ly('<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n<g id="surface1">\n    <g fill="none" stroke-width="50px" transform="matrix(0.233169,0,0,0.245462,-253.455,-131.813)">\n        <path d="M2295,1430.47C2294.8,1429.26 2294.51,1428.1 2294.31,1426.95C2294.21,1426.36 2294.08,1425.69 2293.96,1425.1C2293.86,1424.6 2293.74,1424.01 2293.66,1423.54C2293.41,1422.38 2293.22,1421.19 2292.94,1420C2291.88,1415.51 2290.47,1410.96 2288.78,1406.45C2287.06,1401.87 2285.05,1397.3 2282.7,1392.72C2280.36,1388.17 2277.69,1383.63 2274.71,1379.05C2271.73,1374.5 2268.43,1369.95 2264.83,1365.36C2261.22,1360.83 2257.3,1356.31 2253.1,1351.81C2248.91,1347.32 2244.39,1342.81 2239.58,1338.37C2234.77,1333.92 2229.66,1329.53 2224.28,1325.18C2218.91,1320.8 2213.21,1316.46 2207.28,1312.21C2201.33,1307.95 2195.1,1303.7 2188.62,1299.54C2182.14,1295.39 2175.37,1291.28 2168.35,1287.26C2164.85,1285.24 2161.28,1283.26 2157.64,1281.27C2154.01,1279.32 2150.3,1277.33 2146.55,1275.4C2142.8,1273.48 2138.96,1271.57 2135.09,1269.67C2131.21,1267.78 2127.27,1265.92 2123.28,1264.09C2119.28,1262.23 2115.22,1260.38 2111.1,1258.6C2106.98,1256.77 2102.83,1255.02 2098.61,1253.23C2094.37,1251.48 2090.09,1249.73 2085.76,1248.03C2081.42,1246.31 2077.03,1244.64 2072.59,1243C2068.15,1241.33 2063.66,1239.71 2059.12,1238.12C2054.55,1236.51 2049.95,1234.95 2045.31,1233.41C2040.67,1231.85 2035.98,1230.37 2031.24,1228.87C2026.5,1227.39 2021.69,1225.93 2016.87,1224.53C2012.03,1223.09 2007.15,1221.68 2002.23,1220.32C1997.28,1218.97 1992.31,1217.67 1987.28,1216.38C1982.27,1215.07 1977.21,1213.8 1972.1,1212.59C1967.01,1211.37 1961.87,1210.16 1956.69,1208.99C1951.52,1207.83 1946.29,1206.73 1941.03,1205.65C1935.77,1204.55 1930.46,1203.49 1925.13,1202.45C1919.79,1201.43 1914.42,1200.51 1909.01,1199.57C1903.59,1198.63 1898.14,1197.73 1892.66,1196.85C1887.18,1195.99 1881.67,1195.15 1876.13,1194.38C1870.58,1193.57 1865,1192.87 1859.41,1192.16C1853.8,1191.46 1848.13,1190.76 1842.47,1190.14C1836.79,1189.53 1831.1,1188.94 1825.37,1188.42C1819.64,1187.86 1813.87,1187.38 1808.09,1186.94C1802.31,1186.48 1796.5,1186.08 1790.65,1185.73C1784.82,1185.35 1778.98,1185.03 1773.08,1184.74C1767.18,1184.45 1761.27,1184.22 1755.34,1184.04C1749.42,1183.87 1743.48,1183.72 1737.5,1183.64C1731.52,1183.53 1725.49,1183.5 1719.5,1183.5C1713.49,1183.5 1707.49,1183.55 1701.51,1183.64C1695.51,1183.72 1689.57,1183.87 1683.65,1184.04C1677.72,1184.22 1671.79,1184.45 1665.91,1184.76C1660.03,1185.03 1654.17,1185.31 1648.34,1185.7C1642.49,1186.08 1636.68,1186.48 1630.9,1186.94C1625.1,1187.38 1619.36,1187.86 1613.63,1188.42C1607.91,1188.94 1602.22,1189.52 1596.54,1190.14C1590.86,1190.76 1585.21,1191.44 1579.6,1192.16C1573.99,1192.86 1568.43,1193.57 1562.87,1194.38C1557.32,1195.15 1551.81,1195.99 1546.31,1196.87C1540.85,1197.73 1535.41,1198.63 1530,1199.57C1524.59,1200.53 1519.21,1201.48 1513.86,1202.49C1508.54,1203.49 1503.23,1204.55 1497.96,1205.67C1492.7,1206.73 1487.48,1207.83 1482.28,1208.99C1477.11,1210.17 1471.96,1211.37 1466.85,1212.59C1461.76,1213.82 1456.7,1215.11 1451.69,1216.39C1446.67,1217.67 1441.71,1219 1436.77,1220.36C1431.86,1221.71 1426.97,1223.09 1422.12,1224.53C1417.28,1225.94 1412.51,1227.39 1407.75,1228.87C1403.01,1230.37 1398.3,1231.86 1393.68,1233.41C1389.04,1234.96 1384.43,1236.53 1379.87,1238.15C1375.33,1239.72 1370.84,1241.35 1366.4,1243.02C1361.96,1244.66 1357.58,1246.33 1353.24,1248.05C1348.9,1249.75 1344.62,1251.5 1340.39,1253.25C1336.15,1255.02 1331.99,1256.78 1327.87,1258.6C1323.77,1260.4 1319.71,1262.24 1315.71,1264.1C1311.72,1265.93 1307.77,1267.8 1303.88,1269.69C1300.01,1271.58 1296.19,1273.48 1292.44,1275.4C1288.69,1277.33 1284.99,1279.33 1281.35,1281.29C1277.71,1283.26 1274.15,1285.29 1270.64,1287.31C1263.62,1291.3 1256.86,1295.41 1250.37,1299.56C1243.89,1303.73 1237.64,1307.95 1231.69,1312.23C1225.76,1316.44 1220.07,1320.84 1214.69,1325.2C1209.31,1329.56 1204.2,1333.93 1199.39,1338.37C1194.6,1342.83 1190.08,1347.33 1185.88,1351.84C1181.67,1356.32 1177.77,1360.84 1174.16,1365.38C1170.56,1369.96 1167.26,1374.51 1164.28,1379.07C1161.3,1383.65 1158.63,1388.18 1156.29,1392.78C1153.94,1397.3 1151.92,1401.89 1150.19,1406.47C1148.48,1410.97 1147.11,1415.52 1146.05,1420.03C1145.77,1421.19 1145.6,1422.38 1145.35,1423.5C1145.22,1424.12 1145.1,1424.79 1144.98,1425.36C1144.88,1425.88 1144.76,1426.44 1144.68,1426.93C1144.46,1428.1 1144.19,1429.26 1143.99,1430.48C1143.79,1431.76 1143.66,1433.12 1143.51,1434.49C1143.66,1435.86 1143.79,1437.25 1143.99,1438.55C1144.19,1439.75 1144.48,1440.87 1144.68,1442.05C1144.8,1442.62 1144.91,1443.29 1145.03,1443.88C1145.13,1444.41 1145.25,1445 1145.35,1445.46C1145.6,1446.6 1145.77,1447.8 1146.05,1449.01C1147.11,1453.49 1148.52,1458.03 1150.21,1462.53C1151.93,1467.13 1153.94,1471.7 1156.29,1476.28C1158.63,1480.82 1161.3,1485.35 1164.28,1489.97C1167.26,1494.49 1170.56,1499.07 1174.16,1503.64C1177.77,1508.16 1181.69,1512.69 1185.89,1517.2C1190.1,1521.68 1194.6,1526.17 1199.41,1530.63C1204.22,1535.12 1209.33,1539.46 1214.71,1543.82C1220.09,1548.2 1225.78,1552.54 1231.73,1556.78C1237.66,1561.06 1243.89,1565.31 1250.37,1569.46C1256.86,1573.63 1263.62,1577.72 1270.64,1581.74C1274.15,1583.73 1277.71,1585.75 1281.37,1587.71C1284.99,1589.68 1288.69,1591.67 1292.44,1593.58C1296.19,1595.51 1300.03,1597.42 1303.9,1599.3C1307.79,1601.19 1311.72,1603.08 1315.73,1604.91C1319.71,1606.74 1323.79,1608.62 1327.89,1610.39C1332.01,1612.24 1336.16,1613.97 1340.39,1615.74C1344.62,1617.5 1348.91,1619.25 1353.25,1620.95C1357.58,1622.66 1361.96,1624.35 1366.4,1626C1370.84,1627.65 1375.33,1629.28 1379.89,1630.9C1384.45,1632.49 1389.04,1634.05 1393.68,1635.6C1398.32,1637.16 1403.03,1638.64 1407.75,1640.1C1412.51,1641.63 1417.28,1643.04 1422.12,1644.48C1426.97,1645.91 1431.86,1647.33 1436.78,1648.68C1441.73,1650.03 1446.68,1651.37 1451.69,1652.62C1456.72,1653.94 1461.78,1655.19 1466.89,1656.41C1471.98,1657.64 1477.12,1658.85 1482.3,1659.98C1487.49,1661.19 1492.7,1662.24 1497.96,1663.33C1503.23,1664.45 1508.54,1665.51 1513.86,1666.55C1519.21,1667.57 1524.59,1668.47 1530,1669.41C1535.41,1670.35 1540.85,1671.28 1546.31,1672.13C1551.81,1672.99 1557.32,1673.81 1562.87,1674.63C1568.41,1675.4 1573.99,1676.11 1579.6,1676.83C1585.21,1677.55 1590.86,1678.23 1596.52,1678.87C1602.2,1679.49 1607.9,1680.04 1613.63,1680.59C1619.36,1681.13 1625.1,1681.63 1630.88,1682.07C1636.68,1682.49 1642.49,1682.92 1648.34,1683.29C1654.17,1683.66 1660.03,1683.99 1665.91,1684.25C1671.79,1684.55 1677.72,1684.75 1683.65,1684.94C1689.57,1685.14 1695.51,1685.23 1701.5,1685.36C1707.48,1685.44 1713.47,1685.5 1719.49,1685.5C1725.49,1685.5 1731.5,1685.44 1737.48,1685.36C1743.46,1685.23 1749.42,1685.14 1755.34,1684.94C1761.25,1684.75 1767.18,1684.55 1773.06,1684.25C1778.96,1683.99 1784.82,1683.7 1790.65,1683.31C1796.5,1682.94 1802.31,1682.51 1808.09,1682.08C1813.87,1681.63 1819.64,1681.13 1825.37,1680.59C1831.08,1680.04 1836.77,1679.5 1842.47,1678.87C1848.13,1678.23 1853.78,1677.58 1859.39,1676.85C1865,1676.14 1870.57,1675.4 1876.13,1674.63C1881.67,1673.81 1887.18,1672.99 1892.66,1672.13C1898.14,1671.28 1903.59,1670.35 1909.01,1669.41C1914.42,1668.47 1919.79,1667.54 1925.13,1666.53C1930.46,1665.51 1935.77,1664.45 1941.03,1663.33C1946.29,1662.25 1951.52,1661.19 1956.71,1659.98C1961.88,1658.83 1967.03,1657.64 1972.14,1656.41C1977.23,1655.17 1982.29,1653.94 1987.32,1652.59C1992.33,1651.35 1997.3,1650 2002.23,1648.65C2007.15,1647.29 2012.03,1645.91 2016.87,1644.46C2021.71,1643.04 2026.5,1641.63 2031.24,1640.1C2035.98,1638.65 2040.67,1637.16 2045.33,1635.6C2049.97,1634.05 2054.58,1632.49 2059.12,1630.87C2063.66,1629.26 2068.15,1627.65 2072.59,1625.98C2077.04,1624.35 2081.42,1622.66 2085.76,1620.95C2090.09,1619.25 2094.38,1617.5 2098.61,1615.74C2102.84,1613.97 2107,1612.25 2111.12,1610.39C2115.22,1608.62 2119.3,1606.74 2123.28,1604.91C2127.29,1603.08 2131.22,1601.19 2135.09,1599.3C2138.98,1597.4 2142.8,1595.53 2146.57,1593.58C2150.32,1591.67 2154.01,1589.68 2157.64,1587.71C2161.28,1585.75 2164.86,1583.73 2168.36,1581.71C2175.37,1577.69 2182.14,1573.61 2188.62,1569.44C2195.1,1565.29 2201.33,1561.09 2207.3,1556.81C2213.23,1552.59 2218.92,1548.2 2224.32,1543.82C2229.68,1539.46 2234.79,1535.1 2239.6,1530.64C2244.41,1526.17 2248.91,1521.68 2253.12,1517.2C2257.34,1512.69 2261.22,1508.17 2264.83,1503.65C2268.43,1499.09 2271.73,1494.5 2274.71,1489.97C2277.69,1485.35 2280.36,1480.83 2282.7,1476.27C2285.05,1471.7 2287.09,1467.13 2288.8,1462.55C2290.49,1458.05 2291.88,1453.49 2292.95,1449.01C2293.22,1447.81 2293.41,1446.62 2293.66,1445.54C2293.78,1444.9 2293.89,1444.23 2294.03,1443.64C2294.13,1443.13 2294.24,1442.59 2294.31,1442.08C2294.51,1440.91 2294.81,1439.76 2295,1438.57C2295.22,1437.26 2295.33,1435.88 2295.5,1434.53C2295.33,1433.12 2295.2,1431.74 2295,1430.47Z" />\n    </g>\n    <path d="M179.539,220.301C179.539,239.078 165.082,254.301 147.246,254.301C129.41,254.301 114.953,239.078 114.953,220.301C114.953,201.527 129.41,186.305 147.246,186.305C165.082,186.305 179.539,201.527 179.539,220.301Z"/>\n    <g fill="none" stroke-width= "40px" transform="matrix(0.233169,0,0,0.245462,-253.455,-131.813)">\n        <path d="M1996.5,1434.49C1996.5,1329.76 1938.43,1238.62 1852.76,1191.41C1849.2,1190.98 1845.65,1190.53 1842.1,1190.14C1836.42,1189.53 1830.71,1188.94 1824.98,1188.42C1819.23,1187.86 1813.49,1187.38 1807.69,1186.94C1801.89,1186.48 1796.1,1186.08 1790.24,1185.73C1784.39,1185.35 1778.53,1185.03 1772.63,1184.74C1766.75,1184.45 1760.82,1184.22 1754.89,1184.04C1748.96,1183.87 1742.99,1183.72 1737.01,1183.64C1731.01,1183.53 1724.98,1183.5 1718.99,1183.5C1712.99,1183.5 1706.97,1183.55 1700.98,1183.64C1695,1183.72 1689.03,1183.87 1683.1,1184.04C1677.19,1184.22 1671.26,1184.45 1665.34,1184.76C1659.46,1185.03 1653.58,1185.31 1647.75,1185.7C1641.9,1186.08 1636.09,1186.48 1630.3,1186.94C1624.5,1187.38 1618.74,1187.86 1613.01,1188.42C1607.28,1188.94 1601.56,1189.52 1595.88,1190.14C1592.33,1190.53 1588.82,1190.96 1585.26,1191.39C1499.57,1238.62 1441.51,1329.76 1441.51,1434.49C1441.51,1539.24 1499.56,1630.38 1585.25,1677.59C1588.78,1678.01 1592.33,1678.47 1595.88,1678.87C1601.58,1679.49 1607.29,1680.04 1613.02,1680.59C1618.75,1681.13 1624.52,1681.63 1630.3,1682.07C1636.09,1682.49 1641.9,1682.92 1647.77,1683.29C1653.6,1683.66 1659.46,1683.99 1665.36,1684.25C1671.26,1684.55 1677.19,1684.75 1683.12,1684.94C1689.05,1685.14 1695,1685.23 1700.99,1685.36C1706.97,1685.44 1712.99,1685.5 1719,1685.5C1725,1685.5 1731.01,1685.44 1737.01,1685.36C1742.99,1685.23 1748.97,1685.14 1754.89,1684.94C1760.82,1684.75 1766.75,1684.55 1772.64,1684.25C1778.53,1683.99 1784.4,1683.7 1790.24,1683.31C1796.1,1682.94 1801.91,1682.51 1807.71,1682.08C1813.49,1681.63 1819.25,1681.13 1825,1680.59C1830.71,1680.04 1836.42,1679.5 1842.1,1678.87C1845.67,1678.48 1849.2,1678.02 1852.74,1677.61C1938.43,1630.39 1996.5,1539.24 1996.5,1434.49Z"/>\n    </g>\n    <g stroke-width="25px" transform="matrix(0.235243,0,0,0.245462,-256.696,-129.858)">\n        <path d="M1117.26,774.021L1495.79,554.41L1876.76,773.989L1498.22,993.616L1117.26,774.021M1883.5,773.989L1495.75,550.495L1110.5,774.021L1498.25,997.499L1883.5,773.989" />\n    </g>\n    <g transform="matrix(-0.233169,0,0,0.245462,188.517,69.5886)">\n        <path d="M0.007,0.005L0.007,369.922" fill="none" stroke-width="22.92px" stroke-linecap="round"/>\n    </g>\n    <g transform="matrix(0.233169,0,0,0.245462,-253.455,-131.813)">\n        <path d="M1513.49,1036.5L1513.49,1193.24" fill="none" stroke-width="22.92px" stroke-linecap="round"/>\n    </g>\n    <g transform="matrix(-0.116585,-0.212577,-0.20193,0.122731,188.644,67.8623)">\n        <path d="M-0.003,0.003L-0.005,441.736" fill="none" stroke-width="22.92px" stroke-linecap="round"/>\n    </g>\n    <g transform="matrix(0.233169,0,0,0.245462,-253.455,-131.813)">\n        <path d="M1480.51,1033.5L1480.51,1202.4" fill="none" stroke-width="22.92px" stroke-linecap="round"/>\n    </g>\n    <g transform="matrix(-0.11662,0.212556,0.201158,0.122262,2.826,67.8637)">\n        <path d="M0.002,-0.008L0.004,441.726" fill="none" stroke-width="22.92px" stroke-linecap="round"/>\n    </g>\n    <g transform="matrix(-0.233169,0,0,0.245462,2.91461,67.6249)">\n        <path d="M0.002,0L0.002,439.254" fill="none" stroke-width="22.92px" stroke-linecap="round"/>\n    </g>\n    <g transform="matrix(-0.116585,0.212577,0.20193,0.122731,3.4509,175.859)">\n        <path d="M0.005,-0.006L0.003,116.931" fill="none" stroke-width="22.92px" stroke-linecap="round"/>\n    </g>\n</g>\n') };
for (const e3 in bL)
  Kx(e3, { pathData: "", collection: "custom", packageName: "custom", viewBox: "0 0 284 284", customTemplate: bL[e3] });
let yL = class extends ae {
  constructor() {
    super(...arguments), this.currentViewModeIndex = 2, this.isColumnMode = false;
  }
  render() {
    return z`
          <ui5-segmented-button id="viewModeBtn" class="${this.isColumnMode ? "ver-orientation" : "hor-orientation"}" @selection-change= "${this._handleSelectionChanged}">
              <ui5-segmented-button-item tooltip="One View Mode" ?pressed=${0 == this.currentViewModeIndex}>
                <ui5-icon name="${this.isColumnMode ? "custom/singleview-mobile" : "custom/singleview"}" class="${this.isColumnMode ? "rotated-icon" : ""}"></ui5-icon>
              </ui5-segmented-button-item>
              <ui5-segmented-button-item tooltip="Sync Mode" ?pressed=${1 == this.currentViewModeIndex}>
                <ui5-icon name="${this.isColumnMode ? "custom/doubleview-synced-mobile" : "custom/doubleview-synced"}" class="${this.isColumnMode ? "rotated-icon" : ""}"></ui5-icon>
              </ui5-segmented-button-item>
              <ui5-segmented-button-item tooltip="Navigation Mode" ?pressed=${2 == this.currentViewModeIndex}>
                <ui5-icon name="${this.isColumnMode ? "custom/doubleview-mobile" : "custom/doubleview"}" class="${this.isColumnMode ? "rotated-icon" : ""}"></ui5-icon>
              </ui5-segmented-button-item>
          </ui5-segmented-button>

          <pv-menu ?isColumnMode=${this.isColumnMode}>
            <pv-menu-item icon="custom/environment3D" title="3D Environment">
              <environment-settings 
                  ?isColumnMode=${this.isColumnMode}
                  .environmentSettings="${this.viewerSettings.environment3D}">
                </environment-settings > 
            </pv-menu-item>
            <pv-menu-item icon="custom/rotation" title="Rotation Settings">
                <rotation-settings 
                  ?isColumnMode=${this.isColumnMode}
                  ?isAutoRotationDisabled= "${this.currentViewModeIndex < 2}"
                  .imageRotationSettings="${this.viewerSettings.imageRotation}"
                  .modelOrientationSettings="${this.viewerSettings.modelOrientation}">
                </rotation-settings> 
            </pv-menu-item>
            <measurement-tool icon="custom/measure" title="Measurement Tool"
              ?isColumnMode=${this.isColumnMode}
              .measurementTool ="${this.viewerSettings.measurementTool}"></measurement-tool>
            </measurement-tool>                   
          </pv-menu>
        `;
  }
  _handleSelectionChanged(e3) {
    const t2 = e3.detail.selectedItem.posInSet - 1;
    t2 != this.currentViewModeIndex && (this.currentViewModeIndex = t2, this.dispatchEvent(new CustomEvent("view-mode-changed", { detail: { viewIndex: t2 } })));
  }
};
yL.styles = r`
    :host {
      height: 100%;
      width: 100%;
      --_ui5_button_base_padding: 0px;
    }

    .rotated-icon{
      transform: rotate(-90deg)
    }

    .hor-orientation{
      left: 50%;
    }

    .ver-orientation{
      top: 50%;
    }

    #viewModeBtn.hor-orientation{
      bottom: 1%;
      transform: translateX(-50%);
    }

    #viewModeBtn.ver-orientation{
      right: 1%;
      transform-origin: 100% 0;
      transform: rotate(90deg) translateX(50%)
    }

    #viewModeBtn
    {
      position: absolute;
      pointer-events: auto;
    }


    ui5-segmented-button-item {
      height: 3.5rem;
      padding: 1px 1px 1px 1px;
    }

    ui5-icon {
      width: 3.5rem;
      height: 3.5rem;
      stroke:black;
      fill: black;
      pointer-events: none;
      transform: translateY(2.5%)
    }

    [pressed] ui5-icon {
      color:white;
      stroke:white;
      fill: white;
    }
  `, AL([ue({ type: Number })], yL.prototype, "currentViewModeIndex", 2), AL([ue({ type: Boolean })], yL.prototype, "isColumnMode", 2), AL([ue({ type: Object })], yL.prototype, "viewerSettings", 2), yL = AL([ce("control-panel")], yL);
class wL {
  constructor(e3, t2, i2) {
    this.focalLengthInPx = e3, this._sensorWidthInPx = t2, this._sensorHeightInPx = i2, 0 == this._sensorHeightInPx || 0 == this._sensorWidthInPx ? this.aspectRatio = -1 : this.aspectRatio = t2 / i2, this.fovInRad = this._sensorHeightInPx / this.focalLengthInPx, this.cx = 0.5 * (this._sensorWidthInPx - 1), this.cy = 0.5 * (this._sensorHeightInPx - 1);
  }
  equals(e3) {
    return e3.focalLengthInPx == this.focalLengthInPx && e3.cx == this.cx && e3.cy == this.cy;
  }
}
class xL extends _y.EventEmitter {
  constructor() {
    super(), this.isValid = false, this.sensorMap = /* @__PURE__ */ new Map(), this.sensorIds = [], this.imageFiles = [], this.camPosesInChunk = [], this.transformationChunkToWorld = new Qi(), this._xhttp = new XMLHttpRequest(), this._xmlDoc = null, this._xhttp.onload = this._extractInformation.bind(this);
  }
  readFromFile(e3) {
    this._xhttp.open("GET", e3, true), this._xhttp.send();
  }
  _extractInformation() {
    this.isValid = false, 200 == this._xhttp.status ? (this._xmlDoc = this._xhttp.responseXML, null != this._xmlDoc ? this._extractIntrinsicCameraInformation() ? this._extractExtrinsicCameraInformation() ? (this.isValid = true, this.emit("scanInformationExtracted")) : console.log("Coudn't extract extrinisc camera information from xml document") : console.log("Coudn't extract intrinsic camera information from xml document") : console.log("Xml of scaninformation is not valid")) : console.log("Coudn't read xml file");
  }
  _extractIntrinsicCameraInformation() {
    if (null == this._xmlDoc)
      return false;
    const e3 = this._xmlDoc.getElementsByTagName("sensor");
    if (0 == e3.length)
      return console.log("No sensors found in xml document"), false;
    for (let t2 = 0; t2 < e3.length; t2++) {
      const i2 = e3[t2].getAttribute("id");
      if (null == i2)
        return console.log(`Sensor Element in xml doesn't contain key "id"`, t2, e3[t2]), false;
      const n2 = CL(e3[t2], "calibration");
      if (null == n2)
        return false;
      const o2 = CL(n2, "resolution");
      if (null == o2)
        return false;
      const r2 = SL(o2, "width"), s2 = SL(o2, "height");
      if (null == r2 || null == s2)
        return console.log("XML Document doesn't contain information about sensor width and height"), false;
      const a2 = CL(n2, "f");
      if (null == a2 || null == a2.textContent)
        return console.log("XML Document doesn't contain information about the field of view", a2), false;
      const l2 = Number(a2.textContent);
      if (Number.isNaN(l2) || l2 <= 0)
        return console.log("XML Document doesn't contain valid information about the field of view:", l2), false;
      this.sensorMap.set(i2, new wL(l2, r2, s2));
    }
    return true;
  }
  _extractExtrinsicCameraInformation() {
    return null != this._xmlDoc && (this._extractChunkToWorldCoorTransformation() ? !!this._extractCamPoses() || (console.log("Coudn't extract cam poses information from xml document"), false) : (console.log("Coudn't extract transformation chunk to world coordinate system from xml document"), false));
  }
  _extractChunkToWorldCoorTransformation() {
    if (null == this._xmlDoc)
      return false;
    const e3 = function(e4, t3) {
      const i3 = e4.getElementsByTagName(t3);
      return 0 == i3.length ? (console.log("XML Document doesn't contain valid element with name", t3), null) : i3[i3.length - 1];
    }(this._xmlDoc, "transform");
    if (null == e3)
      return false;
    const t2 = CL(e3, "rotation");
    if (null == t2 || null == t2.textContent)
      return console.log("XML Document doesn't contain valid information about the rotation between chunk and world coordinate system", t2), false;
    const i2 = t2.textContent.split(" ").map((e4) => Number(e4));
    if (9 != i2.length)
      return console.log("Rotation part of chunk doesn't contain 9 numbers:", i2), false;
    var n2 = new Gt();
    n2.fromArray(i2).transpose();
    const o2 = CL(e3, "scale");
    if (null == o2 || null == o2.textContent)
      return console.log("XML Document doesn't contain valid information about the scaling between chunk and world coordinate system", o2), false;
    const r2 = Number(o2.textContent);
    if (r2 <= 0)
      return console.log("Scalefactor in xml document is not valid: ", r2), false;
    n2.multiplyScalar(r2);
    const s2 = CL(e3, "translation");
    if (null == s2 || null == s2.textContent)
      return console.log("XML Document doesn't contain valid information about the translation between chunk and world coordinate system", s2), false;
    const a2 = s2.textContent.split(" ").map((e4) => Number(e4));
    if (3 != a2.length)
      return console.log("Translation part of chunk doesn't contain 3 numbers:", a2), false;
    const l2 = new di(a2[0], a2[1], a2[2]);
    return this.transformationChunkToWorld.setFromMatrix3(n2), this.transformationChunkToWorld.setPosition(l2), true;
  }
  _extractCamPoses() {
    if (null == this._xmlDoc)
      return false;
    const e3 = this._xmlDoc.getElementsByTagName("camera");
    if (0 == e3.length)
      return console.log("No cameras found in xml document"), false;
    this.imageFiles.length = e3.length, this.camPosesInChunk.length = e3.length, this.sensorIds.length = e3.length;
    for (let t2 = 0; t2 < e3.length; t2++) {
      const i2 = e3[t2].getAttribute("label");
      if (null == i2)
        return console.log(`Camera Element in xml doesn't contain key "label"`, t2, e3[t2]), false;
      this.imageFiles[t2] = i2;
      const n2 = e3[t2].getAttribute("sensor_id");
      if (null == n2)
        return console.log(`Camera Element in xml doesn't contain key "sensor_id"`, t2, e3[t2]), false;
      if (0 == this.sensorMap.has(n2))
        return console.log("Sensor with id", n2, "doesn't exist in xml file"), false;
      this.sensorIds[t2] = n2;
      const o2 = CL(e3[t2], "transform");
      if (null == o2 || null == o2.textContent)
        return console.log("Camera Element in xml doesn't contain transformationElement", t2, e3[t2]), false;
      const r2 = o2.textContent.split(" ").map((e4) => Number(e4));
      if (16 != r2.length)
        return console.log("cam pose doesn't contain 16 numbers:", t2, r2), false;
      this.camPosesInChunk[t2] = new Qi(), this.camPosesInChunk[t2].fromArray(r2).transpose();
    }
    return true;
  }
}
function CL(e3, t2) {
  const i2 = e3.getElementsByTagName(t2);
  return 0 == i2.length ? (console.log("XML Document doesn't contain valid element with name", t2), null) : i2[0];
}
function SL(e3, t2) {
  const i2 = e3.getAttribute(t2);
  return i2 ? Number(i2) : null;
}
class EL extends _y.EventEmitter {
  constructor() {
    super(...arguments), this.poses = [], this.normedPositions = [], this._sensorMap = /* @__PURE__ */ new Map(), this._sensorIds = [], this._camPosesInChunk = [], this._chunkToWorldTransform = new Qi(), this._isYupTransformApplied = true, this._additionalRotation = new Qi();
  }
  init(e3, t2, i2) {
    this._sensorMap = e3.sensorMap, this._sensorIds = e3.sensorIds, this._camPosesInChunk = e3.camPosesInChunk, this._chunkToWorldTransform = e3.transformationChunkToWorld, this._isYupTransformApplied = t2, this._additionalRotation = this._additionalRotation.makeRotationFromEuler(i2), this._calculateCamPosesInWorldCoor();
  }
  setIsYupTransformApplied(e3) {
    e3 != this._isYupTransformApplied && (this._isYupTransformApplied = e3, this._calculateCamPosesInWorldCoor(), this.emit("camera-parameters-changed"));
  }
  setAdditionalRotation(e3) {
    console.log("Set additional rotation"), this._additionalRotation = this._additionalRotation.makeRotationFromEuler(e3.angleInRad), this._calculateCamPosesInWorldCoor(), this.emit("camera-parameters-changed");
  }
  getImageSensor(e3) {
    const t2 = this._sensorIds[e3];
    return this._sensorMap.get(t2);
  }
  getCameraPose(e3) {
    return e3 < this.poses.length && e3 >= 0 ? this.poses[e3] : new Qi();
  }
  getSyncSettingsOfNextBestImage(e3) {
    let t2 = e3.position.clone().normalize(), i2 = Number.MAX_VALUE, n2 = -1;
    for (let e4 = 0; e4 < this.normedPositions.length; e4++) {
      const o3 = Math.acos(t2.dot(this.normedPositions[e4]));
      o3 < i2 && (i2 = o3, n2 = e4);
    }
    if (-1 == n2)
      return [null, null];
    let o2 = new di(), r2 = new di(), s2 = new di();
    this.poses[n2].extractBasis(o2, r2, s2);
    const a2 = Math.acos(-s2.y);
    let l2 = Math.atan2(-s2.x, -s2.z), c2 = new di(Math.cos(l2), 0, -Math.sin(l2)), h2 = new di(-Math.cos(a2) * Math.sin(l2), Math.sin(a2), -Math.cos(a2) * Math.cos(l2)), u2 = new Vt();
    u2.x = o2.dot(c2), u2.y = o2.dot(h2), u2.normalize();
    const d2 = 180 * Math.atan2(u2.y, u2.x) / Math.PI;
    let p2 = new di();
    p2.setFromMatrixPosition(this.poses[n2]);
    const _2 = p2.length();
    let g2 = { theta: l2, phi: a2, radius: _2, toString() {
      return `${this.theta}rad ${this.phi}rad ${this.radius}m`;
    } }, m2 = new di();
    m2.x = p2.x - _2 * Math.sin(a2) * Math.sin(l2), m2.y = p2.y - _2 * Math.cos(a2), m2.z = p2.z - _2 * Math.sin(a2) * Math.cos(l2);
    const f2 = this._sensorIds[n2], v2 = this._sensorMap.get(f2);
    let A2 = 0.25 * Math.PI, b2 = 1;
    null != v2 && (A2 = v2.fovInRad, b2 = v2.aspectRatio);
    return [{ imageIdx: n2, rotationAngle: -d2, imageAspectRatio: b2 }, { orbitPos: g2, cameraTarget: Gv(m2), fovInRad: A2 }];
  }
  _calculateCamPosesInWorldCoor() {
    var e3 = this._chunkToWorldTransform.clone();
    if (this._isYupTransformApplied) {
      var t2 = new Qi();
      t2.makeRotationX(0.5 * -Math.PI), e3.premultiply(t2);
    }
    let i2 = new di(), n2 = new ui(), o2 = new di();
    this.poses.length = this._camPosesInChunk.length, this.normedPositions.length = this._camPosesInChunk.length;
    for (let t3 = 0; t3 < this._camPosesInChunk.length; t3++) {
      let s2 = new Qi();
      s2.multiplyMatrices(e3, this._camPosesInChunk[t3]), s2.premultiply(this._additionalRotation), s2.decompose(i2, n2, o2);
      var r2 = new di(1, 1, 1);
      i2.multiplyScalar(1e3);
      let a2 = new Qi();
      a2.compose(i2, n2, r2), this.poses[t3] = a2;
      let l2 = new di();
      l2.setFromMatrixPosition(a2), this.normedPositions[t3] = l2.normalize();
    }
  }
}
class IL {
  constructor() {
    this.angleInRad = new Zi(0, 0, 0, "YXZ");
  }
  angleInRadAsString() {
    return `${this.angleInRad.z}rad ${this.angleInRad.x}rad ${this.angleInRad.y}rad`;
  }
  equals(e3) {
    return e3.angleInRadAsString() == this.angleInRadAsString();
  }
  set x(e3) {
    this.angleInRad.x = e3;
  }
  get x() {
    return this.angleInRad.x;
  }
  set y(e3) {
    this.angleInRad.y = e3;
  }
  get y() {
    return this.angleInRad.y;
  }
  set z(e3) {
    this.angleInRad.z = e3;
  }
  get z() {
    return this.angleInRad.x;
  }
}
function TL(e3) {
  return `rgb(${e3.r}, ${e3.g}, ${e3.b})`;
}
class BL extends _y.EventEmitter {
  constructor() {
    super(...arguments), this._eulerOrientation = new IL();
  }
  set xOrientationInRad(e3) {
    this._eulerOrientation.x != e3 && (this._eulerOrientation.x = e3, this.emit("model-orientation-changed", this.eulerOrientationYXZInRad));
  }
  set yOrientationInRad(e3) {
    this._eulerOrientation.y != e3 && (this._eulerOrientation.y = e3, this.emit("model-orientation-changed", this.eulerOrientationYXZInRad));
  }
  set zOrientationInRad(e3) {
    this._eulerOrientation.z != e3 && (this._eulerOrientation.z = e3, this.emit("model-orientation-changed", this.eulerOrientationYXZInRad));
  }
  get eulerOrientationYXZInRad() {
    return this._eulerOrientation;
  }
}
class ML extends _y.EventEmitter {
  constructor() {
    super(...arguments), this._autoRotationAngle = 0, this._userSetRotationAngle = 0, this._isAutoRotationActivated = false;
  }
  set autoRotationAngle(e3) {
    this._autoRotationAngle != e3 && (this._autoRotationAngle = e3, this._isAutoRotationActivated && this.emit("rotation-angle-changed", this._autoRotationAngle));
  }
  get autoRotationAngle() {
    return this._autoRotationAngle;
  }
  set userSetRotationAngle(e3) {
    this._userSetRotationAngle != e3 && (this._userSetRotationAngle = e3, this._isAutoRotationActivated || this.emit("rotation-angle-changed", this._userSetRotationAngle));
  }
  get userSetRotationAngle() {
    return this._userSetRotationAngle;
  }
  set isAutoRotationActivated(e3) {
    this._isAutoRotationActivated != e3 && (this._isAutoRotationActivated = e3, this._isAutoRotationActivated ? this.emit("rotation-angle-changed", this._autoRotationAngle) : this.emit("rotation-angle-changed", this._userSetRotationAngle, false));
  }
  get isAutoRotationActivated() {
    return this._isAutoRotationActivated;
  }
}
class kL extends _y.EventEmitter {
  constructor() {
    super(...arguments), this._showAxes = true, this._backgroundColor = "#444444", this._gradientColor = "#b9b9b9", this._applyGradient = true, this._brightness = 1;
  }
  set showAxes(e3) {
    this._showAxes != e3 && (this._showAxes = e3, this.emit("change-axes-visibility-requested", this._showAxes));
  }
  get showAxes() {
    return this._showAxes;
  }
  set backgroundColor(e3) {
    const t2 = Dk(e3), i2 = TL(t2);
    if (console.log("Set backgroundcolor", t2, i2), this._backgroundColor == i2)
      return;
    this._backgroundColor = i2;
    const n2 = { r: Math.min(2.5 * t2.r, 255), g: Math.min(2.5 * t2.g, 255), b: Math.min(2.5 * t2.b, 255) };
    this._gradientColor = TL(n2), console.log("Set gradient color", n2, this._gradientColor), this._applyGradient ? this.emit("change-viewer-background-color-requested", this._backgroundColor, this._gradientColor) : this.emit("change-viewer-background-color-requested", this._backgroundColor, "");
  }
  get backgroundColor() {
    return this._applyGradient ? [this._backgroundColor, this._gradientColor] : [this._backgroundColor, ""];
  }
  set applyGradient(e3) {
    this._applyGradient != e3 && (this._applyGradient = e3, this._applyGradient ? this.emit("change-viewer-background-color-requested", this._backgroundColor, this._gradientColor) : this.emit("change-viewer-background-color-requested", this._backgroundColor, ""));
  }
  get applyGradient() {
    return this._applyGradient;
  }
  set brightness(e3) {
    this._brightness != e3 && (this._brightness = e3, this.emit("change-exposure-requested", this._brightness));
  }
}
class RL extends _y.EventEmitter {
  constructor() {
    super(...arguments), this._isActive = false, this._isEditModeActive = false, this._measurementPoints = [], this._measuredLength = 0, this._currentOrientation = new Zi(), this._currentTranslation = new di(), this._imageSensor = null, this._imageCamOrientation = new Qi(), this._measurementDistances = [], this._sceneElementGroup = new ca();
  }
  set imageSensor(e3) {
    this._imageSensor && e3.equals(this._imageSensor) || (this._imageSensor = e3);
  }
  set imageCamOrientation(e3) {
    this._imageCamOrientation.equals(e3) || (this._imageCamOrientation = e3);
  }
  get sceneElementGroup() {
    return this._sceneElementGroup;
  }
  set isActive(e3) {
    this._isActive != e3 && (this._isActive = e3, e3 ? this.showPoints() : (this.hidePoints(), this.isEditModeActive = false));
  }
  get isActive() {
    return this._isActive;
  }
  set isEditModeActive(e3) {
    this._isEditModeActive != e3 && (this._isEditModeActive = e3);
  }
  get isEditModeActive() {
    return this._isEditModeActive;
  }
  get numPoints() {
    return this._measurementPoints.length;
  }
  get measuredLength() {
    return this._measuredLength;
  }
  set translation(e3) {
    e3.equals(this._currentTranslation) || (this._measurementDistances.forEach((t2) => {
      t2.translate(e3);
    }), this._currentTranslation = e3.clone());
  }
  set eulerOrientation(e3) {
    this._currentOrientation.equals(e3.angleInRad) || (this._currentOrientation = e3.angleInRad.clone(), this._measurementDistances.forEach((e4) => {
      e4.changeSceneOrientation(this._currentOrientation);
    }), this._measurementPoints.forEach((e4) => {
      e4.updatePosition(this._currentOrientation);
    }));
  }
  addPointFromImage(e3, t2) {
    if (null == this._imageSensor)
      return;
    let i2 = new di();
    i2.x = e3 - this._imageSensor.cx, i2.y = t2 - this._imageSensor.cy, i2.z = this._imageSensor.focalLengthInPx;
    let n2 = new Gt();
    n2.setFromMatrix4(this._imageCamOrientation), console.log("Cam orientation in World", this._imageCamOrientation), i2.applyMatrix3(n2);
    let o2 = i2.normalize(), r2 = new di();
    r2.setFromMatrixPosition(this._imageCamOrientation), this.emit("calculate-hotspot-requested", r2, o2);
  }
  addPointFrom3DScene(e3, t2, i2 = true) {
    const n2 = this._measurementPoints.length, o2 = new di(e3.x, e3.y, e3.z), r2 = new di(t2.x, t2.y, t2.z), s2 = new FL(n2, o2, r2, this._currentOrientation);
    if (s2.on("hotspot-selected", this._updateHotspotInImage.bind(this)), s2.on("hotspot-focus-changed", (e4) => this.emit("change-image-hotspot-visibility", e4)), this._measurementPoints.push(s2), this._isActive || s2.hide(), n2 > 0) {
      const e4 = new DL(this._measurementDistances.length, this._measurementPoints[n2 - 1], s2, this._currentTranslation, this._currentOrientation);
      this._measuredLength += e4.distance, this._sceneElementGroup.add(e4.sceneElement), this._measurementDistances.push(e4), this.emit("hotspot-added", e4.annotationElement), this.emit("update-requested"), this._isActive || e4.hide();
    }
    this.emit("hotspot-added", s2.domElement), i2 && this._updateHotspotInImage(s2.positionInSceneCoor), window.setTimeout(() => s2.domElement.focus(), 0);
  }
  resetPoints() {
    this._measurementPoints.forEach((e3) => {
      e3.delete();
    }), this._measurementPoints.length = 0, this._measuredLength = 0, this._measurementDistances.forEach((e3) => {
      e3.reset();
    }), this.emit("update-requested");
  }
  showPoints() {
    this._measurementPoints.forEach((e3) => {
      e3.show();
    }), this._measurementDistances.forEach((e3) => {
      e3.show();
    }), this.emit("scene-update-requested");
  }
  hidePoints() {
    this._measurementDistances.forEach((e3) => {
      e3.hide();
    }), this._measurementPoints.forEach((e3) => {
      e3.hide();
    }), this.emit("scene-update-requested");
  }
  _updateHotspotInImage(e3) {
    if (!this.isActive || null == this._imageSensor)
      return;
    const t2 = this._imageSensor, i2 = this._imageCamOrientation.clone(), n2 = new di().setFromMatrixPosition(i2);
    n2.add(this._currentTranslation), i2.setPosition(n2), i2.invert();
    const o2 = new di().addVectors(e3, this._currentTranslation);
    let r2 = new ai(o2.x, o2.y, o2.z, 1).applyMatrix4(i2), s2 = new di(r2.x / r2.w, r2.y / r2.w, r2.z / r2.w), a2 = s2.x / s2.z * t2.focalLengthInPx + t2.cx, l2 = s2.y / s2.z * t2.focalLengthInPx + t2.cy;
    a2 > 0 && l2 > 0 && this.emit("update-image-hotspot-position-requested", a2, l2);
  }
}
class PL {
  constructor() {
    this._lineGeometry = new Zn(), this._translation = new di(), this._pointsInModelCoor = [], this._lineMaterial = new Ml({ color: 16777215, gapSize: 0.1, dashSize: 0.1 }), this._lineMaterial.transparent = true, this._lineMaterial.depthTest = false, this._distanceLine = new ul(this._lineGeometry, this._lineMaterial);
  }
  get lineElement() {
    return this._distanceLine;
  }
  addPoint(e3, t2, i2) {
    const n2 = new Qi().makeRotationFromEuler(i2).invert(), o2 = e3.clone().applyMatrix4(n2);
    this._pointsInModelCoor.push(o2), this._lineGeometry.setFromPoints(this._pointsInModelCoor), this._lineGeometry.applyMatrix4(new Qi().makeRotationFromEuler(i2)), this._lineGeometry.translate(t2.x, t2.y, t2.z), this._distanceLine.computeLineDistances(), this._translation = t2;
  }
  addPointInModelCoor(e3, t2, i2) {
    this._pointsInModelCoor.push(e3), this._lineGeometry.setFromPoints(this._pointsInModelCoor), this._lineGeometry.applyMatrix4(new Qi().makeRotationFromEuler(i2)), this._lineGeometry.translate(t2.x, t2.y, t2.z), this._distanceLine.computeLineDistances(), this._translation = t2;
  }
  setTranslation(e3) {
    this._lineGeometry.translate(-this._translation.x + e3.x, -this._translation.y + e3.y, -this._translation.z + e3.z), this._translation = e3;
  }
  setEulerOrientation(e3) {
    this._lineGeometry.setFromPoints(this._pointsInModelCoor), this._lineGeometry.applyMatrix4(new Qi().makeRotationFromEuler(e3)), this._lineGeometry.translate(this._translation.x, this._translation.y, this._translation.z), this._distanceLine.computeLineDistances();
  }
  set opacity(e3) {
    this._lineMaterial.opacity = e3;
  }
  show() {
    this._distanceLine.visible = true;
  }
  hide() {
    this._distanceLine.visible = false;
  }
  reset() {
    this._pointsInModelCoor.length = 0, this._lineGeometry.setFromPoints(this._pointsInModelCoor), this._distanceLine.removeFromParent();
  }
}
class DL {
  constructor(e3, t2, i2, n2, o2) {
    this._sceneLineElement = new PL(), this._numVisiblePoints = 0, this._isHidden = false;
    const r2 = t2.distanceTo(i2), s2 = new di().addVectors(t2.positionInSceneCoor, i2.positionInSceneCoor).multiplyScalar(0.5), a2 = new di().addVectors(t2.normalInSceneCoor, i2.normalInSceneCoor).multiplyScalar(0.5);
    this._distanceAnnotation = new NL(e3, r2, s2, a2, o2), this._sceneLineElement.addPointInModelCoor(t2.positionInModelCoor, n2, o2), this._sceneLineElement.addPointInModelCoor(i2.positionInModelCoor, n2, o2);
    const l2 = new MutationObserver(this._handlePointVisibilityChanged.bind(this));
    l2.observe(t2.domElement, { attributes: true }), l2.observe(i2.domElement, { attributes: true }), this._numVisiblePoints = Number(t2.domElement.hasAttribute("data-visible")) + Number(i2.domElement.hasAttribute("data-visible"));
  }
  get distance() {
    return this._distanceAnnotation.distance;
  }
  get sceneElement() {
    return this._sceneLineElement.lineElement;
  }
  get annotationElement() {
    return this._distanceAnnotation.domElement;
  }
  translate(e3) {
    this._sceneLineElement.setTranslation(e3);
  }
  changeSceneOrientation(e3) {
    this._sceneLineElement.setEulerOrientation(e3), this._distanceAnnotation.updatePosition(e3);
  }
  show() {
    this._sceneLineElement.show(), this._distanceAnnotation.show(), this._isHidden = false, this._updateAnnotationVisibility();
  }
  hide() {
    this._isHidden = true, this._distanceAnnotation.hide(), this._sceneLineElement.hide();
  }
  reset() {
    this._sceneLineElement.reset(), this._distanceAnnotation.delete();
  }
  _handlePointVisibilityChanged(e3) {
    for (const t2 of e3)
      if ("attributes" === t2.type && "data-visible" === t2.attributeName) {
        const e4 = t2.target;
        this._numVisiblePoints += e4.hasAttribute("data-visible") ? 1 : -1;
      }
    this._isHidden || this._updateAnnotationVisibility();
  }
  _updateAnnotationVisibility() {
    this._numVisiblePoints <= 0 ? (this._distanceAnnotation.hide(), this._sceneLineElement.opacity = 0.25) : (this._distanceAnnotation.show(), this._sceneLineElement.opacity = 1);
  }
}
class LL extends _y.EventEmitter {
  constructor(e3, t2, i2) {
    super();
    const n2 = new Qi().makeRotationFromEuler(i2).invert();
    this._positionInSceneCoor = e3, this._positionInModelCoor = this._positionInSceneCoor.clone().applyMatrix4(n2), this._normalInSceneCoor = t2, this._normalInModelCoor = this._normalInSceneCoor.clone().applyMatrix4(n2), this._domElement = document.createElement("button"), this._domElement.dataset.visibilityAttribute = "visible", this._domElement.style.display = "block", this._domElement.dataset.position = this.positionInSceneCoorAsString, this._domElement.dataset.normal = this.normalInSceneCoorAsString, this._domElement.addEventListener("focus", this._handleFocusChanged.bind(this)), this._domElement.addEventListener("blur", this._handleFocusChanged.bind(this));
  }
  get domElement() {
    return this._domElement;
  }
  get positionInModelCoor() {
    return this._positionInModelCoor;
  }
  get positionInSceneCoor() {
    return this._positionInSceneCoor;
  }
  get normalInSceneCoor() {
    return this._normalInSceneCoor;
  }
  get positionInSceneCoorAsString() {
    return `${this._positionInSceneCoor.x}m ${this._positionInSceneCoor.y}m ${this._positionInSceneCoor.z}m`;
  }
  get normalInSceneCoorAsString() {
    return `${this._normalInSceneCoor.x}m ${this._normalInSceneCoor.y}m ${this._normalInSceneCoor.z}m`;
  }
  updatePosition(e3) {
    this._positionInSceneCoor = this._positionInModelCoor.clone().applyEuler(e3), this._normalInSceneCoor = this._normalInModelCoor.clone().applyEuler(e3), this.domElement.dataset.position = this.positionInSceneCoorAsString, this.domElement.dataset.normal = this.normalInSceneCoorAsString, this.domElement.dispatchEvent(new Event("hotspot-position-changed"));
  }
  show() {
    this.domElement.style.display = "block";
  }
  hide() {
    this.domElement.style.display = "none";
  }
  delete() {
    var _a2;
    (_a2 = this.domElement.parentNode) == null ? void 0 : _a2.removeChild(this.domElement);
  }
  _handleFocusChanged(e3) {
    this.emit("hotspot-focus-changed", "focus" == e3.type);
  }
}
class FL extends LL {
  constructor(e3, t2, i2, n2) {
    super(t2, i2, n2), this._domElement.slot = "hotspot-measurementpoint" + e3, this.domElement.classList.add("hotspot"), this.domElement.textContent = e3.toString(), this.domElement.addEventListener("click", (e4) => {
      e4.stopPropagation(), this.emit("hotspot-selected", this.positionInSceneCoor);
    });
  }
  distanceTo(e3) {
    return this.positionInModelCoor.distanceTo(e3.positionInModelCoor);
  }
}
class NL extends LL {
  constructor(e3, t2, i2, n2, o2) {
    super(i2, n2, o2), this._distance = 0, this._distance = t2, this._domElement.slot = "hotspot-distance-annotation" + e3, this.domElement.classList.add("annotation"), this.domElement.textContent = t2.toFixed(1) + " mm";
  }
  get distance() {
    return this._distance;
  }
}
var OL = Object.defineProperty, zL = Object.getOwnPropertyDescriptor, UL = (e3, t2, i2, n2) => {
  for (var o2, r2 = n2 > 1 ? void 0 : n2 ? zL(t2, i2) : t2, s2 = e3.length - 1; s2 >= 0; s2--)
    (o2 = e3[s2]) && (r2 = (n2 ? o2(t2, i2, r2) : o2(r2)) || r2);
  return n2 && r2 && OL(t2, i2, r2), r2;
};
let HL = class extends ae {
  constructor() {
    super(), this.isYupTransformApplied = false, this.src3D = "", this.src2D = "", this.srcScanInformation = "", this._scanInformation = new xL(), this._imageCamera = new EL(), this._syncSettings2DViewer = null, this._syncSettings3DViewer = null, this._viewerAspectRatio = 1, this._viewModeIndex = 2, this._isInit = false, this._isColumnDir = false, this._viewerSettings = { imageRotation: new ML(), modelOrientation: new BL(), measurementTool: new RL(), environment3D: new kL() }, this._viewerSettings.modelOrientation.on("model-orientation-changed", (e3) => this._imageCamera.setAdditionalRotation(e3)), this._scanInformation.on("scanInformationExtracted", this._handleScanInformationExtracted.bind(this)), this._imageCamera.on("camera-parameters-changed", this._updateViewer.bind(this)), this._resizeObserver = new ResizeObserver(this._handleViewerResizeEvent.bind(this));
  }
  render() {
    return z`
      <div id="viewerBase">
        <viewer-3d id="viewer3D" 
          src=${this.src3D}
          camera-controls  disable-tap
          camera-orbit="0deg 90deg auto" max-camera-orbit="Infinity 157.5deg auto"  min-camera-orbit="-Infinity 22.5deg auto" camera-target="0m 0m 0m"
          exposure="1.2" shadow-intensity="0" alt="Leptinotarsa" min-field-of-view='0deg' max-field-of-view='18deg'  interaction-prompt="none"
          .measurementTool ="${this._viewerSettings.measurementTool}"
          @fov-based-zoom-changed ="${this._handleFovBasedZoomChanged}"
          @cam-orbit-angle-changed = "${this._updateViewer}"
          @dblclick = "${this._updateOneViewSyncMode}"  > 
        </viewer-3d>
        <viewer-2d id="viewer2D" src2D=${this.src2D} 
          .measurementTool ="${this._viewerSettings.measurementTool}"
          @image-zoom-changed ="${this._handleImageZoomChanged}"
          @image-shifted ="${this._handleImageShifted}"
          @min-zoom-level-changed ="${this._handleImageMinZoomLevelChanged}"
          @double-press= "${this._updateOneViewSyncMode}"
          @pointer-move-in-disable-mode =  "${this._handlePointerMoveOnImageInDisableMode}"
          @double-press-completed = "${this._updateOneViewSyncMode}" >  
        </viewer-2d>
        <control-panel id="controls" ?isColumnMode=${this._isColumnDir}
        .viewerSettings ="${this._viewerSettings}"
         @view-mode-changed = "${this._handleViewModeChanged}">
        </control-panel>
      </div>
    `;
  }
  connectedCallback() {
    super.connectedCallback();
  }
  disconnectedCallback() {
    this._resizeObserver.disconnect(), super.disconnectedCallback();
  }
  firstUpdated() {
    this._resizeObserver.observe(this.viewerBase), this.viewer2DElement.connectWithSettings(this._viewerSettings), this.viewer3DElement.connectWithSettings(this._viewerSettings);
  }
  updated(e3) {
    super.updated(e3), e3.has("srcScanInformation") && (this._isInit = false, this._scanInformation.readFromFile(this.srcScanInformation)), e3.has("isYupTransformApplied") && this._imageCamera.setIsYupTransformApplied(this.isYupTransformApplied);
  }
  _handleViewModeChanged(e3) {
    if (this._viewModeIndex == e3.detail.viewIndex)
      return;
    const t2 = this._viewModeIndex;
    this._viewModeIndex = e3.detail.viewIndex, 0 == t2 && (this._activateAndShow2DViewer(), this._updateViewerSize()), 2 != t2 && 2 != this._viewModeIndex || this._changeSyncMode(), 0 == this._viewModeIndex && this._updateViewerSize();
  }
  _handlePointerMoveOnImageInDisableMode(e3) {
    this._viewModeIndex > 0 || this.viewer3DElement.rotateModel(e3.detail.dx, e3.detail.dy);
  }
  _handleScanInformationExtracted() {
    this._imageCamera.init(this._scanInformation, this.isYupTransformApplied, this._viewerSettings.modelOrientation.eulerOrientationYXZInRad.angleInRad), this.viewer2DElement.setImageFiles(this._scanInformation.imageFiles), this.viewer3DElement.loaded && this._updateViewer();
  }
  _activateAndShow2DViewer() {
    this.viewer2DElement.style.cursor = "auto", this.viewer2DElement.style.opacity = "1", this.viewer2DElement.style.zIndex = "2", this.viewer2DElement.updatePointerEventsState(false);
  }
  _deactivateAndHide2DViewer() {
    this.viewer2DElement.style.opacity = "0", this.viewer2DElement.style.zIndex = "0", this.viewer2DElement.updatePointerEventsState(true), this.viewer2DElement.style.cursor = "grabbing";
  }
  _updateOneViewSyncMode() {
    this._viewModeIndex > 0 || ("0" === this.viewer2DElement.style.opacity ? this._activateAndShow2DViewer() : this._deactivateAndHide2DViewer());
  }
  _handleViewerResizeEvent() {
    this.viewerBase.style.setProperty("--margin", 0.025 * this.viewerBase.offsetWidth + "px"), this._updateViewerSize();
  }
  _updateViewerSize() {
    if (0 == this._viewModeIndex) {
      if (this._viewerAspectRatio = this.viewerBase.offsetWidth / this.viewerBase.offsetHeight, this.viewer3DElement.resize(this.viewerBase.offsetHeight, this.viewerBase.offsetWidth), this.viewer2DElement.resize(this.viewerBase.offsetHeight, this.viewerBase.offsetWidth, "translate(0,0)"), null == this._syncSettings2DViewer || null == this._syncSettings3DViewer)
        return;
      const e4 = this._syncSettings2DViewer.imageAspectRatio / this._viewerAspectRatio, t3 = this._syncSettings3DViewer.fovInRad * e4;
      return this.viewer3DElement.setReferenceFieldOfView(t3, this._viewModeIndex < 2), void this._synchronize3DViewer();
    }
    if (this._isColumnDir = this.viewerBase.offsetHeight > this.viewerBase.offsetWidth, null != this._syncSettings2DViewer) {
      let e4 = this._syncSettings2DViewer.imageAspectRatio * this.viewerBase.offsetHeight / this.viewerBase.offsetWidth;
      this._isColumnDir = e4 > 1;
    }
    let e3 = this.viewerBase.offsetWidth, t2 = 0.5 * this.viewerBase.offsetHeight, i2 = "translate(0,100%)";
    if (this._isColumnDir || (e3 = 0.5 * this.viewerBase.offsetWidth, t2 = this.viewerBase.offsetHeight, i2 = "translate(100%,0)"), this._viewerAspectRatio = e3 / t2, this.viewer3DElement.resize(t2, e3), this.viewer2DElement.resize(t2, e3, i2), this.requestUpdate(), null == this._syncSettings2DViewer || null == this._syncSettings3DViewer)
      return;
    const n2 = this._syncSettings2DViewer.imageAspectRatio / this._viewerAspectRatio, o2 = this._syncSettings3DViewer.fovInRad * n2;
    this.viewer3DElement.setReferenceFieldOfView(o2, true), this._synchronize3DViewer();
  }
  _changeSyncMode() {
    this._viewModeIndex < 2 ? (this.viewer3DElement.updateRadiusMode(true), this._synchronize3DViewer(), this.viewer3DElement.disablePan = true) : (this.viewer3DElement.disablePan = false, this.viewer3DElement.updateRadiusMode(false), this.viewer3DElement.setViewerOffset(0, 0));
  }
  _handleFovBasedZoomChanged(e3) {
    2 != this._viewModeIndex && this.viewer2DElement.zoomImage(e3.detail.zoomLevel);
  }
  _handleImageZoomChanged(e3) {
    this._viewModeIndex < 2 && this.viewer3DElement.zoomTo(e3.detail.zoomLevel);
  }
  _handleImageMinZoomLevelChanged(e3) {
    this.viewer3DElement.setMinZoomLevel(e3.detail.zoomLevel);
  }
  _handleImageShifted(e3) {
    this._viewModeIndex < 2 && this.viewer3DElement.setViewerOffset(e3.detail.deltaX, e3.detail.deltaY);
  }
  _updateViewer() {
    const e3 = this.viewer3DElement.getCamera();
    if ([this._syncSettings2DViewer, this._syncSettings3DViewer] = this._imageCamera.getSyncSettingsOfNextBestImage(e3), null == this._syncSettings2DViewer || null == this._syncSettings3DViewer)
      return;
    this._viewerSettings.imageRotation.autoRotationAngle = this._syncSettings2DViewer.rotationAngle;
    const t2 = this._syncSettings2DViewer.imageIdx;
    this.viewer2DElement.loadNextImage(t2);
    const i2 = this._imageCamera.getImageSensor(t2);
    null == i2 ? console.log("There is no sensor to the image index ", t2) : this._viewerSettings.measurementTool.imageSensor = i2, this._viewerSettings.measurementTool.imageCamOrientation = this._imageCamera.getCameraPose(t2);
    const n2 = this._syncSettings2DViewer.imageAspectRatio / this._viewerAspectRatio, o2 = this._syncSettings3DViewer.fovInRad * n2;
    this._isInit ? this.viewer3DElement.setReferenceFieldOfView(o2, this._viewModeIndex < 2) : (this.viewer3DElement.setReferenceFieldOfView(o2, true), this.viewer3DElement.setCameraOrbitPos(this._syncSettings3DViewer.orbitPos), this._updateViewerSize(), this._isInit = true), this._viewModeIndex < 2 && this._synchronize3DViewer();
  }
  _synchronize3DViewer() {
    null != this._syncSettings3DViewer && null != this._syncSettings2DViewer && (this.viewer3DElement.setCameraOrbitPos(this._syncSettings3DViewer.orbitPos), this.viewer3DElement.cameraTarget = this._syncSettings3DViewer.cameraTarget.toString(), this.viewer3DElement.zoomTo(this.viewer2DElement.getZoomLevel()));
  }
};
HL.styles = r`
    :host {
      width: 100%;
      height: 100%;
      display: flex; 
      justify-content: center;
      align-items: center
    }

    #viewerBase {
        --margin: 0px;
        position: relative;
        border: 2px solid blue;
        width: 95%;
        height: calc(100% - 2*var(--margin));
        min-height: 400px;
        border: 0;
        background-color: lightgray
    }
    
    #viewer2D {
      position: absolute;
      z-index: 2;
      opacity: 1;
    }

    #viewer3D {
      position: absolute;
      z-index: 1;
      overflow: hidden
    }

    #controls {
      position: absolute;
      width: 100%;
      height: 100%;
      z-index: 5;
      pointer-events: none;
    }

    .hotspot{
        display: block;
        width: 20px;
        height: 20px;
        border-radius: 20px;
        border: none;
        background-color: #fff;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.25);
        box-sizing: border-box;
        cursor: pointer;
        transition: opacity 0.3s;
        position: relative;
        font-size: 12px;
        padding: 0
    }

    .hotspot:not([data-visible]) {
        background: transparent;
        border: 3px solid #fff;
        box-shadow: none;
        pointer-events: none;
    }

    .hotspot:focus {
        border: 3px solid rgb(0, 128, 200);
        outline: none;
        padding: 0;
    }

    .hotspot > * {
        opacity: 1;
    }

    .annotation{
        background: rgba(0, 0, 0,0.75);
        color: rgba(255, 255, 255);
        border-radius: 5px;
        border: 0;
        box-shadow: 0;
        width: max-content;
        padding: 0.25em 0.5em
    }

  `, UL([ue({ type: Boolean })], HL.prototype, "isYupTransformApplied", 2), UL([ue()], HL.prototype, "src3D", 2), UL([ue()], HL.prototype, "src2D", 2), UL([ue()], HL.prototype, "srcScanInformation", 2), UL([de("#viewerBase")], HL.prototype, "viewerBase", 2), UL([de("#viewer3D")], HL.prototype, "viewer3DElement", 2), UL([de("#viewer2D")], HL.prototype, "viewer2DElement", 2), UL([de("#controls")], HL.prototype, "controlsElement", 2), HL = UL([ce("photogrammetry-viewer")], HL);
